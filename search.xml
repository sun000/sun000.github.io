<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hadoop-MapReduce入门]]></title>
    <url>%2F2018%2F05%2F14%2FHadoop-MapReduce%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[转自CSDN；改了几个笔误 原博客链接 MapReduce是用于数据处理的一种编程模型，简单但足够强大，专门为并行处理大数据而设计。 1. 通俗理解MapReduce 例如从大量历史数据中找出往年最高气温，NCDC公开了过去每一年的所有气温等天气数据的检测，每一行记录一条观测记录，格式如下： MapReduce-1 为了使用MapReduce找出历史上每年的最高温度，我们将行数作为map输入的key，每一行的文本作为map输入的value： MapReduce-2 上图中粗体部分分别表示年份和温度。map函数对每一行记录进行处理，提取出（年份，温度）形式的键值对，作为map的输出 12345(1950,0)(1950,22)(1950,-11)(1949,111)(1947,78) 很明显，有些数据是脏（错误）的，比如有些年份的气温丢失，或者不在理论范围内，因此map也是进行脏数据处理和过滤的好地方。在map输出被传输到reduce之前，MapReduce框架会对键值对进行排序，根据key进行分组，甚至在key相同的一组内先统计出最高气温，所以reduce收到的数据格式像这样： 12(1949,[111,78](1950,[0,22,-11] 如果有多个map任务同时运行（通常都是的，这就是MapReduce来并行计算的原因），那么每个map任务完成后，都会向reduce发送上面格式的数据，发送数据的过程叫shuffle。 map的输出会作为reduce的输入，reduce收到的是key加上一个列表，然后对这个列表进行处理，天气数据的例子中，就是找出最大值作为最高气温。最后reduce输出即为每年最高气温： 12(1949,111)(1950,22) 整个MapReduce数据流如下图： MapReduce-3 其中的3个黑圈圈分别为map，shuffle和reduce过程。在Hadoop中，map和reduce的操作可以由多种语言来编写，例如Java、Python、Ruby等。 在实际的分布式计算中，上述过程由整个集群协调完成，我们假设现在有5年（2011-2015）的天气数据，分布存放在3个文件中: weather1.txt，weather2.txt，weather3.txt。再假设我们现在有一个3台机器的集群，b并且map任务实例数量为3，reduce实例数量2。那么实际运行MapReduce做作业时，整个流程类似于这样： MapReduce-4 注意到2014年的数据分布在两个不同的文件中，黄色的粗线部分，代表2014年的2个map作业的输出都统一传输到一个reduce，因为他们的key相同（2014）。其实这个过程非常好理解，现实生活中，比如期末考试完了，那考卷由不同的老师批改，完成后如果想知道全年级最高分，那么可以这么做： 各个老师根据自己批改过的所有试卷分数整理出来（map）: 1=&gt;(course,[score1,score2,...]) 各个老师把最高分汇报给系主任（shuffle） 系主任统计最高分（reduce） 1=&gt;(courese, highest_score) 当然，如果要多门课程混在一起，系主任工作量太大，于是副主任也上（相当于2个reduce），则老师在汇报最高分的时候，相同课程要汇报给同一个人（相同key传输给同一个reduce），例如数学英语汇报给主任，政治汇报给副主任。 2. 实例及代码实现 life is short , show me the code MapReduce的概念框架有Google提出，Hadoop提供了经典的开源实现。但是并不是Hadoop特有的，例如在文档型数据库MongoDB中，可以通过JS来编写Map-Reduce，对数据库中的数据进行处理。我们这里以Hadoop为例说明。 数据准备 首先将本地的文件上传到HDFS： 1hadoop fs -copyFromLocal /home/data/hadoop_book_input/ hdfs://master:9000/input 可以查管理界面查看是否成功上传： MapReduce-5 查看一下数据内容： 1hadoop fs -text hdfs://master:9000/input/ncdc/sample.txt MapReduce-6 编写Java代码 首先实现Mapper类，Mapper在新版本Hadoop中改变为类（旧版为接口）定义如下： 1234567891011121314151617181920212223242526272829303132333435// 支持泛型，泛型定义map输入输出的键值类型public class Mapper &lt;KEYIN, VALUEIN, KEYOUT, VALUEOUT&gt; &#123; public Mapper() &#123; &#125; // map任务开始的时候调用一次，用于做准备工作 protected void setup(Context context) throws IOException, InterruptedException &#123; // 空实现 &#125; // map逻辑 默认直接将输入进行类型转换后输出 protected void map(KEYIN key, VALUEIN value, Context context) throws IOException, InterruptedException &#123; context.write((KEYOUT) key, (VALUEOUT) value); &#125; // 任务结束后调用一次，清理工作，与setup对应 protected void cleanup(Context context ) throws IOException, InterruptedException &#123; // 空实现 &#125; // map的实际运行过程就是调用run方法，一般用于高级实现，更精细地控制 任务的执行过程, 一般情况不需要覆盖这个方法 public void run(Context context) throws IOException, InterruptedException &#123; // 准备工作 setup(context); try &#123; // 遍历分配给该任务的数据，循环调用map while (context.nextKeyValue()) &#123; map(context.getCurrentKey(), context.getCurrentValue(), context); &#125; &#125; finally &#123; // 清理工作 cleanup(context); &#125; &#125;&#125; 实现中我们只覆盖map方法，其他保留不变。具体实现如下： 12345678910111213141516171819202122232425262728293031323334353637public class MaxTemperatureMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt; &#123; // 9999代表数据丢失 private static final int MISSING = 9999; @Override public void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123; // 行作为输入值 key在这里暂时不需要使用 String line = value.toString(); // 提取年份 String year = line.substring(15, 19); // 提取气温 int airTemperature = parseTemperature( line ); String quality = line.substring(92, 93); // 过滤脏数据 boolean isRecordClean = airTemperature != MISSING &amp;&amp; quality.matches("[01459]"); if ( isRecordClean ) &#123; // 输出（年份，温度）对 context.write(new Text(year), new IntWritable(airTemperature)); &#125; &#125; private int parseTemperature(String line)&#123; int airTemperature; if (line.charAt(87) == '+') &#123; // parseInt doesn't like leading plus signs airTemperature = Integer.parseInt(line.substring(88, 92)); &#125; else &#123; airTemperature = Integer.parseInt(line.substring(87, 92)); &#125; return airTemperature; &#125;&#125; 接着实现Reducer，看看定义： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Reducer&lt;KEYIN,VALUEIN,KEYOUT,VALUEOUT&gt; &#123; // Reducer上下文类定义 public abstract class Context implements ReduceContext&lt;KEYIN,VALUEIN,KEYOUT,VALUEOUT&gt; &#123; &#125; // 初始化 在Reduce任务开始时调用一次 protected void setup(Context context ) throws IOException, InterruptedException &#123; // 空实现 &#125; /** * map shuffle过来的数据中，每一个key调用一次这个方法 */ @SuppressWarnings("unchecked") protected void reduce(KEYIN key, Iterable&lt;VALUEIN&gt; values, Context context ) throws IOException, InterruptedException &#123; // 默认将所有的值一一输出 for(VALUEIN value: values) &#123; context.write((KEYOUT) key, (VALUEOUT) value); &#125; &#125; protected void cleanup(Context context ) throws IOException, InterruptedException &#123; // 空实现 收尾工作 &#125; // Reducer的运行逻辑 供更高级的定制 public void run(Context context) throws IOException, InterruptedException &#123; setup(context); try &#123; // 遍历输入key while (context.nextKey()) &#123; reduce(context.getCurrentKey(), context.getValues(), context); // 一个key处理完要转向下一个key时，重置值遍历器 Iterator&lt;VALUEIN&gt; iter = context.getValues().iterator(); if(iter instanceof ReduceContext.ValueIterator) &#123; ((ReduceContext.ValueIterator&lt;VALUEIN&gt;)iter).resetBackupStore(); &#125; &#125; &#125; finally &#123; cleanup(context); &#125; &#125;&#125; 我们的Reducer实现主要是找出最高气温： 1234567891011121314151617181920public class MaxTemperatureReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; &#123; @Override public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException &#123; int maxValue = findMax( values ); context.write(key, new IntWritable(maxValue)); &#125; private static int findMax(Iterable&lt;IntWritable&gt; values)&#123; int maxValue = Integer.MIN_VALUE; for (IntWritable value : values) &#123; maxValue = Math.max(maxValue, value.get()); &#125; return maxValue; &#125;&#125; Mapper和Reducer实现后，需要一个入口提交作业到Hadoop集群，在新版本中，使用YARN框架来运行MapReduce作业。作业配置如下： 1234567891011121314151617181920212223242526272829public class MaxTemperature &#123; public static void main(String[] args) throws Exception &#123; if (args.length != 2) &#123; System.err.println("Usage: MaxTemperature &lt;input path&gt; &lt;output path&gt;"); System.exit(-1); &#125; // 设置jar包及作业名称 Job job = new Job(); job.setJarByClass(MaxTemperature.class); job.setJobName("Max temperature"); // 输入输出路径 FileInputFormat.addInputPath(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); // 设置Mapper和Reducer实现 job.setMapperClass(MaxTemperatureMapper.class); job.setReducerClass(MaxTemperatureReducer.class); // 设置输出格式 job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); // 等待作业完成后退出 System.exit(job.waitForCompletion(true) ? 0 : 1); &#125;&#125; 输入输出路径使用FileInputFormat/FileOutputFormat的静态方法来设置，在运行作业之前，输出目录不能存在，这是为了避免覆盖数据导致数据丢失。运行之前如果检测到目录已经存在，作业将无法运行。 OK，把项目打包，如果使用Eclipse，使用Export功能。如果使用Maven开发，则直接运行package命令。假设我们最后的jar包为max-temp.jar.把jar包上传到你的集群机器上，或者放在安装了Hadoop的客户端机器上，这里假设jar包放在/opt/job目录下。 运行 首先把作业jar包放到CLASSPATH： 12cd /opt/jobexport HADOOP_CLASSPATH=max-temp.jar 运行: 1hadoop MaxTemperature /input/ncdc/sample.txt /output hadoop会自动把HADOOP_CLASSPAT设置的路径加入到CLASSPATH中，同时把HADOOP相关的依赖包也加入CLASSPATH，然后启动一个JVM运行MaxTemperature这个带有main方法的类。 结果如下： MapReduce-7 MapReduce-8 日志中可以看到作业的一些运行情况，例如map任务数量，reduce任务数量，以及输入输出的记录数，可以看到跟实际情况完全吻合。 我们看一下输出目录/output: 1hadoop fs -ls /output MapReduce-9 可以看到该目录下有个成功标识文件_SUCCESS和结果输出文件part-r-0000，每个reducer会输出一个文件。查看一下这个输出文件的内容： 1hadoop fs -text hdfs://master:9000/output/part-r-00000 如上图所示，我们成功得到了1949和1950年的最高温度，无需管结果是否合理，只要按照我们想要的逻辑运行即可。 YARN管理界面也可以看到该作业的情况： MapReduce-10 3. 进一步理解MapReduce 一个MapReduce作业通常包括输入数据、MapReduce程序以及一些配置信息。Hadoop把作业分解为task运行，task分为map任务和reduce任务，在新版本的Hadoop中，这些Task通过资源管理框架进行调度，如果任务失败，MapReduce应用框架会重新运行任务。 作业的输入被划分为固定大小的分片，叫input splits，简称splits。然后为每一个split分块创建一个map任务，map任务对每一条记录运行用户定义的map函数。划分为split之后，不同配置的机器就可以根据自己的资源及运算能力运行适当的任务，即使是相同配置的机器，最后运行的任务数也往往不等，这样能有效利用整个集群的计算能力。但是split也不已太多，否则会耗费很多时间在创建map任务上，通常而言，按集群Block大小（默认为128M）来划分split是合理的。 Hadoop会把map任务运行在距离数据最近的节点上，最好的情况是直接在数据（split）所在的节点上运行map任务，这样不需要占用带宽，这一优化叫做数据本地优化（data locality optimization)。下图的map选址方案从最优到最次为a，b，c： MapReduce-11 关于Hadoop如何衡量两个集群节点的距离，参考另一批博客 深入理解HDFS：Hadoop分布式文件系统。但是节点距离不是分配task考虑的唯一因素，还会考虑节点当前负载等因素。 Reduce任务通常无法利用本地数据的优化，大多数情况下，reduce的输入都来自集群的其他节点。reduce针对每一个key运行reduce函数之后，输出结果通常保存在HDFS中，并且存储一定的副本数，第一个副本存在运行reduce任务的本地机器，其他副本根据HDFS写入的管道分别写入节点，关于更多HDFS的数据写入流程，参考这里。 下图是一个单reduce的数据流示例： MapReduce-12 如果有多个reduce任务，那么map任务的输出到底该传输到哪一个reduce任务呢？决定某个key的数据（key,[value1, value2,...])该发送给那个reduce的过程叫partition。默认情况下，MapReduce使用key的哈希函数进行分桶，这通常工作的很好。如果需要自行指定分区函数，可以自己实现一个Partitioner并配置到作业中。key相同的map任务输出一定会发送到同一个reduce任务。map任务的输出数据传输到reduce任务所在节点的过程，叫做shuffle。下面是一个更通用的MapReduce数据流图： MapReduce-13 当然，有些作业中我们可能根本不需要有reduce任务，所有工作在map任务并行执行完之后就完毕了，例如Hadoop提供的并行复制工作distcp，其内部实现就是采用一个只有Mapper，没有Reducer的MapReduce作业，在map完成文件复制之后作业就完成了，如下图所示： MapReduce-14 在上面计算最高天气的例子中，每个map将每一条记录所产生的（年份，温度）记录都shuffle到reduce节点，当数据量较大时，将占用很多带宽，耗费很长时间。事实上，可以在map任务所在的节点上做更多工作。map任务运行完之后，可以把所有结果按年份分组，并统计出每一年的最高温度（类似于sql中的 1select max(temperature) from table group by year ），这个最高温度是局部的，只在本任务重产生的数据做比较。做完局部统计之后，将结果发送给reduce做最终的汇总，找出 全局最高温度。过程示意图如下： MapReduce-15 这么做之所以符合逻辑，是基于以下的事实： 1max(0,20,10,25,15)=max(max(0,20,10) , max(25,15)) 符合上述性质的函数称为是commutative和associative，有时候也成为是distributive。如果是计算平均温度，则不能使用这一的方式。 上述的局部计算在Hadoop中使用Combiner来表示。为了在作业中使用Combiner，我们需要明确指定，在前面的例子中，可以直接使用Reducer作为Combiner，因为两者逻辑是一样的： 1234// 设置Mapper和Reducer实现job.setMapperClass(MaxTemperatureMapper.class);job.setCombinerClass(MaxTemperatureReducer.class);job.setReducerClass(MaxTemperatureReducer.class); 4.Hadoop Streaming Hadoop完全允许我们使用Java以外的语言来编写map和reduce函数。Hadoop Streaming使用Unix标准流作为Hadoop和其他应用程序的接口。数据流的大致示意图如下： MapReduce-16 整个数据在Hadoop MapReduce与Ruby应用、标准输入输出之间流转，因此叫Streaming。我们继续使用前面气温的例子来说明，先使用ruby来编写map和reduce，然后使用unix的管道来模拟整个过程，最后迁移到Hadoop上运行。 Ruby版本的map函数从标准流中读取数据，运算后将结果输出到标准输出流： 123456#!/usr/bin/rubySTDIN.each_line do |line| val = line year , temp , q = val[15,4],val[87,5],val[92,1] puts "#&#123;year&#125;\t#&#123;temp&#125;" if (temp != "+9999" &amp;&amp; q =~/[01459]/)end 逻辑与Java版本完全一样，STDIN是ruby的标准输入，each_line针对每一行进行操作，逻辑封装在do和end之间。puts是ruby标准输出函数，打印tab分割的记录到标准输出流。 因为这个脚本与标准输入输出交互，所以很容易结合linux的管道来测试： 1cat input/ncdc/sample.txt | ruby max_temp_map.rb MapReduce-17 一样用ruby脚本来完成reduce的功能： 123456789101112last_key , max_val = nil , -1000000STDIN.each_line do |line| key , val = line.split("\t") if last_key &amp;&amp; last_key != key puts "#&#123;last_key&#125;\t#&#123;max_val&#125;" last_key , max_val = key , val.to_i else last_key , max_val = key,[max_val , val.to_i].max endend# 处理最后一个key的输出put "#&#123;last_key&#125;\t#&#123;max_val&#125;" if last_key map处理完之后，同一个key的一组键值对中，value是排序的，所以当前读到的key如果不同于上一个key，表示这个key的所有值都处理完了（前文提到会在切换key之前reset输入）。我们使用sort命令来替代MapReduce中的排序过程，把map的标准输出作为sort的输入，sort通过管道连接到map： 1cat /home/data/hadoop_book_input/ncdc/sample.txt| ruby max_temp_map.rb | sort | ruby max_temp_reduce.rb 输出结果如下图，与前文完全一致。 MapReduce-18 很好，我们在Hadoop上运行这个作业。非Java语言的MapReduce作业，需要使用Hadoop Streaming来运行。Hadoop Streaming会负责作业的Task分解，把输入数据作为标准输入流传递给Ruby写的map脚本，并接受来自map脚本的标准输出，排序后shuffle到reduce节点上，并以标准输入传递给reduce，最后把reduce的标准输出保存到HDFS文件中。 我们使用hadoop jar命令,同时指定输入输出目录，脚本位置等。 1hadoop jar /home/hadoop-2.6.0/share/hadoop/tools/lib/hadoop-streaming-2.6.0.jar -files max_temp_map.rb,max_temp_reduce.rb -input /input/ncdc/sample.txt -output /output/max-tem-ruby -mapper max_temp_map.rb -reducer max_temp_reduce.rb -file参数把这些文件上传到集群中。注意map和reduce脚本需要在CLASSPATH下，我是在当前目录下运行的，默认加入到类路径中。另外请确保集群中的所有机器都安装了ruby，否则可能出现类似subprocess failed with code 127。这里的输出文件是/outp/max-tem-ruby，MapReduce不允许多个作业输出到同一个目录。 查看输出文件，与Java版本完全一致。OK，我们设置combiner，然后在大的数据集上感受一下： 1hadoop jar /home/hadoop-2.6.0/share/hadoop/tools/lib/hadoop-streaming-2.6.0.jar -files max_temp_map.rb,max_temp_reduce.rb -input /input/ncdc/all -output /output/max-tem-all -mapper max_temp_map.rb -combiner x_temp_reduce.rb -reducer max_temp_reduce.rb MapReduce-19]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>MapReduce</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Code Jam Round1C-C]]></title>
    <url>%2F2018%2F05%2F05%2FGoogle-Code-Jam-Round1C-C%2F</url>
    <content type="text"><![CDATA[题目链接 题目:Ant Stack Problem Scott has an ant farm containing N ants. Each ant has a certain length and weight. Today, as a challenge for the ants, Scott has placed some food at the top of the ant farm. The ants will try to reach it by arranging themselves into a vertical stack, with each ant in the stack directly holding the next on its back. In this way, each ant bears the weight of all ants above it. Scott's ants are very strong for their size and are able to carry up to 6 times their own weight. For example, an ant that weights 8 milligrams can carry two other ants weighing 24 milligrams each! Each ant also has a body length; the exact lengths are not important, except that they are all different. The stack must be linear. Each ant except for the top ant must be directly below exactly one ant, and each ant except for the bottom ant must be directly above exactly one ant. The lengths of the ants in the stack must be strictly decreasing from the bottom to the top of the stack; this ensures that each new ant that joins the stack will be able to climb up to the top. For each ant, the sum of the weights of all the ants above it in the stack must be no more than 6 times the weight of that ant. What is the maximum number of these ants that can form such a stack? Input The first line of the input gives the number of test cases, T. T test cases follow. Each begins with one line with an integer N: the number of ants in the colony. Then, a second line follows containing N integers W1, W2, ..., WN, where Wi is the weight in milligrams of the i-th ant. The ants are listed in strictly increasing order of length. Notice that no actual length values are given; only the order is important. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum number of the given ants that can form a stack that obeys the rules above. Limits 7 ≤ T ≤ 100. Time limit: 15 seconds per test set. Memory limit: 1GB. Test set 1 (Visible) For exactly 6 cases, N = 100; for the other T - 6 cases, 2 ≤ N ≤ 50. 1 ≤ Wi ≤ 1000, for all i. Test set 2 (Hidden) For exactly 6 cases, \(N= 10^5\); for the other T - 6 cases, 2 ≤ N ≤ 500. 1 ≤ Wi ≤ \(10^9\), for all i. Sample Input 3 2 9 1 3 8 4 100 9 10 10 10 10 10 10 10 10 100 Output Case #1: 1 Case #2: 3 Case #3: 8 In Sample Case #1, there are two ants. The first weighs 9 mg; the second weighs 1 mg, and is longer than the first ant. The first ant is strong enough to hold the second ant (since it can hold up to 9 × 6 mg), but it cannot, because the second ant is longer. The second ant is not strong enough to hold the first ant (since it can only hold up to 1 × 6 mg, which is less than 9 mg). So it is only possible to make a &quot;stack&quot; of one of the two ants. In Sample Case #2, it is possible for all three ants to form a stack, with the third holding up the second, which holds up the first. In Sample Case #3, the optimal solution has the ninth ant on the bottom, and then seven of the other ants above it. 分析 很容易想到是一个动态规划\(dp[i]\)：i个蚂蚁得在一起最小的重量 \(dp[j - 1] &lt;= w[i] * 6\)：若当前的蚂蚁可以支撑起j-1个蚂蚁， \(dp[j] &gt;= dp[j - 1] + w[i]\)若以当前的蚂蚁替换j个蚂蚁中的蚂蚁，可以使蚂蚁的总重量减小 这里其实是一个滚动数组，复杂度是\(O(N^2)\) 但是注意到事实上是两层循环层循环枚举n个蚂蚁，内层循环是答案k，时间复杂度是\(O(n*k)\) 那么k最大是多少呢？ 考虑最极端的情况： 蚂蚁从上往下的重量分别是1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 4, 4, 5, 6, … 因为\(w \leq 10^9\)写一个程序就知道 K最大是139 所以时间复杂度够。 代码 12345678910111213141516171819202122232425262728293031323334353637/** @Author: sun000* @Date: 2018-05-05 17:43:30* @Last Modified by: sun000* @Last Modified time: 2018-05-05 18:15:47*/#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAX_N = 1e5 + 10;long long int w[MAX_N], dp[MAX_N];int main(void) &#123; int t, n; scanf("%d", &amp;t); for(int ca = 1; ca &lt;= t; ca++) &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) scanf("%lld", &amp;w[i]); memset(dp, 0x7f, sizeof dp); dp[0] = 0; int ans = 0; for(int i = 1; i &lt;= n; i++) &#123; for(int j = ans + 1; j &gt; 0; j--) &#123; if(dp[j - 1] &lt;= w[i] * 6 &amp;&amp; dp[j] &gt;= dp[j - 1] + w[i]) &#123; dp[j] = dp[j - 1] + w[i]; if(ans &lt; j) ans = j; &#125; &#125; &#125; printf("Case #%d: %d\n", ca, ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NCPC2017-I-Import-SPaghetti]]></title>
    <url>%2F2018%2F03%2F08%2FNCPC2017-I-Import-SPaghetti%2F</url>
    <content type="text"><![CDATA[题目链接 题目 You just graduated from programming school and nailed a Python programming job. The ﬁrst day at work you realize that you have inherited a mess. The spaghetti design pattern was chosen by the previous maintainer, who recently ﬂed the country. You try to make sense of the code, but immediately discover that different ﬁles depend cyclically on each other. Testing the code, in fact running the code, has not yet been attempted. As you sit down and think, you decide that the ﬁrst thing to do is to eliminate the cycles in the dependency graph. So you start by ﬁnding a shortest dependency cycle. Input The ﬁrst line of input contains a number n, 1 ≤ n ≤ 500, the number of ﬁles. Then follows one line with n names of ﬁles. Each name is a string with at least 1 and at most 8 lower case letters ‘a’ to ‘z’. Then follow n sections, one section per ﬁle name, in the order they were given on the second line. Each section starts with one line containing the name of the ﬁle and an integer k, followed by k lines, each starting with “import”. Each “import” line is a comma-space separated line of dependencies. No ﬁle imports the same ﬁle more than once, and every ﬁle imported is listed in the second line of the input. Comma-space separated means that every line will start with “import”, then have a list of class names separated by “,” (see sample inputs for examples). Output If the code base has no cyclic dependencies, output “SHIP IT”. Otherwise, output a line containing the names of ﬁles in a shortest cycle, in the order of the cycle. If there are many shortest cycles, any one will be accepted. Sample Input 1 123456789104 a b c d a 1 import d, b, c b 2 import d import c c 1 import c d 0 Sample Output 1 1c Sample Input 2 1234567891011125 classa classb myfilec execd libeclassa 2 import classb import myfilec, libe classb 1 import execd myfilec 1 import libe execd 1 import libe libe 0 Sample Output 2 1SHIP IT Sample Input 3 1234567891011125 classa classb myfilec execd libe classa 2 import classb import myfilec, libe classb 1 import execd myfilec 1 import libe execd 1 import libe, classa libe 0 Sample Output 3 1classa classb execd 分析 题意是在一个图上求最小环，最小环的求法是用最短路，先用Floyd算法处理每两点之间的最短路(时间复杂度是o(n3)， 枚举每一条边i→j:G[i][j]则包含着一条边的最小环是：j到i的最短路加上这条边。 设最小环的长度是ans则ans=min(ans,G[i][j]+dis[j][i]) 注意判断自环弗洛伊德求最小环不能处理自环的情况 处理完最小环要输出路径。 这里就涉及到了Floyd记录路径的： path[i][j]:i到j的最短路必须经过path[i][j] ： 这样就能在Flody的过程中记录该数组，那么如何输出呢？ 显然很容易想到,递归输出。详情看代码 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/** @Author: sun000* @Date: 2017-10-12 11:11:45* @Last Modified by: sun000* @Last Modified time: 2017-10-22 12:50:20*/#include &lt;map&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 510;const int INF = 0x3f3f3f3f;int n;int G[MAXN][MAXN], dis[MAXN][MAXN];map&lt;string, int&gt; name_to_id;string id_to_name[MAXN];void init() &#123; memset(G, 0x3f, sizeof(G)); memset(dis, 0x3f, sizeof(dis)); for(int i = 0; i &lt; n; i++) G[i][i] = dis[i][i] = 0;&#125;bool flag;string gg;void build() &#123; flag = false; char name[100]; int cnt, now; for(int i = 0; i &lt; n; i++) &#123; scanf("%s%d", name, &amp;cnt); // printf("name = %s cnt = %d\n", name, cnt); now = name_to_id[(string)name]; for(int j = 0; j &lt; cnt; j++) &#123; scanf("%s", name); while(scanf("%s", name)) &#123; int len = strlen(name); if(name[len - 1] == ',') &#123; name[len - 1] = '\0'; if (name_to_id[string(name)] == now)&#123; flag = true; gg = (string)name; &#125; G[now][name_to_id[string(name)]] = 1; dis[now][name_to_id[string(name)]] = 1; &#125; else &#123; if (name_to_id[string(name)] == now)&#123; flag = true; gg = (string)name; &#125; G[now][name_to_id[string(name)]] = 1; dis[now][name_to_id[string(name)]] = 1; break; &#125; &#125; &#125; &#125;&#125;int path[MAXN][MAXN];void output(int i, int j) &#123; if(path[i][j] == -1) cout&lt;&lt; id_to_name[j] &lt;&lt; ' '; else&#123; output(i,path[i][j]); output(path[i][j],j); &#125; &#125;void Floyd() &#123; int r1, r2; memset(path, -1, sizeof(path)); if(flag) &#123; cout &lt;&lt; gg &lt;&lt; endl; return; &#125; int ans = INF; for(int k = 0; k &lt; n; k++) &#123; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(i == j) continue; if(dis[i][j] &gt; dis[i][k]+ dis[k][j]) &#123; dis[i][j] = dis[i][k] + dis[k][j]; path[i][j] = k; &#125; if(ans &gt; G[j][i] + dis[i][j]) &#123; ans = G[j][i] + dis[i][j]; r1 = i, r2 = j; &#125; &#125; &#125; &#125; if(ans &gt;= INF) printf("SHIP IT\n"); else &#123; cout &lt;&lt; id_to_name[r1] &lt;&lt; ' '; output(r1, r2); printf("\n"); &#125;&#125;void show() &#123; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) printf("%d\t", G[i][j]); printf("\n"); &#125;&#125;int main(void) &#123; // freopen("in.txt", "r", stdin); char tmp[20]; scanf("%d", &amp;n); init(); for(int i = 0; i &lt; n; i++) &#123; scanf("%s", tmp); name_to_id[(string)tmp] = i; id_to_name[i] = (string)tmp; &#125; build(); Floyd(); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>最小环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode4-Median of Two Sorted Arrays]]></title>
    <url>%2F2018%2F03%2F08%2FLeetCode4-Median-of-Two-Sorted-Arrays%2F</url>
    <content type="text"><![CDATA[题目链接 题目 There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example 1: 123nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2: 1234nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 分析 分奇偶考虑，二分在第一个Arrays中选择的数量k，然后可以唯一确定在第二个Arrays中的数量，k的选择是满足二分的，当第一个Arrays中选择的最大的数据，小于等于Arrays中没有选择的最小数据，时，说明当前k满足条件，然后左边界变大，一直二分选出满足要求的最大的k，其中两个Arrays中有一个全不选或则全选在计算答案的时候要特殊处理。 代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: bool check(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int a) &#123; int l1 = nums1.size(), l2 = nums2.size(), b; if((l1 + l2) &amp; 1) b = (l1 + l2 + 1) / 2 - a; else b = (l1 + l2) / 2 - a; if(!a || b &gt;= l2) return true; else if(b &lt; 0) return false; return nums1[a - 1] &lt;= nums2[b]; &#125; double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int l1 = nums1.size(), l2 = nums2.size(); int m = (l1 + l2) / 2; int l = 0, r = l1 + 1; int k = 0; while(r - l &gt; 1) &#123; k = (l + r) / 2; if(check(nums1, nums2, k)) l = k; else r = k; &#125; if((l1 + l2) &amp; 1) &#123; int a = l, b = m + 1 - l; if(!a) return nums2[b - 1]; else if(!b) return nums1[a - 1]; return max(nums1[a - 1], nums2[b - 1]); &#125; else &#123; int a = l, b = m - l; int aa, bb; if(!a) aa = nums2[b - 1]; else if(!b) aa = nums1[a - 1]; else aa = max(nums1[a - 1], nums2[b - 1]); if(a == l1) bb = nums2[b]; else if(b == l2) bb = nums1[a]; else bb = min(nums1[a], nums2[b]); return (aa + bb) / 2.0; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Latex数学符号]]></title>
    <url>%2F2017%2F10%2F09%2FLatex%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[符号 编码 符号 编码 符号 编码 符号 编码 \(\alpha\) \alpha \(\beta\) \beta \(\gamma\) \gamma \(\delta\) \delta \(\epsilon\) \epsilon \(\varepsilon\) \varepsilon \(\zeta\) \zeta \(\eta\) \eta \(\theta\) \theta \(\vartheta\) \vartheta \(\iota\) \iota \(\kappa\) \kappa \(\lambda\) \lambda \(\mu\) \mu \(\nu\) \nu \(\xi\) \xi \(\omicron\) \omicron \(\pi\) \pi \(\varpi\) \varpi \(\rho\) \rho \(\varrho\) \varrho \(\sigma\) \sigma \(\varsigma\) \varsigma \(\tau\) \tau \(\upsilon\) \upsilon \(\phi\) \phi \(\varphi\) \varphi \(\chi\) \chi \(\psi\) \psi \(\omega\) \omega \(\Gamma\) \Gamma \(\Delta\) \Delta \(\Theta\) \Theta \(\Lambda\) \Lambda \(\Xi\) \Xi \(\Pi\) \Pi \(\Sigma\) \Sigma \(\Upsilon\) \Upsilon \(\Phi\) \Phi \(\Psi\) \Psi \(\Omega\) \Omega \(\leq\) \leq \(\geq\) \geq \(\equiv\) \equiv \(\models\) \models \(\prec\) \prec \(\succ\) \succ \(\sim\) \sim \(\perp\) \perp \(\preceq\) \preceq \(\succeq\) \succeq \(\simeq\) \simeq \(\mid\) \mid \(\ll\) \ll \(\gg\) \gg \(\asymp\) \asymp \(\parallel\) \parallel \(\subset\) \subset \(\supset\) \supset \(\approx\) \approx \(\bowtie\) \bowtie \(\subseteq\) \subseteq \(\supseteq\) \supseteq \(\cong\) \cong \(\sqsubset\) \sqsubset \(\sqsupset\) \sqsupset \(\neq\) \neq \(\smile\) \smile \(\sqsubseteq\) \sqsubseteq \(\sqsupseteq\) \sqsupseteq \(\doteq\) \doteq \(\frown\) \frown \(\in\) \in \(\ni\) \ni \(\propto\) \propto \(\vdash\) \vdash \(\dashv\) \dashv \(\leftarrow\) \leftarrow \(\longleftarrow\) \longleftarrow \(\Leftarrow\) \Leftarrow \(\Longleftarrow\) \Longleftarrow \(\rightarrow\) \rightarrow \(\longrightarrow\) \longrightarrow \(\Rightarrow\) \Rightarrow \(\Longrightarrow\) \Longrightarrow \(\uparrow\) \uparrow \(\Uparrow\) \Uparrow \(\downarrow\) \downarrow \(\Downarrow\) \Downarrow \(\leftrightarrow\) \leftrightarrow \(\longleftrightarrow\) \longleftrightarrow \(\Leftrightarrow\) \Leftrightarrow \(\Longleftrightarrow\) \Longleftrightarrow \(\updownarrow\) \updownarrow \(\Updownarrow\) \Updownarrow \(\mapsto\) \mapsto \(\longmapsto\) \longmapsto \(\nearrow\) \nearrow \(\searrow\) \searrow \(\nwarrow\) \nwarrow \(\swarrow\) \swarrow \(\hookleftarrow\) \hookleftarrow \(\hookrightarrow\) \hookrightarrow \(\leftharpoonup\) \leftharpoonup \(\rightharpoonup\) \rightharpoonup \(\leftharpoondown\) \leftharpoondown \(\rightharpoondown\) \rightharpoondown \(\sum\) \sum \(\prod\) \prod \(\coprod\) \coprod \(\int\) \int \(\oint\) \oint \(\bigcap\) \bigcap \(\bigcup\) \bigcup \(\bigsqcup\) \bigsqcup \(\bigvee\) \bigvee \(\bigwedge\) \bigwedge \(\bigodot\) \bigodot \(\bigotimes\) \bigotimes \(\bigoplus\) *** \(\biguplus\) \biguplus \(\lfloor\) \lfloor \(\rfloor\) \rfloor \(\lceil\) \lceil \(\rceil\) \rceil \(\langle\) \langle \(\rangle\) \rangle \(\backslash\) \backslash \(\boxdot\) \boxdot \(\boxplus\) \boxplus \(\boxtimes\) \boxtimes \(\square\) \square \(\blacksquare\) \blacksquare \(\boxminus\) \boxminus \(\lozenge\) \lozenge \(\blacklozenge\) \blacklozenge \(\circlearrowright\) \circlearrowright \(\circlearrowleft\) \circlearrowleft \(\leftrightharpoons\) \leftrightharpoons \(\centerdot\) \centerdot \(\Vdash\) \Vdash \(\Vvdash\) \Vvdash \(\vDash\) \vDash \(\twoheadrightarrow\) \twoheadrightarrow \(\twoheadleftarrow\) \twoheadleftarrow \(\leftleftarrows\) \leftleftarrows \(\rightrightarrows\) \rightrightarrows \(\upuparrows\) \upuparrows \(\downdownarrows\) \downharpoonleft \(\upharpoonright\) \upharpoonright \(\upharpoonleft\) \upharpoonleft \(\downharpoonright\) \downharpoonright \(\downharpoonleft\) \downharpoonleft \(\rightarrowtail\) \rightarrowtail \(\leftarrowtail\) \leftarrowtail \(\rightleftarrows\) \rightleftarrows \(\leftrightarrows\) \leftrightarrows \(\Lsh\) \Lsh \(\Rsh\) \Rsh \(\rightsquigarrow\) \rightsquigarrow \(\leftrightsquigarrow\) \leftrightsquigarrow \(\looparrowleft\) \looparrowleft \(\looparrowright\) \looparrowright \(\circeq\) \circeq \(\succsim\) \succsim 先更新这么多。。。。。]]></content>
      <categories>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces-Gym-101201F-Illumination]]></title>
    <url>%2F2017%2F10%2F09%2FCodeForces-Gym-101201F-Illumination%2F</url>
    <content type="text"><![CDATA[题目链接 题目 You inherited a haunted house. Its floor plan is an n-by-n square grid with l lamps in fixedlocations and no interior walls. Each lamp can either illuminate its row or its column, but not bothsimultaneously. The illumination of each lamp extends by r squares in both directions, so a lampunobstructed by an exterior wall of the house can illuminate as many as 2r + 1 squares. If a square is illuminated by more than one lamp in its row, or by more than one lamp in its column,the resulting bright spot will scare away ghosts forever, diminishing the value of your property. Isit possible for all lamps to illuminate a row or column, without scaring any ghosts? Note that asquare illuminated by two lamps, one in its row and the other in its column, will not scare awaythe ghosts. Input The first line of input contains three positive integers, n, r and l \((1 \leqslant n, r, l \leqslant 1,000)\). Each of the next l lines contains two positive integers ri and ci \((1 \leqslant r_i,c_i \leqslant n)\), indicating that there is a lamp in row \(r_i\) and column \(c_i\). It is guaranteed that all lamps are in distinct locations. Output Print, on a single line, YES if it is possible to illuminate all lamps as stated above; otherwise, print NO. 分析 典型的2-SAT问题 每个灯泡有两个状态，状态之间相互影响。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;int n, r, l;struct node &#123; int x, y;&#125; p[1010];vector&lt;int&gt; G[2010], rG[2010], vs;bool used[2010];int cmp[2010];void addedge(int u, int v) &#123; G[u].push_back(v); rG[v].push_back(u);&#125;void build() &#123; for (int i = 0; i &lt; l; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (p[i].y == p[j].y &amp;&amp; abs(p[i].x - p[j].x) &lt;= 2 * r) &#123; addedge(i, l + j); addedge(j, l + i); &#125; if (p[i].x == p[j].x &amp;&amp; abs(p[i].y - p[j].y) &lt;= 2 * r) &#123; addedge(l + i, j); addedge(l + j, i); &#125; &#125; &#125;&#125;void dfs(int v) &#123; used[v] = true; for (int i = 0; i &lt; (int)G[v].size(); ++i) &#123; if (!used[G[v][i]]) dfs(G[v][i]); &#125; vs.push_back(v);&#125;void rdfs(int v, int k) &#123; used[v] = true; cmp[v] = k; for (int i = 0; i &lt; (int)rG[v].size(); ++i) &#123; if (!used[rG[v][i]]) rdfs(rG[v][i], k); &#125;&#125;int scc() &#123; memset(used, 0, sizeof(used)); vs.clear(); for (int i = 0; i &lt; 2 * l; ++i) &#123; if (!used[i]) dfs(i); &#125; memset(used, 0, sizeof(used)); int k = 0; for (int i = vs.size() - 1; i &gt;= 0; --i) &#123; if (!used[vs[i]]) rdfs(vs[i], k++); &#125; return k;&#125;int main(void) &#123; scanf("%d%d%d", &amp;n, &amp;r, &amp;l); for (int i = 0; i &lt; l; i++) scanf("%d%d", &amp;p[i].x, &amp;p[i].y); build(); scc(); for (int i = 0; i &lt; l; i ++) &#123; if (cmp[i] == cmp[l + i]) &#123; printf("NO\n"); return 0; &#125; &#125; printf("YES\n"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NAIPC-2017-A]]></title>
    <url>%2F2017%2F10%2F09%2FNAIPC-2017-A%2F</url>
    <content type="text"><![CDATA[题目链接 题目 You are teaching a class in programming, and you want to cover balanced parentheses. You’ve got a great visual aid, a sign with a very long, balanced string of parentheses. But, alas, somehow, your visual aid has been broken into pieces, and some pieces may be missing! You’ve got to try to put it back together as best you can. Given the string of parentheses on each piece, what is the longest balanced string you can form by concatenating some of them in some order? Each piece may be used at most once, and the pieces cannot be reversed. A balanced string of parentheses is defined as: The empty string ABAB where AA and BB are both balanced strings of parentheses (AA) where AA is a balanced string of parentheses Input Each input will consist of a single test case. Note that your program may be run multiple times on different inputs. The first line of input will contain a single integer nn (1≤n≤3001≤n≤300), which is the number of pieces. Each of the next nn lines will hold a single string ss (1≤|s|≤3001≤|s|≤300), which consists only of the characters ’(’ and ’)’. This describes one of the pieces. Output Output a single integer, which is the length of the longest string of balanced parentheses you can form from the pieces. Note that the empty string is technically a balanced string of parentheses, so it is always possible to form a string of length at least 00 (although the empty string is not a very effective visual aid!). Example sample input1 12343())((())() sample output1 110 sample input2 1234565))))))(())((( sample output2 12 分析 题意是给定n个由括号组成的字符串，问选择一些字符串来拼接，能得到的括号匹配的最长的最长的字符串的长度。 先将每个字符串中已经能够匹配的括号消去，得到一个))...(((这种类型的字符串 dp[i][j] 表示处理完前i个字符串，左括号还剩下的j个字符串的最大长度 \(dp[i + 1][j] = max(dp[i][j], dp[i][j + p[i].r - p[i].l] + p[i].w\) 结构体p{l:处理后左括号个数, r: 处理后右括号个数, w:原字符串的长度} 这个题目的重点在于排序，很容易就能想到这样的dp方程 排序：只有左括号的排在最前面，只有右括号的排在最后面，然后对于中 间的使左括号增加的排在减少的之前，对于都增加或者都减少的的，右括号少的排在前面。（这里就是一个贪心） 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123;//预处理后的字符串的左括号和右括号的个数还有原字符串的长度 int l, r, w;&#125; p[310];bool cmp(node a, node b) &#123; if(a.r == 0 &amp;&amp; b.r != 0) return true; else if(a.r != 0 &amp;&amp; b.r == 0) return false; else if(a.r == 0 &amp;&amp; b.r == 0) return a.l &lt; b.l; if(a.l == 0 &amp;&amp; b.l != 0) return false; else if(a.l != 0 &amp;&amp; b.l == 0) return true; else if(a.l == 0 &amp;&amp; b.l == 0) return a.r &lt; b.r; if(a.l - a.r &gt;= 0 &amp;&amp; b.l - b.r &gt;= 0) return a.r &lt; b.r; if (a.l - a.r &gt;= 0 &amp;&amp; b.l - b.r &lt; 0) return true; if (b.l - b.r &gt;= 0 &amp;&amp; a.l - a.r &lt; 0) return false; return a.r - a.l &lt; b.r - b.l;&#125;int dp[310][90010];char tmp[310];int main(void) &#123; int n; int cntl, cntr; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; cntl = cntr = 0; scanf("%s", tmp); p[i].w = (int)strlen(tmp); for (int j = 0; j &lt; p[i].w; j++) &#123; if (tmp[j] == '(') cntl++; else &#123; if (cntl) cntl--; else cntr++; &#125; &#125; p[i].l = cntl; p[i].r = cntr; &#125; sort(p, p + n, cmp); memset(dp, -0x3f, sizeof(dp)); dp[0][0] = 0; for (int i = 0; i &lt; n ; i++) &#123; for(int j = 0; j &lt; p[i].l; j++) dp[i + 1][j] = dp[i][j]; for (int j = p[i].l; j &lt;= 90000 &amp;&amp; j + p[i].r - p[i].l &lt;= 90000; j++) dp[i + 1][j] = max(dp[i][j], dp[i][j + p[i].r - p[i].l] + p[i].w); &#125; printf("%d\n", dp[n][0]);&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces-868C-Qualification-Rounds]]></title>
    <url>%2F2017%2F10%2F08%2FCodeForces-868C-Qualification-Rounds%2F</url>
    <content type="text"><![CDATA[题目链接 题目 Snark and Philip are preparing the problemset for the upcoming pre-qualification round for semi-quarter-finals. They have a bank of nproblems, and they want to select any non-empty subset of it as a problemset. k experienced teams are participating in the contest. Some of these teams already know some of the problems. To make the contest interesting for them, each of the teams should know at most half of the selected problems. Determine if Snark and Philip can make an interesting problemset! Input The first line contains two integers n, k (1 ≤ n ≤ 105, 1 ≤ k ≤ 4) — the number of problems and the number of experienced teams. Each of the next n lines contains k integers, each equal to 0 or 1. The j-th number in the i-th line is 1 if j-th team knows i-th problem and 0 otherwise. Output Print &quot;YES&quot; (quotes for clarity), if it is possible to make an interesting problemset, and &quot;NO&quot; otherwise. You can print each character either upper- or lowercase (&quot;YeS&quot; and &quot;yes&quot; are valid when the answer is &quot;YES&quot;). Examples input 1234565 31 0 11 1 01 0 01 0 01 0 0 output 1NO input 12343 21 01 10 1 output 1YES Note In the first example you can't make any interesting problemset, because the first team knows all problems. In the second example you can choose the first and the third problems. 分析 由于队伍的数量最多只有4个，那么对于一道题目的状态最多也只有16种，假设存在一道题目所有的队伍都不会，那么只要选这一道题是肯定可以的。 现在考虑没有所有人都不会的题目，则至少先选一道题目（并且这道题目至少被一个队伍知道），假设这道题目的状态是“1000”则现在至少要选择一道题目来抵消第一个队伍，因为第一个队伍已经知道了一道题目了，现在至少要选一个“0***”的题目，若存在这样的题目则答案肯定是“YES”的，现在考虑更加复杂的情况。 答案存在当且仅当存在两道题目的状态是a和b且a&amp;b = 0 必要性显而易见。 对于充分性：由上面的例子考虑跟家复杂等情况，当我们选择了一道题目后，在选择第二道题目的时候必须选择一道题抵消第一道状态上是1队伍，这个时候肯定要先选择这些位置为0的，若存在其他答案，选择了为1的，则1增加了，题目要求每个队伍的0比1多，则通过交换选择题目的顺序，这个时候肯定要选一个在第一次选择的时候为1的队伍，此时为0的题目。 共有16种状态16*16枚举一下就好了 代码 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int n, k;bool vis[20];int main(void) &#123; memset(vis, false, sizeof(vis)); scanf("%d%d", &amp;n, &amp;k); int gg; for (int i = 0; i &lt; n; i++) &#123; int tmp = 0; for (int j = 0; j &lt; k; j++) &#123; scanf("%d", &amp;gg); tmp = tmp * 2 + gg; &#125; vis[tmp] = true; &#125; bool flag = false; if (vis[0]) flag = true; else &#123; for(int i = 0; i &lt; 16; i++) &#123; if(vis[i]) &#123; for(int j = 0; j &lt; i; j++) &#123; if(vis[j] &amp;&amp; !(i &amp; j)) &#123; flag = true; break; &#125; &#125; &#125; if(flag) break; &#125; &#125; if(flag) printf("YES\n"); else printf("NO\n"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces-869c-The-Intriguing-Obsession]]></title>
    <url>%2F2017%2F10%2F08%2FCodeForces-869c-The-Intriguing-Obsession%2F</url>
    <content type="text"><![CDATA[题目链接 题目 —This is not playing but duty as allies of justice, Nii-chan! — Not allies but justice itself, Onii-chan! With hands joined, go everywhere at a speed faster than our thoughts! This time, the Fire Sisters — Karen and Tsukihi — is heading for somewhere they've never reached — water-surrounded islands! There are three clusters of islands, conveniently coloured red, blue and purple. The clusters consist of a, b and c distinct islands respectively. Bridges have been built between some (possibly all or none) of the islands. A bridge bidirectionally connects two different islands and has length 1. For any two islands of the same colour, either they shouldn't be reached from each other through bridges, or the shortest distance between them is at least 3, apparently in order to prevent oddities from spreading quickly inside a cluster. The Fire Sisters are ready for the unknown, but they'd also like to test your courage. And you're here to figure out the number of different ways to build all bridges under the constraints, and give the answer modulo 998 244 353. Two ways are considered different if a pair of islands exist, such that there's a bridge between them in one of them, but not in the other. Input The first and only line of input contains three space-separated integers a, b and c (1 ≤ a, b, c ≤ 5 000) — the number of islands in the red, blue and purple clusters, respectively. Output Output one line containing an integer — the number of different ways to build bridges, modulo 998 244 353. Examples input 11 1 1 output 18 input 11 2 2 output 163 input 11 3 5 output 13264 input 16 2 9 output 1813023575 Note In the first example, there are 3 bridges that can possibly be built, and no setup of bridges violates the restrictions. Thus the answer is 23 = 8. In the second example, the upper two structures in the figure below are instances of valid ones, while the lower two are invalid due to the blue and purple clusters, respectively. img 分析 由于任意两种颜色的影响是独立的，所以可以综合考虑任意两种颜色之间的连接情况，然后把三个数乘起来，就是最后的答案。 考虑两种颜色之间的方案数目。 dp[i][j]表示的是两种颜色分别为i个和j个之间的颜色，则现在考虑i表示的颜色增加了一个点，则这个点和j表示的颜色相连的方案数目是\(j * dp[i][j - 1]\),若不与j中任意一个颜色相连则是\(dp[i][j]\) 则\[dp[i + 1][j] = j * dp[i ][j - 1] + dp[i ][j]\] 即\[dp[i][j] = j * dp[i - 1][j - 1] + dp[i - 1][j]\] 代码 12345678910111213141516171819202122232425#include &lt;cstdio&gt;const long long int MOD = 998244353;const int MAXN = 5e3 + 10;int dp[MAXN][MAXN];void init() &#123; for(int i = 0; i &lt; MAXN; i++) dp[i][0] = dp[0][i] = 1; for(int i = 1; i &lt; MAXN; i++) &#123; for(int j = 1; j &lt; MAXN; j++) &#123; dp[i][j] = (j * 1LL * dp[i - 1][j - 1] + dp[i - 1][j]) % MOD; &#125; &#125;&#125;int main(void) &#123; init(); int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); int ans = ((1LL * dp[a][b] * dp[a][c]) % MOD) * dp[b][c] % MOD; printf("%d\n", ans); return 0; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU5242-Game]]></title>
    <url>%2F2017%2F09%2F12%2FHDU5242-Game%2F</url>
    <content type="text"><![CDATA[题目链接 题目 Problem Description It is well known that Keima Katsuragi is The Capturing God because of his exceptional skills and experience in ''capturing'' virtual girls in gal games. He is able to play k games simultaneously. One day he gets a new gal game named ''XX island''. There are n scenes in that game, and one scene will be transformed to different scenes by choosing different options while playing the game. All the scenes form a structure like a rooted tree such that the root is exactly the opening scene while leaves are all the ending scenes. Each scene has a value , and we use wi as the value of the i-th scene. Once Katsuragi entering some new scene, he will get the value of that scene. However, even if Katsuragi enters some scenes for more than once, he will get wi for only once. For his outstanding ability in playing gal games, Katsuragi is able to play the game k times simultaneously. Now you are asked to calculate the maximum total value he will get by playing that game for k times. Input The first line contains an integer T(T≤20), denoting the number of test cases. For each test case, the first line contains two numbers n,k(1≤k≤n≤100000), denoting the total number of scenes and the maximum times for Katsuragi to play the game ''XX island''. The second line contains n non-negative numbers, separated by space. The i-th number denotes the value of the i-th scene. It is guaranteed that all the values are less than or equal to 231−1. In the following n−1 lines, each line contains two integers a,b(1≤a,b≤n), implying we can transform from the a-th scene to the b-th scene. We assume the first scene(i.e., the scene with index one) to be the opening scene(i.e., the root of the tree). Output For each test case, output ''Case #t:'' to represent the t-th case, and then output the maximum total value Katsuragi will get. Sample Input 1234567891011121325 24 3 2 1 11 21 52 32 45 34 3 2 1 11 21 52 32 4 Sample Output 12Case #1: 10Case #2: 11 分析 这题是一个贪心，由于每次选择的路径肯定是从根节点到一个叶结点的，则首先dfs计算出从根节点到叶子节点的路径上所有点的权值和，然后将叶结点按照路径权值和的从大到小排序，然后根据这个顺序向上走到根节点或则走到被选择的节点，计算权值和，然后计算出cnt（叶结点个数）个权值和，然后从大到小排序，选前k条路就是最优的路。 贪心证明：考虑一般情况，有一颗子树：a有两个子节点b和c，假设根节点到b的路径权值和比较大，则选择b向上走到一个已经被选择的节点或者根节点肯定比c要更优，因为b和c的最近公共祖先是a的根节点，且最近公共祖先到b和c的路径都没有被染色，则考虑更复杂的情况，可以发现，对于同一棵子树之中，叶子到子树根节点的路径权值和的偏序关系和根节点到该叶节点的路径权值和的偏序关系是相同的。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e5 +10;vector&lt;int&gt; G[MAXN];long long int val[MAXN], g[MAXN]; int fa[MAXN], d[MAXN], cnt;bool vis[MAXN]; bool cmp(int a, int b) &#123; return val[a] &gt; val[b];&#125;void dfs(int s) &#123; for(int i = 0; i &lt; G[s].size(); i++) &#123; val[G[s][i]] += val[s]; dfs(G[s][i]); &#125; if(!G[s].size()) d[cnt++] = s;&#125;long long int getNum(int k) &#123; long long int ret = 0; while(!vis[k]) &#123; ret += g[k]; vis[k] = true; k = fa[k]; &#125; return ret;&#125;int main(void) &#123; int t, n, k, u, v; scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; cas++) &#123; scanf("%d%d", &amp;n, &amp;k); for(int i = 1; i &lt;= n; i++) &#123; G[i].clear(); vis[i] = false; scanf("%lld", &amp;val[i]); g[i] = val[i]; &#125; for(int i = 0; i &lt; n- 1; i++) &#123; scanf("%d%d", &amp;u, &amp;v); fa[v] = u; G[u].push_back(v); &#125; cnt = 0; dfs(1); sort(d, d + cnt, cmp); for(int i = 0; i &lt; cnt; i++) &#123; val[i] = getNum(d[i]); &#125; sort(val, val + cnt); long long int ans = 0; for(int i = cnt - 1; i &gt;= cnt - k; i--) ans += val[i]; printf("Case #%d: %lld\n",cas, ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>贪心</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU5245-Joyful]]></title>
    <url>%2F2017%2F09%2F12%2FHDU5245-Joyful%2F</url>
    <content type="text"><![CDATA[题目链接 题目 Problem Description Sakura has a very magical tool to paint walls. One day, kAc asked Sakura to paint a wall that looks like an M×N matrix. The wall has M×N squares in all. In the whole problem we denotes (x,y) to be the square at the x-th row, y-th column. Once Sakura has determined two squares (x1,y1) and (x2,y2), she can use the magical tool to paint all the squares in the sub-matrix which has the given two squares as corners. However, Sakura is a very naughty girl, so she just randomly uses the tool for K times. More specifically, each time for Sakura to use that tool, she just randomly picks two squares from all the M×N squares, with equal probability. Now, kAc wants to know the expected number of squares that will be painted eventually. Input The first line contains an integer T(T≤100), denoting the number of test cases. For each test case, there is only one line, with three integers M,N and K. It is guaranteed that 1≤M,N≤500, 1≤K≤20. Output For each test case, output ''Case #t:'' to represent the t-th case, and then output the expected number of squares that will be painted. Round to integers. Sample Input 12323 3 14 4 2 Sample Output 12Case #1: 4Case #2: 8 Hint The precise answer in the first test case is about 3.56790123. 分析 计算出每一个格子被上色的概率，累加四舍五入就是答案，每个格子被上色的概率就是1减去不被上色的概率的k次方。计算一个格子不被上色的概率用到一个容斥定理。 计算两次选择都选在该格子一面的概率，累加四个面的概率，由于累加的时候重复计算了在格子的四个角的概率，则用容斥定力减去。 代码 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;double q_pow(double a, int b) &#123; double ans = 1.0, tmp = a; while(b) &#123; if(b &amp; 1) ans = ans * tmp; tmp = tmp * tmp; b &gt;&gt;= 1; &#125; return ans;&#125;int main(void) &#123; int t, k; double n, m; scanf("%d", &amp;t); int nn, mm; for(int cas = 1; cas &lt;= t; cas++) &#123; double ans = 0.5; scanf("%lf%lf%d", &amp;n, &amp;m, &amp;k); nn= (int)n, mm = (int)m; for(int i = 1; i &lt;= nn; i++) &#123; for(int j = 1; j &lt;= mm; j++) &#123; ans += 1.0 - q_pow((m * (i - 1) * m * (i - 1) + m * (n - i) * m * (n - i) + n * (j - 1) * n * (j - 1) + n * (m - j) * n * (m - j) - ((double)i - 1) * (j - 1) * (i - 1) * (j - 1) - (n - i) * (m - j) * (n - i) * (m - j) - (n - i) * (j - 1) * (n - i) * (j - 1) - (i - 1) * (m - j) * (i - 1) * (m - j)) / (n * m * n * m), k); &#125; &#125; printf("Case #%d: %d\n", cas, (int)ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数学</tag>
        <tag>容斥</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6146 Pokemon-GO]]></title>
    <url>%2F2017%2F08%2F25%2FHDU6146-Pokemon-GO%2F</url>
    <content type="text"><![CDATA[题目链接 题目 Problem Description 众所周知，度度熊最近沉迷于 Pokémon GO。 今天它决定要抓住所有的精灵球！ 为了不让度度熊失望，精灵球已经被事先放置在一个2*N的格子上，每一个格子上都有一个精灵球。度度熊可以选择任意一个格子开始游戏，抓捕格子上的精灵球，然后移动到一个相邻的至少有一个公共点的格子上继续抓捕。例如，(2, 2) 的相邻格子有(1, 1), (2, 1) 和 (1, 2) 等等。 现在度度熊希望知道将所有精灵球都抓到并且步数最少的方案数目。两个方案被认为是不同，当且仅当两个方案至少有一步所在的格子是不同的。 Input 第一行为T，表示输入数据组数。 每组数据包含一个数N。 ●1≤T≤100 ●1≤N≤10000 Output 对每组数据输出方案数目，结果对 1 000 000 007 取模。 Sample Input 12343123 Sample Output 12322496 分析 DP[i][0]：一个长度为i的图从左上角出发，所有的方案数。 DP[i][1]：一个长度为i的图从左上角出发回到左下角的方案数。 则显然要回到下面则，从第一个点出发进入[i - 1]的剩余部分有两种走法，即 dp[i][1] = 2 * dp[i - 1][0] 如果不要求回到左下角，则 dp[i][0] = ((dp[i - 1][1] + dp[i - 1][0] + dp[i - 2][0] * 2 ) * 2 其中每一项的意义： dp[i - 1][1]:先向右走，最后回到左下角 dp[i - 1][0]:先向下走，然后走剩下的右边剩余部分 dp[i - 2][0]:先在最开始的田字格里走一个叉，交叉的走完田字格，然后走剩下的部分。 最后统计答案时，枚举起点然后把图分成左右两部分，就可以用dp里的数值来统计答案。 代码 1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstring&gt;const long long int MOD = 1e9 + 7;const int MAXN = 1e4 + 10;long long int dp[MAXN][2];int main(void) &#123; dp[1][0] = 1; dp[1][1] = 1; dp[2][0] = 6; dp[2][1] = 2; for(int i = 3; i &lt; MAXN; i++) &#123; dp[i][1] = dp[i - 1][1] * 2 % MOD; dp[i][0] = (((dp[i - 1][1] + dp[i - 1][0]) % MOD + dp[i - 2][0] * 2 % MOD) % MOD) * 2 % MOD; &#125; int t, n; scanf("%d", &amp;t); while(t--) &#123; scanf("%d", &amp;n); if(n == 1) &#123; printf("2\n"); continue; &#125; long long int ans = dp[n][0]; for(int i = 2; i &lt; n; i++) &#123; ans = (ans + (dp[i][1] * dp[n - i][0] % MOD + dp[n - i + 1][1] * dp[i - 1][0] % MOD) % MOD) % MOD; &#125; ans = (ans * 4) % MOD; printf("%I64d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6134-Battlestation-Operational]]></title>
    <url>%2F2017%2F08%2F25%2FHDU6134-Battlestation-Operational%2F</url>
    <content type="text"><![CDATA[转载链接：http://blog.csdn.net/v5zsq/article/details/77338191 题目链接 题目 Problem Description The Death Star, known officially as the DS-1 Orbital Battle Station, also known as the Death Star I, the First Death Star, Project Stardust internally, and simply the Ultimate Weapon in early development stages, was a moon-sized, deep-space mobile battle station constructed by the Galactic Empire. Designed to fire a single planet-destroying superlaser powered by massive kyber crystals, it was the pet project of the Emperor, Darth Vader, and its eventual commander Grand Moff Wilhuff Tarkin to expound the military philosophy of the aptly named Tarkin Doctrine. — Wookieepedia In the story of the Rogue One, the rebels risked their lives stolen the construction plan of the Death Star before it can cause catastrophic damage to the rebel base. According to the documents, the main weapon of the Death Star, the Superlaser, emits asymmetric energy in the battlefield that cause photons to annihilate and burns everything in a single shot. You are assigned the task to estimate the damage of one shot of the Superlaser. Assuming that the battlefield is an n×n grid. The energy field ignited by the Superlaser is asymmetric over the grid. For the cell at i-th row and j-th column, ⌈i/j⌉ units of damage will be caused. Furthermore, due to the quantum effects, the energies in a cell cancel out if gcd(i,j)≠1 or i&lt;j. The figure below illustrates the damage caused to each cell for n=100. A cell in black indicates that this cell will not be damaged due to the quantum effects. Otherwise, different colors denote different units of damages. img Your should calculate the total damage to the battlefield. Formally, you should compute f(n)=∑i=1n∑j=1i⌈ij⌉[(i,j)=1], where [(i,j)=1] evaluates to be 1 if gcd(i,j)=1, otherwise 0. Input There are multiple test cases. Each line of the input, there is an integer n (1≤n≤106), as described in the problem. There are up to 104 test cases. Output For each test case, output one integer in one line denoting the total damage of the Superlaser, f(n) mod 109+7. Sample Input 12341 2310 Sample Output 1234138110 分析 img 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 1000005#define mod 1000000007typedef long long ll;int prime[maxn],mu[maxn],euler[maxn],res,d[maxn],temp[maxn];void Moblus(int n=1000000)&#123; mu[1]=euler[1]=d[1]=1; res=0; for(int i=2;i&lt;=n;i++) &#123; if(!temp[i]) &#123; prime[res++]=i; mu[i]=-1; euler[i]=i-1; temp[i]=i; d[i]=2; &#125; for(int j=0;j&lt;res&amp;&amp;i*prime[j]&lt;=n;j++) &#123; if(i%prime[j]==0) &#123; mu[i*prime[j]]=0; euler[prime[j]*i]=euler[i]*prime[j]; temp[i*prime[j]]=temp[i]*prime[j]; d[i*prime[j]]=d[i/temp[i]]*(d[temp[i]]+1); break; &#125; mu[i*prime[j]]=-mu[i]; euler[prime[j]*i]=euler[i]*(prime[j]-1); temp[i*prime[j]]=prime[j]; d[i*prime[j]]=2*d[i]; &#125; &#125;&#125;void inc(int &amp;x,int y)&#123; x=x+y&gt;=mod?x+y-mod:x+y;&#125;void dec(int &amp;x,int y)&#123; x=x-y&lt;0?x-y+mod:x-y;&#125;int ans[maxn];void init(int n=1000000)&#123; for(int i=1;i&lt;=n;i++) for(int j=i;j&lt;=n;j+=i) if(mu[j/i]==-1)dec(ans[j],d[i]); else if(mu[j/i]==1)inc(ans[j],d[i]); for(int i=1;i&lt;=n;i++) inc(ans[i],euler[i]),dec(ans[i],1),inc(ans[i],ans[i-1]);&#125;int main()&#123; Moblus(); for(int i=2;i&lt;=1000000;i++)d[i]+=d[i-1]; init(); int n; while(~scanf("%d",&amp;n)) printf("%d\n",ans[n]); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>莫比乌斯反演</tag>
        <tag>积性函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6107-Typesetting]]></title>
    <url>%2F2017%2F08%2F14%2FHDU6107-Typesetting%2F</url>
    <content type="text"><![CDATA[题目链接 题目 Problem Description Yellowstar is writing an article that contains N words and 1 picture, and the i-th word contains ai characters. The page width is fixed to W characters. In order to make the article look more beautiful, Yellowstar has made some rules: The fixed width of the picture is pw. The distance from the left side of the page to the left side of the photo fixed to dw, in other words, the left margin is dw, and the right margin is W - pw - dw. The photo and words can't overlap, but can exist in same line. The relative order of words cannot be changed. Individual words need to be placed in a line. If two words are placed in a continuous position on the same line, then there is a space between them. Minimize the number of rows occupied by the article according to the location and height of the image. However, Yellowstar has not yet determined the location of the picture and the height of the picture, he would like to try Q different locations and different heights to get the best look. Yellowstar tries too many times, he wants to quickly know the number of rows each time, so he asked for your help. It should be noted that when a row contains characters or pictures, the line was considered to be occupied. Input The first line of the input gives the number of test cases T; T test cases follow. Each case begins with one line with four integers N, W, pw, dw : the number of words, page width, picture width and left margin. The next line contains N integers ai, indicates i-th word consists of ai characters. The third line contains one integer Q. Then Q lines follow, each line contains the values of xi and hi, indicates the starting line and the image height of the image. Limits T≤10 1≤N,W,Q≤105 1≤pw,ai≤W 0≤dw≤W−pw Output For each query, output one integer denotes the minimum number of rows. Sample Input 123456789101122 7 4 31 331 22 25 23 8 2 31 1 311 1 Sample Output 12342331 分析 在固定某个宽度的前提下，预处理以第i个单词开始，一行内最多能放置的单词个数。因为页面宽度，图片的左右边距都固定了，所以只要预处理这3种宽度。用\(f_{i,j}\)表示从第i个单词开始，占用\(2^j\)行能放置的最大单词个数。图片最多将n个单词划分成3部分，每部分都使用倍增即可完成快速查询。为了方便，可以添加第n+1个单词，单词长度大于页面宽度且该单词不占据行。 时间复杂度 O((n+q)log(n) 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/** @Author: sun000* @Date: 2017-08-11 13:14:44* @Last Modified by: sun000* @Last Modified time: 2017-08-11 20:00:59*/#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAXN = 1e5 + 10;int n, w, pw, dw;int dp[3][MAXN][19];int l[MAXN], b[20];void init() &#123; memset(dp, 0, sizeof(dp)); int pl = 0, pr = 0, len = 0; for (; pl &lt; n; pl++) &#123; for(;pr &lt; n; pr++) &#123; if(len + l[pr] &gt; w + 1) break; else len += l[pr]; &#125; //printf("$$ %d %d %d\n", pl, pr, len); dp[0][pl][0] = pr - pl; len -= l[pl]; &#125; pl = 0, pr = 0, len = 0; for (; pl &lt; n; pl++) &#123; for(;pr &lt; n; pr++) &#123; if(len + l[pr] &gt; dw + 1) break; else len += l[pr]; &#125; //printf("$$ %d %d %d\n", pl, pr, len); dp[1][pl][0] = pr - pl; len -= l[pl]; &#125; pl = 0, pr = 0, len = 0; for (; pl &lt; n; pl++) &#123; for(;pr &lt; n; pr++) &#123; if(len + l[pr] &gt; w - dw - pw + 1) break; else len += l[pr]; &#125; //printf("$$ %d %d %d\n", pl, pr, len); dp[2][pl][0] = pr - pl; len -= l[pl]; &#125; for(int i = 0; i &lt; n; i++) dp[1][i][0] = dp[1][i][0] + dp[2][ i + dp[1][i][0] ][0]; for (int j = 1; j &lt; 18; j++) &#123; for (int i = 0; i &lt; n; i++) &#123; dp[0][i][j] = dp[0][i][j - 1] + dp[0][i + dp[0][i][j - 1]][j - 1]; dp[1][i][j] = dp[1][i][j - 1] + dp[1][i + dp[1][i][j - 1]][j - 1]; &#125; &#125;&#125;int query(int x, int h) &#123; int ret = 0, ans = 0; int tx = x, tl = 0; while (tx) &#123; if (tx &amp; 1) ret += dp[0][ret][tl]; tx &gt;&gt;= 1; tl++; &#125; if (ret &gt;= n) &#123; ret = 0; while (ret &lt; n) &#123; for (int i = 1; i &lt; 17; i++) &#123; if (dp[0][ret][i] == dp[0][ret][i + 1]) &#123; ans += b[i - 1]; ret += dp[0][ret][i - 1]; break; &#125; &#125; &#125; return ans + h; &#125; tx = h, tl = 0; while (tx) &#123; if (tx &amp; 1) ret += dp[1][ret][tl]; tx &gt;&gt;= 1; tl++; &#125; ans = x + h; if (ret &gt;= n) return ans; while (ret &lt; n) &#123; for (int i = 1; i &lt; 17; i++) &#123; if (dp[0][ret][i] == dp[0][ret][i + 1]) &#123; ans += b[i - 1]; ret += dp[0][ret][i - 1]; break; &#125; &#125; &#125; return ans;&#125;int main(void) &#123; // freopen("in.txt", "r", stdin); // freopen("out.txt", "w", stdout); b[0] = 1; for (int i = 1; i &lt; 20; i++) b[i] = b[i - 1] &lt;&lt; 1; int t, q, x, h; scanf("%d", &amp;t); while (t--) &#123; memset(dp, 0, sizeof(dp)); scanf("%d%d%d%d", &amp;n, &amp;w, &amp;pw, &amp;dw); for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;l[i]); l[i]++; &#125; init(); scanf("%d", &amp;q); for (int i = 0; i &lt; q; i++) &#123; scanf("%d%d", &amp;x, &amp;h); printf("%d\n", query(x - 1, h)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>倍增法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6103-Kirinriki]]></title>
    <url>%2F2017%2F08%2F14%2FHDU6103-Kirinriki%2F</url>
    <content type="text"><![CDATA[题目链接 题目 Problem Description We define the distance of two strings A and B with same length n is \(dis(A,B)=\sum_{i=0}^{(n−1)}{|A_i−B_{n−1−i}|}\) The difference between the two characters is defined as the difference in ASCII. You should find the maximum length of two non-overlapping substrings in given string S, and the distance between them are less then or equal to m. Input The first line of the input gives the number of test cases T; T test cases follow. Each case begins with one line with one integers m : the limit distance of substring. Then a string S follow. Limits T≤100 0≤m≤5000 Each character in the string is lowercase letter, 2≤|S|≤5000 ∑|S|≤20000 Output For each test case output one interge denotes the answer : the maximum length of the substring. Sample Input 12315abcdefedcb Sample Output 123455Hint[0, 4] abcde[5, 9] fedcbThe distance between them is abs(&apos;a&apos; - &apos;b&apos;) + abs(&apos;b&apos; - &apos;c&apos;) + abs(&apos;c&apos; - &apos;d&apos;) + abs(&apos;d&apos; - &apos;e&apos;) + abs(&apos;e&apos; - &apos;f&apos;) = 5 分析 容易得到取出的字串是一个回文串，当回文串的对称轴固定的时候，计算出有多少满足条件的回文串的时间复杂度是O(n)的：只要维护四个指针，左右各两个，指针只会往外移动，若满足条件，则外指针往外移动，否则内脂针向外移动一直到满足条件为止，那么总的时间复杂的是\(O(n^2)\)的。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** @Author: sun000* @Date: 2017-08-11 11:24:20* @Last Modified by: sun000 * @Last Modified time: 2017-08-11 11:41:25*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;char str[5010];int dis(char a, char b) &#123; int d = a - b; if(d &lt; 0) d = -d; return d;&#125;int main(void) &#123; int t, m; scanf("%d", &amp;t); while(t--) &#123; scanf("%d", &amp;m); scanf("%s", str); int len = strlen(str); int ls, le, rs, re; int ans = 0; for(int mid = 0; mid &lt; len; mid++) &#123; ls = le = mid, rs = re = mid + 1; int d = 0; for(;le &gt;= 0 &amp;&amp; re &lt; len; le--, re++) &#123; d += dis(str[le], str[re]); while(d &gt; m) &#123; d -= dis(str[ls], str[rs]); ls--; rs++; &#125; ans = max(ans, re - rs + 1); &#125; ls = le = mid - 1, rs = re = mid + 1; d = 0; for(;le &gt;= 0 &amp;&amp; re &lt; len; le--, re++) &#123; d += dis(str[le], str[re]); while(d &gt; m) &#123; d -= dis(str[ls], str[rs]); ls--; rs++; &#125; ans = max(ans, re - rs + 1); &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>暴力</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6053-TrickGCD]]></title>
    <url>%2F2017%2F08%2F14%2FHDU6053-TrickGCD%2F</url>
    <content type="text"><![CDATA[题目链接 题目 Problem Description You are given an array A , and Zhu wants to know there are how many different array B satisfy the following conditions? 1≤Bi≤Ai For each pair( l , r ) (1≤l≤r≤n) , gcd(bl,bl+1...br)≥2 Input The first line is an integer T(1≤T≤10) describe the number of test cases. Each test case begins with an integer number n describe the size of array A. Then a line contains n numbers describe each element of A You can assume that 1≤n,Ai≤105 Output For the kth test case , first output &quot;Case #k: &quot; , then output an integer as answer in a single line . because the answer may be large , so you are only need to output answer mod 109+7 Sample Input 123144 4 4 4 Sample Output 1Case #1: 17 分析 枚举gcd然后用莫比乌斯反演来计算。 设: ​ f(d): gcd是d时的方案数量 ​ F(n): gcd是n的倍数的方案数量 则 \[F(n)=\sum_{d|n}f(d) \\f(n)=\sum_{d|n}\mu(d)F(\frac{n}{d})\\f(n)=\sum_{d|n}\mu(\frac{n}{d})F(n)\] 那么问题就变成了如何快速的求出F(n) ​ \[F(n) = \sum_{i=1}^{n}{Ai/n}\] 容易看出这样计算F的复杂度是\(O(n^2)\)的，这需要优化。 我们用一个pre标记，如果有一个数tmp则pre[tmp]++,最后处理成前缀和的形式pre[i] += pre[i - 1]。 那么pre[i]就表示i及其之前出现了几个数字。那么我们枚举F(n)里gcd是n的倍数的这个“倍数k”则\(F(n)=\sum{k^{pre[(k+1)*n-1]-pre[k*n-1]}}​\) 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** @Author: sun000* @Date: 2017-08-07 16:13:26* @Last Modified by: sun000* @Last Modified time: 2017-08-07 17:09:34*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 2e5 + 10;const int INF = 0x3f3f3f3f;const long long int MOD = 1e9 + 7;int U[MAXN];void mobus()&#123; bool mark[MAXN]; int prime[MAXN]; int pcnt = 0; memset(mark, 0, sizeof(mark)); U[1] = 1; for (int i = 2; i &lt; MAXN; i++) &#123; if (mark[i] == 0) &#123; prime[pcnt++] = i; U[i] = -1; &#125; for (int j = 0; j &lt; pcnt &amp;&amp; i * prime[j] &lt; MAXN; j++) &#123; int tmp = i * prime[j]; mark[tmp] = 1; if (i % prime[j] == 0) &#123; U[tmp] = 0; break; &#125; U[tmp] = -U[i]; &#125; &#125;&#125;long long int pre[MAXN], F[MAXN];long long int q_pow(long long int a, int b) &#123; long long int ans = 1, temp = a; while (b) &#123; if (b &amp; 1) ans = ans * temp % MOD; temp = temp * temp % MOD; b &gt;&gt;= 1; &#125; return ans;&#125;int main(void) &#123; //freopen("in.txt", "r", stdin); //freopen("out.txt", "w", stdout); int t, n, temp; mobus(); scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; cas++) &#123; memset(pre, 0, sizeof(pre)); scanf("%d", &amp;n); int mi = INF, ma = -INF; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;temp); mi = min(mi, temp); ma = max(ma, temp); pre[temp]++; &#125; for (int i = 1; i &lt; MAXN; i++) pre[i] += pre[i - 1]; for (int d = 1; d &lt;= mi; d++) &#123; F[d] = 1; for (int k = 1; k &lt;= ma / d; k++) F[d] = (F[d] * q_pow((long long int)k, pre[(k + 1) * d - 1] - pre[k * d - 1])) % MOD; &#125; long long int ans = 0; for(int d = 2; d &lt;= mi; d++) for(int num = 1; num * d &lt;= ma; num++) ans = (ans + (long long int)U[num] * F[d * num] % MOD) % MOD; printf("Case #%d: %lld\n", cas, ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6050 Funny Function]]></title>
    <url>%2F2017%2F08%2F08%2FHDU6050-Funny-Function%2F</url>
    <content type="text"><![CDATA[题目链接 题目 Problem Description Function Fx,ysatisfies: For given integers N and M,calculate Fm,1 modulo 1e9+7. Input There is one integer T in the first line. The next T lines,each line includes two integers N and M . 1&lt;=T&lt;=10000,1&lt;=N,M&lt;2^63. Output For each given N and M,print the answer in a single line. Sample Input 12322 23 3 Sample Output 12233 分析 这是一个数学推导题，首先不难发现对于每一个i都有\(F_{i,j}=F_{i,j-1}+2*F_{i,j-2}\)则\(F_{i,j}+F_{i,j-1}=2*(F_{i,j-1}+F_{i,j-2})\)即 \[ F_{i,j}+F_{i,j-1}=4*(F_{i,j-2}+F_{i,j-3}) \] 则对于每一行，每两个连续的两项看成一项，那么现在对于n我们分奇偶来考虑，首先考虑 当n为偶数时 \[F_{i,1}=\sum_{k=1}^{n}{F_{i-1,k}} = F_{i-1,1}+F_{i-1,2}+……F_{i-1,n-1}+F_{i-1,n}\] \[=\left(F_{i-1,1}+F_{i-1,2}\right)+4*\left(F_{i-1,1}+F_{i-1,2}\right)……+4^{\frac{n}{2}-1}*\left(F_{i-1,1}+F_{i-1,2}\right)\] ​ \[=\frac{2^n- 1}{3}*F_{i-1,1}+\frac{2^n- 1}{3}*F_{i-1,2}\] ​ \[F_{i,2}=\sum_{k=2}^{n+1}{F_{i-1,k}}=F_{i-1,2}+F_{i-1,3}+……F_{i-1,n}+F_{i-1,n+1}\] ​ \[=\left(F_{i-1,2}+F_{i-1,3}\right)+4*\left(F_{i-1,2}+F_{i-1,3}\right)……+4^{\frac{n}{2}-1}*\left(F_{i-1,2}+F_{i-1,3}\right)\] ​ \[=\frac{2^n-1}{3}*\left(F_{i-1,2}+F_{i-1,3}\right)=\frac{2*\left(2^n-1\right)}{3}*F_{i-1,1}+\frac{2*\left(2^n-1\right)}{3}*F_{i-1,2}\] 当n为奇数时 \[F_{i,1}=\sum_{k=1}^{n}{F_{i-1,k}} = F_{i-1,1}+F_{i-1,2}+……F_{i-1,n-1}+F_{i-1,n}\] ​ \[=F_{i-1,1}+\left(F_{i-1,2}+F_{i-1,3}\right)+4*\left(F_{i-1,2}+F_{i-1,3}\right)……+4^{\frac{n-1}{2}-1}*\left(F_{i-1,2}+F_{i-1,3}\right)\] ​ \[=F_{i-1,1}+\left(F_{i-1,2}+F_{i-1,3}\right)\frac{2^{n-1}-1}{3}=F_{i-1,1}+\left(F_{i-1,1}+F_{i-1,2}\right)\frac{2^n-2}{3}\] ​ \[=\frac{2^n+1}{3}*F_{i-1,1}+\frac{2^n-2}{3}*F_{i-1,2}\] ​ \[F_{i,2}=\sum_{k=2}^{n+1}{F_{i-1,k}}=F_{i-1,2}+F_{i-1,3}+……F_{i-1,n}+F_{i-1,n+1}\] ​ \[=F_{i-1,2}+\left(F_{i-1,3}+F_{i-1,4}\right)+4*\left(F_{i-1,3}+F_{i-1,4}\right)……+4^{\frac{n-1}{2}-1}*\left(F_{i-1,3}+F_{i-1,4}\right)\] ​ \[=F_{i-1,2}+\left(F_{i-1,3}+F_{i-1,4}\right)\frac{2^{n-1}-1}{3}=F_{i-1,2}+\left(F_{i-1,1}+F_{i-1,2}\right)\frac{2^{n+1}-4}{3}\] ​ \[=\frac{2^{n+1}-4}{3}*F_{i-1,1}+\frac{2^{n+1}-1}{3}*F_{i-1,2}\] 这样就可以用矩阵快速幂在o(log(n))的时间复杂度下求解了。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** @Author: sun000* @Date: 2017-08-07 12:38:12* @Last Modified by: sun000 * @Last Modified time: 2017-08-07 13:41:28*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const long long int mod = 1e9 + 7;const long long int inv3 = 333333336;//除3取模要求逆元struct MAT&#123; int r, c; long long int mx[2][2]; MAT()&#123;&#125; MAT(int rr = 0, int cc = 0):r(rr),c(cc)&#123;&#125; friend MAT operator *(MAT ta, MAT tb)&#123; MAT tc(ta.r, tb.c); for(int i = 0; i &lt; tc.r; i++) for(int j = 0; j &lt; tc.c; j++)&#123; tc.mx[i][j] = 0; for(int k = 0; k &lt; tb.r; k++) tc.mx[i][j] = (tc.mx[i][j] + ta.mx[i][k] * tb.mx[k][j] % mod) % mod; &#125; return tc; &#125; friend MAT operator ^(MAT ta, long long int num)&#123; MAT ret(ta.r, ta.c); memset(ret.mx, 0, sizeof(ret.mx)); for(int i = 0; i &lt; ta.r; i++) ret.mx[i][i] = 1; while(num)&#123; if(num &amp; 1) ret = ta * ret; num &gt;&gt;= 1; ta = ta * ta; &#125; return ret; &#125;&#125;;long long int q_pow(long long int a, long long int b) &#123; long long int ans = 1, temp = a; while(b) &#123; if(b &amp; 1) ans = (ans * temp) % mod; temp = (temp * temp) % mod; b &gt;&gt;= 1; &#125; return ans;&#125;MAT getMAT(long long int n) &#123; if(n == 1) return 1; MAT m(2, 2); if(n &amp; 1) &#123; m.mx[0][0] = (q_pow(2, n) + 1) * inv3 % mod; m.mx[0][1] = (((q_pow(2, n + 1) - 4 ) * inv3 % mod) + mod) % mod; m.mx[1][0] = (((q_pow(2, n) - 2) * inv3 % mod) + mod) % mod; m.mx[1][1] = (((q_pow(2, n + 1) - 1) * inv3 % mod) + mod) % mod; &#125;else &#123; m.mx[0][0] = m.mx[1][0] = ((q_pow(2, n) - 1) * inv3 % mod + mod) % mod; m.mx[0][1] = m.mx[1][1] = (((q_pow(2, n) - 1) * 2 % mod) * inv3 % mod + mod) % mod; &#125; //printf("-----\n%lld %lld\n%lld %lld\n-----\n", m.mx[0][0], m.mx[0][1], m.mx[1][0], m.mx[1][1]); //getchar(); return m;&#125;long long int solve(long long int n, long long int m) &#123; MAT s(2, 2); MAT g(2, 2); g = getMAT(n); s.mx[0][0] = s.mx[0][1] = 1; s.mx[1][0] = s.mx[1][1] = 0; MAT ans = s * (g ^ (m - 1)); return ans.mx[0][0];&#125;int main(void) &#123; // freopen("in.txt", "r", stdin); // freopen("out.txt", "w", stdout); int t; long long int n, m; scanf("%d", &amp;t); while(t--) &#123; scanf("%lld%lld", &amp;n, &amp;m); printf("%lld\n", solve(n, m)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数学</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6044 Limited Permutation]]></title>
    <url>%2F2017%2F07%2F26%2FHDU6044-Limited-Permutation%2F</url>
    <content type="text"><![CDATA[题目链接 题目 Problem Description As to a permutation p1,p2,⋯,pn from 1 to n, it is uncomplicated for each 1≤i≤n to calculate (li,ri) meeting the condition that min(pL,pL+1,⋯,pR)=pi if and only if li≤L≤i≤R≤ri for each 1≤L≤R≤n. Given the positive integers n, (li,ri) (1≤i≤n), you are asked to calculate the number of possible permutations p1,p2,⋯,pn from 1 to n, meeting the above condition. The answer may be very large, so you only need to give the value of answer modulo 109+7. Input The input contains multiple test cases. For each test case: The first line contains one positive integer n, satisfying 1≤n≤106. The second line contains n positive integers l1,l2,⋯,ln, satisfying 1≤li≤i for each 1≤i≤n. The third line contains n positive integers r1,r2,⋯,rn, satisfying i≤ri≤n for each 1≤i≤n. It's guaranteed that the sum of n in all test cases is not larger than 3⋅106. Warm Tips for C/C++: input data is so large (about 38 MiB) that we recommend to use fread() for buffering friendly. 1size_t fread(void *buffer, size_t size, size_t count, FILE *stream); // reads an array of count elements, each one with a size of size bytes, from the stream and stores them in the block of memory specified by buffer; the total number of elements successfully read is returned. Output For each test case, output &quot;Case #x: y&quot; in one line (without quotes), where x indicates the case number starting from 1 and y denotes the answer of corresponding case. Sample Input 3 1 1 3 1 3 3 5 1 2 2 4 5 5 2 5 5 5 Sample Output Case #1: 2 Case #2: 3 分析 注意到题目中：有n个区间，对于第i个区间[li,ri]有li&lt;=i&lt;=ri,对于任意1&lt;=L&lt;=i&lt;=R&lt;=n，当前仅当li&lt;=L&lt;=i&lt;=R&lt;=ri时P[i]=min(P[L],P[L+1],...,P[R])，即对于P[i]一定有P[i]&gt;P[li-1]且P[i]&gt;P[ri+1]，也就是说区间\([l_i,r_i]\)(除了[1,n])一定被某个区间[lj,rj]包含,且j=li-1或j=ri+1 即区间j可分成[lj,j-1]和[j+1,rj]。 注意到一个非常巧妙的点：我们将区间按照L升序，R降序的顺序排序：得到的这个序列恰好就是这可笛卡尔树的先跟DFS序 则我们dfs往下走，每一个区间和给定的区间恰好是一一对应的，否则构不成笛卡尔树，则无答案。 若存在一棵笛卡尔树（不能真的去建树，会爆内存，gg），则这棵笛卡尔树是唯一的。每棵子树都基于相似的子问题，所以我们只需要在合并子树时计算子树的组合即可。例如 u 有两个儿子 v1 和 v2 ，它们的子树对应的方案数分别为 f(v1) 和 f(v2) ，子树大小分别为 s(v1) 和 s(v2) ，则 u 的子树对应的方案数为 \(f(u)=C(s(v1)+s(v2), s(v1))*f(v1)*f(v2)\) C(a, b)是求组合数的意思，要取模，所以要求逆元。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/** @Author: sun000* @Date: 2017-07-26 20:13:20* @Last Modified by: sun000* @Last Modified time: 2017-07-26 21:58:52*/#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e6 + 10;const long long int MOD = 1e9 + 7;namespace fastIO &#123; const int MAXN = 4e7; char buf[MAXN]; int p, len;//指向当前读到的位子的指针 void begin() &#123; p = 0; len = fread(buf, 1, MAXN, stdin); &#125; inline bool isNum(char c) &#123; if('0' &lt;= c &amp;&amp; c &lt;= '9') return true; return false; &#125; inline bool read(int &amp;t) &#123; t = 0; while(p &lt; len &amp;&amp; !isNum(buf[p])) p++; if(p &gt;= len) return false; while(isNum(buf[p])) t = t * 10 + buf[p++] -'0'; return true; &#125;&#125;int n;struct node &#123; int l, r, id; node *lson, *rson; node()&#123;&#125; node(int _l, int _r):l(_l),r(_r)&#123; lson = rson = NULL; &#125;&#125;s[MAXN], *root;bool cmp(const node &amp;a,const node &amp;b) &#123; if(a.l == b.l) return a.r &gt; b.r; return a.l &lt; b.l;&#125;int inv[MAXN];void init()&#123; inv[1] = 1; for (int i = 2; i &lt; MAXN; i++) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;&#125;long long int C(int a, int b) &#123; // printf("c(%d %d)\n", a, b); b = min(b, a - b); if(!b) return 1; long long int temp = 1; long long int B = (long long int)b; long long int A = (long long int)a; for(long long int i = 0; i &lt; B; i++) temp = (temp * (A - i) % MOD * (long long int)inv[i + 1]) % MOD; return temp;&#125;bool flag;int cnt;long long int dfs(int l, int r) &#123; if(!flag) return 0; if(l &gt; r) return 1; if(s[cnt].l == l &amp;&amp; s[cnt].r == r) &#123; node now = s[cnt++]; long long int temp = (C(now.r - now.l, now.id - now.l) * dfs(now.l, now.id - 1) % MOD) * dfs(now.id + 1, now.r) % MOD; if(temp == 0) flag = false; return temp; &#125; else &#123; flag = false; return 0; &#125;&#125;long long int solve() &#123; flag = true; cnt = 0; sort(s, s + n, cmp); return dfs(1, n);&#125;int main(void) &#123; init(); fastIO::begin(); int cas = 1; while(fastIO::read(n)) &#123; for(int i = 0; i &lt; n; i++) fastIO::read(s[i].l), s[i].id = i + 1; for(int i = 0; i &lt; n; i++) fastIO::read(s[i].r); printf("Case #%d: %lld\n", cas++, solve()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数学</tag>
        <tag>图论</tag>
        <tag>搜索</tag>
        <tag>多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6040 Hints of sd0061]]></title>
    <url>%2F2017%2F07%2F26%2FHDU6040-Hints-of-sd0061%2F</url>
    <content type="text"><![CDATA[题目链接 题目 Problem Description sd0061, the legend of Beihang University ACM-ICPC Team, retired last year leaving a group of noobs. Noobs have no idea how to deal with m coming contests. sd0061 has left a set of hints for them. There are n noobs in the team, the i-th of which has a rating ai. sd0061 prepares one hint for each contest. The hint for the j-th contest is a number bj, which means that the noob with the (bj+1)-th lowest rating is ordained by sd0061 for the j-th contest. The coach asks constroy to make a list of contestants. constroy looks into these hints and finds out: bi+bj≤bk is satisfied if bi≠bj, bi]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数学</tag>
        <tag>多校</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6035 Colorful Tree]]></title>
    <url>%2F2017%2F07%2F26%2FHDU6035-Colorful-Tree%2F</url>
    <content type="text"><![CDATA[题目链接 题目 Problem Description There is a tree with n nodes, each of which has a type of color represented by an integer, where the color of node i is ci. The path between each two different nodes is unique, of which we define the value as the number of different colors appearing in it. Calculate the sum of values of all paths on the tree that has n(n−1)2 paths in total. Input The input contains multiple test cases. For each test case, the first line contains one positive integers n, indicating the number of node. (2≤n≤200000) Next line contains n integers where the i-th integer represents ci, the color of node i. (1≤ci≤n) Each of the next n−1 lines contains two positive integers x,y (1≤x,y≤n,x≠y), meaning an edge between node x and node y. It is guaranteed that these edges form a tree. Output For each test case, output &quot;Case #x: y&quot; in one line (without quotes), where x indicates the case number starting from 1 and y denotes the answer of corresponding case. Sample Input 3 1 2 1 1 2 2 3 6 1 2 1 3 2 1 1 2 1 3 2 4 2 5 3 6 Sample Output Case #1: 6 Case #2: 29 分析 ​ 单独考虑每一种颜色，答案就是对于每种颜色至少经过一次这种的路径条数之和。反过来思考只需要求有多少条路径没有经过这种颜色即可。直接做可以采用虚树的思想（不用真正建出来），对每种颜色的点按照 dfs 序列排个序，就能求出这些点把原来的树划分成的块的大小。这个过程实际上可以直接一次 dfs 求出。 这些都是官方题解，其实我就是DFS瞎记录了一些值搞了高就好了，看代码就能看懂，都有注释。和官方题解一样转化，求反面的路径数量，求法如代码DFS。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** @Author: sun000* @Date: 2017-07-25 10:27:08* @Last Modified by: sun000* @Last Modified time: 2017-07-25 11:16:17*/#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 2e5 + 10;vector&lt;int&gt; g[MAXN];int del[MAXN];//记录当前每个颜色已经分出来的块的大小bool vis[MAXN];int col[MAXN], n;long long int ans;//记录的是反面，不经过某个颜色的路径数量int cnt; //时间戳void addEdge(int u, int v) &#123; g[u].push_back(v);&#125;long long int cal(long long int k) &#123; if(k == 0) return 0; return k * (k - 1) / 2;&#125;void dfs(int u) &#123; cnt++; int v, now = cnt; int pre = del[col[u]];//不在这条路的子树里的已经分出来块 for(int i = 0; i &lt; g[u].size(); i++) &#123; v = g[u][i]; if(!vis[v]) &#123; vis[v] = true;; dfs(v); int temp = cnt - now - (del[col[u]] - pre); //重新回到u的v子树的大小-（v子树里+之前分出的块的总和）+不是v子树的块的数量 ans += cal(temp); del[col[u]] += temp; &#125; &#125; del[col[u]]++;//加上u颜色本身&#125;int main(void) &#123; int cas = 1; while(scanf("%d", &amp;n) != EOF) &#123; ans = 0, cnt = 0; memset(vis, false, sizeof(vis)); memset(del, 0, sizeof(del)); for(int i = 1; i &lt;= n; i++) &#123; g[i].clear(); scanf("%d", &amp;col[i]); &#125; int u, v; for(int i = 0; i &lt; n - 1; i++) &#123; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); &#125; vis[1] = true; dfs(1); long long int tot = 0; memset(vis, false, sizeof(vis)); for(int i = 1; i &lt;= n; i++) &#123;//最后计算根节点所在的各种颜色的分块数量 if(!vis[col[i]]) &#123; tot += cal(n); ans += cal(n - del[col[i]]); vis[col[i]] = true; &#125; &#125; printf("Case #%d: %lld\n", cas++, tot - ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
        <tag>DFS</tag>
        <tag>多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces832D. Misha, Grisha-and-Underground]]></title>
    <url>%2F2017%2F07%2F24%2FCodeForces832D-Misha-Grisha-and-Underground%2F</url>
    <content type="text"><![CDATA[题目链接 题目 Misha and Grisha are funny boys, so they like to use new underground. The underground has n stations connected with n - 1 routes so that each route connects two stations, and it is possible to reach every station from any other. The boys decided to have fun and came up with a plan. Namely, in some day in the morning Misha will ride the underground from station s to station f by the shortest path, and will draw with aerosol an ugly text &quot;Misha was here&quot; on every station he will pass through (including s and f). After that on the same day at evening Grisha will ride from station t to station f by the shortest path and will count stations with Misha's text. After that at night the underground workers will wash the texts out, because the underground should be clean. The boys have already chosen three stations a, b and c for each of several following days, one of them should be station s on that day, another should be station f, and the remaining should be station t. They became interested how they should choose these stations s, f, tso that the number Grisha will count is as large as possible. They asked you for help. Input The first line contains two integers n and q (2 ≤ n ≤ 105, 1 ≤ q ≤ 105) — the number of stations and the number of days. The second line contains n - 1 integers p2, p3, ..., *p**n* (1 ≤ pi ≤ n). The integer pi means that there is a route between stations *p**i* and i. It is guaranteed that it's possible to reach every station from any other. The next q lines contains three integers a, b and c each (1 ≤ a, b, c ≤ n) — the ids of stations chosen by boys for some day. Note that some of these ids could be same. Output Print q lines. In the i-th of these lines print the maximum possible number Grisha can get counting when the stations s, t and f are chosen optimally from the three stations on the i-th day. Examples input 3 2 1 1 1 2 3 2 3 3 output 2 3 input 4 1 1 2 3 1 2 3 output 2 Note In the first example on the first day if s = 1, f = 2, t = 3, Misha would go on the route 1 -&gt; 2, and Grisha would go on the route 3 -&gt; 1 -&gt;2. He would see the text at the stations 1 and 2. On the second day, if s = 3, f = 2, t = 3, both boys would go on the route 3 -&gt; 1 -&gt; 2. Grisha would see the text at 3 stations. In the second examle if s = 1, f = 3, t = 2, Misha would go on the route 1 -&gt; 2 -&gt; 3, and Grisha would go on the route 2 -&gt; 3 and would see the text at both stations. 分析 枚举f是哪一个点， 求出s-&gt;f, t-&gt;f,s-&gt;t的长度，\(l_0,l_1,l_2\)则\(ans = (l_0 + l_1 - l_2) / 2 + 1\) 简单证明： 如图s-f和t-f的路径上的公共长度是$(l_0 + l_1 - l_2) / 2 $加上本身的点就是ans了 IMG_2558 LCA就用在求路径上，比如：要求a到b的路径长度 deep[a] +deep[b] - 2 * deep[ lca(a, b)] 附上倍增法LCA链接http://sun000.cn/2017/07/24/倍增法LCA/ 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int head[100010], cnt;int fa[100010][20];//节点i的2^j个人祖先是什么int deep[100010]; //deep保存每个节点的深度，CNT为保存图的虚拟指针int n, m, root; // root为根节点编号struct node &#123; int next, v;&#125; e[1000010];void add(int a, int b)&#123; e[cnt].v = b; e[cnt].next = head[a]; head[a] = cnt; cnt++;&#125;void dfs(int x) &#123;//计算每一个节点的深度 for (int i = head[x]; i; i = e[i].next) &#123; int v = e[i].v; if (!deep[v]) &#123; deep[v] = deep[x] + 1; fa[v][0] = x; dfs(v); &#125; &#125;&#125;void init() &#123; memset(deep, 0, sizeof(deep)); deep[1] = 1; dfs(root); cnt = 1; for (int i = 1; i &lt; 20; i++) for (int j = 1; j &lt;= n; j++) fa[j][i] = fa[fa[j][i - 1]][i - 1];&#125;int lca(int x, int y) &#123; if (deep[x] &lt; deep[y]) swap(x, y); // 如果深度不同 调到同一深度 for (int i = 19; i &gt;= 0; i--) &#123; if (deep[fa[x][i]] &gt;= deep[y]) x = fa[x][i]; &#125; if (x == y) return x; for (int i = 19; i &gt;= 0; i--) if (fa[x][i] != fa[y][i]) &#123;//同时向上跳 x = fa[x][i]; y = fa[y][i]; &#125; return fa[x][0];&#125;int getlen(int a, int b) &#123; int l = lca(a, b); return deep[a] +deep[b] - 2 * deep[l];&#125;int main()&#123; int q; scanf("%d%d", &amp;n, &amp;q); int temp; for (int i = 2; i &lt;= n; i++) &#123; scanf("%d", &amp;temp); add(i, temp); add(temp, i); &#125; root = 1; init(); for (int i = 0; i &lt; q; i++) &#123; int ans = -1; int x, y, z; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); int xy = getlen(x, y); int xz = getlen(x, z); int yz = getlen(y, z); ans = max(ans, xy + xz - yz); ans = max(ans, xy + yz - xz); ans = max(ans, yz + xz - xy); printf("%d\n", ans / 2 + 1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[倍增法LCA]]></title>
    <url>%2F2017%2F07%2F24%2F%E5%80%8D%E5%A2%9E%E6%B3%95LCA%2F</url>
    <content type="text"><![CDATA[简介 今天学习了一个倍增法LCA实现起来很方便，而且算法复杂度\(log_2(d)\)其中d是树的深度，其实写法也很简单，就是用一个： fa[i][j]数组用来记录i标号的节点的第\(2^j\)个祖先 很容易就能得到fa[i][j]的递推式子是： fa[i][j] = fa[fa[i][j - 1]][j - 1] 根据二进制的原理，i可以通过二进制向上跳到达任何祖先。 查询过程lca(u, v) u和v所在的树的层数如果一样，令u'=u。否则需要平衡操作（假设u更深），先找到u的一个祖先u', 使得u'的层数和v一样，此时lca(u,v)=lca(u',v) 。 证明很简单：如果LCA(u,v)=v , 那么u'一定等于v ;如果LCA(u,v)=k ，k!=v ，那么k 的深度一定小于 v ， u、u'、v 一定在k的子树中；综上所述，lca(u,v)=lca(u',v)一定成立。 此时u' 和 v 的祖先序列中一开始的部分一定有所重叠，重叠部分的最后一个元素（也就是深度最深，与u'、v最近的元素）就是所求的lca(u,v)。这里fa数组就可以派上用场了。找到第一个不重叠的节点k，lca(u,v)=fa[k][0] 。 找k的过程利用二进制贪心思想，先尽可能跳到最上层的祖先，如果两祖先相等，说明完全可以跳小点，跳的距离除2，这样一步步跳下去一定可以找到k。 模版 ​ 例题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int head[100010], cnt;int fa[100010][20];//节点i的2^j个人祖先是什么int deep[100010]; //deep保存每个节点的深度，CNT为保存图的虚拟指针int n, m, root; // root为根节点编号struct node &#123; int next, v;&#125; e[1000010];void add(int a, int b)&#123; e[cnt].v = b; e[cnt].next = head[a]; head[a] = cnt; cnt++;&#125;void dfs(int x) &#123;//计算每一个节点的深度 for (int i = head[x]; i; i = e[i].next) &#123; int v = e[i].v; if (!deep[v]) &#123; deep[v] = deep[x] + 1; fa[v][0] = x; dfs(v); &#125; &#125;&#125;void init() &#123; memset(deep, 0, sizeof(deep)); deep[1] = 1; dfs(root); cnt = 1; for (int i = 1; i &lt; 20; i++) for (int j = 1; j &lt;= n; j++) fa[j][i] = fa[fa[j][i - 1]][i - 1];&#125;int lca(int x, int y) &#123; if (deep[x] &lt; deep[y]) swap(x, y); // 如果深度不同 调到同一深度 for (int i = 19; i &gt;= 0; i--) &#123; if (deep[fa[x][i]] &gt;= deep[y]) x = fa[x][i]; &#125; if (x == y) return x; for (int i = 19; i &gt;= 0; i--) if (fa[x][i] != fa[y][i]) &#123;//同时向上跳 x = fa[x][i]; y = fa[y][i]; &#125; return fa[x][0];&#125;int getlen(int a, int b) &#123; int l = lca(a, b); return deep[a] +deep[b] - 2 * deep[l];&#125;int main()&#123; int q; scanf("%d%d", &amp;n, &amp;q); int temp; for (int i = 2; i &lt;= n; i++) &#123; scanf("%d", &amp;temp); add(i, temp); add(temp, i); &#125; root = 1; init(); for (int i = 0; i &lt; q; i++) &#123; int ans = -1; int x, y, z; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); int xy = getlen(x, y); int xz = getlen(x, z); int yz = getlen(y, z); ans = max(ans, xy + xz - yz); ans = max(ans, xy + yz - xz); ans = max(ans, yz + xz - xy); printf("%d\n", ans / 2 + 1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yet another card game]]></title>
    <url>%2F2017%2F07%2F23%2FYet-another-card-game%2F</url>
    <content type="text"><![CDATA[题目链接 题目 Petr and Snuke are playing a cooperative card game. The game is played with special cards: each card is labeled with some positive integer. The integers on cards are not necessarily distinct. At the beginning of the game Petr is holding some cards in his hand and Snuke is holding all the other cards in his hand. You are given int[]s petr and snuke that describe the state at the beginning of the game: the elements of petr are the numbers on Petr's cards and the elements of snuke are the numbers on Snuke's cards. During the game the players will place some of their cards onto a pile. Initially, the pile is empty. The players take alternating turns, Petr goes first. In each turn, if the current player has no cards in his hand, the game ends. Otherwise, the player must make exactly one valid move. There are three types of valid moves: If the pile is empty, the player may choose any card and place it onto the pile. If the pile is not empty, the player may choose any card and place it on top of the pile. However, this move is only valid if the number on the new card is strictly greater than the number on the card that was previously on the top of the pile. The player may always choose one of his cards and eat it. Petr and Snuke have a common goal: they want to create a pile with as many cards as possible. Return the size of the pile at the end of the game, assuming that they cooperate and play the game optimally. Input The first line contains integer n — number of cards of Petr and Snuke (1 ≤ n ≤ 50). Next line contains numbers f1, f2... *f**n* — numbers written on Petr's cards. Next line contains numbers s1, s2... *s**n* — numbers written on Snuke's cards. 1 ≤ fi, si ≤ 100. Output Output integer — the maximum size of the pile, that can be created. Examples input 2 2 5 3 1 output 3 input 5 1 1 1 1 1 1 1 1 1 1 output 1 input 5 1 4 6 7 3 1 7 1 5 7 output 6 分析 动态规划，定义dp[i][j]记录第i次操作下堆顶为最大是j的情况下的size 转移方程见代码，可以滚动数组，我写的有点丑，但是意思是那么个意思。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243/** @Author: sun000* @Date: 2017-07-23 13:31:11* @Last Modified by: sun000* @Last Modified time: 2017-07-23 14:07:04*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int dp[105][105];//第i次操作后pile顶最大是j的最大sizeint f[55], s[55];int main(void) &#123; int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;f[i]); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;s[i]); memset(dp, 0, sizeof(dp)); for (int i = 1; i &lt;= 2 * n; i++) &#123; for (int j = 0; j &lt; n; j++) for (int k = 0; k &lt; f[j]; k++) dp[i + 1][f[j]] = dp[i][f[j]] = max(dp[i][f[j]], dp[i - 1][k] + 1); i++; for (int j = 0; j &lt; n; j++) for (int k = 0; k &lt; s[j]; k++) dp[i + 1][s[j]] = dp[i][s[j]] = max(dp[i][s[j]], dp[i - 1][k] + 1); &#125; int ans = -1; for (int i = 0; i &lt;= 100; i++) ans = max(ans, dp[n * 2][i]); printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 3760 Ideal Path]]></title>
    <url>%2F2017%2F07%2F22%2FHDU-3760-Ideal-Path%2F</url>
    <content type="text"><![CDATA[题目链接 题目 Problem Description New labyrinth attraction is open in New Lostland amusement park. The labyrinth consists of n rooms connected by m passages. Each passage is colored into some color ci. Visitors of the labyrinth are dropped from the helicopter to the room number 1 and their goal is to get to the labyrinth exit located in the room number n. Labyrinth owners are planning to run a contest tomorrow. Several runners will be dropped to the room number 1. They will run to the room number n writing down colors of passages as they run through them. The contestant with the shortest sequence of colors is the winner of the contest. If there are several contestants with the same sequence length, the one with the ideal path is the winner. The path is the ideal path if its color sequence is the lexicographically smallest among shortest paths. Andrew is preparing for the contest. He took a helicopter tour above New Lostland and made a picture of the labyrinth. Your task is to help him find the ideal path from the room number 1 to the room number n that would allow him to win the contest. Note A sequence (a1, a2, …, ak) is lexicographically smaller than a sequence (b1, b2, …, bk) if there exists i such that ai &lt; bi, and aj = bj for all j &lt; i. Input The input begins with an integer T. The next T blocks each represents a case. The first line of each case contains integers n and m - the number of rooms and passages, respectively (2 ≤ n ≤ 100 000, 1 ≤ m ≤ 200 000). The following m lines describe passages, each passage is described with three integer numbers: ai, bi, and ci - the numbers of rooms it connects and its color (1 ≤ ai, bi ≤ n, 1 ≤ ci ≤ 109). Each passage can be passed in either direction. Two rooms can be connected with more than one passage, there can be a passage from a room to itself. It is guaranteed that it is possible to reach the room number n from the room number 1. Output For each case, the first line of the output must contain k - the length of the shortest path from the room number 1 to the room number n. The second line must contain k numbers - the colors of passages in the order they must be passed in the ideal path. Sample Input 1 4 6 1 2 1 1 3 2 3 4 3 2 3 1 2 4 4 3 1 1 Output 2 1 3 分析 先BFS求出所有的最短路，然后在最短路构成的图上分层搜索，求出字典序最小的路径。判断一个点是否在最短路上：只要求出起点到这一点的最短路a和终点到这一点的最短路b如果a+b等于起点到终点的最短路L则这一点在最短路上。至于分层的话，所在的层就是起点到这一点的最短路。map去重小优化。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/** @Author: sun000* @Date: 2017-07-22 12:46:55* @Last Modified by: sun000* @Last Modified time: 2017-07-22 22:00:56*/#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;const int MAXN = 1e5 + 10 ;const int MAXM = 4e5 + 10;struct EDGE &#123; int v, w, next;&#125; edge[MAXM * 2];int head[MAXN], cnt;int dis[2][MAXN];bool vis[MAXN];void init() &#123; memset(head, -1, sizeof(head)); cnt = 0;&#125;void add(int u, int v, int w) &#123; edge[cnt].v = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt++;&#125;int n, m;int L;//最短路void bfs_clolr() &#123; memset(vis, false, sizeof(vis)); queue&lt;int&gt; q; q.push(1); vis[1] = true; int temp[MAXN]; int u, v, w, pre = 1, now, d = 1, minw; while (!q.empty() &amp;&amp; d &lt;= L) &#123; minw = 0x3f3f3f3f; for (int i = 0; i &lt; pre; i++) &#123; u = q.front(); q.pop(); temp[i] = u; for (int j = head[u]; j != -1; j = edge[j].next) &#123; v = edge[j].v; w = edge[j].w; if (dis[0][v] == d &amp;&amp; dis[0][v] + dis[1][v] == L) &#123; minw = min(minw, w); &#125; &#125; &#125; printf("%d%c", minw, d == L ? '\n' : ' '); now = 0; for (int i = 0; i &lt; pre; i++) &#123; u = temp[i]; for (int j = head[u]; j != -1; j = edge[j].next) &#123; v = edge[j].v; w = edge[j].w; if (dis[0][v] == d &amp;&amp; dis[0][v] + dis[1][v] == L &amp;&amp; minw == w &amp;&amp; !vis[v]) &#123; q.push(v); vis[v] = true; now++; &#125; &#125; &#125; d++; pre = now; &#125;&#125;void bfs(int src, int k) &#123; memset(vis, false, sizeof(vis)); queue&lt;int&gt; q; q.push(src); dis[k][src] = 0; int u, v; while (!q.empty()) &#123; u = q.front(); q.pop(); for (int i = head[u]; i != -1; i = edge[i].next) &#123; v = edge[i].v; if (!vis[v]) &#123; dis[k][v] = min(dis[k][v], dis[k][u] + 1); vis[v] = true; q.push(v); &#125; &#125; &#125; if (k == 0) L = dis[k][n];&#125;void solve() &#123; memset(dis, 0x3f, sizeof(dis)); bfs(1, 0); bfs(n, 1); printf("%d\n", L); bfs_clolr();&#125;map&lt;pair&lt;int, int&gt;, int&gt; mm;int main() &#123; int u, v, w, t; scanf("%d", &amp;t); while (t--) &#123; scanf("%d%d", &amp;n, &amp;m); init(); mm.clear(); while (m--) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); if (u == v) continue; if (u &gt; v) swap(u, v); pair&lt;int, int&gt; temp = make_pair(u, v); if (mm.count(temp)) mm[temp] = min(mm[temp], w); else mm[temp] = w; &#125; for (map&lt;pair&lt;int, int&gt;, int&gt;::iterator it = mm.begin(); it != mm.end(); it++) &#123; add((it -&gt; first).first, (it -&gt; first).second, it -&gt; second); add((it -&gt; first).second, (it -&gt; first).first, it -&gt; second); &#125; solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>搜索</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A+B]]></title>
    <url>%2F2017%2F07%2F22%2FA%2BB%2F</url>
    <content type="text"><![CDATA[题目链接 题目 Andrew is studying in the seventh grade. The class has recently learned about periodic decimals, so Andrew is very curious how to work with them. Recall that a periodic decimal is the way to represent rational numbers by specifying the preperiod and the period of its infinite decimal representation. For example, 1 / 7 = 0.(142857), 1 / 12 = 0.08(3). There are some numbers that have two representations as periodic decimals, those that are actually finite decimals such as 0.(9) = 1.(0). In this problem such numbers must be represented as ending with zeroes, so 0.(9) is an incorrect periodic decimal for the purpose of this problem. Now Andrew wants to add two numbers given as periodic decimals. The sum of two periodic decimals is always again a periodic decimal, but the length of the period can be quite big. Therefore Andrew only asks you to find some particular digits of the sum. You have to output digits at positions a1, a2, ..., *a**n*. To simplify the task, Andrew only wants to add numbers of the form 0.(α) where α is a period. Input The input contains multiple test cases. The first line of the input contains t — the number of tests in the input. The first two lines of each test case contain periods of the two numbers to add, the periods contain digits from 0 to 9. The length of each period is at most 200. The following line contains n — the number of queries, the line with n integers *a**i* follows (1 ≤ n ≤ 300 000, 1 ≤ *a**i* ≤ 1018). The total length of periods of all numbers in the input doesn't exceed 200 000. The sum of n in the input doesn't exceed 300 000. Output For each *a**i* in the test case print a digits that is at the *a**i*-th position after the decimal point in the sum of two periodic decimals specified in the input. Positions are numbered from 1. Do not separate digits by spaces. Print answer for each test case on a separate line. Example input 2 142857 3 10 1 2 3 4 5 6 7 8 9 10 4 5 3 1 2 3 output 4761904761 000 分析 直接暴力模拟，有一个坑点就是(9)+(9)并不是每一位都是9，不需要替换成0，因为最后一位永远都是8。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;cstring&gt;char a[100100], b[100100];int g;int gcd(int a, int b) &#123; if (!b) return a; return gcd(b, a % b);&#125;void init() &#123; int la = strlen(a); int lb = strlen(b); g = la / gcd(la, lb) * lb; for (int i = 1; i &lt; g / la; i++) for (int j = 0; j &lt; la; j++) a[i * la + j] = a[j]; for (int i = 1; i &lt; g / lb; i++) for (int j = 0; j &lt; lb; j++) b[i * lb + j] = b[j]; a[g] = b[g] = '\0'; int gg = 0, now; for (int i = g - 1; i &gt;= 0; i--) &#123; now = (a[i] - '0' + b[i] - '0') + gg; a[i] = '0' + now % 10; gg = now / 10; &#125; if (!gg) &#123; bool flag = true; for (int i = 0; i &lt; g; i++) if (a[i] != '9') &#123; flag = false; break; &#125; if (flag) &#123; for (int i = 0; i &lt; g; i++) a[i] = '0'; return; &#125; &#125; while (gg) &#123; for (int i = g - 1; i &gt;= 0; i--) &#123; now = a[i] - '0' + gg; a[i] = '0' + now % 10; gg = now / 10; &#125; &#125;&#125;int main(void) &#123; int t, m; long long int q; scanf("%d", &amp;t);// while (t--) &#123; scanf("%s", a); scanf("%s", b); init(); scanf("%d", &amp;m); for (int i = 0; i &lt; m; i++) &#123; scanf("%lld", &amp;q); q = (q - 1) % (long long int)g; printf("%c", a[(int)q]); &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hash Code Hacker]]></title>
    <url>%2F2017%2F07%2F22%2FHash-Code-Hacker%2F</url>
    <content type="text"><![CDATA[题目链接 题目 According to Java standard library documentation, the hash code of String is computed ass[0]31^(n-1) + s[1]31^(n-2) + ... + s[n-1] Here s[i] is the i-th character of the string, n is the length of the string, and ˆ indicates exponentiation.Computation uses signed 32-bit integers in two’s complement form. Heather is going to hack the servers of Not Entirely Evil Recording Company (NEERC). To performan attack she needs k distinct query strings that have equal hash codes. Unfortunately, NEERC serversaccept query string containing lower- and uppercase English letters only. Heather hired you to write a program that generates such query strings for her. Input The single line of the input file contains integer k — the number of required query strings to generate(2 ≤ k ≤ 1000). Output Output k lines. Each line should contain a single query string. Each query string should be non-emptyand its length should not exceed 1000 characters. Query string should contain only lower- and uppercaseEnglish letters. All query strings should be distinct and should have equal hash codes. Example Input 4 Output edHs mENAGeS fEHs edIT 分析 观察样例，很容易发现hash(&quot;Hs&quot;)=hash(&quot;IT&quot;)，得到规律hash(&quot;Aa&quot;)=hash(&quot;BB&quot;),hash(&quot;Bb&quot;)=hash(&quot;CC&quot;)........由于最大的k是1000则最多取10对，用二进制枚举每一对是什么就能得到答案了。 代码 12345678910111213141516171819#include &lt;cstdio&gt;char a[10][3] = &#123;"Aa", "Bb", "Cc", "Dd", "Ee", "Ff", "Gg", "Hh", "Ii", "Jj"&#125;;char b[10][3] = &#123;"BB", "CC", "DD", "EE", "FF", "GG", "HH", "II", "JJ", "KK"&#125;;int main(void) &#123; int k; scanf("%d", &amp;k); for(int i = 0; i &lt; k; i++) &#123; for(int j = 0; j &lt; 10; j++) &#123; if((i &gt;&gt; j) &amp; 1) printf("%s", a[j]); else printf("%s", b[j]); &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫队]]></title>
    <url>%2F2017%2F07%2F13%2F%E8%8E%AB%E9%98%9F%2F</url>
    <content type="text"><![CDATA[转载自 摘要 莫队算法是一个对于区间、树或其他结构离线（在线）维护的算法，此算法基于一些基本算法，例如暴力维护，树状数组，分块，最小曼哈顿距离生成树，对其进行揉合从而产生的一个简单易懂且短小好写的算法。此算法在很多情况下可以很轻松的切掉一些复杂而且难写的数据结构问题。 关键词 程序设计、算法、算法优化，暴力算法，分块算法，最小曼哈顿距离生成树。 背景 众所周知，在OI竞赛、软件的设计中都会要求我们去处理各种各样的棘手的问题，而这些问题之中，有一大类就是维护问题：比如说对于一个序列的维护，对于棵二叉或者多叉树的维护……这些问题往往会需要我们去使用一个或多个高端的数据结构复合来完美解决，通常题目的代码十分冗长而且出错可能性十分大，是广大OIer、Acmer、Coder所害怕的题目。那么有没有一种方法可以既简单又快捷的解决这类问题（这类问题中的一大部分）呢？莫队算法就诞生辣！ 理论1 序列莫队：我们现在有一个长为n的静态的序列，对于序列，我们有m次查询，我们要动态查询l到r之间大于a小于b的数的个数以及种类。遇到了这个问题我们通常需要使用书套树的数据结构，即一颗以自平衡二叉查找树为节点的线段树（时间复杂度大约是O(mlognlogn)），而且由于空间限制，我们还必须动态创建线段树的节点，这样一来十分难写，一些大约要个400-500行，调试起来也很困难。这时候我们来考虑暴力算法，如果暴力的处理题目中的问题那么复杂度是多少呢？这个不难计算，对于每个询问我们都要O(n)的时间处理,一共有m个询问，那么暴力处理的复杂度就是O(nm)的，明显处理问题花费的时间我们是不能接受的。这是我们想到可以交换询问和询问之间的先后次序，这样每次询问在前一次询问的基础上转移就可以节省一些时间了。 但是如何重新排列询问之间的顺序是一个问题。我们需要进行一些理论分析。我们再上一个询问的基础上暴力地维护一个询问（假设上一个询问询问区间为[l0,r0]，这个询问区间为[l,r]），那么我们所谓的暴力维护就是先把现有答案的右边界从r0移动到r，再把左边界从l0移动到l，那么我们的总花费是O(|l-l0|+|r-r0|)。仔细看一看，没错，这就是我们的曼哈顿距离的计算公式，有了这个思路，我们就可以从图形的角度来思考了，对于一个询问[l,r]我们可以将它映射为平面上在(l,r)位置的点，那么两个询问之间转移的代价就是询问所对应的点之间的曼哈顿距离。有了这一个结论，我们便想到可以用最小曼哈顿生成树来处理询问的顺序。由此莫队算法便诞生啦！莫队算法就是先将询问抽象成平面上的点，然后进行一边最小曼哈顿距离生成树，然后按照生成树的顺序来处理询问，这样的算法复杂度大约是O(mSqrt(n))的。如此，问题便简单了许多。 但是由于最小曼哈顿距离生成树也不是那么的好写，所以莫队算法还能再简单一点么？我们思考是否可以用一个简单而暴力的算法代替莫队算法呢。很快便能想到分块算法。我们可以使用分块算法来处理询问之间的次序问题。再去看那个询问对应的点所在的平面，我们找到它的X轴，我们把X轴平均分割成r分，然后我们把在一个块内的询问统一先处理，不在一个块内的询问我们按照左端点升序右端点升序排序依次处理。这样做有什么好处呢？对于m干个询问，如果在一个块里面，那么处理这些询问花费的复杂度是O(n/rnm)，如果有两个询问不在一个同一个块里面，按照我们之前的排序规则，我们把左区间和右区间在块之间移动的次数最多为r(n/r)r次，那么我们的复杂度就是O(r(n/r)r)次，经过简单的数学分析，我们可以发现r=Sqrt(n)是时间复杂度最低为O(nSqrt(n))次，是可以接受的时间复杂度。这样我们的莫队算法就又简单有强大了。但是在另一些情况下，题目会无耻的限定我们可以使用的空间（一般不会，因为这样高级数据结构的复合也难以解决这样的问题了）。那么如果空间被限定了，我们应该如何解决问题呢？其实很简单， 还记得我们之前的r么？我们为了求的时间复杂度最小令r=Sqrt(n),如果我们令r=n ^ (2 / 3)，那么便是一个时间复杂度和空间复杂度较为平衡的情况，这样可以很好的解决问题。 例题 输入数据首先输入两个整数N,Q，分别代表序列的长度和询问的个数。这两个数字将单独占据一行并用一个空格分开。输入数据的第二行包含了N个由一个空格分开的正整数，代表了整个序列，从左向右依次编号为A1, A2……An。接下来Q行，每行两个整数i,j表示了一个询问区间。输入数据保证1≤i &lt;j&lt;=N 2038: [2009国家集训队]小Z的袜子(hose) Description 作为一个生活散漫的人，小Z每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小Z再也无法忍受这恼人的找袜子过程，于是他决定听天由命…… 具体来说，小Z把这N只袜子从1到N编号，然后从编号L到R(L 尽管小Z并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。 你的任务便是告诉小Z，他有多大的概率抽到两只颜色相同的袜子。当然，小Z希望这个概率尽量高，所以他可能会询问多个(L,R)以方便自己选择。 Input 输入文件第一行包含两个正整数N和M。N为袜子的数量，M为小Z所提的询问的数量。接下来一行包含N个正整数Ci，其中Ci表示第i只袜子的颜色，相同的颜色用相同的数字表示。再接下来M行，每行两个正整数L，R表示一个询问。 Output 包含M行，对于每个询问在一行中输出分数A/B表示从该询问的区间[L,R]中随机抽出两只袜子颜色相同的概率。若该概率为0则输出0/1，否则输出的A/B必须为最简分数。（详见样例） 样例解释 询问1：共C(5,2)=10种可能，其中抽出两个2有1种可能，抽出两个3有3种可能，概率为(1+3)/10=4/10=2/5。 询问2：共C(3,2)=3种可能，无法抽到颜色相同的袜子，概率为0/3=0/1。 询问3：共C(3,2)=3种可能，均为抽出两个3，概率为3/3=1/1。 注：上述C(a, b)表示组合数，组合数C(a, b)等价于在a个不同的物品中选取b个的选取方案数。 数据规模和约定 30%的数据中 N,M ≤ 5000； 60%的数据中 N,M ≤ 25000； 100%的数据中 N,M ≤ 50000，1 ≤ L &lt; R ≤ N，Ci ≤ N。 单个测试点时限2S 对于上述这道题，30%的数据我们可以对于每个询问都扫描询问区间中所存在的数然后计算，这样单次复杂度是O(N)的，但有M的询问，总复杂度是O（MN）。这就显得有点不太能接受了。 但是当我们知道一个询问[l,r]的答案后，[l+1,r],[l-1,r],[l,r+1],[l,r-1]这四个区间的答案可以通过计算做到O(1)的时间内得到 所以我们可以考虑莫队算法，分为如下三步。 1、分块 2、把所有询问左端点排序 3、对于左端点在同一块内的询问按右端点排序，然后分三种情况统计。 而复杂度正如理论部分所说的一样， 一、i与i+1在同一块内，r单调递增，所以r是O(N)的。由于有sqrt(N)块,所以这一部分时间复杂度是Nsqrt(N)。 二、i与i+1跨越一块，r最多变化n，由于有sqrt(N)块，所以这一部分时间复杂度是Nsqrt(N) 三、i与i+1在同一块内时变化不超过sqrt(N)，跨越一块也不会超过2* sqrt(N)，不妨看作是sqrt(N)。由于有N个数，所以时间复杂度是O(Nsqrt(N)) 可以证明复杂度是O(Nsqrt(N))了 理论2 可现在有很多问题都设置了修改操作，对于这类我们我们又该如何处理呢？ 例题 我们现在有一个长为n的，对于序列，我们有m次操作，操作分为两种 1、询问在[l,r]中抽到两个数字相同的概率 2、把某个位置的数ai改成x 100%的数据中 N,M ≤100000，1 ≤ L &lt; R ≤ N，Ci ≤ N。 单个测试点时限10S 我们会发现，加上了修改操作后。就没办法直接按照分块来处理解决询问的顺序。 定义B为分块的大小。 &gt; 首先考虑没有修改操作，那么就和理论1中小Z的袜子一样，令B = sqrt(n) 。把所有询问左端点排序，对于左端点在同一块内的询问按右端点排序,然后写莫队算法，按顺序扫询问，这样是O(n sqrt(n))。如果现在加上修改操作考虑一个询问(l,r)，这样是肯定不够的。 &gt; 于是变成：(l,r,ti)，ti是询问时的时间，即这次询问是第几次操作。把所有询问左端点l排序，对于左端点在同一块内的询问按右端点r所在的块排序，对右端点r所在块相同的我们再按照时间ti排序。 然后做莫队算法，按顺序扫询问，时间有时向前有时倒流。这样令B = n ^ (2 / 3)，因为在每一块中时间最多从1到T改变一次，设询问操作p1次，修改操作p2次，则在最差情况下的时间复杂度是O(p1 n^(2 / 3)+p2 n^(1 / 3) n^(1 / 3))=O(n^(5 / 3))【n与m等价】，这在时限下基本是可以得到答案的。 &gt; 那么还有个遗留的问题，如何处理时间。我们只需要记录修改前和修改后该点的值就可以了。 &gt; 至此这个问题完美解决。 总结 也许莫队是一种看起来复杂度非常高的算法，但如果合理地处理好分块的大小和询问的顺序，，它便可以变成一个极其有效的工具。 辞谢 Vfleaking、莫涛 参考文献 国家集训队命题《小z的袜子》]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>暴力</tag>
        <tag>数据结构</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 617E XOR and Favorite Number]]></title>
    <url>%2F2017%2F07%2F13%2FCodeForces-617E-XOR-and-Favorite-Number%2F</url>
    <content type="text"><![CDATA[题目链接 题目 Bob has a favorite number k and *a**i* of length n. Now he asks you to answer m queries. Each query is given by a pair *l**i* and *r**i* and asks you to count the number of pairs of integers i and j, such that l ≤ i ≤ j ≤ r and the xor of the numbers ai, ai + 1, ..., *a**j* is equal to k. Input The first line of the input contains integers n, m and k (1 ≤ n, m ≤ 100 000, 0 ≤ k ≤ 1 000 000) — the length of the array, the number of queries and Bob's favorite number respectively. The second line contains n integers *a**i* (0 ≤ *a**i* ≤ 1 000 000) — Bob's array. Then m lines follow. The i-th line contains integers *l**i* and *r**i* (1 ≤ li ≤ ri ≤ n) — the parameters of the i-th query. Output Print m lines, answer the queries in the order they appear in the input. Examples input 6 2 3 1 2 1 1 0 3 1 6 3 5 output 7 0 input 5 3 1 1 1 1 1 1 1 5 2 4 1 3 output 9 4 4 Note In the first sample the suitable pairs of i and j for the first query are: (1, 2), (1, 4), (1, 5), (2, 3), (3, 6), (5, 6), (6, 6). Not a single of these pairs is suitable for the second query. In the second sample xor equals 1 for all subarrays of an odd length. 分析 多次询问没有修改，典型的莫队问题。 刚学莫队的第一道题目所以讲简单的介绍一下 传送门 cnt[]表示cnt[在[l - 1, r]之间出现的前缀]在[l - 1, r]之间出现的的数量 首先处理好前缀异或和，注意处理的数据是[l - 1, r]因为事实上这里的莫队自带左开右闭属性(由于用前缀和处理)，在这里卡了很久。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** @Author: sun000* @Date: 2017-07-13 10:13:19* @Last Modified by: sun000* @Last Modified time: 2017-07-13 15:54:49*/#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e5 +10;int n, m, block = 1;int cnt[1048586];long long int num[MAXN];long long int k;struct SEC &#123; int l, r, id; long long int ans; SEC()&#123;&#125;&#125;sec[MAXN];bool cmp_block(SEC a, SEC b) &#123; if(a.l / block == b.l / block) return a.r &lt; b.r; return a.l &lt; b.l;&#125;bool cmp_id(SEC a, SEC b) &#123; return a.id &lt; b.id;&#125;long long int nans;void plus(int in) &#123; nans += cnt[num[in] ^ k]; cnt[num[in]]++;&#125;void dec(int in) &#123; cnt[num[in]]--; nans -= cnt[num[in] ^ k];&#125;int main(void) &#123; memset(cnt, 0, sizeof(cnt)); scanf("%d%d%lld", &amp;n, &amp;m, &amp;k); block = (int)sqrt(n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%lld", &amp;num[i]); num[i] ^= num[i - 1]; &#125; for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d", &amp;sec[i].l, &amp;sec[i].r); sec[i].id = i; sec[i].l--;//查询[l,r]是num[r]前缀与num[l - 1]前缀处理的结果 sec[i].ans = 0; &#125; sort(sec, sec + m, cmp_block); int l = 0, r = 0; nans = 0, cnt[0] = 1; for(int i = 0; i &lt; m; i++) &#123; while(l &gt; sec[i].l) plus(--l); while(r &lt; sec[i].r) plus(++r); while(l &lt; sec[i].l) dec(l++); while(r &gt; sec[i].r) dec(r--); sec[i].ans = nans; &#125; sort(sec, sec + m, cmp_id); for(int i = 0; i &lt; m; i++) printf("%lld\n", sec[i].ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>数据结构</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces161D Distance in Tree]]></title>
    <url>%2F2017%2F07%2F09%2FCodeForces161D-Distance-in-Tree%2F</url>
    <content type="text"><![CDATA[题目链接 题目 A tree is a connected graph that doesn't contain any cycles. The distance between two vertices of a tree is the length (in edges) of the shortest path between these vertices. You are given a tree with n vertices and a positive number k. Find the number of distinct pairs of the vertices which have a distance of exactly k between them. Note that pairs (v, u) and (u, v) are considered to be the same pair. Input The first line contains two integers n and k (1 ≤ n ≤ 50000, 1 ≤ k ≤ 500) — the number of vertices and the required distance between the vertices. Next n - 1 lines describe the edges as &quot;*a**i* bi&quot; (without the quotes) (1 ≤ ai, bi ≤ n, ai ≠ bi), where ai and *b**i* are the vertices connected by the i-th edge. All given edges are different. Output Print a single integer — the number of distinct pairs of the tree's vertices which have a distance of exactly k between them. Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64dspecifier. Examples input 5 2 1 2 2 3 3 4 2 5 output 4 input 5 3 1 2 2 3 3 4 4 5 output 2 Note In the first sample the pairs of vertexes at distance 2 from each other are (1, 3), (1, 5), (3, 5) and (2, 4). 分析 定义一个dp[i][j]表示i的子树中距离i的距离为j的点的个数。用一个dfs求dp的值，然后求答案，则i子树中包含的ans=sum{dp[son[i]][j - 1] * (dp[i][k - j] - dp[son[i]][k - j - 1])} 注意数据范围long long ans 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** @Author: sun000* @Date: 2017-07-09 11:05:44* @Last Modified by: sun000* @Last Modified time: 2017-07-09 12:58:06*/#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int dp[50010][505];vector&lt;int&gt; e[50010];int n, k;long long int ans;void addedge(int u, int v) &#123; e[u].push_back(v); e[v].push_back(u);&#125;void dfs(int s, int pre) &#123; int u, v; if(e[s].size() == 1 &amp;&amp; e[s][0] == pre) return; for(int i = 0; i &lt; e[s].size(); i++) &#123; v = e[s][i]; if(v != pre) &#123; dfs(v, s); for(int j = 1; j &lt;= k; j++) dp[s][j] += dp[v][j - 1]; &#125; &#125; long long int temp = 0; for(int i = 0; i &lt; e[s].size(); i++) &#123; u = e[s][i]; if (u != pre) &#123; temp += dp[u][k - 1] * 2; for(int l = 1; l &lt; k; l++) temp += dp[u][l - 1] * (dp[s][k - l] - dp[u][k - l - 1]); &#125; &#125; ans += temp / 2;&#125;void debug() &#123; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= k; j++) printf("dp[%d][%d] = %d\n", i, j, dp[i][j]);&#125;int main(void)&#123; int u, v; scanf("%d%d", &amp;n, &amp;k); for(int i = 0; i &lt; n - 1; i++) &#123; scanf("%d%d", &amp;u, &amp;v); addedge(u, v); &#125; if(k == 1) &#123; printf("%d\n", n - 1); return 0; &#125; memset(dp, 0, sizeof(dp)); for(int i = 1; i &lt;= n; i++) dp[i][0] = 1; ans = 0; dfs(1, 0); // debug(); printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces13E Holes]]></title>
    <url>%2F2017%2F07%2F09%2FCodeForces13E-Holes%2F</url>
    <content type="text"><![CDATA[题目链接 题目 Little Petya likes to play a lot. Most of all he likes to play a game «Holes». This is a game for one person with following rules: There are N holes located in a single row and numbered from left to right with numbers from 1 to N. Each hole has it's own power (hole number i has the power a i). If you throw a ball into hole i it will immediately jump to hole i + a i, then it will jump out of it and so on. If there is no hole with such number, the ball will just jump out of the row. On each of the M moves the player can perform one of two actions: Set the power of the hole a to value b. Throw a ball into the hole a and count the number of jumps of a ball before it jump out of the row and also write down the number of the hole from which it jumped out just before leaving the row. Petya is not good at math, so, as you have already guessed, you are to perform all computations. Input The first line contains two integers N and M (1 ≤ N ≤ 105, 1 ≤ M ≤ 105) — the number of holes in a row and the number of moves. The second line contains N positive integers not exceeding N — initial values of holes power. The following M lines describe moves made by Petya. Each of these line can be one of the two types: 0 a b 1 a Type 0 means that it is required to set the power of hole a to b, and type 1 means that it is required to throw a ball into the a-th hole. Numbers a and b are positive integers do not exceeding N. Output For each move of the type 1 output two space-separated numbers on a separate line — the number of the last hole the ball visited before leaving the row and the number of jumps it made. Examples input 8 5 1 1 1 1 1 2 8 2 1 1 0 1 3 1 1 0 3 4 1 2 output 8 7 8 5 7 3 分析 分块处理，把每一个给定的数组分成k块，则只要更新的时候只要更新块内就好了，查询的时候查询所有块，每个块内查询时间复杂度是o(1)，则查询的时间复杂度是n／k。这样的话，总时间复杂度是o(m*(k+n / k)), 显然，当k是√n的时候最优，此时的时间复杂的是m√n 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** @Author: sun000* @Date: 2017-07-09 08:08:59* @Last Modified by: sun000* @Last Modified time: 2017-07-09 09:24:56*/#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e5 + 10;int n, m, block;int p[MAXN];int cnt[MAXN];//从i跳出当前块的步数int la[MAXN];//从跳出当前位置在该块中经过的最后一个位置void update_one(int a, int b) &#123;//更新一个下标 if(b &gt;= n) &#123;//跳出 la[a] = a; cnt[a] = 1; &#125; else if(a / block == b / block) &#123;//同一个块中 cnt[a] = cnt[b] + 1; la[a] = la[b]; &#125; else &#123;//跳到其他块 cnt[a] = 1; la[a] = a; &#125;&#125;void update(int a, int b) &#123;//更新所有，即更新当前段 p[a] = b; int now = a / block * block; for(int i = a; i &gt;= now; i--) &#123; update_one(i, i + p[i]); &#125;&#125;void init() &#123; for(int i = n - 1; i &gt;= 0; i--) update_one(i, i + p[i]);&#125;int las;int query(int a) &#123; if(la[a] + p[la[a]] &gt;= n) &#123; las = la[a] + 1; return cnt[a]; &#125; else return cnt[a] + query(la[a] + p[la[a]]);&#125;void debug() &#123; for(int i = 0; i &lt; n; i++) printf("%d ", cnt[i]); printf("\n"); for(int i = 0; i &lt; n; i++) printf("%d ", la[i]); printf("\n");&#125;int main(void)&#123; scanf("%d%d", &amp;n, &amp;m); block = (int)sqrt(n); for(int i = 0; i &lt; n; i++) scanf("%d", &amp;p[i]); init(); // printf("block %d\n", block); // debug(); int op, a, b; for(int i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;op); if(!op) &#123; scanf("%d%d", &amp;a, &amp;b); update(a - 1, b); &#125; else &#123; scanf("%d", &amp;a); int ans = query(a - 1); printf("%d %d\n", las, ans); &#125; // debug(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces546E Soldier and Traveling]]></title>
    <url>%2F2017%2F07%2F08%2FCodeForces546E-Soldier-and-Traveling%2F</url>
    <content type="text"><![CDATA[题目链接 题目 In the country there are n cities and m bidirectional roads between them. Each city has an army. Army of the i-th city consists of *a**i*soldiers. Now soldiers roam. After roaming each soldier has to either stay in his city or to go to the one of neighboring cities by at moving along at most one road. Check if is it possible that after roaming there will be exactly *b**i* soldiers in the i-th city. Input First line of input consists of two integers n and m (1 ≤ n ≤ 100, 0 ≤ m ≤ 200). Next line contains n integers a1, a2, ..., *a**n* (0 ≤ *a**i* ≤ 100). Next line contains n integers b1, b2, ..., *b**n* (0 ≤ *b**i* ≤ 100). Then m lines follow, each of them consists of two integers p and q (1 ≤ p, q ≤ n, p ≠ q) denoting that there is an undirected road between cities p and q. It is guaranteed that there is at most one road between each pair of cities. Output If the conditions can not be met output single word &quot;NO&quot;. Otherwise output word &quot;YES&quot; and then n lines, each of them consisting of n integers. Number in the i-th line in the j-th column should denote how many soldiers should road from city i to city j (if i ≠ j) or how many soldiers should stay in city i (if i = j). If there are several possible answers you may output any of them. Examples input 4 4 1 2 6 3 3 5 3 1 1 2 2 3 3 4 4 2 output YES 1 0 0 0 2 0 0 0 0 5 1 0 0 0 2 1 input 2 0 1 2 2 1 output NO 分析 像这种由a状态转移到状态的都可以用网络流来写，源点0到[1,n]这些点的流量分别是a[i],[n + 1, 2n]到汇点2n + 1的流量分别是b[i - n];(士兵只能流动一次所以拆点)。在点i和i+n之间连边流量无限大，即士兵在自己的城市不移动，若城市间有边[i,j]则在网络流的图中连边[i, j + n]和[j, i + n]，边的流量都是无限大。最后只要判断最大流是不是等于开始状态的士兵和并等于结束状态的士兵和，如果答案可行要输出流的方式，则只要输出残量网络中的反向边流量就好了，表示用掉的流量。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/** @Author: sun000* @Date: 2017-07-08 16:15:42* @Last Modified by: sun000* @Last Modified time: 2017-07-08 21:41:12*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int MAXN = 210;const int INF = 0x3f3f3f3f;struct node &#123; int u, v, next, flow;&#125;;node edge[MAXN * MAXN];int head[MAXN], dis[MAXN];int cnt;//边数void init() &#123; memset(head, -1, sizeof(head)); memset(dis, -1, sizeof(dis)); cnt = 0;&#125;void addedge(int a, int b, int c) &#123; edge[cnt].u = a; edge[cnt].v = b; edge[cnt].flow = c; edge[cnt].next = head[a]; head[a] = cnt++;//反向边(偶数下标正向边，奇数下标反向边) edge[cnt].u = b; edge[cnt].v = a; edge[cnt].flow = 0; edge[cnt].next = head[b]; head[b] = cnt++;&#125;bool bfs(int sp, int tp) &#123;// 给各点分层，离源点的远近分 memset(dis, -1, sizeof(dis)); queue&lt;int&gt; q; dis[sp] = 0; q.push(sp); int cur; while(!q.empty()) &#123; cur = q.front(); q.pop(); for(int i = head[cur]; i != -1; i = edge[i].next) &#123; if (dis[edge[i].v] == -1 &amp;&amp; edge[i].flow &gt; 0) &#123; dis[edge[i].v] = dis[cur] + 1; q.push(edge[i].v); &#125; &#125; &#125; if (dis[tp] &lt; 0) return false; return true;&#125;int Find(int x, int low, int tp) &#123; //找增广 int temp; if (x == tp) return low; for (int i = head[x]; i != -1; i = edge[i].next) &#123; int v = edge[i].v; if (dis[v] == dis[x] + 1 &amp;&amp; edge[i].flow &gt; 0 &amp;&amp; (temp = Find(v, min(low, edge[i].flow), tp))) &#123; edge[i].flow -= temp; edge[i ^ 1].flow += temp; return temp; &#125; &#125; return 0;&#125;int dinic(int sp, int tp) &#123; int ans = 0; while (bfs(sp, tp)) ans += Find(sp, INF, tp); return ans;&#125;int main(void) &#123; int n, m, temp, u, v; int sum1 = 0, sum2 = 0; scanf("%d%d", &amp;n, &amp;m); init(); int sp = 0;//源点 int tp = 2 * n + 1;//汇点 for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;temp); addedge(sp, i, temp); sum1 += temp; addedge(i, i + n, INF); &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;temp); sum2 += temp; addedge(i + n, tp, temp); &#125; for (int i = 0; i &lt; m; i++) &#123; scanf("%d%d", &amp;u, &amp;v); addedge(u, v + n, INF); addedge(v , u + n, INF); &#125; int ans = dinic(sp, tp); if (ans == sum1 &amp;&amp; ans == sum2) &#123; printf("YES\n"); int g[110][110], r; memset(g, 0, sizeof(g)); for(int i = 1; i &lt; cnt; i += 2) &#123; u = edge[i].u; v = edge[i].v; r = edge[i].flow; if(u &gt; n) u -= n; if(v &gt; n) v -= n; g[v][u] = r; &#125; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) printf("%d%c", g[i][j], j == n ? '\n' : ' '); &#125; else printf("NO\n"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
        <tag>建图</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces754D Fedor and coupons]]></title>
    <url>%2F2017%2F07%2F08%2FCodeForces754DFedor-and-coupons%2F</url>
    <content type="text"><![CDATA[题目链接 题目 All our characters have hobbies. The same is true for Fedor. He enjoys shopping in the neighboring supermarket. The goods in the supermarket have unique integer ids. Also, for every integer there is a product with id equal to this integer. Fedor has ndiscount coupons, the i-th of them can be used with products with ids ranging from *l**i* to *r**i, inclusive. Today Fedor wants to take exactly k*coupons with him. Fedor wants to choose the k coupons in such a way that the number of such products x that all coupons can be used with this product xis as large as possible (for better understanding, see examples). Fedor wants to save his time as well, so he asks you to choose coupons for him. Help Fedor! Input The first line contains two integers n and k (1 ≤ k ≤ n ≤ 3·105) — the number of coupons Fedor has, and the number of coupons he wants to choose. Each of the next n lines contains two integers *l**i* and *r**i* ( - 109 ≤ li ≤ ri ≤ 109) — the description of the i-th coupon. The coupons can be equal. Output In the first line print single integer — the maximum number of products with which all the chosen coupons can be used. The products with which at least one coupon cannot be used shouldn't be counted. In the second line print k distinct integers p1, p2, ..., *p**k* (1 ≤ *p**i ≤ n*) — the ids of the coupons which Fedor should choose. If there are multiple answers, print any of them. Examples input 4 2 1 100 40 70 120 130 125 180 output 31 1 2 input 3 2 1 12 15 20 25 30 output 0 1 2 input 5 2 1 10 5 15 14 50 30 70 99 100 output 21 3 4 Note In the first example if we take the first two coupons then all the products with ids in range [40, 70] can be bought with both coupons. There are 31 products in total. In the second example, no product can be bought with two coupons, that is why the answer is 0. Fedor can choose any two coupons in this example. 分析 贪心：若存在答案，则显然这些区间是相邻的，这是最优的。 将区间[l,r]按照l从小到达排序，将区间放到一个关于r的最小堆里，则维护一个大小为k的最小堆，有一个区间[l0,r0]，将这个区间放入堆中后，将堆中所有r小于l0的区间pop，当堆的大小小于k时，不满足要求；当堆的大小是k时，显然这些区间是满足要求的，求得一个答案于与原答案取Max；若堆的大小大于k时，则pop一个区间（这个区间是r最小的，显然这样是最优的，这也是一个贪心）。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** @Author: sun000* @Date: 2017-07-08 14:31:47* @Last Modified by: sun000* @Last Modified time: 2017-07-08 15:14:45*/#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 3e5 + 10;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;struct SEC &#123; int l, r, in; SEC() &#123;&#125; SEC(int _l, int _r): l(_l), r(_r) &#123;&#125; bool operator &lt; (const SEC &amp;s) const &#123;//用于sort排序 return l &lt; s.l; &#125; bool operator &gt; (const SEC &amp;s) const &#123;//用于优先队列排序 return r &gt; s.r; &#125;&#125; sec[MAXN];int main(void)&#123; int n, k, ans = 0; scanf("%d%d", &amp;n, &amp;k); for (int i = 0; i &lt; n; i++) &#123; scanf("%d%d", &amp;sec[i].l, &amp;sec[i].r); sec[i].in = i + 1; &#125; sort(sec, sec + n); for (int i = 0; i &lt; n; i++) &#123; while (!q.empty() &amp;&amp; q.top() &lt; sec[i].l) q.pop(); q.push(sec[i].r); while (q.size() &gt; k) q.pop(); if (q.size() == k) ans = max(ans, q.top() - sec[i].l + 1); &#125; printf("%d\n", ans); if (!ans) for (int i = 0; i &lt; k; i++) printf("%d%c", i + 1, i == k - 1 ? '\n' : ' '); else &#123; int temp = 0; priority_queue&lt;SEC, vector&lt;SEC&gt;, greater&lt;SEC&gt;&gt; g; for (int i = 0; i &lt; n; i++) &#123; while (!g.empty() &amp;&amp; (g.top()).r &lt; sec[i].l) g.pop(); g.push(sec[i]); while (g.size() &gt; k) g.pop(); if (g.size() == k) &#123; temp = max(temp, (g.top()).r - sec[i].l + 1); if (temp == ans) &#123; for (int j = 0; j &lt; k; j++) &#123; printf("%d%c", (g.top()).in, j == k - 1 ? '\n' : ' '); g.pop(); &#125; break; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>贪心</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces755F PolandBall and Gifts]]></title>
    <url>%2F2017%2F07%2F08%2FCodeForces755F-PolandBall-and-Gifts%2F</url>
    <content type="text"><![CDATA[题目链接 题目 It's Christmas time! PolandBall and his friends will be giving themselves gifts. There are n Balls overall. Each Ball has someone for whom he should bring a present according to some permutation p, *p**i ≠ i* for all i. Unfortunately, Balls are quite clumsy. We know earlier that exactly k of them will forget to bring their gift. A Ball number i will get his present if the following two constraints will hold: Ball number i will bring the present he should give. Ball x such that *p**x = i* will bring his present. What is minimum and maximum possible number of kids who will not get their present if exactly k Balls will forget theirs? Input The first line of input contains two integers n and k (2 ≤ n ≤ 106, 0 ≤ k ≤ n), representing the number of Balls and the number of Balls who will forget to bring their presents. The second line contains the permutation p of integers from 1 to n, where *p**i* is the index of Ball who should get a gift from the i-th Ball. For all i, *p**i ≠ i* holds. Output You should output two values — minimum and maximum possible number of Balls who will not get their presents, in that order. Examples input 5 2 3 4 1 5 2 output 2 4 input 10 1 2 3 4 5 6 7 8 9 10 1 output 2 2 Note In the first sample, if the third and the first balls will forget to bring their presents, they will be th only balls not getting a present. Thus the minimum answer is 2. However, if the first ans the second balls will forget to bring their presents, then only the fifth ball will get a present. So, the maximum answer is 4. 分析 建图：设a要给b带礼物，则在在a-&gt;b之间连一条有向边， 则最后的图是若干个环，并且每一个节点的入度和出度都是1，即每个环之间没有交点，因为每个没有带礼物的人会导致要从他着获得礼物的人和他自己都没有礼物，则最坏情况是一个贪心：尽量使一个没带礼物的人导致两个人不能收到礼物。最小的情况的话，就是使要从没带礼物的人那里获得礼物的人自己也没有带礼物，则这样的话就是尽量选择一些在图中连续的点么，这样的话注意到这个序列的最后一个点会导致他的下一个点也收不到礼物，这样的话可会导致多一个人收不到礼物，但是如果这个序列刚好是一个环的话，则没有这种情况，综合考虑，这个序列可以尽量选择一些环，则如果恰好存在一些环的点数和为k的话最小答案就是k否则就是k+1，这样的话问题就变成里求给定的一些环是否能恰好求和成k，这是一个多重背包，考虑到时间复杂度，需要用二进制优化和bitset优化。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** @Author: sun000* @Date: 2017-07-07 18:07:58* @Last Modified by: sun000* @Last Modified time: 2017-07-07 18:46:08*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;bitset&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int p[1000010];int num[1000010];int c[500010];bitset&lt;1000010&gt; dp;int cnt;void init(int s) &#123; for(int i = 0; i &lt;= s; i++) &#123; p[i] = i; num[i] = 1; &#125;&#125;int fin(int x) &#123; if(p[x] == x) return x; return p[x] = fin(p[x]);&#125;bool un(int x, int y) &#123; int a = fin(x); int b = fin(y); if(a == b) &#123; c[cnt++] = num[a]; return true; &#125; p[a] = b; num[b] += num[a]; return false;&#125;int main(void) &#123; cnt = 0; int n, k, temp; scanf("%d%d", &amp;n, &amp;k); init(n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;temp); un(i, temp); &#125; sort(c, c + cnt); int maxans; int co = 0, odd = 0; for(int i = 0; i &lt; cnt; i++) &#123; co += c[i] &gt;&gt; 1; if(c[i] &amp; 1) odd++; &#125; if(co &gt;= k) maxans = k * 2; else maxans = min(n, co * 2 + (k - co)); c[cnt++] = -1; int s = 0, pre = c[0], now = 1; for(int i = 1; i &lt; cnt; i++) &#123; if(pre == c[i]) now++; else &#123; int g = 1; while(now) &#123; now -= g; c[s++] = pre * g; g &lt;&lt;= 1; while(now - g &lt; 0) g &gt;&gt;= 1; &#125; now = 1; pre = c[i]; &#125; &#125; cnt = s; int minans = k + 1; dp.reset(); dp.set(0); for(int i = 0; i &lt; cnt; i++) dp |= (dp &lt;&lt; c[i]); if(dp[k]) minans--; printf("%d %d\n", minans, maxans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>DP</tag>
        <tag>BITSET</tag>
        <tag>背包</tag>
        <tag>并查集</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ITMOSummerCampDay1 GPick Your Team]]></title>
    <url>%2F2017%2F07%2F05%2FITMOSummerCampDay1GPick-Your-Team%2F</url>
    <content type="text"><![CDATA[题目链接 题目 This is it. The final battle between EPFL and Mars. The rules of the game are as follows. Neither side wants to sacrifice their own people, so we will be picking two teams of Unil students to fight each other instead. You have been chosen to pick the team that will fight for EPFL's honour! You are given a list containing the strength of each Unil student. You start by choosing one student to join your team, then the Martians will choose another student, and so on, until all n students are chosen. If you had no extra information, clearly you'd pick the strongest Unil student in each turn. However, we managed to figure out the preference of the Martians. More specifically, we have a permutation P of the first n numbers, representing the indices of the Unil students, which the Martians prefer to pick in order. Take a look at the example inputs to understand this further. You want to pick the team that maximises the difference between your team's strength and theirs. What's the maximum difference? Input The first line of the input has of an even integer n (2 ≤ n ≤ 100), the number of Unil students. The next line contains n space-separated integers si, the strength of each student (1 ≤ si ≤ 107). The last line contains n space-separated integers between 1 and n, representing the permutation P. Output Print the maximum difference in strength between your team and the Martians' team. Examples input 4 3 9 1 7 4 1 2 3 output 12 input 10 1 1 2 3 4 5 6 6 8 10 9 8 7 6 5 4 10 1 2 3 output 14 Note In the first example, there are four Unil students with strengths 3, 9, 1, 7. The Martians prefer to pick them in this order: 4, 1, 2, 3. This means that in their first turn, they'll pick student 4 (strength = 7) if that student hadn't been picked, otherwise they'll pick the next student on their list (student 1, strength = 3). If you had used the simple strategy of picking the strongest available student each turn, you'd have ended up with a total strength of 9 + 3 = 12, and the Martians with 7 + 1 = 8, giving you a difference of 4. Given this extra information, you can first pick student 4 (strength = 7), then student 2 (strength = 9) in your next turn. You'd have a difference of 9 + 7 - 3 - 1 = 12. In this case, this is the best strategy. 分析: 按照火星人的选择顺序来选，则前2k个火星人最少只能选k个，那么倒过来考虑，后2k个地球人至少能选k个，则用一个优先队列，从后往前，地球人每次得到两个新的可选择的，从总共的可选择的里面选去一个，这种选择对于地球人来说是可以做到的，用一个优先队列来保证地球人的选择最优。 代码 1234567891011121314151617181920212223242526272829303132333435363738/** @Author: sun000* @Date: 2017-07-05 18:37:42* @Last Modified by: sun000* @Last Modified time: 2017-07-08 13:09:59*/#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q;int num[110], p[110];int main(void) &#123; int n, sum = 0; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;num[i]); sum += num[i]; &#125; for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;p[i]); int ans = 0; for(int i = n; i &gt; 0;) &#123; q.push(num[p[i--]]); q.push(num[p[i--]]); ans += q.top(); q.pop(); &#125; printf("%d\n", 2 * ans - sum); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces76E Points]]></title>
    <url>%2F2017%2F07%2F04%2FCodeForces76E-Points%2F</url>
    <content type="text"><![CDATA[题目链接 题目 You are given N points on a plane. Write a program which will find the sum of squares of distances between all pairs of points. Input The first line of input contains one integer number N (1 ≤ N ≤ 100 000) — the number of points. Each of the following N lines contain two integer numbers X and Y ( - 10 000 ≤ X, Y ≤ 10 000) — the coordinates of points. Two or more points may coincide. Output The only line of output should contain the required sum of squares of distances between all pairs of points. Examples input 4 1 1 -1 -1 1 -1 -1 1 output 32 分析 答案是: \[ \sum_{i=1}^{n}{\sum_{j=i+1}^{n}{(x_i-x_j)^2+(y_i-y_j)^2}} \] 这里仅计算x部分，y部分相同 \[ \sum_{i=1}^n{\sum_{j=i+1}^n(x_i-x_j)^2} \] \[ =\sum_{i = 1}^n{\sum_{j = 1} ^n(x_i-x_j)^2}/2 \] \[ =\sum_{i = 1}^n{\sum_{j = 1} ^n(x_i^2-2x_ix_j+x_j^2)}/2 \] \[ =\sum_{i = 1}^n{\sum_{j = 1} ^n(x_i^2+x_j^2)}/2-\sum_{i = 1}^n{\sum_{j = 1} ^n(2x_ix_j)}/2 \] \[ =n\sum_{i = 1}^n{x_i^2}-\sum_{i = 1}^n{\sum_{j = 1} ^nx_ix_j} \] 由于 \[ (\sum_{i=1}^n{x_i})^2=\sum_{i=1}^n{x_i}^2+2\sum_{i=1}^n{\sum_{j=i + 1}^n{x_ix_j}}=\sum_{i=1}^n{\sum_{j=1}^n{x_ix_j}} \] 则 \[ \sum_{i = 1}^n{\sum_{j = i + 1} ^n(x_i-x_j)^2}=n\sum_{i = 1}^n{x_i^2}-(\sum_{i=1}^n{x_i})^2 \] 则最终的答案是 \[ \sum_{i=1}^n{\sum_{j = i + 1}^n}{(x_i-x_j)^2 + (y_i-y_j)^2}=n（\sum_{i = 1}^n{x_i^2}+\sum_{i = 1}^n{y_i^2}）-((\sum_{i=1}^n{x_i})^2+(\sum_{i=1}^n{y_i})^2) \] 这样就可以O(n)复杂的写出来了 代码 1234567891011121314151617181920212223242526/** @Author: sun000* @Date: 2017-07-05 07:30:42* @Last Modified by: sun000* @Last Modified time: 2017-07-08 13:41:30*/#include &lt;cstdio&gt;long long int sumx, sumy, sumbx, sumby;int main(void) &#123; long long int n, x, y; sumx = sumy = sumbx = sumby = 0; scanf("%lld", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%lld%lld", &amp;x, &amp;y); sumx += x; sumbx += x * x; sumy += y; sumby += y * y; &#125; long long int ans = (n * (sumbx + sumby) - (sumx * sumx + sumy * sumy)); printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 768E:Game of Stones]]></title>
    <url>%2F2017%2F07%2F04%2FCodeForces-768E-Game-of-Stones%2F</url>
    <content type="text"><![CDATA[题目链接 题目 Sam has been teaching Jon the Game of Stones to sharpen his mind and help him devise a strategy to fight the white walkers. The rules of this game are quite simple: The game starts with n piles of stones indexed from 1 to n. The i-th pile contains *s**i* stones. The players make their moves alternatively. A move is considered as removal of some number of stones from a pile. Removal of 0stones does not count as a move. The player who is unable to make a move loses. Now Jon believes that he is ready for battle, but Sam does not think so. To prove his argument, Sam suggested that they play a modified version of the game. In this modified version, no move can be made more than once on a pile. For example, if 4 stones are removed from a pile, 4 stones cannot be removed from that pile again. Sam sets up the game and makes the first move. Jon believes that Sam is just trying to prevent him from going to battle. Jon wants to know if he can win if both play optimally. Input First line consists of a single integer n (1 ≤ n ≤ 106) — the number of piles. Each of next n lines contains an integer *s**i* (1 ≤ *s**i ≤ 60) — the number of stones in i*-th pile. Output Print a single line containing &quot;YES&quot; (without quotes) if Jon wins, otherwise print &quot;NO&quot; (without quotes) Examples input 1 5 output NO input 2 1 2 output YES Note In the first case, Sam removes all the stones and Jon loses. In second case, the following moves are possible by Sam: In each of these cases, last move can be made by Jon to win the game as follows: 分析 解法一：暴力sg打表（略） 解法二：假设一个堆有n颗石子，那么去到它不能再取，至少要取k次，这种情况去石子的序列是 1，2，3……k， 其中0 &lt;= n-(1+2+3+……+k) &lt;= k 则这个由于可以不按照去最少次数的取法取，则一次可以取ai+aj颗石子，1&lt;=ai,aj&lt;=k，则这个堆石子可以转化成有k颗石子，每次任取几颗，不可不取，那这样就成了普通的NIM游戏了，则可以与处理所有的石头堆石头个数，然后用普通的NIM游戏的做法，异或一遍就可以了。 代码 12345678910111213141516171819202122232425262728293031/** @Author: sun000* @Date: 2017-07-04 22:31:00* @Last Modified by: sun000* @Last Modified time: 2017-07-04 22:37:24*/#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int getNimNum(int n) &#123; int k = (int)sqrt(2.0 * n); while(k * (k + 1) &lt;= 2 * n) k++; //printf("k = %d\n", k - 1); return k - 1;&#125;int main(void) &#123; int n, temp, ans = 0; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;temp); ans ^= getNimNum(temp); &#125; printf("%s\n", ans ? "NO" : "YES"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>博弈</tag>
        <tag>NIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计蒜之道2017复赛D题：百度地图导航]]></title>
    <url>%2F2017%2F06%2F11%2F%E8%AE%A1%E8%92%9C%E4%B9%8B%E9%81%932017%E5%A4%8D%E8%B5%9BD%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%AF%BC%E8%88%AA%2F</url>
    <content type="text"><![CDATA[题目链接 题目 百度地图上有 n 个城市，城市编号依次为 1 到 n。地图中有若干个城市群，编号依次为 1 到 m。每个城市群包含一个或多个城市；每个城市可能属于多个城市群，也可能不属于任何城市群。 地图中有两类道路。第一类道路是 城市之间的快速路，两个城市 u,v 之间增加一条距离为 c 的边；第二类道路是 城市群之间的高速路，连接两个城市群 a,b，通过这条高速路，城市群 a 里的每个城市与城市群 b 里的每个城市之间两两增加一条距离为 c 的边。图中所有边均为无向边。 你需要计算从城市 s 到城市 t 的最短路。 输入格式 第一行输入n(1≤n≤20000), m(0≤m≤20000)，分别表示城市总数和城市群总数。 接下来一共输入 m 行。 第 ii 行首先输入一个ki(1≤ki≤n)，表示第 ii 个城市群中的城市数为 ki。接下来输入 ki 个数，表示第 i 个城市群中每个城市的编号,保证一个城市群内的城市编号不重复且合法 \[ \sum_{i = 1}^m{k_i}≤20000 \] 下一行输入一个整数 m1(0≤m1≤20000)，表示有 m1 条第一类道路，即 城市之间的快速路。 接下来 m1 行，每行输入三个整数 ui,vi(1≤ui,vi≤n),ci(1≤ci≤106)，分别表示快速路连接的两个城市编号和边的距离。 下一行输入一个整数 m2(0≤m2≤20000)，表示有 m2 条第二类道路，即 城市群之间的高速路。 接下来 m2 行，每行输入三个整数 ai,bi(1≤ai,bi≤m),li(1≤li≤106)，分别表示快速路连接的两个城市群编号和边的距离。 最后一行输入s,t(1≤s,t≤n)，表示起点和终点城市编号。 输出格式 输出一个整数，表示城市 s 到城市 t 到最短路。如果不存在路径，则输出-1。 样例说明 1 -&gt; 2 - &gt; 5或者1 -&gt; 4 -&gt; 5是最短的路径，总长度为 12。 样例输入 5 4 2 5 1 2 2 4 1 3 2 3 4 2 1 2 9 1 5 18 2 1 2 6 1 3 10 1 5 样例输出 12 分析 把每一个城市群看成一个新的点加到图里面，新加的“城市群点”到城市群内的所有点的距离都是0，注意这里的“城市群点”要拆点，拆成入点和出点，因为不拆点的话会导致同一个“城市群”内部的点两两之间的距离全部变成0，这显然是不对的。（拆点之后点的数量变多，刚开始数组大小没有改，导致了段错误），建完图跑一边SPFA就可以了。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** @Author: sun000* @Date: 2017-06-11 11:57:57* @Last Modified by: sun000* @Last Modified time: 2017-06-11 15:48:54*/#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 60010;//点的数量是n + 2 * mstruct node &#123; int to; long long int len; node()&#123;&#125; node(int _to, long long int _len):to(_to),len(_len)&#123;&#125;&#125;;vector&lt;node&gt; G[MAXN];int n, m;void build_group(int k)&#123; int cnt, temp; scanf("%d", &amp;cnt); for(int i = 0; i &lt; cnt; i++) &#123; scanf("%d", &amp;temp); temp--; G[k + n + m].push_back(node(temp, 0)); G[temp].push_back(node(k + n, 0)); &#125;&#125;long long int solve(int s, int t) &#123; long long int dis[MAXN]; bool vis[MAXN]; queue&lt;int&gt; Q; memset(dis, 0x3f, sizeof(dis)); memset(vis, false, sizeof(vis)); dis[s] = 0; vis[s] = true; Q.push(s); while(!Q.empty()) &#123; int u = Q.front(); Q.pop(); vis[u] = false; for(int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i].to; long long int w = G[u][i].len; if(dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; if(!vis[v]) &#123; vis[v] = true; Q.push(v); &#125; &#125; &#125; &#125; return dis[t];&#125;int main(void)&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 0; i &lt; m; i++) build_group(i); int g, u, v; long long int len; scanf("%d", &amp;g); for(int i = 0; i &lt; g; i++) &#123; scanf("%d%d%lld", &amp;u, &amp;v, &amp;len); u--; v--; G[u].push_back(node(v, len)); G[v].push_back(node(u, len)); &#125; scanf("%d", &amp;g); for(int i = 0; i &lt; g; i++) &#123; scanf("%d%d%lld", &amp;u, &amp;v, &amp;len); u--; v--; G[v + n].push_back(node(u + n + m, len)); G[u + n].push_back(node(v + n + m, len)); &#125; int s, t; scanf("%d%d", &amp;s, &amp;t); long long int ans = solve(s - 1, t - 1); printf("%lld\n", ans &lt; 0x3f3f3f3f ? ans : -1); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
        <tag>建图</tag>
        <tag>最短路</tag>
        <tag>拆点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计蒜之道2017复赛F题：腾讯消消乐]]></title>
    <url>%2F2017%2F06%2F10%2F%E8%AE%A1%E8%92%9C%E4%B9%8B%E9%81%932017F%E9%A2%98%E8%85%BE%E8%AE%AF%E6%B6%88%E6%B6%88%E4%B9%90%2F</url>
    <content type="text"><![CDATA[题目链接 题目 腾讯推出了一款益智类游戏——消消乐。游戏一开始，给定一个长度为 n 的序列，其中第 i 个数为 Ai。 游戏的目标是把这些数全都删去，每次删除的操作为：选取一段连续的区间，不妨记为 [L,R]，如果这一段区间内所有数的最大公约数 ≥k（k值在游戏的一开始会给定），那么这一段区间就能被直接删去。 注意：一次删除以后，剩下的数会合并成为一个连续区间。 定义 f(i)为进行 i 次操作将整个序列删完的方案数。 你需要实现一个程序，计算 \[ \sum_{i = 1}^n{(f(i) * i)} mod 1000000007 \] 输入格式 第一行输入两个整数 n,k(1≤n≤18) 第二行输入 n个正整数 ai(1≤ai≤10^5)，表示初始序列中的每个数。 输入数据保证 1≤k≤min(a1,a2,…an) 输出格式 输出一个整数，表示算出的答案。 样例说明 对于样例 1 而言，f(1)=1，f(2)=9，f(3))=26，f(4)=24。 对于样例 2，f(1)=0，f(2)=2。 样例输入1 4 1 1 1 1 1 样例输出1 193 样例输入2 2 2 2 3 样例输出2 4 样例输入3 1 233 233 样例输出3 1 分析 暴力状态压缩dp,dp[s][i] : s表示的状态经过i次消完的方案数。 时间复杂度是： \[ n^3*2^n \] ### 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** @Author: sun000* @Date: 2017-06-10 12:08:01* @Last Modified by: sun000* @Last Modified time: 2017-06-11 09:11:55*/#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MOD = 1000000007;const int MAXN = (1 &lt;&lt; 18) + 10;int n, k;int num[20];int dp[MAXN][20];//i, j,状态i用j次消去的方案数int gcd(int a, int b) &#123; return b ? gcd(b, a % b) : a;&#125;void init() &#123; memset(dp, 0, sizeof(dp)); int temp; for(int s = 1; s &lt; (1 &lt;&lt; n); s++) &#123; temp = 0; for(int i = 0; i &lt; n; i++) if(s &amp; (1 &lt;&lt; i)) temp = gcd(temp, num[i]); if(temp &gt;= k) dp[s][1] = 1; &#125;&#125;int main(void)&#123; scanf("%d%d", &amp;n, &amp;k); for(int i = 0; i &lt; n; i++) scanf("%d", &amp;num[i]); init(); int temp, now; for(int s = 1; s &lt; (1 &lt;&lt; n); s++) //枚举状态 for(int i = 2; i &lt;= n; i++) //枚举消去次数 //枚举区间 for(int l = 0; l &lt; n; l++) //枚举起点 if(s &amp; (1 &lt;&lt; l)) //有效起点 &#123; temp = 0; now = 0; for(int r = l; r &lt; n; r++) //枚举终点 if(s &amp; (1 &lt;&lt; r)) //有效终点 &#123; temp = gcd(temp, num[r]); now |= (1 &lt;&lt; r);//选择now表示的状态，消去一次 if(temp &gt;= k) dp[s][i] = (dp[s][i] + dp[s ^ now][i - 1]) % MOD; else break; &#125; &#125; int ans = 0; for(int i = 1; i &lt;= n; i++) ans = (ans + (long long)dp[(1 &lt;&lt; n) - 1][i] * i % MOD) % MOD; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5033 Building 暴力+单调栈优化]]></title>
    <url>%2F2017%2F06%2F08%2FHDU%205033%20Building%20%E6%9A%B4%E5%8A%9B%2B%E5%8D%95%E8%B0%83%E6%A0%88%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Building Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others) Total Submission(s): 2603 Accepted Submission(s): 739 Special Judge Problem Description Once upon a time Matt went to a small town. The town was so small and narrow that he can regard the town as a pivot. There were some skyscrapers in the town, each located at position xi with its height hi. All skyscrapers located in different place. The skyscrapers had no width, to make it simple. As the skyscrapers were so high, Matt could hardly see the sky.Given the position Matt was at, he wanted to know how large the angle range was where he could see the sky. Assume that Matt's height is 0. It's guaranteed that for each query, there is at least one building on both Matt's left and right, and no building locate at his position. Input The first line of the input contains an integer T, denoting the number of testcases. Then T test cases follow. Each test case begins with a number N(1&lt;=N&lt;=10^5), the number of buildings. In the following N lines, each line contains two numbers, xi(1&lt;=xi&lt;=10^7) and hi(1&lt;=hi&lt;=10^7). After that, there's a number Q(1&lt;=Q&lt;=10^5) for the number of queries. In the following Q lines, each line contains one number qi, which is the position Matt was at. Output For each test case, first output one line &quot;Case #x:&quot;, where x is the case number (starting from 1). Then for each query, you should output the angle range Matt could see the sky in degrees. The relative error of the answer should be no more than 10^(-4). Sample Input 3 3 1 2 2 1 5 1 1 4 3 1 3 2 2 5 1 1 4 3 1 4 2 3 5 1 1 4 Sample Output Case #1: 101.3099324740 Case #2: 90.0000000000 Case #3: 78.6900675260 题意： 在一条数轴上有n个大楼，给出n个大楼的坐标x和高度h有n个询问，每次询问给出一个x0表示观测点的坐标，求该观测点能观测到的天空的角度。 分析： 用单调栈来维护一个暴力的顺序，从观测点向两边的建筑进行暴力枚举每一个建筑的最大视角（不是枚举所有的建筑，是按照高度递增的顺序枚举，因为越远但高度却不能更高的话，观测角度肯定更大，我们要求观测角度最小），直到枚举到两边最高的建筑为止。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;cstdio&gt;#include &lt;stack&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const double PI = acos(-1);int n;struct node&#123; double x, h; node()&#123;&#125; node(double xx, double hh):x(xx),h(hh)&#123;&#125;&#125;s[100010];bool cmp(node a, node b)&#123; return a.x &lt; b.x;&#125;int bef[100010], nex[100010], lm[100010], rm[100010];stack&lt;int&gt; ss;void init()&#123; memset(bef, -1, sizeof(bef)); memset(nex, -1, sizeof(nex)); while(!ss.empty()) ss.pop(); for(int i = 0; i &lt; n; i++) &#123; if(ss.empty() || s[ss.top()].h &gt; s[i].h) ss.push(i); else &#123; while(!ss.empty() &amp;&amp; s[ss.top()].h &lt; s[i].h) &#123; nex[ss.top()] = i; ss.pop(); &#125; ss.push(i); &#125; &#125; while(!ss.empty()) ss.pop(); for(int i = n - 1; i &gt;= 0; i--) &#123; if(ss.empty() || s[ss.top()].h &gt; s[i].h) ss.push(i); else &#123; while(!ss.empty() &amp;&amp; s[ss.top()].h &lt; s[i].h) &#123; bef[ss.top()] = i; ss.pop(); &#125; ss.push(i); &#125; &#125; int mh = 0; for(int i = 0; i &lt; n; i++) &#123; if(s[mh].h &lt;= s[i].h) mh = i; lm[i] = mh; &#125; mh = n - 1; for(int i = n - 1; i &gt;= 0; i--) &#123; if(s[mh].h &lt;= s[i].h) mh = i; rm[i] = mh; &#125;&#125;void debug()&#123; for(int i = 0; i &lt; n; i++) &#123; printf("%d x = %f h = %f\n", i, s[i].x, s[i].h); printf("bef %d\nnex %d\nlm %d\nrm %d\n\n", bef[i], nex[i], lm[i], rm[i]); &#125;&#125;int main(void)&#123; int t, q; double x, h, g; scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; cas++) &#123; printf("Case #%d:\n", cas); scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%lf%lf", &amp;x, &amp;h); s[i] = node(x, h); &#125; sort(s, s + n, cmp); init(); //debug(); scanf("%d", &amp;q); while(q--) &#123; scanf("%lf", &amp;g); int r = lower_bound(s, s + n, node(g, 0), cmp) - s; int l = r - 1; double tl = 0, tr = 0; for(int i = l; i != -1 &amp;&amp; i &gt;= lm[l]; i = bef[i]) tl = max(s[i].h / (g - s[i].x), tl); for(int i = r; i != -1 &amp;&amp; i &lt;= rm[r]; i = nex[i]) tr = max(s[i].h / (s[i].x - g), tr); double ans = 180 - 180 * (atan(tl) + atan(tr)) / PI; printf("%.10f\n", ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 2995 Robberies 概率背包]]></title>
    <url>%2F2017%2F06%2F07%2FHDU-2995-Robberies-%E6%A6%82%E7%8E%87%E8%83%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[Robberies Time Limit: 2000/1000 MS ( Memory Limit: 32768/32768 K (: 21326 Accepted Submission(s): 7889 Problem Description The aspiring Roy the Robber has seen a lot of American movies, and knows that the bad guys usually gets caught in the end, often because they become too greedy. He has decided to work in the lucrative business of bank robbery only for a short while, before retiring to a comfortable job at a university. For a few months now, Roy has been assessing the security of various banks and the amount of cash they hold. He wants to make a calculated risk, and grab as much money as possible.His mother, Ola, has decided upon a tolerable probability of getting caught. She feels that he is safe enough if the banks he robs together give a probability less than this. Input The first line of input gives T, the number of cases. For each scenario, the first line of input gives a floating point number P, the probability Roy needs to be below, and an integer N, the number of banks he has plans for. Then follow N lines, where line j gives an integer Mj and a floating point number Pj . Bank j contains Mj millions, and the probability of getting caught from robbing it is Pj . Output For each test case, output a line with the maximum number of millions he can expect to get while the probability of getting caught is less than the limit set.Notes and Constraints0 &lt; T &lt;= 1000.0 &lt;= P &lt;= 1.00 &lt; N &lt;= 1000 &lt; Mj &lt;= 1000.0 &lt;= Pj &lt;= 1.0A bank goes bankrupt if it is robbed, and you may assume that all probabilities are independent as the police have very low funds. Sample Input 3 0.04 3 1 0.02 2 0.03 3 0.05 0.06 3 2 0.03 2 0.03 3 0.05 0.10 3 1 0.03 2 0.02 3 0.05 Sample Output 2 4 6 题意： 一个小偷去银行偷东西，给定一个p要求被抓住的概率必须小于p,然后给定n个银行的mj和pj,分别表示小偷在每个银行能偷到的钱和会被抓住的概率。要求小偷在被抓住的概率小于p的情况下，最多能偷多少钱。（看来小偷也要会编程，不会编程偷不到钱。无业程序员有出路了） :) :) :) 分析： 错误解法：暴力的直接套用01背包的状态转移方程，dp[i] = max{dp[i], dp[i - v[j].p] + v[j].w} 这真是太stupid了，概率不是用来加的，概率和在这里没有任何意义（好气呀，样例用概率加也能过，正式太阴险了） 正确解法：概率应该是相乘的，然而在这里直接算被抓住的概率过于麻烦，于是反过来考虑，算能成功逃跑的概率的最大情况。那么用dp[i]表示偷i的钱能逃跑的最大概率。 得到状态转移方程：dp[i] =max{dp[i], dp[i - v[j].w] * (1 - v[j].p)} 最后找出逃跑概率大于等于p的最大的i 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//// main.cpp// HDU-Fighting//// Created by sun000 on 16/10/21.// Copyright © 2016年 sun000. All rights reserved.//#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;double dp[10010];//偷钱i时能逃跑的最大概率struct node&#123; int w; double p;&#125;v[105];int main(void)&#123; int t, n, sum; double p; scanf("%d", &amp;t); while(t--) &#123; memset(dp, 0, sizeof(dp)); dp[0] = 1; sum = 0; scanf("%lf%d", &amp;p, &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d%lf", &amp;v[i].w, &amp;v[i].p); sum += v[i].w; &#125; for(int i = 1; i &lt;= n; i++)//01背包先循环物品，再循环容量 for(int j = sum; j &gt;= v[i].w; j--)//01背包逆序循环，完全背包正序循环 &#123; dp[j] = max(dp[j], dp[j - v[i].w] * (1 - v[i].p)); //printf("dp[%d] = %lf\n", j, dp[j]); &#125; for(int i = sum; i &gt;= 0; i--) if(dp[i] &gt;= 1 - p) &#123; printf("%d\n", i); break; &#125; &#125; return0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5531（2015长春 icpc E.Rebuild） 计算几何]]></title>
    <url>%2F2017%2F06%2F02%2FHDU-5531%EF%BC%882015%E9%95%BF%E6%98%A5-icpc-E-Rebuild%EF%BC%89-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%2F</url>
    <content type="text"><![CDATA[Rebuild Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others) Total Submission(s): 1881 Accepted Submission(s): 416 Problem Description Archaeologists find ruins of Ancient ACM Civilization, and they want to rebuild it. The ruins form a closed path on an x-y plane, which has n endpoints. The endpoints locate on (x1,y1), (x2,y2), …,(xn,yn) respectively. Endpoint i and endpoint i−1 are adjacent for 1 &lt; i ≤ n, also endpoint 1 and endpoint n are adjacent. Distances between any two adjacent endpoints are positive integers. To rebuild, they need to build one cylindrical pillar at each endpoint, the radius of the pillar of endpoint i is ri. All the pillars perpendicular to the x-y plane, and the corresponding endpoint is on the centerline of it. We call two pillars are adjacent if and only if two corresponding endpoints are adjacent. For any two adjacent pillars, one must be tangent externally to another, otherwise it will violate the aesthetics of Ancient ACM Civilization. If two pillars are not adjacent, then there are no constraints, even if they overlap each other. Note that ri must not be less than 0 since we cannot build a pillar with negative radius and pillars with zero radius are acceptable since those kind of pillars still exist in their neighbors. You are given the coordinates of n endpoints. Your task is to find r1,r2,…,rn which makes sum of base area of all pillars as minimum as possible. For example, if the endpoints are at (0,0), (11,0), (27,12), (5,12), we can choose (r1, r2, r3, r4)=(3.75, 7.25, 12.75, 9.25). The sum of base area equals to 3.752π+7.252π+12.752π+9.252π=988.816…. Note that we count the area of the overlapping parts multiple times. If there are several possible to produce the minimum sum of base area, you may output any of them. Input The first line contains an integer t indicating the total number of test cases. The following lines describe a test case. The first line of each case contains one positive integer n, the size of the closed path. Next n lines, each line consists of two integers (xi,yi) indicate the coordinate of the i-th endpoint. 1≤t≤100 3≤n≤104 |xi|,|yi|≤104 Distances between any two adjacent endpoints are positive integers. Output If such answer doesn't exist, then print on a single line &quot;IMPOSSIBLE&quot; (without the quotes). Otherwise, in the first line print the minimum sum of base area, and then print n lines, the i-th of them should contain a number ri, rounded to 2 digits after the decimal point. If there are several possible ways to produce the minimum sum of base area, you may output any of them. Sample Input 3 4 0 0 11 0 27 12 5 12 5 0 0 7 0 7 3 3 6 0 6 5 0 0 1 0 6 12 3 16 0 12 Sample Output 988.82 3.75 7.25 12.75 9.25 157.08 6.00 1.00 2.00 3.00 0.00 IMPOSSIBLE 题意：这道题目按顺序给出一些点的坐标，点依次相连，并且最后一个点和第一个点相连形成一个环。问在换上以每个点为圆心作一系列圆，要求相邻两点的圆相互外切。如不存在这样的点则输出“IMPOSSIBLE”否则输出这些圆总面积的最小值，并依次输出此时所有圆的半径（所有输出保留两位小数） 分析：我们可以假设第一个圆的半径为x那么能够一次表示出所有的圆的半径，并且可以把每个圆的半径依次表示为f[i] + x,或者f[i] - x;（第i个点）i为奇数是是+，偶数是-；因为要求所有的半径大于等于0，那么我们在可以一次求出所有的f[i]先，和x的范围[minn, maxn]。最后可以用x表示出最后一个圆的半径。 如果是奇数个点：那么x是一个可以求的定值，只要判断在不在[minn, maxn]里就可以，如果在则有解，那么可以通过f[i]求出所有圆的半径，面积也容易求。 如果是偶数个点：那么最后的半径和第一个圆的半径是同号码的，那么不能直接求出x，我们可以用x来表示每一个圆的半径，那么总面积一定能表示称一个x的二次函数，然后结合x在区间[minn, maxn]内，可以求出最大的总面积，并求出此时的x。然后可以求出每个圆的半径。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134//// main.cpp// HDU-Fighting//// Created by 绿色健康文艺小清新 on ...// Copyright 2016年 绿色健康文艺小清新. All rights reserved.//#include &lt;cstdio&gt;#include &lt;cmath&gt;const double PI = acos(-1);//之前吧pi写成3.1415926白wa了一发，pi以后都写成acos(-1)不要无故的waconst double eps = 1e-7;int n;double len[10005], f[10005], x;struct point&#123; double x, y;&#125; p[10005];double cal_len(point a, point b)&#123; return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;void cal_all_len()//一次求出所有边的长&#123; for(int i = 0; i &lt; n - 1; i++) len[i] = cal_len(p[i], p[i + 1]); len[n - 1] = cal_len(p[0], p[n - 1]);&#125;double abs(double x)&#123; if(x &gt; 0) return x; return -x;&#125;void print(double ans)&#123; printf("%.2f\n", ans * PI); for(int i = 0; i &lt; n; i++) &#123; if(i &amp; 1)//我从下标0开始存，所以代码里的i和分析里的第几个奇偶性是相反的 printf("%.2f\n", f[i] - x); else printf("%.2f\n", f[i] + x); &#125;&#125;int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; double maxn = 0x3f3f3f, minn = 0; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) scanf("%lf%lf", &amp;p[i].x, &amp;p[i].y); cal_all_len(); f[0] = 0; for(int i = 1; i &lt; n; i++) &#123; f[i] = len[i - 1] - f[i - 1]; if((i &amp; 1) &amp;&amp; f[i] &lt; maxn) maxn = f[i]; if(!(i &amp; 1) &amp;&amp; (-f[i]) &gt; minn) minn = -f[i]; &#125; if(minn &gt;= maxn + eps) &#123; printf("IMPOSSIBLE\n"); continue; &#125; if(n &amp; 1) &#123; x = 1.0 * (len[n - 1] - f[n -1]) / 2; if(x &lt;= minn - eps || x &gt;= maxn + eps) &#123; printf("IMPOSSIBLE\n"); continue; &#125; double ans = 0.0; for(int i = 0; i &lt; n; i++) &#123; if(i &amp; 1) ans += (f[i] - x) * (f[i] - x); else ans += (f[i] + x) * (f[i] + x); &#125; print(ans); &#125; else &#123; if(abs(f[n - 1] - len[n - 1]) &gt; eps || (minn - maxn) &gt; eps) &#123; printf("IMPOSSIBLE\n"); continue; &#125; double A = 0, B = 0, C = 0; for(int i = 0; i &lt; n; i++) &#123; A = A + 1; C += f[i] * f[i]; if(i &amp; 1) B -= 2 * f[i]; else B += 2 * f[i]; &#125; double l = (-B / 2) / A; if(l &lt; minn + eps) x = minn; else if(maxn &lt; l + eps) x = maxn; else x = l; print(A * x * x + B * x + C); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数学</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1830高斯消元]]></title>
    <url>%2F2017%2F05%2F30%2FPOJ-1830%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%2F</url>
    <content type="text"><![CDATA[某些开关的动作可能影响另一些开关的状态,因此以开关为节点，如果存在这种关系就加入一条有向边（开始我想成对称的了，浪费了很多时间- -），这样就构成了一个图，可以用邻接矩阵表示（但是要转置一下，后面细说）。当某个开关按下时，其自身状态改变，受其影响的开关的状态也改变。 用两个N维向量表示初始状态和结束状态，两者逐个元素异或，就得到了开关状态的变化。 以第一个样例输入为例分析，3个开关，两两相连，初始状态000，最终状态111，将对角线的0全部换成1，得矩阵A= 这里写图片描述 将矩阵每一列想象为一个开关按下后产生的效果（1表示状态翻转，0表示不变），比如，第二列就表示按下第二个开关，则第二个开关的本身状态要改变（这就是把对角线0换成1的原因），受第二个开关影响的开关j状态也要改变，恰好对应邻接矩阵中A[j, 2]=1 把A写成分块矩阵的形式，每一列作为一个子矩阵，则有A=[a1, a2, a3],此处ai均为列向量，设第i个开关按下次数为xi，xi=0或1（开关按两下和没按是等效的，0/1就够了） 记初始状态b0=[0,0,0],最终状态b1=[1,1,1],则状态变化b=b0^b1=[1,1,1],这里b也是列向量。目标就是求x1a1 + x2a2 +x3a3 = b的解的个数（此处的加是模2加，也就是异或，下同） &gt; 这个方程可以写成 &gt; &gt; 下面就是解这个线性方程组 对增广矩阵[A b]做初等行变换，化成阶梯形（高斯消元法），如果存在[0,0,…,0,1]的行，就是无解；如果存在r行[0,0,…,0,0]，就意味着有r个自由变量，因为这里的变量只取0/1，所以有2r个解；如果不存在[0,0,…,0,*]，即把最后一行去掉后不存在全0行，则A为满秩矩阵，则方程组有唯一解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//// main.cpp// HDU-Fighting//// Created by 绿色健康文艺小清新 on ...// Copyright 2016年 绿色健康文艺小清新. All rights reserved.//#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;const int mod = 2;int a[30][31];int gcd(int a, int b)&#123; int t; while(b)&#123; t = b; b = a % b; a = t; &#125; return a;&#125;int lcm(int a, int b)&#123; return a / gcd(a, b) * b;&#125;int Gauss(int equ, int var)&#123; int k, col; for (k = 0, col = 0; k &lt; equ &amp;&amp; col &lt; var; ++k, ++col)&#123; int max_r = k; for (int i = k + 1; i &lt; equ; ++i)&#123; if (abs(a[i][col]) &gt; abs(a[max_r][col])) max_r = i; &#125; if (max_r != k)&#123; for (int i = k; i &lt;= var; ++i) swap(a[k][i], a[max_r][i]); &#125; if (a[k][col] == 0)&#123; --k; continue; &#125; for (int i = k + 1; i &lt; equ; ++i)&#123; if (a[i][col] != 0) &#123; int LCM = lcm(abs(a[i][col]), abs(a[k][col])); int ta = LCM / abs(a[i][col]); int tb = LCM / abs(a[k][col]); if (a[i][col] * a[k][col] &lt; 0) tb = -tb; for (int j = col; j &lt;= var; ++j) &#123; a[i][j] = ((a[i][j] * ta - a[k][j] * tb) % mod + mod) % mod; &#125; &#125; &#125; &#125; for (int i = k; i &lt; equ; ++i)&#123; if (a[i][col] != 0) return -1; &#125; return var - k;&#125;int s[30], e[30];long long int b[30];void build(int n)&#123; int x, y; while(scanf("%d%d", &amp;x, &amp;y), x || y) a[y - 1][x - 1] = 1; for(int i = 0; i &lt; n; i++) a[i][n] = s[i] ^ e[i];&#125;void init()&#123; b[0] = 1; for(int i = 1; i &lt; 30; i++) b[i] = b[i - 1] * 2;&#125;int main(void)&#123; int t, n; scanf("%d", &amp;t); init(); while(t--) &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt;= n; j++) a[i][j] = 0; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;s[i]); a[i][i] = 1; &#125; for(int i = 0; i &lt; n; i++) scanf("%d", &amp;e[i]); build(n); int ans = Gauss(n, n); if(ans == -1) printf("Oh,it's impossible~!!\n"); else printf("%lld\n", b[ans]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数学</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫比乌斯反演入门]]></title>
    <url>%2F2017%2F05%2F28%2F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[这个文章主要讲一下ACM中1个常用的莫比乌斯反演公式，看到很多博客上面公式是有，但是都没证明，《组合数学》上的证明又没看懂， 就自己想了种证明方法，觉得比《组合数学》的证明简单些，就写一下，希望对初学莫比乌斯反演的同学有帮助。 PS：下面公式出现的sigma是累加，另外建议大家看的时候 把公式在纸上写出来！ 一：什么是莫比乌斯反演 简单点的说，就是先给出一个函数 F(n) ,然后再由 F(n)定义一个新函数 G(n) 其中 G(n) = sigma(F(d)) (其中d被“包含”于n) 然后 现在我们不知道 F(n)的值 ， 却知道 G(n)， 接着我们就可以通过 反演由G(n)反向得到F(n) 什么叫 (其中d被“包含”于n) ？以及怎么理解反演？ 通过下面的几个例子说明 例1： 我们直接定义 G(n)=sigma(F(i)) (1&lt;=i&lt;=n) {这里的每个F(i)，相对于G(n)实际上就是一种包含关系了！！} 然后我们现在已经知道 G(n)=n*(n+1)/2; 接下来 我们要通过 G(n)反向得到F(n) 的过程，就是反演 当然，这个问题很简单，很容易都可以看出来 F(n)=n ～～ 例2: 我们先令 S,X 都表示集合 比如 S={1,4,6} X={2} 等 并令|S|表示 S中元素的个数 接着定义 集合上的函数 F(S) /具体怎么定义不用管，我们只需要知道有这么一个关于集合的函数F就好了 :) / 然后再定义 G(S)=sigma(F(X)) (其中X是S的子集) {这里也是一种包含关系，集合的包含！！} 接着我们不知道F(S)，想通过G(S) 来得到 F(S) 这个问题相对于例1就复杂多了，但实际上我们已经有现成的关于集合包含的莫比乌斯反演公式了 :) F(S)=sigma((-1)^(|S|-|X|) * G(X)) (其中X是S的子集) 是不是感觉有点神奇？ 大家可以自己写个程序来验证一下。 下面就是我的验证程序： 我定义 F(S)=|S| ， 然后先 计算出 F(S) ,接着 计算出 G(S) , 然后 比较由G(S)反演得到的 F(S)和 |S| 的大小 下面是 我的程序 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;#define base 10#define REP(i,n) for(int i=0;i&lt;(n);i++)int F[1&lt;&lt;base],G[1&lt;&lt;base];// 集合用二进制表示 base表示集合最多10个元素int Cal(int x)&#123; // 计算 |x| int sum=0; while(x) sum+=(x&amp;1),x/=2; return sum;&#125;int main()&#123; REP(S,1&lt;&lt;base) F[S]=Cal(S); // 计算出最开始的F(S) REP(S,1&lt;&lt;base)&#123; // 计算G(S) G[S]=0; for(int X=S;X;X=(X-1)&amp;S) G[S]+=F[X]; //用X遍历S集合 &#125; REP(S,1&lt;&lt;base)&#123; // 计算反演的 F(S) F[S]=0; for(int X=S;X;X=(X-1)&amp;S) F[S]+=(int)pow(-1,Cal(S)-Cal(X))*G[X]; &#125; bool flag=1; // 验证一下 REP(S,1&lt;&lt;base) if(F[S]!=Cal(S)) flag=0; if(flag) cout&lt;&lt;"YES"&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl;&#125; 最后得到的结果 当然是 YES 咯！:) 关于这个 反演公式 的证明，先不要着急，看完文章过后，你自己都能摸索着证明了！！ 现在先大概理解反演是个什么就行了！！ 例3： 先令 d|n 表示 d能整除n 比如 2|4 (=.=) 定义 关于 整数 的函数 F(n) 然后 定义 G(n)=sigma(F(d)) (其中d|n) 上面的这种包含关系就更复杂了，只有当d是n的因子的时候，F(d)才会被包含在G(n)中。 不过这种 包含关系 在 ACM中遇到的最多，所以我会详细讲一下这种类型的 反演。 相信明白了这个过后，例2的反演也能够自己证明了。 具体的讲解见下一章节 :) 二：一类反演 这个一类反演就是例3中的那一类咯= = 我先直接给出结论吧 原式 : G(n)=sigma(F(d)) (其中d|n) 反演公式: F(n)=sigma(U(n/d)*G(d)) 这里U是一个函数，他是每一项 G(d) 的系数，他的定义见下面 （强烈建议关于U的定义这一段可以先跳过，先认为他是G的系数就行了，可以跳到下面红字位置） (1).U是一个关于整数的函数 (2).U[x] = 1 当且仅当 x能够分解成偶数个不同质数的乘积 （其中1不能被分解，所以1的分解出的质数个数是0，所以U[1]=1） (3).U[x] = -1 当且仅当 x能够分解成奇数个不同质数的乘积 (4).U[x] = 0 除开(2),(3)的其他情况 看上面关于U的定义可能有点看晕了，通俗一点的说 对于一个 x , 分解因式过后 有 x=(p1e1)(p2^e2)...(prer) 如果 ei中(1&lt;=i&lt;=r)有一个数ei大于1 那么 U[x] = 0; 不然的话 U[x] = (-1)^r 依旧来两个例子（我最喜欢举例子了 = =） U[1]=1;定义中的说明 U[2]=-1; 分解式 2=2; U[6]=1; 分解式 6=2*3 U[9]=0; 9=3^2; 出现了e&gt;1 U[12]=0; 12=2^2*3; 跳到这里 :) 上面就是关于这类反演公式的定义，不要头晕= =，继续往下看吧 在证明之前，我们先想一下，为什么反演公式会是 F(n)=sigma(U(n/d)*G(d)) 这样的型式？ 依旧通过例题来找规律 (^ ^) 我们令 n=6; 那么 在计算 F(6)的时候，我们会用到 G(1) G(2) G(3) G(6) 我们考察者4个G G(1) = F(1) G(2) = F(1)+F(2) G(3) = F(1)+F(3) G(6) = F(1)+F(2)+F(3)+F(6) 观察上面可以发现 每个 G(n)都是由一些F(d)累加得到的 当我们需要逆向有G得到F(n)时，只需要将一些 与 F(n) 有关的 G进行容斥！！！！！ 最终组合得到F(n)！！！ 比如 F(6) = G(6)-G(2)-G(3)+G(1) ！！！！ 有些神奇！！ 不过这类莫比乌斯反演的实质也就是容斥原理的应用！！ 那么我们现在知道为什么 这类反演公式会是 这个形式了，而且对其原理也有了更深的理解，现在该想一想公式的细节了。 既然我们知道要得到 F(n) ，只需要将与其相关的 G进行容斥就可以，那么剩下的问题就是每个G的系数！！！ 我们以 求解 F(6)为例子来说明 ，并定义一个系数函数 H(d,n). 其中 H(d,n)表示 求解F(n)时，G(d)的系数 （其中d|n） 所以可以得到这个式子 F(6) = H(6,6)G(6)+H(2,6)G(2)+H(3,6)G(3)+H(1,6)G(1) 我们用 a,b,c,d分别替代 四个H(6,6),H(2,6),H(3,6),H(1,6)，并且把对应的G用F表示出来，得到 F(6)=a(F(6)+F(3)+F(2)+F(1))+b(F(2)+F(1))+c(F(3)+F(1))+dF(1),再变形一下，又有 F(6)(a-1)+F(3)(a+c)+F(2)(a+b)+F(1)(a+b+c+d)=0，把F(6),F(3),F(2),F(1)当作不同的元，则得到了下面的方程组！！！ a-1==0 a+c==0 a+b==0 a+b+c+d==0 由此发现，四个未知数，四个方程，只需要解出方程，就能知道对于G的系数。 再深入的想一下，对于每个 F(n),假设他的因子数为,m，则通过这种方式，总能设出m个未知数，m个方程， 这样总能找到解，而这也为莫比乌斯反演的可能性作出了解释！！ 现在我们要证明一个结论，即使H(a,b)==H(1,b/a)！！这个结论很重要，具体分析见下 :) 我们以求解 F(8)为例子，与F(8)相关的 H 有 ，H(8,8),H(4,8),H(2,8),H(1,8) F(8)=H(8,8)G(8)+H(4,8)G(4)+H(2,8)G(2)+H(1,8)G(1) 首先看 H(8,8),其值可以直接确定，因为把F(8)当作元的话，左边一个F(8),而在右边F(8)只在G(8)中出现，所以H(8,8)==1 同理 对于 F(n)，其G(n)的系数H(n,n)==1，所以H(8,8)==H(1,1) 再来看H(4,8),，首先想，F(4)在哪些地方出现，发现 在G(8)和G(4)出现，因为左边不含F(4)，而前面G(8)的系数又已经确定， 所以这里H(4,8)*G(4)的作用就是为了抵消前面G(8)的代换中，出现的F(4)，所以 H(4,8)==-H(8,8)==-H(2,2)==H(1,2),{H(1,2)==-H(1,1)请大家自己验证一下} 同理对于H(2,8)，他是为了抵消前面在G(8)和G(4)中出现的F(2)，所以H(2,8)相当于受到H(4,4)和H(2,4)的影响(假设这个结论对n==4也成立，H(2,4)==H(1,2))， 所以H(2,8)==H(1,4) 找到规律过后，总结一下，假设n的因子有 d1,d2,d3...dm 其中 d1&gt;d2&gt;d3...&gt;dm 我们依次确定H(di,n)的值，当我们在确定H(di,n)的值时，前面的值已经确定，即H(dj, n)(j &lt; i)的值已经确定， H(di,n)会受到前面一些H(dj,n)的影响，当且仅当 dj&gt;di且 di|dj 。 假设 H(a,b)==H(1,b/a)对前面的 H(dj,n)和 所有的H(k,m)其中m &lt; n 已经成立(首先对于H(n,n)已经成立)，那么有 H(dj,n)==H(1,n/dj)==H(dj/di,n/di) 这样就把前面对H(di,n)造成影响的H由 H(dj,n)转为了 H(dj/di,n/di) ,所以H(di,n) == H(1,n/di) 既然 H(a,b) 都可以 写成 H(1,b/a) ， 于是我们把H的第一个元素略去，简写为 H(x) 说到这里，就可以把H和U联系起来了，其实 U(x) = H(x) = H(1,x) 再来，我们就可以给U(x)赋予一个更具体的意义， U(x)表示在计算 F(x)时，G(1)的系数！！(因为U(x)==H(1,x)) 接下来，我们来尝试一下，如何用上面那个U(x)的新意义，来计算U(x)的值！！ 首先需要明确2点！ 一是G(x)中,一定包含一个F(1)，因为 1|x 二是，F(1)==G(1) (0).如果 x==1 因为 F(1)==G(1) 所以 U[1]=1; (1).假设 x 是一个 质数 F(x) = U(1)G(x)+U(x)G(1) 带入U(1) == 1, 因为G(x)中含有一个F(1),而左边不含F(1)，所以我们需要利用G(1)来消去F(1) 所以得到 U(x)=-1 (2).假设 x 可以写成2个不同质数的乘积 x=p*q 那么 F(x)=U(1)G(pq)+U(q)G(p)+U(p)G(q)+U(x)G(1) 这里 U(1)，U(p)，U(q) 就是前面2种情况 带入系数，因为左边没有 F(1)，所以为了抵消右边的F(1)，我们需要令 U(x)=1; (3).假设 x 可以写成3个不同质数的乘积 x=pp1p2 我们令 z = p1*p2 F(x) = U(1)G(pz)+U(z)G(p)+U(p)G(z)+U(x)G(1); 其中 U(1),U(p),U(z) 分别为前面几种情况，带入过后 ，为抵消F(1) 得到 U(x)=-1 由此可以相同的方式向下递推，得到第一条结论 如果 x = p1p2...pr , 其中pi是互异的质数，那么 U[x] = (-1)^r ----------------------- 1！！ (4).假设 x 可以写成一个质数的平方 x=p^2 F(x) = U(1)G(x)+U(p)G(p)+U(x)*G(1) 带入系数 得到 U(x)=0; (5).假设 x 可以写成一个质数的三次方 x=p^3 F(x) = U(1)G(x)+U(p)G(p2)+U(p2)G(p)+U(x)G(1) 带入系数后 U(x)=0; 由此可用相同方式向下递推，得到第二条结论 如果 x = p^e (e&gt;1) U[x] = 0; -------------------------- 2！！ (6).假设 x 可写成 x = p^e*q 其中p,q为不同质数，e&gt;1 F(x) = U(1)G(x)+U(q)G(pe)+U(pe)G(q)+U(x)G(1) 带入系数后 U(x) = 0; 由此可继续向下递推，得到第二条结论的加强版！！ 如果 x = p^e*z 其中p为质数, z为任意数,e&gt;1 那么 U[x] = 0 ----------------------2！！ 由此，我们得到了 U[x] 的计算方法！！即是U定义中给出的那样！！（没看定义的同学此时再跳回去看吧） 三：应用 得到了公式，也知道了他是怎么来的，现在就用一个应用来加深理解吧 :) 首先我们要给出 第二部分 中那个公式的另外一种形式 = = 我们把它称为形式二吧～ 原式 : G(n)=sigma(F(d)) (其中n|d,d&lt;=N) 反演公式: F(n)=sigma(U(d/n)*G(d)) (其中n|d,d&lt;=N) 这里U[x]的计算方式和上面的相同！！ 注意上面的 n|d 和 d/n 和上面是相反的 证明方法和上面差不多，大致说一下 还是先设置一个系数函数 H(d,n) 表示求解 F(n)时 G(d)出现的次数， 接着 用与上面类似的方法变化H(d,n) 为 H (d/n,1) ---&gt; H(x,1) 则联系 U(x) == H(x,1) 表示 在计算 F(1)时，G(x)的系数 以 x 为质数为例子，由于 G(1)=F(1)+F(2)....+F(N) F(1) = G(1)+U(2)G(2)...+U(x)G(x)...+U(N)G(N) 因为 x 为质数 所以 F(x)这一项 只在G(1)里面出现了一次，而其他地方只会在 G(x)出现 所以我们需要让 U(x)=-1 来抵消 F(x) 剩下的步骤就和上面差不多了，分类讨论一下，就可以求出这种情况下的U的计算方式，和上面相同！！ 接下来就真正的开始演示怎么用 莫比乌斯反演 简化计算了 ！！ 看下面这个问题！ 给出a，b 其中 (1&lt;=a,b&lt;=10^6) 求满足条件的 x,y 的对数，使得 1&lt;=x&lt;=a,1&lt;=y&lt;=b,且gcd(x,y) == 1。 其中 (2,3) (3,2) 算两对！ 直接暴力显然复杂度太大，我们用莫比乌斯反演来解决。 令N = max(a,b) 然后定义 F(n) 表示满足条件的 gcd(x,y)==n的 (x,y) 对数 在定义 G(n) 表示满足 n | gcd(x,y) 的(x,y)对数 即 gcd(x,y)%n==0 的x,y对数 那么根据定义，有 G(n) = sigma(F(d)) (n|d,d&lt;=N) 于是我们需要求的就是 F(1) 怎么解决？ 首先根据G(n)的定义，可以很容易发现 G(n) = (a/n)*(b/n)这里是向下整除 （提示：把n当成最小的元） 然后 我们只直接计算 F(1) 即可 带入 G(n) 的公式 有 F(1) = sigma(U[i](a/i)(b/i)) (1&lt;=i&lt;=N) 至于U[]的值，可以提前用筛法在O(n)的时间内处理出来，这样总的时间复杂度就是 O(n)，问题得到解决！！ 下面附上我自己求U[]的代码 （效率并不是严格上的O(n)，不过一般情况下已经足够） 四：进阶 在ACM中，可以利用 莫比乌斯反演 来求解很多关于 Gcd 的问题 推荐几道基础题： SPOJ 7001 , ZOJ 3435, HDU 1695. 想做更多的题的话，自己去HUST OJ搜索吧 :) 最后再说一下上面的证明方法都是个人YY的，感觉比《组合数学》上的证明简单些（数学太渣orz...那个证明我是没看太懂），写下来 给初学莫比乌斯反演的童鞋当个资料（= =）。关于上面的证明我暂时没发现什么错误，如果发现错误，请在回复里面指出！另外 形式二的证明应该可以由形式一直接得到，不过我没想出什么好办法，知道的神牛也请在评论中说一下！]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包九讲]]></title>
    <url>%2F2017%2F05%2F28%2F%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2%2F</url>
    <content type="text"><![CDATA[转载：dd_engi 的背包九讲 详细原博客（非最初作者dd） 目录 第一讲 01背包问题 第二讲 完全背包问题 第三讲 多重背包问题 第四讲 混合三种背包问题 第五讲 二维费用的背包问题 第六讲 分组的背包问题 第七讲 有依赖的背包问题 第八讲 泛化物品 第九讲 背包问题问法的变化 附：USACO中的背包问题 前言 本篇文章是我(dd_engi)正在进行中的一个雄心勃勃的写作计划的一部分，这个计划的内容是写作一份较为完善的NOIP难度的动态规划总结，名为《解动态规划题的基本思考方式》。现在你看到的是这个写作计划最先发布的一部分。 背包问题是一个经典的动态规划模型。它既简单形象容易理解，又在某种程度上能够揭示动态规划的本质，故不少教材都把它作为动态规划部分的第一道例题，我也将它放在我的写作计划的第一部分。 读本文最重要的是思考。因为我的语言和写作方式向来不以易于理解为长，思路也偶有跳跃的地方，后面更有需要大量思考才能理解的比较抽象的内容。更重要的是：不大量思考，绝对不可能学好动态规划这一信息学奥赛中最精致的部分。 你现在看到的是本文的1.0正式版。我会长期维护这份文本，把大家的意见和建议融入其中，也会不断加入我在OI学习以及将来可能的ACM-ICPC的征程中得到的新的心得。但目前本文还没有一个固定的发布页面，想了解本文是否有更新版本发布，可以在OIBH论坛中以“背包问题九讲”为关键字搜索贴子，每次比较重大的版本更新都会在这里发贴公布。 目录 第一讲 01背包问题 这是最基本的背包问题，每个物品最多只能放一次。 第二讲 完全背包问题 第二个基本的背包问题模型，每种物品可以放无限多次。 第三讲 多重背包问题 每种物品有一个固定的次数上限。 第四讲 混合三种背包问题 将前面三种简单的问题叠加成较复杂的问题。 第五讲 二维费用的背包问题 一个简单的常见扩展。 第六讲 分组的背包问题 一种题目类型，也是一个有用的模型。后两节的基础。 第七讲 有依赖的背包问题 另一种给物品的选取加上限制的方法。 第八讲 泛化物品 我自己关于背包问题的思考成果，有一点抽象。 第九讲 背包问题问法的变化 试图触类旁通、举一反三。 背包的搜索 附：USACO中的背包问题 给出 USACO Training 上可供练习的背包问题列表，及简单的解答。 联系方式 如果有任何意见和建议，特别是文章的错误和不足，或者希望为文章添加新的材料，可以通过http://kontactr.com/user/tianyi/这个网页联系我。 致谢 感谢以下名单： 阿坦 jason911 donglixp 他们每人都最先指出了本文第一个beta版中的某个并非无关紧要的错误。谢谢你们如此仔细地阅读拙作并弥补我的疏漏。 感谢 XiaQ，它针对本文的第一个beta版发表了用词严厉的六条建议，虽然我只认同并采纳了其中的两条。在所有读者几乎一边倒的赞扬将我包围的当时，你的贴子是我的一剂清醒剂，让我能清醒起来并用更严厉的眼光审视自己的作品。 当然，还有用各种方式对我表示鼓励和支持的几乎无法计数的同学。不管是当面赞扬，或是在论坛上回复我的贴子，不管是发来热情洋溢的邮件，或是在即时聊天的窗口里竖起大拇指，你们的鼓励和支持是支撑我的写作计划的强大动力，也鞭策着我不断提高自身水平，谢谢你们！ 最后，感谢 Emacs 这一世界最强大的编辑器的所有贡献者，感谢它的插件 EmacsMuse 的开发者们，本文的所有编辑工作都借助这两个卓越的自由软件完成。谢谢你们——自由软件社群——为社会提供了如此有生产力的工具。我深深钦佩你们身上体现出的自由软件的精神，没有你们的感召，我不能完成本文。在你们的影响下，采用自由文档的方式发布本文档，也是我对自由社会事业的微薄努力。 P01: 01背包问题 题目 有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。 基本思路 这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。 用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是： f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]} 这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”，价值为f[i-1][v]；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-c[i]的背包中”，此时能获得的最大价值就是f[i-1][v-c[i]]再加上通过放入第i件物品获得的价值w[i]。 优化空间复杂度 以上方法的时间和空间复杂度均为O(N*V)，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到O(V)。 先考虑上面讲的基本思路如何实现，肯定是有一个主循环i=1..N，每次算出来二维数组f[i][0..V]的所有值。那么，如果只用一个数组f[0..V]，能不能保证第i次循环结束后f[v]中表示的就是我们定义的状态f[i][v]呢？f[i][v]是由f[i-1][v]和f[i-1][v-c[i]]两个子问题递推而来，能否保证在推f[i][v]时（也即在第i次主循环中推f[v]时）能够得到f[i-1][v]和f[i-1][v-c[i]]的值呢？事实上，这要求在每次主循环中我们以v=V..0的顺序推f[v]，这样才能保证推f[v]时f[v-c[i]]保存的是状态f[i-1][v-c[i]]的值。伪代码如下： 123for i=1..N for v=V..0 f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; 其中的f[v]=max{f[v],f[v-c[i]]}一句恰就相当于我们的转移方程f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]}，因为现在的f[v-c[i]]就相当于原来的f[i-1][v-c[i]]。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f[i][v]由f[i][v-c[i]]推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。 事实上，使用一维数组解01背包的程序在后面会被多次用到，所以这里抽象出一个处理一件01背包中的物品过程，以后的代码中直接调用不加说明。{！背过} 我们看一下原来的方程f[i][v]=max{f[i-1][v], f[i-1][v-c[i]]+w[i]} 不一定从1开始，那样会浪费 ​ 过程ZeroOnePack，表示处理一件01背包中的物品，两个参数cost、weight分别表明这件物品的费用和价值。 123procedure ZeroOnePack(cost,weight) for v=V..cost f[v]=max&#123;f[v],f[v-cost]+weight&#125; 注意这个过程里的处理与前面给出的伪代码有所不同。前面的示例程序写成v=V..0是为了在程序中体现每个状态都按照方程求解了，避免不必要的思维复杂度。而这里既然已经抽象成看作黑箱的过程了，就可以加入优化。费用为cost的物品不会影响状态f[0..cost-1]，这是显然的。 有了这个过程以后，01背包问题的伪代码就可以这样写： 12for i=1..N ZeroOnePack(c[i],w[i]); 初始化的细节问题 我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。 如果是第一种问法，要求恰好装满背包，那么在初始化时除了f[0]为0其它f[1..V]均设为-∞，这样就可以保证最终得到的f[N]是一种恰好装满背包的最优解。 如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将f[0..V]全部设为0。 为什么呢？可以这样理解：初始化的f数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可能被价值为0的nothing“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是-∞了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。 这个小技巧完全可以推广到其它类型的背包问题，后面也就不再对进行状态转移之前的初始化进行讲解。 小结 01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。 首页 P02: 完全背包问题 题目 有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 基本思路 这个问题非常类似于01背包问题 ，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样： f[i][v]=max{f[i-1][v-k*c[i]]+kw[i]|0&lt;=kc[i]&lt;=v} 这跟01背包问题一样有O(NV)个状态需要求解，但求解每个状态的时间已经不是常数了，求解状态f[i][v]的时间是O(v/c[i])，总的复杂度是超过O(VN)的。 将01背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。但我们还是试图改进这个复杂度。 一个简单有效的优化 完全背包问题有一个很简单有效的优化，是这样的：若两件物品i、j满足c[i]&lt;=c[j]且w[i]&gt;=w[j]，则将物品j去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小费用高得j换成物美价廉的i，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。 这个优化可以简单的O(N^2)地实现，一般都可以承受。另外，针对背包问题而言，比较不错的一种方法是：[显然]首先将费用大于V的物品去掉，然后使用类似计数排序的做法，计算出费用相同的物品中价值最高的是哪个，可以O(V+N)地完成这个优化。这个不太重要的过程就不给出伪代码了，希望你能独立思考写出伪代码或程序。 转化为01背包问题求解 既然01背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为01背包问题来解。最简单的想法是，考虑到第i种物品最多选V/c[i]件，于是可以把第i种物品转化为V/c[i]件费用及价值均不变的物品，然后求解这个01背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为01背包问题的思路：将一种物品拆成多件物品。 更高效的转化方法是：把第i种物品拆成费用为c[i]2k、价值为w[i]2^k的若干件物品，其中k满足c[i]2k&lt;=V。这是二进制的思想，因为不管最优策略选几件第i种物品，总可以表示成若干个2^k件物品的和。这样比把每种物品拆成O(log(V/c[i]))件物品，是一个很大的改进。 但我们有更优的O(VN)的算法。 O(VN)的算法 这个算法使用一维数组，先看伪代码： 123for i=1..N for v=0..V f[v]=max&#123;f[v],f[v-cost]+weight&#125; 你会发现，这个伪代码与P01的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么P01中要按照v=V..0的逆序来循环。这是因为要保证第i次循环中的状态f[i][v]是由状态f[i-1][v-c[i]]递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果f[i-1][v-c[i]]。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[i][v-c[i]]，所以就可以并且必须采用v=0..V的顺序循环。这就是这个简单的程序为何成立的道理。 这个算法也可以以另外的思路得出。例如，基本思路中的状态转移方程可以等价地变形成这种形式： f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]} 将这个方程用一维数组实现，便得到了上面的伪代码。 最后抽象出处理一件完全背包类物品的过程伪代码，以后会用到： 123procedure CompletePack(cost,weight) for v=cost..V f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125; 总结 完全背包问题也是一个相当基础的背包问题，它有两个状态转移方程，分别在“基本思路”以及“O(VN)的算法“的小节中给出。希望你能够对这两个状态转移方程都仔细地体会，不仅记住，也要弄明白它们是怎么得出来的，最好能够自己想一种得到这些方程的方法。事实上，对每一道动态规划题目都思考其方程的意义以及如何得来，是加深对动态规划的理解、提高动态规划功力的好方法。 首页 P03: 多重背包问题 题目 有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 基本算法 这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第i种物品有n[i]+1种策略：取0件，取1件……取n[i]件。令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值，则有状态转移方程： f[i][v]=max{f[i-1][v-k*c[i]]+kw[i]|0&lt;=k&lt;=n[i]} 复杂度是O(VΣn[i])。 转化为01背包问题 另一种好想好写的基本方法是转化为01背包求解：把第i种物品换成n[i]件01背包中的物品，则得到了物品数为Σn[i]的01背包问题，直接求解，复杂度仍然是O(VΣn[i])。 但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想，我们考虑把第i种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取0..n[i]件——均能等价于取若干件代换以后的物品。另外，取超过n[i]件的策略必不能出现。 方法是：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为1,2,4,...,2(k-1),n[i]-2k+1，且k是满足n[i]-2k+1&gt;0的最大整数。例如，如果n[i]为13，就将这种物品分成系数分别为1,2,4,6的四件物品。 分成的这几件物品的系数和为n[i]，表明不可能取多于n[i]件的第i种物品。另外这种方法也能保证对于0..n[i]间的每一个整数，均可以用若干个系数的和表示，这个证明可以分0..2k-1和2^k..n[i]两段来分别讨论得出，并不难，希望你自己思考尝试一下。 这样就将第i种物品分成了O(log n[i])种物品，将原问题转化为了复杂度为O(VΣlog n[i])的01背包问题，是很大的改进。 下面给出O(log amount)时间处理一件多重背包中物品的过程，其中amount表示物品的数量： 12345678910procedure MultiplePack(cost,weight,amount) if cost*amount&gt;=V CompletePack(cost,weight) return integer k=1 while k&lt;num ZeroOnePack(k*cost,k*weight) amount=amount-k k=k*2 ZeroOnePack(amount*cost,amount*weight) 希望你仔细体会这个伪代码，如果不太理解的话，不妨翻译成程序代码以后，单步执行几次，或者头脑加纸笔模拟一下，就会慢慢理解了。 O(VN)的算法 多重背包问题同样有O(VN)的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊O(1)的时间求解。由于用单调队列优化的DP已超出了NOIP的范围，故本文不再展开讲解。我最初了解到这个方法是在楼天成的“男人八题”幻灯片上。 小结 这里我们看到了将一个算法的复杂度由O(VΣn[i])改进到O(VΣlog n[i])的过程，还知道了存在应用超出NOIP范围的知识的O(VN)算法。希望你特别注意“拆分物品”的思想和方法，自己证明一下它的正确性，并将完整的程序代码写出来。 首页 P04: 混合三种背包问题 问题 如果将P01、P02、P03混合起来。也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？ 01背包与完全背包的混合 考虑到在P01和P02中给出的伪代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可，复杂度是O(VN)。伪代码如下： 1234567for i=1..N if 第i件物品是01背包 for v=V..0 f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; else if 第i件物品是完全背包 for v=0..V f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; 再加上多重背包 如果再加上有的物品最多可以取有限次，那么原则上也可以给出O(VN)的解法：遇到多重背包类型的物品用单调队列解即可。但如果不考虑超过NOIP范围的算法的话，用P03中将每个这类物品分成O(log n[i])个01背包的物品的方法也已经很优了。 当然，更清晰的写法是调用我们前面给出的三个相关过程。 混血儿的优势 1234567for i=1..N if 第i件物品是01背包 ZeroOnePack(c[i],w[i]) else if 第i件物品是完全背包 CompletePack(c[i],w[i]) else if 第i件物品是多重背包 MultiplePack(c[i],w[i],n[i]) 在最初写出这三个过程的时候，可能完全没有想到它们会在这里混合应用。我想这体现了编程中抽象的威力。如果你一直就是以这种“抽象出过程”的方式写每一类背包问题的，也非常清楚它们的实现中细微的不同，那么在遇到混合三种背包问题的题目时，一定能很快想到上面简洁的解法，对吗？ 小结 有人说，困难的题目都是由简单的题目叠加而来的。这句话是否公理暂且存之不论，但它在本讲中已经得到了充分的体现。本来01背包、完全背包、多重背包都不是什么难题，但将它们简单地组合起来以后就得到了这样一道一定能吓倒不少人的题目。但只要基础扎实，领会三种基本背包问题的思想，就可以做到把困难的题目拆分成简单的题目来解决。 首页 目录 第五讲 二维费用的背包问题 一个简单的常见扩展。 第六讲 分组的背包问题 一种题目类型，也是一个有用的模型。后两节的基础。 第七讲 有依赖的背包问题 另一种给物品的选取加上限制的方法。 第八讲 泛化物品 我自己关于背包问题的思考成果，有一点抽象。 第九讲 背包问题问法的变化 试图触类旁通、举一反三。 背包的搜索 附：USACO中的背包问题 给出 USACO Training 上可供练习的背包问题列表，及简单的解答。 P05: 二维费用的背包问题 问题 二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a[i]和b[i]。两种代价可付出的最大值（两种背包容量）分别为V和U。物品的价值为w[i]。 算法 费用加了一维，只需状态也加一维即可。设f[i][v][u]表示前i件物品付出两种代价分别为v和u时可获得的最大价值。状态转移方程就是： f[i][v][u]=max{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]} 如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量v和u采用逆序的循环，当物品有如完全背包问题时采用顺序的循环。当物品有如多重背包问题时拆分物品。这里就不再给出伪代码了，相信有了前面的基础，你能够自己实现出这个问题的程序。 物品总个数的限制 有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取M件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为1，可以付出的最大件数费用为M。换句话说，设f[v][m]表示付出费用v、最多选m件时可得到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，最后在f[0..V][0..M]范围内寻找答案。 小结 是不是可以用来解决多重背包的问题？？？只不过比多重背包复杂度高 当发现由熟悉的动态规划题目变形得来的题目时，在原来的状态中加一维以满足新的限制是一种比较通用的方法。希望你能从本讲中初步体会到这种方法。 首页 P06: 分组的背包问题 问题 有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 算法 这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设f[k][v]表示前k组物品花费费用v能取得的最大权值，则有： f[k][v]=max{f[k-1][v],f[k-1][v-c[i]]+w[i]|物品i属于第k组} 使用一维数组的伪代码如下： 1234for 所有的组k for v=V..0 for 所有的i属于组k f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125; 注意这里的三层循环的顺序，甚至在本文的beta版中我自己都写错了。“for v=V..0”这一层循环必须在“for 所有的i属于组k”之外。这样才能保证每一组内的物品最多只有一个会被添加到背包中。 另外，显然可以对每组内的物品应用P02中“一个简单有效的优化”。 小结 分组的背包问题将彼此互斥的若干物品称为一个组，这建立了一个很好的模型。不少背包问题的变形都可以转化为分组的背包问题（例如P07），由分组的背包问题进一步可定义“泛化物品”的概念，十分有利于解题。 首页 P07: 有依赖的背包问题 简化的问题 这种背包问题的物品间存在某种“依赖”的关系。也就是说，i依赖于j，表示若选物品i，则必须选物品j。为了简化起见，我们先设没有某个物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。 算法 这个问题由NOIP2006金明的预算方案一题扩展而来。遵从该题的提法，将不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。由这个问题的简化条件可知所有的物品由若干主件和依赖于每个主件的一个附件集合组成。 按照背包问题的一般思路，仅考虑一个主件和它的附件集合。可是，可用的策略非常多，包括：一个也不选，仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……无法用状态转移方程来表示如此多的策略。（事实上，设有n个附件，则策略有2^n+1个，为指数级。） 考虑到所有这些策略都是互斥的（也就是说，你只能选择一种策略），所以一个主件和它的附件集合实际上对应于P06中的一个物品组，每个选择了主件又选择了若干个附件的策略对应于这个物品组中的一个物品，其费用和价值都是这个策略中的物品的值的和。但仅仅是这一步转化并不能给出一个好的算法，因为物品组中的物品还是像原问题的策略一样多。 再考虑P06中的一句话： 可以对每组中的物品应用P02中“一个简单有效的优化”。 这提示我们，对于一个物品组中的物品，所有费用相同的物品只留一个价值最大的，不影响结果。所以，我们可以对主件i的“附件集合”先进行一次01背包，得到费用依次为0..V-c[i]所有这些值时相应的最大价值f'[0..V-c[i]]。那么这个主件及它的附件集合相当于V-c[i]+1个物品的物品组，其中费用为c[i]+k的物品的价值为f'[k]+w[i]。也就是说原来指数级的策略中有很多策略都是冗余的，通过一次01背包后，将主件i转化为V-c[i]+1个物品的物品组，就可以直接应用P06的算法解决问题了。 较一般的问题 更一般的问题是：依赖关系以图论中“森林”的形式给出（森林即多叉树的集合），也就是说，主件的附件仍然可以具有自己的附件集合，限制只是每个物品最多只依赖于一个物品（只有一个主件）且不出现循环依赖。 解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，由于附件可能还有附件，就不能将每个附件都看作一个一般的01背包中的物品了。若这个附件也有附件集合，则它必定要被先转化为物品组，然后用分组的背包问题解出主件及其附件集合所对应的附件组中各个费用的附件所对应的价值。 事实上，这是一种树形DP，其特点是：每个父节点都需要对它的各个儿子的属性进行一次DP以求得自己的相关属性。这已经触及到了“泛化物品”的思想。看完P08后，你会发现这个“依赖关系树”每一个子树都等价于一件泛化物品，求某节点为根的子树对应的泛化物品相当于求其所有儿子的对应的泛化物品之和。 小结 NOIP2006的那道背包问题我做得很失败，写了上百行的代码，却一分未得。后来我通过思考发现通过引入“物品组”和“依赖”的概念可以加深对这题的理解，还可以解决它的推广问题。用物品组的思想考虑那题中极其特殊的依赖关系：物品不能既作主件又作附件，每个主件最多有两个附件，可以发现一个主件和它的两个附件等价于一个由四个物品组成的物品组，这便揭示了问题的某种本质。 我想说：失败不是什么丢人的事情，从失败中全无收获才是。 首页 P08: 泛化物品 定义 考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的费用而变化。这就是泛化物品的概念。 更严格的定义之。在背包容量为V的背包问题中，泛化物品是一个定义域为0..V中的整数的函数h，当分配给它的费用为v时，能得到的价值就是h(v)。 这个定义有一点点抽象，另一种理解是一个泛化物品就是一个数组h[0..V]，给它费用v，可得到价值h[V]。{fuck!这不一样啊！} [将所有的背包普遍化]：1.一个费用为c价值为w的物品，如果它是01背包中的物品，那么把它看成泛化物品，它就是除了h(c)=w其它函数值都为0的一个函数。2.如果它是完全背包中的物品，那么它可以看成这样一个函数，仅当v被c整除时有h(v)=v/cw，其它函数值均为0。3.如果它是多重背包中重复次数最多为n的物品，那么它对应的泛化物品的函数有h(v)=v/cw仅当v被c整除且v/c&lt;=n，其它情况函数值均为0。 一个物品组可以看作一个泛化物品h。对于一个0..V中的v，若物品组中不存在费用为v的的物品，则h(v)=0，否则h(v)为所有费用为v的物品的最大价值。P07中每个主件及其附件集合等价于一个物品组，自然也可看作一个泛化物品。 泛化物品的和 如果面对两个泛化物品h和l，要用给定的费用从这两个泛化物品中得到最大的价值，怎么求呢？事实上，对于一个给定的费用v，只需枚举将这个费用如何分配给两个泛化物品就可以了。同样的，对于0..V的每一个整数v，可以求得费用v分配到h和l中的最大价值f(v)。也即f(v)=max{h(k)+l(v-k)|0&lt;=k&lt;=v}。可以看到，f也是一个由泛化物品h和l决定的定义域为0..V的函数，也就是说，f是一个由泛化物品h和l决定的泛化物品。 由此可以定义泛化物品的和：h、l都是泛化物品，若泛化物品f满足f(v)=max{h(k)+l(v-k)|0&lt;=k&lt;=v}，则称f是h与l的和，即f=h+l。这个运算的时间复杂度取决于背包的容量，是O(V^2)。 泛化物品的定义表明：在一个背包问题中，若将两个泛化物品代以它们的和，不影响问题的答案。事实上，对于其中的物品都是泛化物品的背包问题，求它的答案的过程也就是求所有这些泛化物品之和的过程。设此和为s，则答案就是s[0..V]中的最大值。 背包问题的泛化物品 一个背包问题中，可能会给出很多条件，包括每种物品的费用、价值等属性，物品之间的分组、依赖等关系等。但肯定能将问题对应于某个泛化物品。也就是说，给定了所有条件以后，就可以对每个非负整数v求得：若背包容量为v，将物品装入背包可得到的最大价值是多少，这可以认为是定义在非负整数集上的一件泛化物品。这个泛化物品——或者说问题所对应的一个定义域为非负整数的函数——包含了关于问题本身的高度浓缩的信息。一般而言，求得这个泛化物品的一个子域（例如0..V）的值之后，就可以根据这个函数的取值得到背包问题的最终答案。 综上所述，一般而言，求解背包问题，即求解这个问题所对应的一个函数，即该问题的泛化物品。而求解某个泛化物品的一种方法就是将它表示为若干泛化物品的和然后求之。 小结 本讲可以说都是我自己的原创思想。具体来说，是我在学习函数式编程的 Scheme 语言时，用函数编程的眼光审视各类背包问题得出的理论。这一讲真的很抽象，也许在“模型的抽象程度”这一方面已经超出了NOIP的要求，所以暂且看不懂也没关系。相信随着你的OI之路逐渐延伸，有一天你会理解的。 我想说：“思考”是一个OIer最重要的品质。简单的问题，深入思考以后，也能发现更多。 首页 P09: 背包问题问法的变化 以上涉及的各种背包问题都是要求在背包容量（费用）的限制下求可以取到的最大价值，但背包问题还有很多种灵活的问法，在这里值得提一下。但是我认为，只要深入理解了求背包问题最大价值的方法，即使问法变化了，也是不难想出算法的。 例如，求解最多可以放多少件物品或者最多可以装满多少背包的空间。这都可以根据具体问题利用前面的方程求出所有状态的值（f数组）之后得到。 很多都是这样的 还有，如果要求的是“总价值最小”“总件数最小”，只需简单的将上面的状态转移方程中的max改成min即可。 下面说一些变化更大的问法。 输出方案 一般而言，背包问题是要求一个最优值，如果要求输出这个最优值的方案，可以参照一般动态规划问题输出方案的方法：记录下每个状态的最优值是由状态转移方程的哪一项推出来的，换句话说，记录下它是由哪一个策略推出来的。便可根据这条策略找到上一个状态，从上一个状态接着向前推即可。 还是以01背包为例，方程为f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}。再用一个数组g[i][v]，设g[i][v]=0表示推出f[i][v]的值时是采用了方程的前一项（也即f[i][v]=f[i-1][v]），g[i][v]表示采用了方程的后一项。注意这两项分别表示了两种策略：未选第i个物品及选了第i个物品。那么输出方案的伪代码可以这样写（设最终状态为f[N][V]）： 12345678i=Nv=Vwhile(i&gt;0) if(g[i][v]==0) print "未选第i项物品" else if(g[i][v]==1) print "选了第i项物品" v=v-c[i] 另外，采用方程的前一项或后一项也可以在输出方案的过程中根据f[i][v]的值实时地求出来，也即不须纪录g数组，将上述代码中的g[i][v]==0改成f[i][v]==f[i-1][v]，g[i][v]==1改成f[i][v]==f[i-1][v-c[i]]+w[i]也可。 输出字典序最小的最优方案 这里“字典序最小”的意思是1..N号物品的选择方案排列出来以后字典序最小。以输出01背包最小字典序的方案为例。 一般而言，求一个字典序最小的最优方案，只需要在转移时注意策略。首先，子问题的定义要略改一些。我们注意到，如果存在一个选了物品1的最优方案，那么答案一定包含物品1，原问题转化为一个背包容量为v-c[1]，物品为2..N的子问题。反之，如果答案不包含物品1，则转化成背包容量仍为V，物品为2..N的子问题。不管答案怎样，子问题的物品都是以i..N而非前所述的1..i的形式来定义的，所以状态的定义和转移方程都需要改一下。但也许更简易的方法是先把物品逆序排列一下，以下按物品已被逆序排列来叙述。 在这种情况下，可以按照前面经典的状态转移方程来求值，只是输出方案的时候要注意：从N到1输入时，如果f[i][v]==f[i-v]及f[i][v]==f[i-1][f-c[i]]+w[i]同时成立，应该按照后者（即选择了物品i）来输出方案。{取I与不取I相比，取的话一定在字典前} 求方案总数 对于一个给定了背包容量、物品费用、物品间相互关系（分组、依赖等）的背包问题，除了再给定每个物品的价值后求可得到的最大价值外，还可以得到装满背包或将背包装至某一指定容量的方案总数。 对于这类改变问法的问题，一般只需将状态转移方程中的max改成sum即可。例如若每件物品均是完全背包中的物品，转移方程即为 f[i][v]=sum{f[i-1][v],f[i][v-c[i]]} 初始条件f[0][0]=1。 事实上，这样做可行的原因在于状态转移方程已经考察了所有可能的背包组成方案。 最优方案的总数 这里的最优方案是指物品总价值最大的方案。以01背包为例。 结合求最大总价值和方案总数两个问题的思路，最优方案的总数可以这样求：f[i][v]意义同前述，g[i][v]表示这个子问题的最优方案的总数，则在求f[i][v]的同时求g[i][v]的伪代码如下： 12345678for i=1..N for v=0..V f[i][v]=max&#123;f[i-1][v],f[i-1][v-c[i]]+w[i]&#125; g[i][v]=0 if(f[i][v]==f[i-1][v]) inc(g[i][v],g[i-1][v]) if(f[i][v]==f[i-1][v-c[i]]+w[i]) inc(g[i][v],g[i-1][v-c[i]]) 如果你是第一次看到这样的问题，请仔细体会上面的伪代码。 求次优解、第K优解 对于求次优解、第K优解类的问题，如果相应的最优解问题能写出状态转移方程、用动态规划解决，那么求次优解往往可以相同的复杂度解决，第K优解则比求最优解的复杂度上多一个系数K。 其基本思想是将每个状态都表示成有序队列，将状态转移方程中的max/min转化成有序队列的合并。这里仍然以01背包为例讲解一下。 首先看01背包求最优解的状态转移方程：f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}。如果要求第K优解，那么状态f[i][v]就应该是一个大小为K的数组f[i][v][1..K]。其中f[i][v][k]表示前i个物品、背包大小为v时，第k优解的值。“f[i][v]是一个大小为K的数组”这一句，熟悉C语言的同学可能比较好理解，或者也可以简单地理解为在原来的方程中加了一维。显然f[i][v][1..K]这K个数是由大到小排列的，所以我们把它认为是一个有序队列。 然后原方程就可以解释为：f[i][v]这个有序队列是由f[i-1][v]和f[i-1][v-c[i]]+w[i]这两个有序队列合并得到的。有序队列f[i-1][v]即f[i-1][v][1..K]，f[i-1][v-c[i]]+w[i]则理解为在f[i-1][v-c[i]][1..K]的每个数上加上w[i]后得到的有序队列。合并这两个有序队列并将结果（的前K项）储存到f[i][v][1..K]中的复杂度是O(K)。最后的答案是f[N][V][K]。总的复杂度是O(NVK)。 为什么这个方法正确呢？实际上，一个正确的状态转移方程的求解过程遍历了所有可用的策略，也就覆盖了问题的所有方案。只不过由于是求最优解，所以其它在任何一个策略上达不到最优的方案都被忽略了。如果把每个状态表示成一个大小为K的数组，并在这个数组中有序的保存该状态可取到的前K个最优值。那么，对于任两个状态的max运算等价于两个由大到小的有序队列的合并。 另外还要注意题目对于“第K优解”的定义，将策略不同但权值相同的两个方案是看作同一个解还是不同的解。如果是前者，则维护有序队列时要保证队列里的数没有重复的。 小结 显 然，这里不可能穷尽背包类动态规划问题所有的问法。甚至还存在一类将背包类动态规划问题与其它领域（例如数论、图论）结合起来的问题，在这篇论背包问题的 专文中也不会论及。但只要深刻领会前述所有类别的背包问题的思路和状态转移方程，遇到其它的变形问法，只要题目难度还属于NOIP，应该也不难想出算法。触类旁通、举一反三，应该也是一个OIer应有的品质吧。 首页 P11: 背包问题的搜索解法 《背包问题九讲》的本意是将背包问题作为动态规划问题中的一类进行讲解。但鉴于的确有一些背包问题只能用搜索来解，所以这里也对用搜索解背包问题做简单介绍。大部分以01背包为例，其它的应该可以触类旁通。 简单的深搜 对于01背包问题，简单的深搜的复杂度是O(2N)。就是枚举出所有2N种将物品放入背包的方案，然后找最优解。基本框架如下： 12345678procedure SearchPack(i,cur_v,cur_w) if(i&gt;N) if(cur_w&gt;best) best=cur_w return if(cur_v+v[i]&lt;=V) SearchPack(i+1,cur_v+v[i],cur_w+w[i]) SearchPack(i+1,cur_v,cur_w) 其中cur_v和cur_w表示当前解的费用和权值。主程序中调用SearchPack(1,0,0)即可。 搜索的剪枝 基本的剪枝方法不外乎可行性剪枝或最优性剪枝。 可行性剪枝即判断按照当前的搜索路径搜下去能否找到一个可行解，例如：若将剩下所有物品都放入背包仍然无法将背包充满（设题目要求必须将背包充满），则剪枝。 最优性剪枝即判断按照当前的搜索路径搜下去能否找到一个最优解，例如：若加上剩下所有物品的权值也无法得到比当前得到的最优解更优的解，则剪枝。 搜索的顺序 在搜索中，可以认为顺序靠前的物品会被优先考虑。所以利用贪心的思想，将更有可能出现在结果中的物品的顺序提前，可以较快地得出贪心地较优解，更有利于最优性剪枝。所以，可以考虑将按照“性价比”（权值/费用）来排列搜索顺序。 另一方面，若将费用较大的物品排列在前面，可以较快地填满背包，有利于可行性剪枝。 最后一种可以考虑的方案是：在开始搜索前将输入文件中给定的物品的顺序随机打乱。这样可以避免命题人故意设置的陷阱。 以上三种决定搜索顺序的方法很难说哪种更好，事实上每种方法都有适用的题目和数据，也有可能将它们在某种程度上混合使用。 子集和问题 子集和问题是一个NP-Complete问题，与前述的（加权的）01背包问题并不相同。给定一个整数的集合S和一个整数X，问是否存在S的一个子集满足其中所有元素的和为X。 这个问题有一个时间复杂度为O(2(N/2))的较高效的搜索算法，其中N是集合S的大小。 第一步思想是二分。将集合S划分成两个子集S1和S2，它们的大小都是N/2。对于S1和S2，分别枚举出它们所有的2(N/2)个子集和，保存到某种支持查找的数据结构中，例如hash set。 然后就要将两部分结果合并，寻找是否有和为X的S的子集。事实上，对于S1的某个和为X1的子集，只需寻找S2是否有和为X-X1的子集。 假设采用的hash set是理想的，每次查找和插入都仅花费O(1)的时间。两步的时间复杂度显然都是O(2^(N/2))。 实践中，往往可以先将第一步得到的两组子集和分别排序，然后再用两个指针扫描的方法查找是否有满足要求的子集和。这样的实现，在可接受的时间内可以解决的最大规模约为N=42。 搜索还是DP? 在看到一道背包问题时，应该用搜索还是动态规划呢？ 首先，可以从数据范围中得到命题人意图的线索。如果一个背包问题可以用DP解，V一定不能很大，否则O(VN)的算法无法承受，而一般的搜索解法都 是仅与N有关，与V无关的。所以，V很大时（例如上百万），命题人的意图就应该是考察搜索。另一方面，N较大时（例如上百），命题人的意图就很有可能是考 察动态规划了。 另外，当想不出合适的动态规划算法时，就只能用搜索了。例如看到一个从未见过的背包中物品的限制条件，无法想出DP的方程，只好写搜索以谋求一定的分数了。 附：USACO中的背包问题 USACO是USA Computing Olympiad的简称，它组织了很多面向全球的计算机竞赛活动。 USACO Trainng是一个很适合初学者的题库，我认为它的特色是题目质量高，循序渐进，还配有不错的课文和题目分析。其中关于背包问题的那篇课文 (TEXT Knapsack Problems) 也值得一看。 另外，USACO Contest是USACO常年组织的面向全球的竞赛系列，在此也推荐NOIP选手参加。 我整理了USACO Training中涉及背包问题的题目，应该可以作为不错的习题。其中标加号的是我比较推荐的，标叹号的是我认为对NOIP选手比较有挑战性的。 题目列表 Inflate (+) （基本01背包） Stamps (+)(!) （对初学者有一定挑战性） Money Nuggets Subsets Rockers (+) （另一类有趣的“二维”背包问题） Milk4 (!) （很怪的背包问题问法，较难用纯DP求解） 题目简解 以下文字来自我所撰的《USACO心得》一文，该文的完整版本，包括我的程序，可在DD的USACO征程中找到。 Inflate 是加权01 背包问题，也就是说：每种物品只有一件，只可以选择放或者不放；而且每种物品有对应的权值，目标是使总权值最大或最小。它最朴素的状态转移方程是：f[k][i] = max{f[k-1][i] , f[k-1][i-v[k]]+w[k]}。f[k][i]表示前k 件物品花费代价i 可以得到的最大权值。v[k]和w[k]分别是第k 件物品的花费和权值。可以看到，f[k]的求解过程就是使用第k 件物品对f[k-1]进行更新的过程。那么事实上就不用使用二维数组，只需要定义f[i]，然后对于每件物品k，顺序地检查f[i]与f[i-v[k]]+w[k]的大小，如果后者更大，就对前者进行更新。这是背包问题中典型的优化方法。 题目stamps 中，每种物品的使用量没有直接限制，但使用物品的总量有限制。求第一个不能用这有限个物品组成的背包的大小。（可以这样等价地认为）设f[k][i] 表示前k 件物品组成大小为i 的背包， 最少需要物品的数量。则f[k][i]= min{f[k-1][i],f[k-1][i-j*s[k]]+j}，其中j 是选择使用第k 件物品的数目，这个方程运用时可以用和上面一样的方法处理成一维的。求解时先设置一个粗糙的循环上限，即最大的物品乘最多物品数。 Money 是多重背包问题。也就是每个物品可以使用无限多次。要求解的是构成一种背包的不同方案总数。基本上就是把一般的多重背包的方程中的min 改成sum 就行了。 Nuggets 的模型也是多重背包。要求求解所给的物品不能恰好放入的背包大小的最大值（可能不存在）。只需要根据“若i、j 互质，则关于x、y 的不定方程ix+yj=n 必有正整数解，其中n&gt;ij”这一定理得出一个循环的上限。Subsets 子集和问题相当于物品大小是前N 个自然数时求大小为N(N+1)/4 的 01 背包的方案数。 Rockers 可以利用求解背包问题的思想设计解法。我的状态转移方程如下： f[i][j][t]=max{f[i][j][t-1] , f[i-1][j][t] , f[i-1][j][t-time[i]]+1 , f[i-1][j-1][T]+(t&gt;=time[i])}。其中 f[i][j][t]表示前i 首歌用j 张完整的盘和一张录了t 分钟的盘可以放入的最多歌数，T 是一张光盘的最大容量，t&gt;=time[i]是一个bool 值转换成int 取值为0 或1。但我后来发现我当时设计的状态和方程效率有点低，如果换成这样：f[i][j]=(a,b)表示前i 首歌中选了j 首需要用到a 张完整的光盘以及一张录了b 分钟的光盘，会将时空复杂度都大大降低。这种将状态的值设为二维的方法值得注意。 Milk4 是这些类背包问题中难度最大的一道了。很多人无法做到将它用纯DP 方法求解，而是用迭代加深搜索枚举使用的桶，将其转换成多重背包问题再DP。由于 USACO 的数据弱，迭代加深的深度很小，这样也可以AC，但我们还是可以用纯DP 方法将它完美解决的。设f[k]为称量出k 单位牛奶需要的最少的桶数。那么可以用类似多重背包的方法对f 数组反复更新以求得最小值。然而困难在于如何输出字典序最小的方案。我们可以对每个i记录pre_f[i]和pre_v[i]。表示得到i 单位牛奶的过程是用pre_f[i]单位牛奶加上若干个编号为pre_v[i]的桶的牛奶。这样就可以一步步求得得到i 单位牛奶的完整方案。为了使方案的字典序最小，我们在每次找到一个耗费桶数相同的方案时对已储存的方案和新方案进行比较再决定是否更新方案。为了使这种比较快捷，在使用各种大小的桶对f 数组进行更新时先大后小地进行。USACO 的官方题解正是这一思路。如果认为以上文字比较难理解可以阅读官方程序或我的程序。 26 背包问题应用 Category: 数据结构与算法 View: 6,055 阅 Author: Dong 作者:Dong | 可以转载, 但必须以超链接形式标明文章原始出处和作者信息及版权声明 网址:http://dongxicheng.org/structure/knapsack-problems/ 背包问题介绍 背包问题不单单是一个简单的算法问题，它本质上代表了一大类问题，这类问题实际上是01线性规划问题，其约束条件和目标函数如下： 自从dd_engi在2007年推出《背包问题九讲》之后，背包问题的主要精髓基本已道尽。本文没有尝试对背包问题的本质进行扩展或深入挖掘，而只是从有限的理解（这里指对《背包问题九讲》的理解）出发，帮助读者更快地学习《背包问题九讲》中的提到的各种背包问题的主要算法思想，并通过实例解释了相应的算法，同时给出了几个背包问题的经典应用。 背包问题及应用 dd_engi在《背包问题九讲》中主要提到四种背包问题，分别为：01背包问题，完全背包问题，多重背包问题，二维费用背包问题。本节总结了这几种背包问题，并给出了其典型的应用以帮助读者理解这几种问题的本质。 2.1 01背包问题 （1）问题描述 有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。 （2）状态转移方程 其中，f(i,v) 表示从前i件物品选择若干物品装到容量为v的背包中产生的最大价值。当v=0时，f(i,v)初始化为0，表示题目不要求背包一定刚好装满，而f(i,v)=inf/-inf（正无穷或负无穷）表示题目要求背包一定要刚好装满。下面几种背包类似，以后不再赘述。 （3） 伪代码 从转移方程上可以看出，前i个物品的最优解只依赖于前i-1个物品最优解，而与前i-2，i-3,…各物品最优无直接关系，可以利用这个特点优化存储空间，即只申请一个一维数组即可，算法时间复杂度（O(VN)）为: 123for i=1..N for v=V..0 f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; 注意v的遍历顺序！！！ 下面几种背包用到类似优化，以后不再赘述。 （4） 举例 V=10，N=3，c[]={3,4,5}, w={4,5,6} （1）背包不一定装满 计算顺序是：从右往左，自上而下： （2）背包刚好装满 计算顺序是：从右往左，自上而下。注意初始值，其中-inf表示负无穷 （5） 经典题型 [1] 你有一堆石头质量分别为W1,W2,W3…WN.(W＜＝100000,N &lt;30)现在需要你将石头合并为两堆，使两堆质量的差为最小。 [2] 给一个整数的集合，要把它分成两个集合，要两个集合的数的和最接近 [3] 有一个箱子容量为V（正整数，0≤V≤20000），同时有n个物品（0小于n≤30），每个物品有一个体积（正整数）。要求从n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。 2.2 完全背包问题 （1）问题描述 有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 （2）状态转移方程 或者： （3） 伪代码 123for i=1..N for v=0..V f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; 注意v的遍历顺序！！！ 注意，时间复杂度仍为：O(VN). （4） 举例 V=10，N=3，c[]={3,4,5}, w={4,5,6} （1）背包不一定装满 计算顺序是：从左往右，自上而下： （2）背包刚好装满 计算顺序是：从左往右，自上而下。注意初始值，其中-inf表示负无穷 （5） 经典题型 [1] 找零钱问题：有n种面额的硬币，每种硬币无限多，至少用多少枚硬币表示给定的面值M？ 2.3 多重背包问题 （1）问题描述 有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 （2）状态转移方程 （3） 解题思想 用以下方法转化为普通01背包问题：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为 1,2,4,…,2(k-1),n[i]-2k+1，且k是满足n[i]-2^k+1&gt;0的最大整数。例如，如果n[i]为13，就将这种 物品分成系数分别为1,2,4,6的四件物品。这种方法能保证对于0..n[i]间的每一个整数，均可以用若干个系数的和表示。这个很容易证明，证明过程中用到以下定理：任何一个整数n均可以表示成：n=a020+a121+…+ak2k,其中ak=0或者1(实际上就是n的二进制分解)， 定理：一个正整数n可以被分解成1,2,4,…,2(k-1),n-2k+1（k是满足n-2k+1&gt;0的最大整数）的形式，且1～n之内的所有整数均可以唯一表示成1,2,4,…,2(k-1),n-2k+1中某几个数的和的形式。 该定理的证明如下： （1） 数列1,2,4,…,2(k-1),n-2k+1中所有元素的和为n，所以若干元素的和的范围为：[1, n]； （2）如果正整数t&lt;= 2^k – 1,则t一定能用1,2,4,…,2^(k-1)中某几个数的和表示，这个很容易证明：我们把t的二进制表示写出来，很明显，t可以表示成n=a020+a121+…+ak2（k-1），其中ak=0或者1，表示t的第ak位二进制数为0或者1. （3）如果t&gt;=2k,设s=n-2k+1，则t-s&lt;=2k-1，因而t-s可以表示成1,2,4,…,2(k-1)中某几个数的和的形式，进而t可以表示成1,2,4,…,2(k-1)，s中某几个数的和（加数中一定含有s）的形式。 （证毕！） 该算法的时间复杂度为：O(V*sum(logn[i])). （4） 经典题型 [1] 找零钱问题：有n种面额的硬币，分别为a[0], a[1],…, a[n-1]，每种硬币的个数为b[0], b[1],…, b[n-1]，至少用多少枚硬币表示给定的面值M？ 2.4 二维费用背包 （1） 问题描述 二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问 怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a[i]和b[i]。两种代价可付出的最大值（两种 背包容量）分别为V和U。物品的价值为w[i]。 （2） 状态转移方程 （3） 算法思想 采用同一维情况类似的方法求解 （4） 经典题型 有2n个整数，平均分成两组，每组n个数，使这两组数的和最接近。 3. 背包总结 背包问题实际上代表的是线性规划问题，一般要考虑以下几个因素已决定选取什么样的算法： （1） 约束条件，有一个还是两个或者更多个，如果是一个，可能是01背包，完全背包或者多重背包问题，如果有两个约束条件，则可能是二维背包问题。 （2） 优化目标，求最大值，还是最小值，还是总数(只需将max换成sum) （3） 每种物品的个数限制，如果每种物品只有一个，只是简单的01背包问题，如果个数无限制，则是完全背包问题，如果每种物品的个数有限制，则是多重背包问题。 （4） 背包是否要求刚好塞满，注意不塞满和塞满两种情况下初始值不同。 4. 参考资料 dd_engi：《背包问题九讲》 ———————————————————————————————- 更多关于数据结构和算法的介绍，请查看：数据结构与算法汇总 ———————————————————————————————]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博弈基础汇总]]></title>
    <url>%2F2017%2F05%2F28%2F%E5%8D%9A%E5%BC%88%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[有一种很有意思的游戏，就是有物体若干堆，可以是火柴棍或是围棋子等等均可。两个人轮流从堆中取物体若干，规定最后取光物体者取胜。这是我国民间很古老的一个游戏，别看这游戏极其简单，却蕴含着深刻的数学原理。下面我们来分析一下要如何才能够取胜。 （一）巴什博奕（Bash Game）： 只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。 显然，如果n=m+1，那么由于一次最多只能取m个，所以，无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，后者取胜。因此我们发现了如何取胜的法则：如果n=（m+1）r+s，（r为任意自然数，s≤m),那么先取者要拿走s个物品，如果后取者拿走k（≤m)个，那么先取者再拿走m+1-k个，结果剩下（m+1）（r-1）个，以后保持这样的取法，那么先取者肯定获胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。这个游戏还可以有一种变相的玩法：两个人轮流报数，每次至少报一个，最多报十个，谁能报到100者胜。 （二）威佐夫博奕（Wythoff Game）： 有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 这种情况下是颇为复杂的。我们用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。 可以看出,a0=b0=0,ak是未在前面出现过的最小自然数,而 bk= ak + k，奇异局势有如下三条性质： 1。任何自然数都包含在一个且仅有一个奇异局势中。 由于ak是未在前面出现过的最小自然数，所以有ak &gt; ak-1 ，而 bk= ak + k &gt; ak -1 + k-1 = bk-1 &gt; ak-1 。所以性质1。成立。 &gt; 2。任意操作都可将奇异局势变为非奇异局势。 &gt; 事实上，若只改变奇异局势（ak，bk）的某一个分量，那么另一个分量不可能在其他奇异局势中，所以必然是非奇异局势。如果使（ak，bk）的两个分量同时减少，则由于其差不变，且不可能是其他奇异局势的差，因此也是非奇异局势。 &gt; 3。采用适当的方法，可以将非奇异局势变为奇异局势。 &gt; 假设面对的局势是（a,b），若 b = a，则同时从两堆中取走 a 个物体，就变为了奇异局势（0，0）；如果a = ak ，b &gt; bk，那么，取走b – bk个物体，即变为奇异局势；如果 a = ak ， b &lt; bk ,则同时从两堆中拿走 ak – ab + ak个物体,变为奇异局势（ ab – ak , ab – ak+ b – ak）；如果a &gt; ak ，b= ak + k,则从第一堆中拿走多余的数量a – ak 即可；如果a &lt; ak ，b= ak + k,分两种情况，第一种，a=aj （j &lt; k）,从第二堆里面拿走 b – bj 即可；第二种，a=bj （j &lt; k）,从第二堆里面拿走 b – aj 即可。 &gt; 从如上性质可知，两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜；反之，则后拿者取胜。 &gt; 那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式： &gt; ak =[k（1+√5）/2]，bk= ak + k （k=0，1，2，…,n 方括号表示取整函数) 奇妙的是其中出现了黄金分割数（1+√5）/2 = 1。618…,因此,由ak，bk组成的矩形近似为黄金矩形，由于2/（1+√5）=（√5-1）/2，可以先求出j=[a（√5-1）/2]，若a=[j（1+√5）/2]，那么a = aj，bj = aj + j，若不等于，那么a = aj+1，bj+1 = aj+1+ j + 1，若都不是，那么就不是奇异局势。然后再按照上述法则进行，一定会遇到奇异局势。 （三）尼姆博奕（Nimm Game）： 有三堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 这种情况最有意思，它与二进制有密切关系，我们用（a，b，c）表示某种局势，首先（0，0，0）显然是奇异局势，无论谁面对奇异局势，都必然失败。第二种奇异局势是（0，n，n），只要与对手拿走一样多的物品，最后都将导致（0，0，0）。仔细分析一下，（1，2，3）也是奇异局势，无论对手如何拿，接下来都可以变为（0，n，n）的情形。 计算机算法里面有一种叫做按位模2加，也叫做异或的运算，我们用符号（+）表示这种运算。这种运算和一般加法不同的一点是1+1=0。先看（1，2，3）的按位模2加的结果： 1 =二进制01 2 =二进制10 3 =二进制11 （+） ——————— 0 =二进制00 （注意不进位） 对于奇异局势（0，n，n）也一样，结果也是0。 任何奇异局势（a，b，c）都有a（+）b（+）c =0。 如果我们面对的是一个非奇异局势（a，b，c），要如何变为奇异局势呢？假设 a &lt; b&lt; c,我们只要将 c 变为 a（+）b,即可,因为有如下的运算结果: a（+）b（+）(a（+）b)=(a（+）a)（+）(b（+）b)=0（+）0=0。要将c 变为a（+）b，只要从 c中减去 c-（ a（+）b）即可。 例1。（14，21，39），14（+）21=27，39-27=12，所以从39中拿走12个物体即可达到奇异局势（14，21，27）。 例2。（55，81，121），55（+）81=102，121-102=19，所以从121中拿走19个物品就形成了奇异局势（55，81，102）。 例3。（29，45，58），29（+）45=48，58-48=10，从58中拿走10个，变为（29，45，48）。 例4。我们来实际进行一盘比赛看看： 甲:(7,8,9)-&gt;(1,8,9)奇异局势 乙:(1,8,9)-&gt;(1,8,4) 甲:(1,8,4)-&gt;(1,5,4)奇异局势 乙:(1,5,4)-&gt;(1,4,4) 甲:(1,4,4)-&gt;(0,4,4)奇异局势 乙:(0,4,4)-&gt;(0,4,2) 甲:(0.4,2)-&gt;(0,2,2)奇异局势 乙:(0,2,2)-&gt;(0,2,1) 甲:(0,2,1)-&gt;(0,1,1)奇异局势 乙:(0,1,1)-&gt;(0,1,0) 甲:(0,1,0)-&gt;(0,0,0)奇异局势 甲胜。 取火柴的游戏 题目1： 今有若干堆火柴，两人依次从中拿取，规定每次只能从一堆中取若干根， 可将一堆全取走，但不可不取，最后取完者为胜，求必胜的方法。 题目2： 今有若干堆火柴，两人依次从中拿取，规定每次只能从一堆中取若干根， 可将一堆全取走，但不可不取，最后取完者为负，求必胜的方法。 嘿嘿，这个游戏我早就见识过了。小时候用珠算玩这个游戏：第一档拨一个，第二档拨两个，依次直到第五档拨五个。然后两个人就轮流再把棋子拨下来，谁要是最后一个拨谁就赢。有一次暑假看见两个小孩子在玩这个游戏，我就在想有没有一个定论呢。下面就来试着证明一下吧 先解决第一个问题吧。 定义：若所有火柴数异或为0，则该状态被称为利他态，用字母T表示；否则， 为利己态，用S表示。 [定理1]：对于任何一个S态，总能从一堆火柴中取出若干个使之成为T态。 证明： 若有n堆火柴，每堆火柴有A(i)根火柴数，那么既然现在处于S态， c = A(1) xor A(2) xor … xor A(n) &gt; 0; 把c表示成二进制，记它的二进制数的最高位为第p位，则必然存在一个A(t),它二进制的第p位也是1。（否则，若所有的A(i)的第p位都是0，这与c的第p位就也为0矛盾）。 那么我们把x = A(t) xor c,则得到x &lt; A(t).这是因为既然A(t)的第p位与c的第p位同为1,那么x的第p位变为0,而高于p的位并没有改变。所以x &lt; A(t).而 A(1) xor A(2) xor … xor x xor … xor A(n) = A(1) xor A(2) xor … xor A(t) xor c xor … xor A(n) = A(1) xor A(2) xor… xor A(n) xor A(1) xor A(2) xor … xor A(n) = 0 这就是说从A(t)堆中取出 A(t) – x 根火柴后状态就会从S态变为T态。证毕 [定理2]：T态，取任何一堆的若干根，都将成为S态。 证明：用反证法试试。 若 c = A(1) xor A(2) xor … xor A(i) xor … xor A(n) = 0； c’ = A(1) xor A(2) xor … xor A(i’) xor c xor … xor A(n) = 0; 则有 c xor c’ = A(1) xor A(2) xor … xor A(i) xor … xor A(n) xor A(1) xor A(2) xor … xor A(i’) xor c xor … xor A(n) = A(i) xor A(i’) =0 进而推出A(i) = A(i’)，这与已知矛盾。所以命题得证。 [定理 3]：S态，只要方法正确，必赢。 最终胜利即由S态转变为T态，任何一个S态，只要把它变为T态，（由定理1，可以把它变成T态。）对方只能把T态转变为S态(定理2)。这样，所有S态向T态的转变都可以有己方控制，对方只能被动地实现由T态转变为S态。故S态必赢。 [定理4]：T态，只要对方法正确，必败。 由定理3易得。 接着来解决第二个问题。 定义：若一堆中仅有1根火柴，则被称为孤单堆。若大于1根，则称为充裕堆。 定义：T态中，若充裕堆的堆数大于等于2，则称为完全利他态，用T2表示；若充裕堆的堆数等于0，则称为部分利他态，用T0表示。 孤单堆的根数异或只会影响二进制的最后一位，但充裕堆会影响高位（非最后一位）。一个充裕堆，高位必有一位不为0，则所有根数异或不为0。故不会是T态。 [定理5]：S0态，即仅有奇数个孤单堆，必败。T0态必胜。 证明： S0态，其实就是每次只能取一根。每次第奇数根都由己取，第偶数根都由对 方取，所以最后一根必己取。败。同理, T0态必胜# [定理6]：S1态，只要方法正确，必胜。 证明： 若此时孤单堆堆数为奇数，把充裕堆取完；否则，取成一根。这样，就变成奇数个孤单堆，由对方取。由定理5，对方必输。己必胜。 # [定理7]：S2态不可转一次变为T0态。 证明： 充裕堆数不可能一次由2变为0。得证。 # [定理8]：S2态可一次转变为T2态。 证明： 由定理1，S态可转变为T态，态可一次转变为T态，又由定理6，S2态不可转一次变为T0态，所以转变的T态为T2态。 # [定理9]：T2态，只能转变为S2态或S1态。 证明： 由定理2，T态必然变为S态。由于充裕堆数不可能一次由2变为0，所以此时的S态不可能为S0态。命题得证。 [定理10]：S2态，只要方法正确，必胜. 证明： 方法如下： 1） S2态，就把它变为T2态。（由定理8） 2） 对方只能T2转变成S2态或S1态（定理9） 若转变为S2, 转向1） 若转变为S1, 这己必胜。（定理5） [定理11]：T2态必输。 证明：同10。 综上所述，必输态有： T2,S0 必胜态： S2,S1,T0. 两题比较： 第一题的全过程其实如下： S2-&gt;T2-&gt;S2-&gt;T2-&gt; …… -&gt;T2-&gt;S1-&gt;T0-&gt;S0-&gt;T0-&gt;……-&gt;S0-&gt;T0(全0) 第二题的全过程其实如下： S2-&gt;T2-&gt;S2-&gt;T2-&gt; …… -&gt;T2-&gt;S1-&gt;S0-&gt;T0-&gt;S0-&gt;……-&gt;S0-&gt;T0(全0) 下划线表示胜利一方的取法。 是否发现了他们的惊人相似之处。 我们不难发现(见加黑部分)，S1态可以转变为S0态（第二题做法），也可以转变为 T0（第一题做法）。哪一方控制了S1态，他即可以有办法使自己得到最后一根（转变为 T0）,也可以使对方得到最后一根（转变为S0）。 所以，抢夺S1是制胜的关键！ 为此，始终把T2态让给对方，将使对方处于被动状态，他早晚将把状态变为S1. 推荐HDOJ题目 http://acm.hdu.edu.cn/showproblem.php?pid=1907 http://acm.hdu.edu.cn/showproblem.php?pid=2509 看完上面的结论，就能顺利解决上面2道了 S-Nim http://acm.hdu.edu.cn/showproblem.php?pid=1536 http://acm.hdu.edu.cn/showproblem.php?pid=1944 博弈算法入门小节 1536 1517 1907 小子最近迷途于博弈之中。。。感触颇深。 为了让大家能够在学习博弈的时候少走弯路，最重要的也是为了加深自己的影响，温故而知新，特发此贴与大家共勉。 学博弈先从概念开始： 特别推荐LCY老师的课件：博弈入门。 下载地址：http://acm.hdu.edu.cn/forum/read.php?tid=6875 这个课件个人认为从博弈的基本思想，一直到解博弈的中心算法做了很好的诠释。但是特别要注意的是。课件后面一部分英语写的讲义是重中之重。小子英语很弱，在这困扰很久。现在为大家大概介绍一下。 主要是后继点和SG值的问题: SG值：一个点的SG值就是一个不等于它的后继点的SG的且大于等于零的最小整数。 后继点：也就是按照题目要求的走法（比如取石子可以取的数量，方法）能够走一步达到的那个点。 具体的有关SG值是怎么运用的希望大家自己多想想。 课件后面有一个1536的代码。可以放在后面做做 看到这里推荐大家做几道题：1846（最简单的博弈水题） 1847（求SG值） 有了上面的知识接下来我们来看看组合博弈（n堆石子） 推荐大家看个资料： 博弈-取石子游戏(推荐等级五星级) 这里提出了一个奇异状态的问题。看了这篇文章你会发现异或运算在博弈中使用的妙处。当然这里指出的只是组合博弈中一种特殊情况。 王道还是对SG值的求解，但是知道这么一种思路无疑对思维的广度和深度扩展是很有帮助的。 ZZ博弈 这里介绍了组和博弈的两种大的类型，一种是最后取的是N状态一种是最后取的是P状态，两个状态的解题方法能看懂很有帮助。当然，能够把推导过程理解，吃透无疑是大牛级的做法小子也佩服的紧 1536题推荐做做这题，这题前面提醒大家是一个求SG值的题目，题目前面是对异或运算运用在组合博弈问题中的很好的解释。当然题目本身是有所不同的。因为在这里面对取法有所要求。那么这样就回归到了解决博弈问题的王道算法——求SG值上。 有关运用求SG值的博弈题目有： 1850（也可基于奇异状态异或） 1848（中和的大斐波那契数列的典型求SG值题） 1517（个人认为有点猥琐的题目。。。。在此题上困扰很久。当然搞出来很开心。小子是用比较规矩的求SG值的方法求出来的，但是论坛有人对其推出来了规律，这里佩服一下，大家可以学习一下） 1079（更猥琐的题目，对新手要求较高，因为按传统方法需要比较细致的模拟加对边角状态的考虑，同样有人推出来了公式） 当你全部看完以上的东西。做完以上的题目的话。。。小子恭喜你你博弈入门了~ 这里小子告诉大家。博弈很强大。学习要耐心~谢谢 Current System Time : 2008-12-11 19:16:03 ACM课作业： 1001 Brave Game 1002 Good Luck in CET-4 Everybody! 1003 Fibonacci again and again 1004 Rabbit and Grass 1005 Being a Good Boy in Spring Festival 1006 Public Sale 1007 悼念512汶川大地震遇难同胞——选拔志愿者 1008 kiki’s game 1009 Calendar Game 1010 A Multiplication Game 1011 Digital Deletions 1012 S-Nim 1536的参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//博弈-基于求SG值//Accepted 1536 578MS 416K 904 B#include”iostream”using namespace std;int f[101],sg[10001],k;int mex(int b)&#123; int a[101]=&#123;0&#125;,i; for(i=0;i&lt;k;i++) &#123; if(b-f&lt;0)//b-f后继点 break; if(sg[b-f]==-1) &#123; sg[b-f]=mex(b-f); &#125; a[sg[b-f]]=1; &#125; for(i=0;i&lt;k;i++) if(!a) &#123; return i; &#125;&#125;int main()&#123; int i,t,n,s,bead,j; while(cin &gt;&gt; k,k) &#123; for(i=0;i&lt;k;i++) &#123; cin &gt;&gt; f; &#125; memset(sg,-1,sizeof(sg)); for(i=0;i&lt;k;i++) for(j=i+1;j&lt;k;j++) if(f&gt;f[j]) &#123; f+=f[j]; f[j]=f-f[j]; f-=f[j]; &#125; sg[0]=0; cin &gt;&gt; t; while(t–) &#123; cin &gt;&gt; n; s=0; while(n–) &#123; cin &gt;&gt; bead;//该堆的成员个数 if(sg[bead]==-1) sg[bead]=mex(bead); s=s^sg[bead]; &#125; if(s==0) cout &lt;&lt; “L”; else cout &lt;&lt; “W”; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 1517参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//博弈-基于求SG值//Accepted 1517 234MS 0K 837 B#include”iostream”using namespace std;int main()&#123; __int64 a[7000]=&#123;1&#125;,min,n; int p[10],sg[7000],i,j,k; for(i=2;i&lt;10;p=0,i++); for(i=1;i&lt;7000;i++) &#123; for(j=2,min=-1;j&lt;10;j++) if(min==-1||a[p[j]]*j&lt;a[p[min]]*min) min=j; a=a[p[min]]*min; min=a[p[min]]*min; if(a&gt;=5000000000) break; for(j=2;j&lt;10;j++) if(a[p[j]]*j==min) p[j]++; &#125;//从小到大求出所有乘积 while(scanf(“%I64d”,&amp;n)!=EOF) &#123; for(i=0;i&lt;7000;i++) &#123; sg=0; if(a&gt;=n) break; &#125; for(j=i-1;a[j]*9&gt;=n&amp;&amp;j&gt;=0;j–) sg[j]=1; while(j&gt;=0) &#123; for(k=j+1;k&lt;i&amp;&amp;a[j]*9&gt;=a[k];k++) if(a[k]%a[j]==0&amp;&amp;sg[k]==0) &#123; sg[j]=1; break; &#125; j–; &#125; puts(sg[0]?”Stan wins.”:”Ollie wins.”); &#125; return 0;&#125; 这里感谢shǎ崽同学的一段代码让小子学会了puts的妙用 1907参考代码 12345678910111213141516171819202122#include”iostream”using namespace std;int main()&#123; int temp,t,n,s,x,i; cin &gt;&gt; t; while(t–) &#123; cin &gt;&gt; n; for(i=s=temp=0;i&lt;n;i++) &#123; cin &gt;&gt; x; if(x&gt;1) temp=1; s^=x; &#125; if((s&amp;&amp;temp)||(!s&amp;&amp;!temp)) cout &lt;&lt; “John” &lt;&lt; endl; else cout &lt;&lt; “Brother” &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Linux（或者Mac OS X）的对拍程序]]></title>
    <url>%2F2017%2F05%2F28%2F%E5%9F%BA%E4%BA%8ELinux%EF%BC%88%E6%88%96%E8%80%85Mac%20OS%20X%EF%BC%89%E7%9A%84%E5%AF%B9%E6%8B%8D%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[比赛时调程序的奇淫巧技之一：对拍。 程序bug调试不出来，但是能写一个暴力的保证正确的算法，并且直接提交暴力的程序会超时，于是这时候就可以用“对拍”来调试了。 由于ACM ICPC用的系统都是Ubuntu所以给出一个基于Linux的对拍程序（Mac OS X同样适用） data_maker ：你写的能够随机生成数据的程序，注意生成数据的条件（有些题目对数据的要求比较高，这时候很难生成可以用的数据，所以对拍也是有局限性的） MyProg：你写的高效程序 StdProg：暴力的保证答案正确的程序 12345678910111213while true; do ./data_maker &gt; tmp.in #出数据 ./MyProg &lt; tmp.in &gt; my.out #被测程序 ./StdProg &lt; tmp.in &gt; std.out #正确（暴力）程序 if diff my.out std.out; then #比较两个输出文件 printf "AC\n" #结果相同显示AC elif diff -B -b my.out std.out; then printf "PE\n" else printf "WA\n" #结果不同显示WA，并退出 exit 0 fi done 上面这个程序需要保存成.sh的格式，例如：对拍.sh直接在终端里面运行 运行方法： 打开终端 执行 方法一： 输入命令 ./aa.sh 方法二：直接把 aa.sh 拖入到终端里面。 注意事项： 如果 没有成功报出问题：: Permission denied。 就是没有权限。 解决办法：修改该文件对拍.sh 的权限 ：使用命令： chmod 777 对拍.sh 。 然后再执行 上面第一步或者第二步的操作就 OK 了. 附赠一个windows的对拍程序（转载于他人，侵删）：对拍.bat 对拍程序的写法 如下 1234567891011@echo off :loop datamaker #数据生成器 rand.exe &gt; data.in 这里的大于符号，小于符号为重定向符号 std #标准程序 std.exe &lt; data.in &gt; std.out myprogram #my.exe &lt; data.in &gt; my.out 我的程序 fc ans.out std.out //比较两个程序的输出是否一致，一致则返回0 if not errorlevel 1 goto loop pause goto loop #最后上边的 内容 保存为.bat文件 #rand.exe std.exe my.exe 以及windows下的这个 .bat文件 放在同一个目录下*************************************************************************************************** 这里数据生成器： 就是你自己编写一个应用程序 rand.exe，这个应用程序就是随机的生成一组符合题意的输入数据并存放到上边提到的 输入数据文件中data.in高效程序：就是上边提到的 高效算法 写的程序，即 my.exe 暴力程序 ：就是指能够保证所有输入数据都能输出正确结果的 程序，即这里的std.exe上边的. bat文件 的功能就是循环 判断高效程序和 暴力程序 在同样的输入数据情况下，输出数据是否相同，从而实现了对拍程序的功能]]></content>
      <categories>
        <category>奇淫巧技</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Mac OSX</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[kuangbin带你飞]刷题顺序]]></title>
    <url>%2F2017%2F05%2F27%2Fkuangbin%E5%B8%A6%E4%BD%A0%E9%A3%9E-%E5%88%B7%E9%A2%98%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[一些基本算法和数据结构(队列 栈 树 图 并查集 堆 DFS BFS 最短路 最小生成树 拓扑排序 动态规划 贪心 搜索 KMP 哈希 Trie AC自动机 快速幂 逆元 费马小定理 欧拉函数 素数筛 分解质因数)你可以找两个小伙伴一起分工合作，各自认领专题 【参考书籍：刘汝佳《算法竞赛入门经典第二版》or《算法竞赛训练手册》，《算法导论》】 这时候可以刷的题就多了，你可以选择一些专题进行突破，学习一下技巧 例如 [kuangbin带你飞]专题一 简单搜索 [kuangbin带你飞]专题四 最短路练习 [kuangbin带你飞]专题五 并查集 [kuangbin带你飞]专题六 最小生成树 [kuangbin带你飞]专题十二 基础DP [kuangbin带你飞]专题十四 数论基础 [kuangbin带你飞]专题十六 KMP &amp; 扩展KMP &amp; Manacher [kuangbin带你飞]专题十七 AC自动机 如果这些你和你的小伙伴都能熟悉掌握，并且能够尽快写出来，那么没有意外的话就可以在网络赛中拿到现场赛的门票（当然还得看出题人的风格...） 一些进阶的算法以及复杂一些的数据结构（树状数组 线段树 平衡树 后缀数组 二分图匹配 网络流 费用流 割点 桥 强联通 双联通 最近公共祖先 四大DP(数位dp 区间dp 状压dp 概率dp) 博弈论SG函数 ） 【参考资料：各种博客......】 [kuangbin带你飞]专题七 线段树 [kuangbin带你飞]专题九 连通图 [kuangbin带你飞]专题十 匹配问题 [kuangbin带你飞]专题十一 网络流 [kuangbin带你飞]专题十五 数位DP [kuangbin带你飞]专题十八 后缀数组 [kuangbin带你飞]专题二十一 概率&amp;期望 [kuangbin带你飞]专题二十二 区间DP 这些掌握之后在现场赛中拿到牌子应该就没什么问题了，发挥出色还能拿到银牌。。。不过如果遇到比较凶残的赛区...2.5 这时候如果开始组队了，就可以去刷一些套题了，例如Contests - Virtual Judge 这里每一场比赛都是过去真实发生的录像，你可以clone之后和自己的队友一起实操一下。 更高深的技巧，更复杂的数据结构（树链剖分，动态树，可持久化线段树，DLX，后缀自动机，回文树，斜率优化/单调队列优化/四边形优化DP，插头dp，莫比乌斯反演......） 这部分最能体现人与人的差异了...智商碾压一般就在这部分。而要想拿到金牌，一般来说这些知识都要尽可能掌握。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>kuangbin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
