<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Reinforcement-Learning-2-ÊúâÈôêÈ©¨Â∞îÁßëÂ§´ÂÜ≥Á≠ñËøáÁ®ã]]></title>
    <url>%2F2018%2F07%2F18%2FReinforcement-Learning-2-%E6%9C%89%E9%99%90%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[‰∏ä‰∏ÄÁØáÂçöÂÆ¢Á®çÂæÆ‰ªãÁªç‰∫Ü‰∏Ä‰∫õÂº∫ÂåñÂ≠¶ÁöÑÂü∫Êú¨Ê¶ÇÂøµÔºåËøôÊ¨°Âú®ËÆ≤ÊúâÈôêÈ©¨Â∞îÁßëÂ§´ÂÜ≥Á≠ñËøáÁ®ãÔºàFinite Markov Decision ProcessesÔºâ‰πãÂâçÔºåÂÖàÂØπÂº∫ÂåñÂ≠¶‰π†ÁöÑÊ®°ÂûãÊù•‰∏Ä‰∏™Êõ¥ËØ¶ÁªÜÁöÑ‰ªãÁªç„ÄÇ Âü∫Êú¨Ê¶ÇÂøµ 1. ËßÑÂàôÔºàpolicyÔºâ Policy ÂÆö‰πâ‰∫Ü agents Âú®ÁâπÂÆöÁöÑÊó∂Èó¥ÁâπÂÆöÁöÑÁéØÂ¢É‰∏ãÁöÑË°å‰∏∫ÊñπÂºèÔºåÂèØ‰ª•ËßÜ‰∏∫ÊòØ‰ªéÁéØÂ¢ÉÁä∂ÊÄÅÂà∞Ë°å‰∏∫ÁöÑÊò†Â∞ÑÔºåÂ∏∏Áî® œÄÊù•Ë°®Á§∫„ÄÇpolicy ÂèØ‰ª•ÂàÜ‰∏∫‰∏§Á±ªÔºö Á°ÆÂÆöÊÄßÁöÑ policyÔºàDeterministic policyÔºâ: \(a=\pi(s)\) ÈöèÊú∫ÊÄßÁöÑ policyÔºàStochastic policyÔºâ: \(\pi(a|s)=P[A_t=a|S_t=s]\) ÂÖ∂‰∏≠ÔºåtÊòØÊó∂Èó¥ÁÇπÔºåt=0,1,2,3,‚Ä¶‚Ä¶ \(S_t \in S\)ÔºåSÊòØÁéØÂ¢ÉÁä∂ÊÄÅÁöÑÈõÜÂêàÔºå\(S_t\)‰ª£Ë°®Êó∂Âàª \(t\) ÁöÑÁä∂ÊÄÅÔºås‰ª£Ë°®ÂÖ∂‰∏≠Êüê‰∏™ÁâπÂÆöÁöÑÁä∂ÊÄÅ \(A_t \in A(S_t)\)Ôºå\(A_(S_t)\) ÊòØÂú®Áä∂ÊÄÅ\(S_t\)‰∏ãÁöÑ actions ÁöÑÈõÜÂêàÔºå\(A_t\)‰ª£Ë°®Êó∂Âàª t ÁöÑË°å‰∏∫Ôºåa‰ª£Ë°®ÂÖ∂‰∏≠Êüê‰∏™ÁâπÂÆöÁöÑË°å‰∏∫„ÄÇ 2. Â•ñÂä±‰ø°Âè∑Ôºàa reward signalÔºâ Reward Â∞±ÊòØ‰∏Ä‰∏™Ê†áÈáèÂÄºÔºåÊòØÊØè‰∏™ time step ‰∏≠ÁéØÂ¢ÉÊ†πÊçÆ agent ÁöÑË°å‰∏∫ËøîÂõûÁªô agent ÁöÑ‰ø°Âè∑Ôºåreward ÂÆö‰πâ‰∫ÜÂú®ËØ•ÊÉÖÊôØ‰∏ãÊâßË°åËØ•Ë°å‰∏∫ÁöÑÂ•ΩÂùèÔºåagent ÂèØ‰ª•Ê†πÊçÆ reward Êù•Ë∞ÉÊï¥Ëá™Â∑±ÁöÑ policy„ÄÇÂ∏∏Áî® R Êù•Ë°®Á§∫„ÄÇ 3. ÂÄºÂáΩÊï∞Ôºàvalue functionÔºâ Reward ÂÆö‰πâÁöÑÊòØÁ´ãÂç≥ÁöÑÊî∂ÁõäÔºåËÄå value function ÂÆö‰πâÁöÑÊòØÈïøÊúüÁöÑÊî∂ÁõäÔºåÂÆÉÂèØ‰ª•Áúã‰ΩúÊòØÁ¥ØËÆ°ÁöÑ rewardÔºåÂ∏∏Áî® v Êù•Ë°®Á§∫„ÄÇ ÈÄöÂ∏∏Êàë‰ª¨Êúâ‰∏âÁßçÊñπÊ≥ïÂéªË°®Á§∫value functionÔºå\(V^\pi(s)\)ÔºöË°®Á§∫Âú®\(\pi\) policy‰∏ãÔºå‰ªésÁä∂ÊÄÅÂºÄÂßãÂà∞ÁªìÊùüËÉΩËé∑ÂæóÁöÑrewardsÁöÑÊúüÊúõ \(V^\pi(s) = E_\pi[\sum_{t=0}^{T}r_t|s_0=s]\) \(V^\pi(s) = lim_{T \rightarrow \infty}E_\pi[\frac{1}{T}\sum_{t=0}^{T}r_t|s_0=s]\) \(V^\pi(s) = E_\pi[\sum_{t=0}^{\infty}\gamma ^tr_t|s_0=s]\) ÂàÜÂà´‰∏∫ ÈááÁî®Á≠ñÁï•\(\pi\)ÁöÑÊÉÖÂÜµ‰∏ãÊú™Êù•ÊúâÈôêhÊ≠•ÁöÑÊúüÊúõÁ´ãÂç≥ÂõûÊä•ÊÄªÂíåÔºõ ÈááÁî®Á≠ñÁï•\(\pi\)ÁöÑÊÉÖÂÜµ‰∏ãÊúüÊúõÁöÑÂπ≥ÂùáÂõûÊä•Ôºõ ÂÄºÂáΩÊï∞ÊúÄÂ∏∏ËßÅÁöÑÂΩ¢ÂºèÔºåÂºè‰∏≠Œ≥‚àà[0,1]Áß∞‰∏∫ÊäòÂêàÂõ†Â≠êÔºåË°®Êòé‰∫ÜÊú™Êù•ÁöÑÂõûÊä•Áõ∏ÂØπ‰∫éÂΩìÂâçÂõûÊä•ÁöÑÈáçË¶ÅÁ®ãÂ∫¶„ÄÇÁâπÂà´ÁöÑÔºåŒ≥=0Êó∂ÔºåÁõ∏ÂΩì‰∫éÂè™ËÄÉËôëÁ´ãÂç≥‰∏çËÄÉËôëÈïøÊúüÂõûÊä•ÔºåŒ≥=1Êó∂ÔºåÂ∞ÜÈïøÊúüÂõûÊä•ÂíåÁ´ãÂç≥ÂõûÊä•ÁúãÂæóÂêåÁ≠âÈáçË¶Å„ÄÇ Êàë‰ª¨ÊúÄÂ∏∏Áî®ÁöÑÊòØÁ¨¨‰∏âÁßçÂΩ¢ÂºèÔºåÊé•‰∏ãÊù•ÁöÑËÆ®ËÆ∫‰πüÂ∞ÜÂõ¥ÁªïÁ¨¨‰∏âÁßçÂΩ¢ÂºèËøõË°å 4. ÁéØÂ¢ÉÊ®°ÂûãÔºàa model of the environmentÔºâ Êï¥‰∏™AgentÂíåEnvironment‰∫§‰∫íÁöÑËøáÁ®ãÂèØ‰ª•Áî®‰∏ãÂõæÊù•Ë°®Á§∫Ôºö Âú®ÊØè‰∏™Êó∂Èó¥Ê≠•È™§‰∏≠Ôºåagent ÈÉΩ‰ºöÂÆûÁé∞‰∏Ä‰∏™‰ªé states Âà∞ÊØè‰∏™ÂèØËÉΩÁöÑ actions ÁöÑ probabilities ÁöÑÊò†Â∞Ñ(ËøôÈáåËÆ≤ÁöÑÊòØÈöèÊú∫ÊÄßploicyÊ®°ÂûãÔºåÁ°ÆÂÆöÊÄßÁöÑÁõ¥Êé•ËæìÂá∫a)ÔºåËøô‰∏™Êò†Â∞ÑÂáΩÊï∞Â∞±Áß∞‰ΩúÊòØËøô‰∏™ agent ÁöÑ policyÔºåÂ∏∏Áî®Á¨¶Âè∑\(\pi_t\)Êù•Ë°®Á§∫Ôºå\(\pi_t(a|s)\)ÊåáÁöÑÂ∞±ÊòØÂú®Áä∂ÊÄÅ\(S_t=s\)‰∏ãÈÄâÊã©ÊâßË°å\(A_t=a\)ÁöÑÊ¶ÇÁéá„ÄÇ ÂÖ∂ÂÆûÊ¶ÇÊã¨ÁöÑÊù•ËØ¥Ôºå‰∏çÂêåÁöÑ RL ÊñπÊ≥ïÁöÑ‰∏ªË¶Å‰∏çÂêåÂ∞±ÊòØÂà©Áî® experience Êù•ÊîπÂèòËá™Â∑±ÁöÑ œÄt ÁöÑÊñπÊ≥ïÔºåÊØïÁ´üRLÂ∞±ÊòØ‰ªé experience ‰∏≠ËøõË°åÂ≠¶‰π†ÁöÑ‰∏ÄÁ≥ªÂàóÊñπÊ≥ï„ÄÇ 5. goals&amp;rewards Âú®RL‰∏≠ÔºågoalsÂíårewardsÊòØ‰∏§‰∏™ÈáçË¶ÅÁöÑÊ¶ÇÂøµÔºåÂú®ÊØè‰∏™Êó∂Èó¥Ê≠•È™§‰∏≠ÔºåÁéØÂ¢ÉËøîÂõûÁªô Agent ÁöÑ reward Â∞±ÊòØ‰∏Ä‰∏™ÁÆÄÂçïÁöÑÊï∞ÂÄºÔºåËÄå Agent ÁöÑ goal Â∞±ÊòØÊúÄÂ§ßÂåñÂÆÉÊé•ÂèóÂà∞ÁöÑÊâÄÊúâÁöÑ reward ÁöÑÂíåÔºå‰πüÂ∞±ÊòØËØ¥ÔºåÂÆÉÁöÑÁõÆÁöÑ‰∏çÊòØÊúÄÂ§ßÂåñÂΩìÂâçÊ≠•È™§ÁöÑÁ´ãÂç≥Ëé∑ÂæóÁöÑ reward ÔºåËÄåÊòØ‰∏Ä‰∏™ÈïøËøúÁöÑÁõÆÊ†á( \(V^\pi(s)\) )ÔºåÂπ∂‰∏îÈúÄË¶ÅÊ≥®ÊÑèÁöÑÊòØÔºåËøô‰∏™ reward ÊòØÁî± environment ÂÆö‰πâÁöÑËÄåÈùû Agent„ÄÇ]]></content>
      <categories>
        <category>Êú∫Âô®Â≠¶‰π†</category>
      </categories>
      <tags>
        <tag>Êú∫Âô®Â≠¶‰π†</tag>
        <tag>Âº∫ÂåñÂ≠¶‰π†</tag>
        <tag>MDP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reinforcement-Learning-1-Âü∫Êú¨Ê¶ÇÂøµ]]></title>
    <url>%2F2018%2F07%2F18%2FReinforcement-Learning-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[ÂâçË®Ä Âº∫ÂåñÂ≠¶‰π† (Reinforcement Learning) ÊòØ‰∏ÄÁ±ªÁî®‰∫éÂ§çÊùÇÂú∫ÊôØÁöÑÊú∫Âô®Â≠¶‰π†ÁÆóÊ≥ïÔºåË¢´ÂπøÊ≥õÂ∫îÁî®Âú®Êú∫Âô®ÊéßÂà∂‰ªªÂä°‰∏≠„ÄÇËøëÂá†Âπ¥Êù•ÔºåÈöèÁùÄÁ•ûÁªèÁΩëÁªúÁöÑÈáçÊñ∞ÂÖ¥Ëµ∑ÔºåÂº∫ÂåñÂ≠¶‰π†‰πüË¢´ÈÄêÊ∏êÂ∫îÁî®Âú®‰∏Ä‰∫õÊñ∞ÁöÑÈ¢ÜÂüüÔºåÊØîÂ¶ÇËá™Âä®È©æÈ©∂ÔºåËÆ°ÁÆóÊú∫ËßÜËßâÁ≠â„ÄÇAlpha GO ÊàòËÉú‰∫∫Á±ªÊ£ãÊâãÊ†áÂøóÁùÄÊú∫Âô®Â≠¶‰π†ÁâπÂà´ÊòØÂº∫ÂåñÂ≠¶‰π†Ê≠£Âú®ÈÄêÊ∏êÊàêÁÜüÔºåÊàê‰∏∫ËÉΩÂ§üÊé®Âä®‰∫∫Â∑•Êô∫ËÉΩÂèñÂæóÁ™ÅÁ†¥ÁöÑÈáçË¶ÅÊñπÂêë‰πã‰∏Ä„ÄÇÊú¨ÊñáÊó®Âú®ÁÆÄÂçïÁöÑ‰ªãÁªç‰∏Ä‰∫õÂº∫ÂåñÂ≠¶‰π†ÁöÑÂü∫Êú¨Ê¶ÇÂøµÔºåÊõ¥Âä†ËØ¶ÁªÜÁöÑ‰ªãÁªç‰ºöÂú®‰ª•ÂêéÁöÑÂçöÂÆ¢‰∏≠Êõ¥Êñ∞„ÄÇ Âº∫ÂåñÂ≠¶‰π† ÂÆö‰πâÔºöReinforcement learning is learning what to do ----how to map situations to actions ---- so as to maximize a numerical reward signal.[1] ÁõÆÂâçÁöÑÊú∫Âô®Â≠¶‰π†ÁÆóÊ≥ï‰∏ªË¶ÅÊúâ3ÁßçÔºö ÁõëÁù£Â≠¶‰π†ÔºàSupervised LearningÔºâ Êó†ÁõëÁù£Â≠¶‰π†ÔºàUnsupervised LearningÔºâ Âº∫ÂåñÂ≠¶‰π†ÔºàReinforcement LearningÔºâ ÁªìÊûÑÂõæÂ¶Ç‰∏ãÊâÄÁ§∫Ôºö Âº∫ÂåñÂ≠¶‰π†ÊòØÊú∫Âô®Â≠¶‰π†ÁöÑ‰∏Ä‰∏™ÂàÜÊîØÔºå‰ΩÜÊòØÂÆÉ‰∏éÊàë‰ª¨Â∏∏ËßÅÁõëÁù£ÂºèÂ≠¶‰π†‰∏çÂ§™‰∏ÄÊ†∑„ÄÇ‰ªéÂ≠¶‰π†ÊñπÂºè‰∏äËÆ≤Âº∫ÂåñÂ≠¶‰π†Êõ¥Âä†Êé•Ëøë‰∫∫Á±ªÁöÑÂ≠¶‰π†ÔºåÂ∞±ÂÉèÊâìÊ∏∏Êàè‰∏ÄÊ†∑ÔºåÊØîÂ¶ÇÈ••ËçíÔºö‰∏ÄÂºÄÂßãÁé©ÂÆ∂‰ªÄ‰πàÈÉΩ‰∏çÊáÇÔºåÂè™Áü•ÈÅìË¶ÅÊ¥ª‰∏ãÂéªÔºåÊ≤°Êúâ‰ªª‰ΩïÊèêÁ§∫„ÄÇÁé©Ê≥ïÂè™ËÉΩÈÄöËøáÁé©ÂÆ∂ÁöÑ‰∏çÊñ≠ÁöÑÂ∞ùËØïÔºåÈÄöËøáËØïÈîôÂ≠¶‰π†ÔºåÁÑ∂ÂêéÊ†πÊçÆÁéØÂ¢ÉÁªô‰∫àÁöÑÂèçÈ¶àÔºåÂà§Êñ≠ÂΩìÂâçÁöÑÂ∞ùËØïÁöÑÊïàÁõäÔºåÊúÄÂêéÁªàÁªìÂá∫‰∏ÄÂ•óÊ∏∏ÊàèÁöÑÁ≠ñÁï•ÔºåÊàê‰∏∫‰∏ÄÂêçÈ••ËçíËÄÅÂè∏Êú∫„ÄÇ Âº∫ÂåñÂ≠¶‰π†ÁöÑÂü∫Êú¨ÊûÑÊàê ‰∏ª‰ΩìÔºàAgentÔºâÔºöËÉΩÂ§üÈÄöËøáÂä®‰Ωú‰∏éÁéØÂ¢É‰∫§‰∫íÁöÑÂØπË±°ÔºåÂº∫ÂåñÂ≠¶‰π†‰∏≠‰∏ª‰ΩìÈÄöÂ∏∏ÊòØËøêË°å‰∏≠ÁöÑÁÆóÊ≥ïÔºåÊØîÂ¶ÇÂú®È••ËçíÊ∏∏Êàè‰∏≠ÁöÑ‰∏ª‰ΩìÊòØÁé©ÂÆ∂ÊéßÂà∂ÁöÑËßíËâ≤ÔºåÂèØ‰ª•Âà∞Â§ÑÊêûÁ†¥Âùè ÁéØÂ¢ÉÔºàEnvironmentÔºâÔºö‰∏ª‰ΩìÂä®‰Ωú‰ΩúÁî®ÁöÑÂØπË±°Ôºå ÊØîÂ¶ÇÊ∏∏ÊàèÊú¨Ë∫´ÔºåÈ••ËçíÊ∏∏Êàè‰∏≠ÁöÑÁéØÂ¢ÉÂèòÂåñÔºåËßíËâ≤ÁöÑÂêÑÈ°πÂ±ûÊÄßÁöÑÂèòÂåñ„ÄÇ Âä®‰Ωú ÔºàActionÔºâ: ÊâÄÊúâÂèØËÉΩ‰ΩúÁî®‰∫éÁéØÂ¢É‰∏äÁöÑÊìç‰ΩúÔºåÊØîÂ¶ÇÊ∏∏Êàè‰∏≠ÊéßÂà∂ËßíËâ≤Á†çÊ†ë„ÄÅÈááÁüø„ÄÅÊäìËúúËúÇÁ≠â„ÄÇ Áä∂ÊÄÅ ÔºàStateÔºâ: ÂèØË¢´‰∏ª‰ΩìÊÑüÁü•ÁöÑÂÖ≥‰∫éÁéØÂ¢ÉÁöÑ‰ø°ÊÅØÔºåÊØîÂ¶ÇÊ∏∏Êàè‰∏≠Ëá™ÁÑ∂ÁéØÂ¢ÉÁöÑÁä∂ÊÄÅ‰ª•ÂèäËßíËâ≤ÁöÑÂÅ•Â∫∑ÊÉÖÂÜµ Â•ñÂä± ÔºàRewardÔºâ: Áî±ÁéØÂ¢ÉÂõûÈ¶àÁªô‰∏ª‰ΩìÁöÑÊèèËø∞‰∏ä‰∏Ä‰∏™Âä®‰ΩúÊïàÊûúÁöÑ‰ø°ÊÅØÔºåÊØîÂ¶ÇËßíËâ≤ÂêÉ‰∫Ü‰∏Ä‰∏™È£üÁâ©ÔºåÈ•±ËÖπÊÑü‰∏äÂçá„ÄÅÂêÉ‰∫ÜËçØ‰πãÂêéÔºåË°ÄÈáèÂõûÂ§ç Âº∫ÂåñÂ≠¶‰π†ÁöÑËøáÁ®ãÊòØ‰∏Ä‰∏™ÈÄöËøáÂíåÁéØÂ¢É‰∫§‰∫íËé∑ÂæóÂèçÈ¶àÔºåÂÜçÊ†πÊçÆÂèçÈ¶àË∞ÉÊï¥Âä®‰Ωú‰ª•Êúü‰ΩøÊÄªÂ•ñÂä±ÊúÄÂ§ßÂåñÁöÑËøáÁ®ãÔºåËøô‰∏™ÊòØ‰∏Ä‰∏™Â§öÊ≠• (multi timestep) ÁöÑ‰∫§‰∫íÁöÑËøáÁ®ãÔºåÊØè‰∏ÄÊ≠•‰∫§‰∫íÈÉΩ‰ºöÂΩ±ÂìçÂÖ∂ÂêéÁöÑÊâÄÊúâÊ≠•È™§„ÄÇÂº∫ÂåñÂ≠¶‰π†‰∏≠ÁöÑ‰∏ÄÊ¨°‰∫§‰∫íÊòØÊåá‰∏ª‰ΩìÂØπÁéØÂ¢ÉÊñΩÂä†‰∏Ä‰∏™Âä®‰ΩúÔºåÁéØÂ¢ÉÁöÑÁä∂ÊÄÅÂèëÁîüÊîπÂèòÂπ∂‰∏îÂõûÈ¶àÁªô‰∏ª‰Ωì‰∏Ä‰∏™Â•ñÂä±ÔºàÂ•ñÂä±Êó¢ÂèØ‰ª•ÊòØÊ≠£ÂêëÁöÑÔºåÂ¶ÇÊú¨ÊñπÂæóÂàÜÂ¢ûÂä†Ôºõ‰πüÂèØ‰ª•ÊòØË¥üÂêëÁöÑÔºåÂ¶ÇÂØπÊñπÂæóÂàÜÂ¢ûÂä†Ôºâ„ÄÇÂº∫ÂåñÂ≠¶‰π†ÁöÑÁõÆÊ†áÂ∞±ÊòØÂØªÊâæ‰∏Ä‰∏™ÊúÄ‰ºòÁöÑÁ≠ñÁï•‰ΩøÂæóÊï¥‰∏™Â≠¶‰π†ËøáÁ®ãÔºà‰ªéÂºÄÂßãÁä∂ÊÄÅÂà∞ÁªàÁªìÁä∂ÊÄÅÔºâËé∑ÂæóÁöÑÂ•ñÂä±ÊúÄÂ§ßÂåñ„ÄÇ Âú®ÂÆûÁé∞‰∏äÔºåÂº∫ÂåñÂ≠¶‰π†ÊòØ‰∏Ä‰∏™ÈÄöËøáÂ§ö‰∏™ËΩÆÊ¨°ÈÄêÊ∏ê‰ºòÂåñÁÆóÊ≥ïÁöÑÂèÇÊï∞‰ªéËÄåÂ¢ûÂº∫Â≠¶‰π†ÊïàÊûúÁöÑËøáÁ®ãÔºåÊØè‰∏™ËΩÆÊ¨°ÂåÖÂê´‰∏§ÈÉ®ÂàÜÔºöÂâçÂêëÂèçÈ¶àÔºàfeed forwardÔºâÂíåÂèçÂêë‰º†Êí≠Ôºàback propagationÔºâ„ÄÇÂ§Ñ‰∫éÂàùÂßãÁä∂ÊÄÅÁöÑ‰∏ª‰ΩìÊ†πÊçÆÁÆóÊ≥ïÁöÑÂΩìÂâçÂèÇÊï∞ÁîüÊàêÂä®‰Ωú‰ΩúÁî®‰∫éÁéØÂ¢ÉÔºåÁéØÂ¢ÉËøîÂõûÁªô‰∏ª‰ΩìÊñ∞ÁöÑÁä∂ÊÄÅÂíåÂØπÂä®‰ΩúÁöÑÂ•ñÂä±ÔºåÂú®ËΩÆÊ¨°ÁªìÊùüÂêéÁÆóÊ≥ïÈÄöËøáÊ±áÊÄªÊâÄÊúâÂú®Êú¨ËΩÆÊî∂ÈõÜÂà∞ÁöÑÂèçÈ¶àË∞ÉÊï¥ÁÆóÊ≥ïÁöÑÂèÇÊï∞ÂºÄÂßã‰∏ã‰∏ÄËΩÆÁöÑÂ≠¶‰π†ÔºåÁõ¥Âà∞Â≠¶‰π†ÁöÑÊïàÊûú‰∏çÂÜçÂ¢ûÂº∫„ÄÇ RL‰∏éÊúâÁõëÁù£Â≠¶‰π†„ÄÅÊó†ÁõëÁù£Â≠¶‰π†ÁöÑÊØîËæÉ ÊúâÁõëÁù£ÁöÑÂ≠¶‰π†ÊòØ‰ªé‰∏Ä‰∏™Â∑≤ÁªèÊ†áËÆ∞ÁöÑËÆ≠ÁªÉÈõÜ‰∏≠ËøõË°åÂ≠¶‰π†ÔºåËÆ≠ÁªÉÈõÜ‰∏≠ÊØè‰∏Ä‰∏™Ê†∑Êú¨ÁöÑÁâπÂæÅÂèØ‰ª•ËßÜ‰∏∫ÊòØÂØπËØ•situationÁöÑÊèèËø∞ÔºåËÄåÂÖ∂labelÂèØ‰ª•ËßÜ‰∏∫ÊòØÂ∫îËØ•ÊâßË°åÁöÑÊ≠£Á°ÆÁöÑactionÔºå‰ΩÜÊòØÊúâÁõëÁù£ÁöÑÂ≠¶‰π†‰∏çËÉΩÂ≠¶‰π†‰∫§‰∫íÁöÑÊÉÖÊôØÔºåÂõ†‰∏∫Âú®‰∫§‰∫íÁöÑÈóÆÈ¢ò‰∏≠Ëé∑ÂæóÊúüÊúõË°å‰∏∫ÁöÑÊ†∑‰æãÊòØÈùûÂ∏∏‰∏çÂÆûÈôÖÁöÑÔºåagentÂè™ËÉΩ‰ªéËá™Â∑±ÁöÑÁªèÂéÜÔºàexperienceÔºâ‰∏≠ËøõË°åÂ≠¶‰π†ÔºåËÄåexperience‰∏≠ÈááÂèñÁöÑË°å‰∏∫Âπ∂‰∏ÄÂÆöÊòØÊúÄ‰ºòÁöÑ„ÄÇËøôÊó∂Âà©Áî®RLÂ∞±ÈùûÂ∏∏ÂêàÈÄÇÔºåÂõ†‰∏∫RL‰∏çÊòØÂà©Áî®Ê≠£Á°ÆÁöÑË°å‰∏∫Êù•ÊåáÂØºÔºåËÄåÊòØÂà©Áî®Â∑≤ÊúâÁöÑËÆ≠ÁªÉ‰ø°ÊÅØÊù•ÂØπË°å‰∏∫ËøõË°åËØÑ‰ª∑„ÄÇ Âõ†‰∏∫RLÂà©Áî®ÁöÑÂπ∂‰∏çÊòØÈááÂèñÊ≠£Á°ÆË°åÂä®ÁöÑexperienceÔºå‰ªéËøô‰∏ÄÁÇπÊù•ÁúãÂíåÊó†ÁõëÁù£ÁöÑÂ≠¶‰π†Á°ÆÂÆûÊúâÁÇπÂÉèÔºå‰ΩÜÊòØËøòÊòØ‰∏ç‰∏ÄÊ†∑ÁöÑÔºåÊó†ÁõëÁù£ÁöÑÂ≠¶‰π†ÁöÑÁõÆÁöÑÂèØ‰ª•ËØ¥ÊòØ‰ªé‰∏ÄÂ†ÜÊú™Ê†áËÆ∞Ê†∑Êú¨‰∏≠ÂèëÁé∞ÈöêËóèÁöÑÁªìÊûÑÔºåËÄåRLÁöÑÁõÆÁöÑÊòØÊúÄÂ§ßÂåñreward signal„ÄÇ ÊÄªÁöÑÊù•ËØ¥ÔºåRL‰∏éÂÖ∂‰ªñÊú∫Âô®Â≠¶‰π†ÁÆóÊ≥ï‰∏çÂêåÁöÑÂú∞ÊñπÂú®‰∫éÔºöÂÖ∂‰∏≠Ê≤°ÊúâÁõëÁù£ËÄÖÔºåÂè™Êúâ‰∏Ä‰∏™reward‰ø°Âè∑ÔºõÂèçÈ¶àÊòØÂª∂ËøüÁöÑÔºå‰∏çÊòØÁ´ãÂç≥ÁîüÊàêÁöÑÔºõÊó∂Èó¥Âú®RL‰∏≠ÂÖ∑ÊúâÈáçË¶ÅÁöÑÊÑè‰πâÔºõagentÁöÑË°å‰∏∫‰ºöÂΩ±Âìç‰πãÂêé‰∏ÄÁ≥ªÂàóÁöÑdata„ÄÇ RLÁöÑ‰∏ªË¶ÅÁâπÁÇπ ÂÖ∂‰ªñËÆ∏Â§öÊú∫Âô®Â≠¶‰π†ÁÆóÊ≥ï‰∏≠Â≠¶‰π†Âô®ÈÉΩÊòØÂ≠¶ÂæóÊÄéÊ†∑ÂÅöÔºåËÄåRLÊòØÂú®Â∞ùËØïÁöÑËøáÁ®ã‰∏≠Â≠¶‰π†Âà∞Âú®ÁâπÂÆöÁöÑÊÉÖÂ¢É‰∏ãÈÄâÊã©Âì™ÁßçË°åÂä®ÂèØ‰ª•ÂæóÂà∞ÊúÄÂ§ßÁöÑÂõûÊä•„ÄÇÂú®ÂæàÂ§öÂú∫ÊôØ‰∏≠ÔºåÂΩìÂâçÁöÑË°åÂä®‰∏ç‰ªÖ‰ºöÂΩ±ÂìçÂΩìÂâçÁöÑrewardsÔºåËøò‰ºöÂΩ±Âìç‰πãÂêéÁöÑÁä∂ÊÄÅÂíå‰∏ÄÁ≥ªÂàóÁöÑrewards„ÄÇRLÊúÄÈáçË¶ÅÁöÑ3‰∏™ÁâπÂÆöÂú®‰∫éÔºö Âü∫Êú¨ÊòØ‰ª•‰∏ÄÁßçÈó≠ÁéØÁöÑÂΩ¢Âºè ‰∏ç‰ºöÁõ¥Êé•ÊåáÁ§∫ÈÄâÊã©Âì™ÁßçË°åÂä®ÔºàactionsÔºâ ‰∏ÄÁ≥ªÂàóÁöÑactionsÂíåÂ•ñÂä±‰ø°Âè∑Ôºàreward signalsÔºâÈÉΩ‰ºöÂΩ±Âìç‰πãÂêéËæÉÈïøÁöÑÊó∂Èó¥„ÄÇ Âº∫ÂåñÂ≠¶‰π†ÊòØÊú∫Âô®Â≠¶‰π†‰∏≠‰∏Ä‰∏™ÈùûÂ∏∏Ê¥ªË∑É‰∏îÊúâË∂£ÁöÑÈ¢ÜÂüüÔºåÁõ∏ÊØîÂÖ∂‰ªñÂ≠¶‰π†ÊñπÊ≥ïÔºåÂ¢ûÂº∫Â≠¶‰π†Êõ¥Êé•ËøëÁîüÁâ©Â≠¶‰π†ÁöÑÊú¨Ë¥®ÔºåÂõ†Ê≠§ÊúâÊúõËé∑ÂæóÊõ¥È´òÁöÑÊô∫ËÉΩÔºåËøô‰∏ÄÁÇπÂú®Ê£ãÁ±ªÊ∏∏Êàè‰∏≠Â∑≤ÁªèÂæóÂà∞‰ΩìÁé∞„ÄÇTesauro(1995)ÊèèËø∞ÁöÑTD-GammonÁ®ãÂ∫èÔºå‰ΩøÁî®Â¢ûÂº∫Â≠¶‰π†Êàê‰∏∫‰∫Ü‰∏ñÁïåÁ∫ßÁöÑË•øÊ¥ãÂèåÈôÜÊ£ãÈÄâÊâã„ÄÇËøô‰∏™Á®ãÂ∫èÁªèËøá150‰∏á‰∏™Ëá™ÁîüÊàêÁöÑÂØπÂºàËÆ≠ÁªÉÂêéÔºåÂ∑≤ÁªèËøë‰ººËææÂà∞‰∫Ü‰∫∫Á±ªÊúÄ‰Ω≥ÈÄâÊâãÁöÑÊ∞¥Âπ≥ÔºåÂπ∂Âú®Âíå‰∫∫Á±ªÈ°∂Á∫ßÈ´òÊâãÁöÑËæÉÈáè‰∏≠ÂèñÂæó40 Áõò‰ªÖËæì1ÁõòÁöÑÂ•ΩÊàêÁª©„ÄÇ ÂèÇËÄÉ [1] R.Sutton et al. Reinforcement learning: An introduction , 1998 [2] UCL Course on RL]]></content>
      <categories>
        <category>Êú∫Âô®Â≠¶‰π†</category>
      </categories>
      <tags>
        <tag>Êú∫Âô®Â≠¶‰π†</tag>
        <tag>Âº∫ÂåñÂ≠¶‰π†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ê∑±Â∫¶Âº∫ÂåñÂ≠¶‰π†ÔºàDRLÔºâÊº´Ë∞à-‰ªéDQNÂà∞AlphaGo]]></title>
    <url>%2F2018%2F07%2F17%2F%E6%B7%B1%E5%BA%A6%E5%A2%9E%E5%BC%BA%E5%AD%A6%E4%B9%A0%EF%BC%88DRL%EF%BC%89%E6%BC%AB%E8%B0%88-%E4%BB%8EDQN%E5%88%B0AlphaGo%2F</url>
    <content type="text"><![CDATA[ÊúÄËøëÂàöÂàöÂºÄÂßãÂ≠¶‰π†Reinforcement LearningÔºåÁúãÂà∞‰∏ÄÁØá‰ªãÁªçÂçöÂÆ¢ÂÜôÁöÑÊØîËæÉÂ•ΩÔºåËΩ¨ËΩΩ‰∏Ä‰∏ã„ÄÇ ÂéüÊñáÈìæÊé• Ê∑±Â∫¶Âº∫ÂåñÂ≠¶‰π†ÔºàDeep reinforcement learning, DRLÔºâÊòØDeepMindÔºàÂêéË¢´Ë∞∑Ê≠åÊî∂Ë¥≠ÔºâËøëÂá†ËøëÊù•ÈáçÁÇπÁ†îÁ©∂‰∏îÂèëÊâ¨ÂÖâÂ§ßÁöÑÊú∫Âô®Â≠¶‰π†ÁÆóÊ≥ïÊ°ÜÊû∂„ÄÇ‰∏§ÁØáNature‰∏äÁöÑÂ•†Âü∫ÊÄßËÆ∫ÊñáÔºàDQNÂíåAlphaGoÔºâ‰ΩøÂæóDRLËøô‰∏ÄÊ∑±Â∫¶Â≠¶‰π†ÔºàDeep learning, DLÔºâÂíåÂº∫ÂåñÂ≠¶‰π†ÔºàReinforcement learning, RLÔºâÁöÑ‰∫§ÂèâÊñπÂêëÂèòÂæóÁÇôÊâãÂèØÁÉ≠„ÄÇÂÜçÂä†‰∏äÂ§ö‰∏™ÂΩ±ÂìçËæÉÂ§ßÁöÑbenchmarkÔºàAtari 2600ÔºåÂõ¥Ê£ãÁ≠âÔºâ‰∏äÊºÇ‰∫ÆÁöÑÊàêÁª©‰ΩøÂÆÉÂ¶Ç‰ªäÂÄçÂèóÂ≠¶ÊúØÁïåÂíåÂïÜ‰∏öÁïåÁöÑÂÖ≥Ê≥®ÔºåÁîöËá≥ËÆ©‰∫∫ÈóªÂà∞‰∫ÜÊ≥°Ê≤´ÁöÑÂë≥ÈÅì„ÄÇ‰∏çÁÆ°ÊÄéÊ†∑ÔºåÂÆÉËøòÊòØÈùûÂ∏∏ÊàêÂäüÂú∞ÂºÄÂàõ‰∫ÜÊñ∞ÁöÑÊñπÂêëÔºåÊó¢ÂÖ∑ÊúâÊûÅÂ§ßÂ≠¶ÊúØ‰ª∑ÂÄº‰πüÂÖ∑ÊúâÈ¢áÈ´òÁöÑÂïÜ‰∏ö‰ª∑ÂÄº„ÄÇÂ∞ΩÁÆ°‰πãÂêéÁî®‰∫éËß£ÂÜ≥ÂÉèÂõ¥Ê£ãËøôÊ†∑ÁöÑÂ§ßËßÑÊ®°ÊêúÁ¥¢ÈóÆÈ¢òÔºå‰ΩÜDQNÂá∫Áé∞‰πãÂàùÁöÑÊúÄÂ§ßÊÑè‰πâÂú®‰∫éÁÆóÊ≥ïÁöÑÈÄöÁî®ÊÄß„ÄÇÂõ†‰∏∫Ê≥õÂåñÊÄßÂêëÊù•ÊòØÊú∫Âô®Â≠¶‰π†ÊúÄÂ§ßÁöÑÊåëÊàò‰πã‰∏ÄÔºåÂÆÉÊâçÊòØÊú∫Âô®Âíå‰∫∫Áõ∏ÊØîÂº±Â§™Â§öÁöÑÂú∞ÊñπÔºå‰πüÊòØÂæàÂ§öÊú∫Âô®Â≠¶‰π†ÁÆóÊ≥ïÊúÄÊúâÂæÖÊîπËøõÁöÑÂú∞Êñπ„ÄÇ‰ªäÂ§©Êàë‰ª¨ÁúãÂêÑÁßçÂ∞èÊä•‰∏äÂØπ‰∫∫Â∑•Êô∫ËÉΩÁ†îÁ©∂ÊàêÊûúÁöÑÊä•ÈÅìÈÉΩÂñúÊ¨¢Êñ≠Á´†Âèñ‰πâÔºåÊãøÁâπÂÆöÊï∞ÊçÆÈõÜ‰∏äÁöÑÂáÜÁ°ÆÊÄßËØ¥‰∫ãÔºåËôΩÁÑ∂ÈÇ£‰πüÂæàÁâõXÔºå‰ΩÜ‰∏ÄÂÆöÁ®ãÂ∫¶‰∏äÂøΩÁï•‰∫ÜÈÄöÁî®ÊÄß‰πüÊòØÊú∫Âô®Â≠¶‰π†Ëµ∞ÂêëÂ§ß‰ºóÊúÄÂ§ßÁì∂È¢à‰πã‰∏ÄÁöÑ‰∫ãÂÆû„ÄÇ ‰ªäÂ§©Êàë‰ª¨Â∞±Êä±ÁùÄ‚ÄúÁü•ÂÖ∂ÁÑ∂Áü•ÂÖ∂ÊâÄ‰ª•ÁÑ∂‚ÄùÁöÑÊÄÅÂ∫¶ÔºåÁúãÁúãÂÆÉÁöÑÊºîÂèòÂéÜÁ®ã„ÄÇÂÖ∂ÂÆûDQNÂπ∂‰∏çÊòØ‰∏ÄËπ¥ËÄåÂ∞±ÔºåÂÆÉÊòØÂü∫‰∫é‰∏Ä‰∏™Âè§ËÄÅÁöÑ‰∫∫Â∑•Êô∫ËÉΩÊñπÂêëÔºåÂç≥Âº∫ÂåñÂ≠¶‰π†„ÄÇÂº∫ÂåñÂ≠¶‰π†‰∏çÂêå‰∏éÊú∫Âô®Â≠¶‰π†‰∏≠ÂÖ∂ÂÆÉ‰∏§Â§ßÁ±ªÂ≠¶‰π†ÊñπÊ≥ï-ÁõëÁù£Â≠¶‰π†Ôºàsupervised learning, SLÔºâÂíåÈùûÁõëÁù£Â≠¶‰π†Ôºàunsupervised learning, ULÔºâÔºåÂÖ∂Âü∫Êú¨ÊÄùÊÉ≥ÊòØÂÄüÈâ¥‰∫∫Á±ªÂ≠¶‰π†ÁöÑËøáÁ®ãÔºåËÆ©agentÔºàÊô∫ËÉΩ‰ΩìÔºåÊàñÁß∞Â≠¶‰π†‰ΩìÔºâÈÄöËøá‰∏çÊñ≠ËØïÈîôÊù•ÊâæÂØªÊúÄ‰ºòÁ≠ñÁï•ÔºåËÄåÊàë‰ª¨Âè™ÈúÄË¶ÅËÆæÁΩÆÂõûÊä•ÔºàÂ•ñÂä±ÂíåÊÉ©ÁΩöÔºâÂç≥ÂèØ„ÄÇ‰ΩÜÁî±‰∫éÂÖ∂Â±ÄÈôêÊÄßÔºàÊØîÂ¶ÇÂº∫‰æùËµñ‰∫é‰∫∫Â∑•ËÆæËÆ°ÁöÑÁâπÂæÅË¥®ÈáèÁ≠âÔºâÔºåÈïøÊúüÂ§Ñ‰∫é‰∏çÊ∏©‰∏çÁÅ´ÁöÑÂ¢ÉÂú∞ÔºåÁõ¥Âà∞DQN‰ΩøÂÆÉËÄÅÊ†ëÂèëÊñ∞ËäΩÔºåÈáçËé∑Êñ∞Áîü„ÄÇNIPS 2013ËÆ∫Êñá„ÄäPlaying Atari with Deep Reinforcement Learning„ÄãÊèêÂá∫ÁöÑÊ∑±Â∫¶QÂ≠¶‰π†ÔºàDeep Q-learningÔºåDQNÔºâÊòØÂü∫‰∫éÂº∫ÂåñÂ≠¶‰π†‰∏≠ÁöÑQÂ≠¶‰π†ÔºàQ-learningÔºâ„ÄÇÈÇ£Êàë‰ª¨Â∞±‰ª•ÂÆÉ‰∏∫ÂàáÂÖ•ÁÇπÔºåÊù•Áúã‰∏Ä‰∏ãQ-learningÊòØÊÄé‰πàÊù•ÁöÑ„ÄÇSuttonÁöÑÁªèÂÖ∏Ëëó‰Ωú„ÄäReinforcement Learning: An Introduction„Äã‰∏≠ÂØπÂ∏∏ËßÑÁöÑÂº∫ÂåñÂ≠¶‰π†ÊñπÊ≥ïÂÅö‰∫ÜÈùûÂ∏∏Â•ΩÁöÑÊÄªÁªì„ÄÇÊàë‰ª¨Â∞±ÂèÇËÄÉÂÆÉÁ≤óÁ≥ôÂú∞ÂãæÂãí‰∏ãQ-learningÂú®ÂÖ∂‰∏≠ÁöÑÂ§ß‰Ωì‰ΩçÁΩÆ„ÄÇ ‰ªéÂõæ‰∏≠ÂèØ‰ª•ÁúãÂà∞ÔºåÂº∫ÂåñÂ≠¶‰π†ÂèëÂ±ï‰∫ÜÂá†ÂçÅÂπ¥ÔºåÂ∑≤ÁªèÂºÄÊûùÊï£Âè∂ÔºåÊúâ‰∫ÜÂæàÂ§öÂàÜÊîØ„ÄÇ1989Âπ¥Áî±WatkinsÊèêÂá∫ÁöÑQÂ≠¶‰π†ÊòØ‰∏ÄÁßçmodel-freeÔºà‰∏çÁî®Â≠¶‰π†ÁéØÂ¢ÉÊ®°ÂûãÔºâÁöÑÂü∫‰∫éoff-policyÔºàÂ≠¶‰π†ËøáÁ®ã‰∏≠ÊâßË°åÁöÑÁ≠ñÁï•‰∏éÂÄº‰º∞ËÆ°‰ΩøÁî®ÁöÑÁ≠ñÁï•‰∏ç‰∏ÄÊ†∑ÔºâÁöÑtemporal differenceÔºàTDÔºâÊñπÊ≥ïÔºå‰πüÊòØRL‰∏≠ÊµÅ‰º†ÊúÄ‰∏∫ÂπøÊ≥õÁöÑ‰∏ÄÁßçÂ≠¶‰π†ÊñπÊ≥ï„ÄÇ Êé•‰∏ãÊù•ËØùÈîã‰∏ÄËΩ¨Â∞±ÈúÄË¶ÅËÆ≤ÂáΩÊï∞ÈÄºËøëÔºàFunction approximationÔºåFAÔºâ‰∫Ü„ÄÇÂõ†‰∏∫ÊúÄÂéüÂßãÁöÑË°®Ê†ºÊ≥ïÔºàtabular methodÔºâÊù•Ë°®Á§∫ÁõÆÊ†áÂáΩÊï∞ÔºàVÊàñQÂáΩÊï∞ÔºâÊØïÁ´üÁî®ÈÄîÊúâÈôêÔºå‰∏îÂ§öÁî®‰∫éÁ¶ªÊï£Á©∫Èó¥„ÄÇËÄåÂáΩÊï∞ÈÄºËøëÁõ∏ÊØî‰πã‰∏ãÂèØÊúâ‰∏çÂ∞ëÂ•ΩÂ§ÑÔºöÊØîÂ¶Ç‰∏ÄÂèØ‰ª•Èôç‰ΩéËæìÂÖ•Áª¥Â∫¶ÔºåÂáèÂ∞ëËÆ°ÁÆóÈáèÔºõ‰∫åÂèØ‰ª•ÊèêÈ´òÊ≥õÂåñËÉΩÂäõÔºåÈÅøÂÖçËøáÂ≠¶‰π†Ôºàover-fittingÔºâÔºõ‰∏âÂèØ‰ª•‰ΩøÁõÆÊ†áÂáΩÊï∞ÂØπ‰∫éÂèÇÊï∞ÂèØÂæÆÔºåÁî®‰∏äÂü∫‰∫éÊ¢ØÂ∫¶ÁöÑËÆ°ÁÆóÊñπÊ≥ï„ÄÇÂâçÈù¢ÊèêÂà∞RLÁöÑÂ±ÄÈôê‰πã‰∏ÄÂ∞±ÊòØÈúÄË¶Å‰∫∫Â∑•ËÆæËÆ°ÁöÑÁâπÂæÅ„ÄÇËÆæËÆ°ÁöÑ‰∏çÂ•ΩÂêéÈù¢ÁöÑÁÆóÊ≥ïÂÜçÂ•Ω‰πüÁôΩÊê≠„ÄÇËøôÂÖ∂ÂÆû‰∏çÂè™ÈíàÂØπRLÔºå‰ª•ÂâçÊàë‰ª¨ÁúãÂà∞ÂàÜÁ±ªÊàñÂõûÂΩíÈóÆÈ¢òÁªìÊûú‰∏çÂ•ΩÔºåÂ∞±ÂéªÊç¢ÂÖ∂ÂÆÉÁÆóÊ≥ïÊàñÊîπËøõÁÆóÊ≥ïÊú¨Ë∫´„ÄÇÂêéÊù•ÂèëÁé∞Âè™Ë¶ÅÁâπÂæÅÈÄâÂèñÂêàÈÄÇÊàñËÆæËÆ°ÂêàÁêÜÔºåÂæàÂ§öÊó∂ÂÄôÁÆóÊ≥ïÁöÑÁªìÊûúÈÉΩÊ≤°ÊúâÊòæËëóÂ∑ÆÂºÇ„ÄÇÂÖ∂ÂÆûÊ∑±Â∫¶Â≠¶‰π†Êú¨Ë∫´‰πüÊ≠£ÊòØÊääÊõ¥Â§öÊ≥®ÊÑèÂäõÊãâÂõûÂà∞ÁâπÂæÅÂ≠¶‰π†‰∏äÊù•„ÄÇÂõûÂà∞Ê≠£È¢òÔºåÂáΩÊï∞ÈÄºËøëÂàÜ‰∏∫‰∏§Â§ßÁ±ªÔºöÁ∫øÊÄßÂíåÈùûÁ∫øÊÄßÁöÑ„ÄÇÂâçËÄÖ‰∏ÄËà¨ÊòØÁî®‰∏ÄÁ≥ªÂàóÁâπÂæÅÁöÑÁ∫øÊÄßÁªÑÂêàÔºåÂÆÉ‰ª¨ÁöÑÊùÉÈáç‰Ωú‰∏∫ÂèÇÊï∞„ÄÇ‰ºòÁÇπËá™ÁÑ∂ÊòØËÆ°ÁÆóÊñπ‰æøÔºåÁÆóÊ≥ïÂ•ΩÂÆûÁé∞„ÄÇÂêéËÄÖÂ∞±ÊØîÂ¶ÇÁî®Á•ûÁªèÁΩëÁªúÔºàNeural networkÔºåNNÔºâÔºå‰ºòÁÇπÊòØË°®ËææËÉΩÂäõÂ§ßÂ§ßÂä†Âº∫ÔºåÁº∫ÁÇπÊòØËÆ≠ÁªÉËµ∑Êù•‰πüÈ∫ªÁÉ¶ÂæóÂ§ö„ÄÇÂΩìÁÑ∂ÔºåÁî®NNÊù•ÈÄºËøëÁõÆÊ†áÂáΩÊï∞ÔºàÊØîÂ¶ÇÂÄºÂáΩÊï∞ÔºâÊó©Â∑≤Ë¢´‰∫∫Á†îÁ©∂ËøáÔºåÊØïÁ´ü‰∏ä‰∏ñÁ∫™80Âπ¥‰ª£ÁöÑÊó∂ÂÄôÁ•ûÁªèÁΩëÁªú‰πüÂ¶ÇÂêå‰ªäÂ§©ÁöÑÊ∑±Â∫¶Â≠¶‰π†‰∏ÄÊ†∑È¶ôÈ•ΩÈ•Ω„ÄÇÊØîÂ¶Ç‰∏ä‰∏ñÁ∫™ÁöÑTD-GammonÔºåÂèØ‰ª•ËØ¥ÊòØÂΩìÊó∂RLÂú®ÂçöÂºàÂ∫îÁî®ÁöÑÁªèÂÖ∏ÔºåÂ∞±ÊòØÁî®‰∫ÜÂ§öÂ±ÇÁ•ûÁªèÁΩëÁªú‰Ωú‰∏∫ÂáΩÊï∞ÈÄºËøë„ÄÇ‰ΩÜÊ∑±Â∫¶Â≠¶‰π†ÂâçÁöÑÁ•ûÁªèÁΩëÁªúÂäüËÉΩ‰∏äÂè™Áî®‰∫éÂàÜÁ±ªÊàñÂõûÂΩíÔºåÊ≤°ÊúâÊó†ÁõëÁù£Â≠¶‰π†ÊèêÂèñÁâπÂæÅÁöÑÂäüËÉΩÔºåÂõ†Ê≠§Èöæ‰ª•Áõ¥Êé•Â§ÑÁêÜË£∏Êï∞ÊçÆÔºåÊØîÂ¶ÇÂÉèÁ¥†Á∫ßÊï∞ÊçÆÔºàraw pixelsÔºâ„ÄÇ NIPS 2013 „ÄäPlaying Atari with Deep Reinforcement Learning„Äã Âà∞ËøôÈáå‰∏∫Ê≠¢ÔºåËøòÊ≤°ÊúâÊ∑±Â∫¶Â≠¶‰π†ÂçäÊØõÈí±ÂÖ≥Á≥ªÔºåÂæàÂ§öÈÉΩÊòØ‰∫åÔºå‰∏âÂçÅÂπ¥ÂâçÁöÑ‰∏úË•ø„ÄÇ‰Ωú‰∏ãÁÆÄÂçïÁöÑÈì∫Âû´ÂêéÔºåÊé•‰∏ãÊù•Êàë‰ª¨Áúã‰∏ãDLÊòØÊÄé‰πàËÆ©Ëøô‰∫õÁªèÂÖ∏ÊñπÊ≥ïÊç¢ÂèëÈùíÊò•ÁöÑ„ÄÇDQN‰∏≠ÁöÑËæìÂÖ•ÈááÁî®ÁöÑÊòØÂéüÂßãÂõæÂÉèÊï∞ÊçÆÔºåÂèØ‰ª•ËØ¥Âü∫Êú¨ÊòØË£∏Êï∞ÊçÆ‰∫Ü„ÄÇËøôÊòØDQNÊúÄÊúâÊÑè‰πâÁöÑ‰∏ÄÊ≠•‰∫Ü„ÄÇÂú®DNNÂâçÂñÇË£∏Êï∞ÊçÆ‰∏ÄËà¨ÊïàÊûúÈÉΩ‰∏çÊÄé‰πàÁêÜÊÉ≥ÔºåÂõ†‰∏∫‰∏ÄËà¨ÁöÑANNÊó†Ê≥ïÈÄöËøáËá™Âä®ËÆ≠ÁªÉcatchÂà∞ÂÖ∂‰∏≠ÁöÑÈöêÂê´ÁâπÂæÅ„ÄÇËÄåËøôÂá†Âπ¥Ê∂åÁé∞ÁöÑ‰∏Ä‰∫õÊàêÊûúÔºåÊØîÂ¶ÇËÆ∫Êñá„ÄäImagenet classification with deep convolutional neural networks„ÄãÁ≠âÔºåÊûÅÂ§ßÂú∞Âº∫Âåñ‰∫ÜDLÂ§ÑÁêÜraw pixelsÊï∞ÊçÆÁöÑ‰ø°ÂøÉ„ÄÇËØ¥ÂÆûËØùÔºåÁ∫ØÊãºAtariÊàêÁª©ÁöÑËØùÔºå‰ªª‰Ωï‰∏Ä‰∏™Ê∏∏ÊàèÈÉΩÂèØ‰ª•ÈÄöËøáÈíàÂØπÊÄßÁöÑÁÆóÊ≥ïÂèñÂæóÈùûÂ∏∏È´òÁöÑÊàêÁª©Ôºå‰ΩÜDQNËÉΩÂèëË°®Âú®Nature‰∏äÔºå‰∫Ü‰∏çËµ∑Âú®ÂÆÉÁöÑÁÆóÊ≥ïÂØπÊâÄÊúâÊ∏∏ÊàèÊòØÈÄöÁî®ÁöÑÔºàÁîöËá≥Ë∂ÖÂèÇÊï∞‰πüÊòØÈÄöÁî®ÁöÑÔºâÔºåËÄåËøôÁßçÈÄöÁî®ÊÄßÁöÑÈáçË¶ÅÂü∫Á°Ä‰πã‰∏ÄÂ∞±ÊòØÂÆÉËÉΩÂêÉraw pixels„ÄÇÂΩìÁÑ∂ÂÆÉÁöÑÊÑè‰πâ‰∏çÊ≠¢‰∫éÊ≠§ÔºåÂÆÉÂÆûÁé∞‰∫ÜÂæàÂ•ΩÁöÑÊïàÊûúÂêëÂÖ®‰∏ñÁïåËØÅÊòé‰∫ÜËØ•ÊñπÊ≥ïÁöÑÊúâÊïàÊÄßÔºåËÄåÂÖ∂‰∏≠ÁöÑ‰∏ÄÂ§ßÂäüËá£Â∞±ÊòØexperience replay„ÄÇËØ•ÊñπÊ≥ïÂú®Long-Ji Lin 1993Âπ¥ÁöÑÊØï‰∏öËÆ∫Êñá‰∏≠ÊúâËæÉËØ¶ÁªÜÁöÑ‰ªãÁªçÔºåÂÖ∂‰∏ªË¶Å‰ΩúÁî®ÊòØÂÖãÊúçÁªèÈ™åÊï∞ÊçÆÁöÑÁõ∏ÂÖ≥ÊÄßÔºàcorrelated dataÔºâÂíåÈùûÂπ≥Á®≥ÂàÜÂ∏ÉÔºànon-stationary distributionÔºâÈóÆÈ¢ò„ÄÇÂÆÉÁöÑÂÅöÊ≥ïÊòØ‰ªé‰ª•ÂæÄÁöÑÁä∂ÊÄÅËΩ¨ÁßªÔºàÁªèÈ™åÔºâ‰∏≠ÈöèÊú∫ÈááÊ†∑ËøõË°åËÆ≠ÁªÉ„ÄÇËøôÊ†∑Ëá≥Â∞ëÊúâ‰∏§‰∏™Â•ΩÂ§ÑÔºö1. Êï∞ÊçÆÂà©Áî®ÁéáÈ´òÔºåÂõ†‰∏∫‰∏Ä‰∏™Ê†∑Êú¨Ë¢´Â§öÊ¨°‰ΩøÁî®„ÄÇ2. ËøûÁª≠Ê†∑Êú¨ÁöÑÁõ∏ÂÖ≥ÊÄß‰ºö‰ΩøÂèÇÊï∞Êõ¥Êñ∞ÁöÑÊñπÂ∑ÆÔºàvarianceÔºâÊØîËæÉÂ§ßÔºåËØ•Êú∫Âà∂ÂèØÂáèÂ∞ëËøôÁßçÁõ∏ÂÖ≥ÊÄß„ÄÇÊ≥®ÊÑèËøôÈáåÁî®ÁöÑÊòØÈöèÊú∫ÈááÊ†∑ÔºåËøô‰πüÁªô‰πãÂêéÁöÑÊîπËøõÂüã‰∏ã‰∫Ü‰ºèÁ¨î„ÄÇ Nature 2015„ÄäHuman-level control through deep reinforcement learning„Äã ‰ª•‰∏äÊòØNIPS 2013ËÆ∫Êñá‰∏≠ÊèêÂá∫ÁöÑDQNÂéüÂûã„ÄÇ‰πãÂêéNature 2015ÁöÑËÆ∫Êñá„ÄäHuman-level control through deep reinforcement learning„ÄãÂØπ‰πã‰Ωú‰∫ÜÊîπËøõÂíåÂÆåÂñÑ„ÄÇÂÖ∂‰∏≠ÂØπ‰∫éÁÆóÊ≥ï‰∏äÁöÑÂèòÂåñÊúÄ‰∏ªË¶ÅÊòØÂºïÂÖ•‰∫ÜÂçïÁã¨ÁöÑQÂáΩÊï∞ÁΩëÁªú„ÄÇÁ†îÁ©∂ËÄÖÂú®ÂÆûË∑µ‰∏≠ÂèëÁé∞ÂΩì‰ΩøÁî®Â¶ÇNNËøôÊ†∑ÁöÑÈùûÁ∫øÊÄßÂáΩÊï∞ÈÄºËøëÂô®ÈÄºËøëQÂáΩÊï∞Êó∂RLÂ≠¶‰π†ËøáÁ®ãÂπ∂‰∏çÁ®≥ÂÆö„ÄÇËøôÁßç‰∏çÁ®≥ÂÆöÊúâÂá†ÁßçÂéüÂõ†ÔºöÁªèÈ™åÊï∞ÊçÆÔºàÂç≥ËßÇÂØüÂ∫èÂàóÔºâÂÖ∑ÊúâÁõ∏ÂÖ≥ÊÄß„ÄÇQÂáΩÊï∞ÁöÑÂæÆÂ∞èÊîπÂèò‰ºöÂºïËµ∑Á≠ñÁï•ÔºàpolicyÔºâÁöÑÂ∑®Â§ßÊîπÂèòÔºåËøõËÄåÊîπÂèòËÆ≠ÁªÉÊï∞ÊçÆÂàÜÂ∏ÉÔºå‰ª•ÂèäQÂáΩÊï∞‰∏éQÂáΩÊï∞ÁõÆÊ†á‰πãÈó¥ÁöÑÂ∑ÆÂÄº„ÄÇÂâçËÄÖÂèØ‰ª•Áî®experience replayËß£ÂÜ≥ÔºàÂèÇËßÅNIPS 2013ËÆ∫ÊñáÔºâ„ÄÇÂêéËÄÖÂèØÈááÁî®Ëø≠‰ª£ÂºèÊõ¥Êñ∞Ôºàiterative updateÔºâËß£ÂÜ≥ÔºàNature 2015ÂºïÂÖ•Ôºâ„ÄÇ ËØ•ÊñπÊ≥ïÂç≥QÂáΩÊï∞ÁöÑÂèÇÊï∞Âè™Âú®‰∏ÄÂÆöÊ≠•Êï∞ÂêéÊâçÊõ¥Êñ∞ÔºåÁõ∏ÂΩì‰∫éÂª∂ËøüÊõ¥Êñ∞Êù•ÂáèÂ∞ëQÂáΩÊï∞ÂíåQÂáΩÊï∞ÁõÆÊ†áÈó¥ÁöÑÁõ∏ÂÖ≥ÊÄß„ÄÇÁõ¥ËßÇ‰∏äÔºåÊï¥‰∏™ËÆ≠ÁªÉÂ≠¶‰π†ËøáÁ®ãÂÖ∂ÂÆûÂ∞±ÊòØQÂáΩÊï∞ÂêëQÂáΩÊï∞ÁõÆÊ†áÈÄºËøëÁöÑËøáÁ®ãÔºåËØïÊÉ≥‰∏ãÔºåÂ¶ÇÊûúÁõÆÊ†á‰πüË∑üÁùÄÂ≠¶‰π†‰Ωì‰∏ÄËµ∑ÂèòÔºåÈÇ£ÂäøÂøÖÂØπÊî∂ÊïõÊÄßÈÄ†ÊàêÂΩ±Âìç„ÄÇ Âà∞ËøôÈáå‰∏∫Ê≠¢ÔºåÂú®QÂ≠¶‰π†ÁöÑÂü∫Á°Ä‰∏äÔºåDQNÁöÑÂ§ßËá¥ÊºîËøõË∑ØÁ∫øÂ¶Ç‰∏ã„ÄÇ ‰πãÂêéÔºåDeepMindÁöÑÂ§ßÁâõ‰ª¨‰∏ÄÂàª‰∏çÂÅúÂú∞Âú®AAAIÔºåICMLÁ≠âÈ°∂Á∫ß‰ºöËÆÆ‰∏≠Áõ∏ÁªßÂØπDQN‰Ωú‰∫ÜÊîπËøõÔºå‰ΩøÂÖ∂ÊàêÁª©‰∏éÊÄßËÉΩÊúâ‰∫ÜË¥®ÁöÑÈ£ûË∑É„ÄÇÊåâÊó∂Èó¥È°∫Â∫è‰∏ªË¶ÅÊúâ‰∏ãÈù¢ËÆ∫ÊñáÔºö AAAI 2016 „ÄäDeep Reinforcement Learning with Double Q-learning„Äã Á†îÁ©∂ËÄÖÂèëÁé∞ÔºåQÂ≠¶‰π†‰∏≠ÁöÑoverestimationÈóÆÈ¢òÔºàÂú®Á°ÆÂÆöÁä∂ÊÄÅ‰∏ãQÂÄº‰º∞ËÆ°ÂÅèÈ´òÔºâÂèØËÉΩÂØºËá¥ÈùûÊúÄ‰ºòËß£ÂíåÂ≠¶‰π†ËøáÁ®ãÁ®≥ÂÆöÊÄß‰∏ãÈôç„ÄÇÊúÄÂàùThrun &amp; SchwartzÂºÄÂßãÊé¢ËÆ®ËØ•ÈóÆÈ¢òÔºåËØÅÊòé‰∫ÜÂú®‰ΩøÁî®ÂáΩÊï∞ÈÄºËøëÂô®Êó∂overestimationÂèØËÉΩÂØºËá¥ÈùûÊúÄ‰ºòËß£„ÄÇ‰πãÂêévan HasseltÂèëÁé∞Âç≥‰ΩøÁî®Ë°®Ê†ºË°®Á§∫Ê≥ïÁöÑÊÉÖÂÜµ‰∏ãÔºåÁéØÂ¢É‰∏≠ÁöÑÂô™Â£∞‰πüËÉΩÂØºËá¥overestimationÔºåÂπ∂‰∏îÊèêÂá∫‰∫ÜËß£ÂÜ≥ÊñπÊ°àDouble Q-learning„ÄÇËÄåDQNÊòØÂü∫‰∫éQ-learningÔºåÊâÄ‰ª•Êú¨Ë¥®‰∏ä‰πüÊúâËøô‰∏™ÈóÆÈ¢ò„ÄÇÂõ†Ê≠§Â∞ÜDouble Q-learningÁªìÂêàËøõDQNÂèØ‰ª•ÊîπÂñÑ„ÄÇÂÖ∂Âü∫Êú¨ÊÄùÊÉ≥ÊòØÂ∞ÜÈÄâÊã©ÂíåËØÑ‰º∞Âä®‰ΩúÂàÜÁ¶ªÔºåËÆ©ÂÆÉ‰ª¨‰ΩøÁî®‰∏çÂêåÁöÑQÂáΩÊï∞ÔºàÁΩëÁªúÔºâ„ÄÇÂÖ∂‰∏≠‰∏Ä‰∏™Áî®‰∫é‰∫ßÁîüË¥™Â©™Á≠ñÁï•Ôºàgreedy policyÔºâÔºåÂè¶‰∏Ä‰∏™Áî®‰∫é‰∫ßÁîüQÂáΩÊï∞‰º∞ËÆ°ÂÄº„ÄÇÂÆûÁé∞Êó∂‰ºöÊúâ‰∏§‰∏™QÂáΩÊï∞ÁΩëÁªúÔºöÂéüDQN‰∏≠ÁöÑQÂáΩÊï∞ÁΩëÁªúÁß∞‰∏∫Âú®Á∫øÁΩëÁªúÔºàonline networkÔºâÔºåÂêéËÄÖÁß∞‰∏∫ÁõÆÊ†áÁΩëÁªúÔºàtarget networkÔºâ„ÄÇÁî±‰∫éNatureÁâàDQNÂ∑≤ÁªèÂºïÂÖ•‰∫ÜÂçïÁã¨ÁöÑQÁõÆÊ†áÁΩëÁªúÔºåÊâÄ‰ª•Double DQNÂØπDQNÊû∂ÊûÑÂü∫Êú¨‰∏çÈúÄ‰ªÄ‰πàÊîπÂä®ÔºåÂè™ÈúÄÊääÁõÆÊ†áÁΩëÁªúÁöÑÂèÇÊï∞ÂíåÂú®Á∫øÁΩëÁªúÁöÑÂèÇÊï∞Áã¨Á´ãËÆ≠ÁªÉÂç≥ÂèØ„ÄÇÊ≥®ÊÑèÂíåÊú¨ÊñáÊñπÊ≥ïÁõ∏ÊØîÔºåNature 2015‰∏äÁöÑÊñπÊ≥ïÁõ∏ÂΩì‰∫éÊòØÂèÇÊï∞ÁöÑÂª∂ËøüÊõ¥Êñ∞ÔºåÂú®Âêå‰∏ÄÊ≠•Êõ¥Êñ∞ÁöÑÂä®‰ΩúÈÄâÂèñÂíåÂáΩÊï∞‰º∞ËÆ°‰∏≠ËøòÊòØÁî®ÁöÑÂêå‰∏Ä‰∏™ÂèÇÊï∞„ÄÇ ICLR 2016„ÄäPrioritized Experience Replay„Äã Âú®RL‰∏éDLÁªìÂêàÁöÑÂÆûË∑µ‰∏≠Ëµ∑Âà∞ÊØîËæÉÂÖ≥ÈîÆ‰ΩúÁî®ÁöÑexperience replayÁÆóÊ≥ïÁÅµÊÑüÂèØ‰ª•ËØ¥ÈÉ®ÂàÜÊù•Ëá™ÁîüÁâ©Â≠¶ÔºåÂÆÉÁ±ª‰ºº‰∫éÂ§ßËÑë‰∏≠Êµ∑È©¨‰ΩìÂú®Êàë‰ª¨‰ºëÊÅØÁöÑÊó∂ÂÄôÂ∞ÜËøëÊúüÁöÑÁªèÈ™åÂõûÊîæÂä†Ê∑±Âç∞Ë±°ÁöÑÊú∫Âà∂„ÄÇÊúÄÂéüÂßãÁöÑRLÊòØÊØèÊ¨°ËßÇÂØüÂà∞‰∏ÄÊ¨°Áä∂ÊÄÅËΩ¨ÁßªÔºàË°®Á§∫‰∏∫s, a, R, Œ≥, S'ÔºâÂè™Êõ¥Êñ∞‰∏ÄÊ¨°ÂèÇÊï∞„ÄÇËøôÊ†∑‰∏ÄÊù•ÊúâÂá†‰∏™ÈóÆÈ¢òÔºö1. ÂèÇÊï∞Êõ¥Êñ∞ÂÖ∑ÊúâÊó∂Èó¥‰∏äÁöÑÁõ∏ÂÖ≥ÊÄßÔºåËøô‰∏éÈöèÊú∫Ê¢ØÂ∫¶‰∏ãÈôçÁÆóÊ≥ïÁöÑÂÅáËÆæ‰∏çÁ¨¶„ÄÇ2. ÈÇ£‰∫õÂá∫Áé∞Ê¨°Êï∞Â∞ëÁöÑÁä∂ÊÄÅËΩ¨ÁßªÔºàÁªèÈ™åÔºâÂæàÂø´Â∞±‰ºöË¢´‚ÄúÈÅóÂøò‚ÄùÊéâ„ÄÇDQN‰∏≠‰ΩøÁî®‰∫Üexperience replayÊù•ÁºìËß£Ëøô‰∏§‰∏™ÈóÆÈ¢ò„ÄÇËØ•ÊñπÊ≥ï‰∏ç‰ªÖÁ®≥ÂÆö‰∫ÜÂáΩÊï∞ËÆ≠ÁªÉËøáÁ®ãÔºå‰πüÊèêÈ´ò‰∫ÜÁªèÈ™åÊï∞ÊçÆÁöÑÂà©Áî®Áéá„ÄÇÁº∫ÁÇπÊòØÈúÄË¶ÅÊõ¥Â§öÂÜÖÂ≠òÊù•Â≠òÂÇ®ÁªèÈ™åÊ±†Ôºàexperience poolÔºâ„ÄÇ ËøôÁßçÊñπÊ≥ïÁöÑÊïàÊûúÂæàÂ•ΩÔºå‰ΩÜÁõÆÂâçÁöÑÂÅöÊ≥ïËøòÊòØÂØπ‰ª•ÂæÄÁªèÈ™åÂùáÂåÄÈááÊ†∑ÁöÑ„ÄÇ‰∏ã‰∏ÄÊ≠•Ëá™ÁÑ∂ÊòØÊ†πÊçÆÁªèÈ™åÁöÑÈáçË¶ÅÁ®ãÂ∫¶ËøõË°åÊúâ‰æßÈáçÁöÑreplay„ÄÇ Âú®RLÈ¢ÜÂüüÔºå‰∏ä‰∏™‰∏ñÁ∫™90Âπ¥‰ª£Â∞±ÊúâÁ±ª‰ººÁöÑÊÉ≥Ê≥ïÔºåÂç≥prioritized sweepingÔºåÂ∫îÁî®Âú®model-basedÁöÑËßÑÂàíÈóÆÈ¢ò‰∏≠„ÄÇÁõ¥Ëßâ‰∏äÔºåÊàë‰ª¨Áü•ÈÅì‰∏ÄÈÉ®ÂàÜÁªèÈ™åÊØîÂÖ∂ÂÆÉÁªèÈ™åË¶ÅÂØπÂèÇÊï∞ÁöÑËÆ≠ÁªÉ‰∫ßÁîüÊõ¥Â§ßÁöÑ‰ΩúÁî® „ÄÇÂü∫‰∫éÊ≠§ÔºåËØ•ÊñπÊ≥ïÁöÑÂü∫Êú¨ÊÄùÊÉ≥ÊòØ‰ΩøÂèÇÊï∞Êõ¥Êñ∞ÂÄæÂêë‰∫é‰ΩøÂÄº‰º∞ËÆ°ÂèòÂåñÊõ¥Â§ßÁöÑÁªèÈ™å„ÄÇËÄåÊÄé‰πàË°°ÈáèÂì™‰∫õÁªèÈ™åÂØπÂÄº‰º∞ËÆ°ÁöÑË¥°ÁåÆÂë¢ÔºåËøôÂ∞±ÈúÄË¶ÅÊúâÂÆöÈáèÁöÑÊµãÂ∫¶„ÄÇÂú®model-freeÁöÑÂú∫ÊôØ‰∏≠ÔºåËøô‰∏™ÊµãÂ∫¶‰∏ÄËà¨ÈÄâÁî®TD error„ÄÇÂÖ∑‰ΩìÂú∞ÔºåTD errorË∂äÂ§ßÔºå‰πüÂ∞±ÊòØexpected learning progressË∂äÈ´òÁöÑÁªèÈ™åÊï∞ÊçÆÔºåÂèØ‰ª•ËÆ©ÂÆÉ‰ª¨replayÁöÑÊ¨°Êï∞Ë∂äÈ¢ëÁπÅ„ÄÇÂü∫‰∫éËøôÁßçÊÄùÊÉ≥ÂÆûÁé∞ÁöÑgreedy TD-error prioritizationÁÆóÊ≥ïÂ∞ÜÁªèÈ™åÊï∞ÊçÆÂíåÂÖ∂TD errorÊåâÂ∫èÂ≠òÂú®replay memory‰∏≠ÔºåÊØèÊ¨°ÂèñÊúÄÂ§ßTD errorÁöÑÁªèÈ™åËøõË°åreplayÔºåÂêåÊó∂ÂèÇÊï∞Êõ¥Êñ∞ÁöÑÈáè‰πü‰∏é‰πãÂêåÊØî„ÄÇÂè¶Â§ñÊñ∞ÁöÑÁªèÈ™å‰ºöËÆæÊàêÊúÄÂ§ß‰ºòÂÖàÁ∫ß‰ª•‰øùËØÅÂÆÉËá≥Â∞ëË¢´ËÆ≠ÁªÉ‰∏ÄÊ¨°„ÄÇ ËÆ∫ÊñáËøòÊèêÂà∞ËøôÁßçÂÅöÊ≥ï‰ºöÂØºËá¥loss of diversityÈóÆÈ¢òÂíåÂºïÂÖ•biasÔºå‰ΩÜÊñá‰∏≠ÂàÜÂà´Áî®stochastic prioritizationÂíåimportance samplingÊñπÊ≥ïÊù•ÂáèËΩªÂíåÁ∫†Ê≠£„ÄÇÊÄªÂæóÊù•ËØ¥ÔºåÊåâÊñáÁöÑÂéüËØùËØ¥Ôºåexperience replay‰ΩøÂæóÂèÇÊï∞ÁöÑÊõ¥Êñ∞‰∏çÂÜçÂèóÈôê‰∫éÂÆûÈôÖÁªèÈ™åÁöÑÈ°∫Â∫èÔºåprioritized experience replayÁªßËÄå‰Ωø‰πã‰∏çÂÜçÂèóÈôê‰∫éÂÆûÈôÖÁªèÈ™åÁöÑÂá∫Áé∞È¢ëÁéá„ÄÇ ICML 2016„ÄäDueling Network Architectures for Deep Reinforcement„Äã ËøôÁØáËÆ∫ÊñáÊèêÂá∫‰∫ÜÈíàÂØπmodel-free RLÁöÑdueling networkÊ°ÜÊû∂„ÄÇÂÆÉÊòØÂØπ‰º†ÁªüDQNÊû∂ÊûÑÂ±ÇÈù¢‰∏äÁöÑÊîπÂä®ÔºåÂ∞ÜÂü∫‰∫éÁä∂ÊÄÅÁöÑVÂáΩÊï∞Ôºàvalue functionÔºâÂíåÁä∂ÊÄÅÁõ∏ÂÖ≥ÁöÑadvantageÂáΩÊï∞Ôºàadvantage functionÔºâÂàÜÁ¶ª„ÄÇAdvantageÂáΩÊï∞ÁöÑÊÄùÊÉ≥Âü∫‰∫é1993Âπ¥BairdÊèêÂá∫ÁöÑadvantage updating„ÄÇÈô§‰∫Ü‰º†ÁªüÁöÑVÂáΩÊï∞Â§ñÔºåÂºïÂÖ•ÁöÑadvantageÂáΩÊï∞ A(x, u)ÁöÑÂÆö‰πâÊòØÂΩìÈááÂèñÂä®‰ΩúuÁõ∏ÊØî‰∫éÈááÂèñÂΩìÂâçÊúÄ‰ºòÂä®‰ΩúËÉΩÂ§öÂ∏¶Êù•Â§öÂ∞ëÁ¥ØÁßØÊäòÊâ£ÂõûÊä•„ÄÇÁÆÄÂçïÁ≤óÊö¥ÂæóËØ¥ÔºåÂ∞±ÊòØÈÄâËøô‰∏™Âä®‰ΩúÊØîÂΩìÂâçÊúÄ‰ºòÂä®‰ΩúÔºàÊàñÂÖ∂ÂÆÉÂä®‰ΩúÔºâÂ•ΩÂ§öÂ∞ë„ÄÇ Âü∫‰∫éËøô‰∏™ÊÄùÊÉ≥ÔºåÂêå‰∏Ä‰∏™ÁΩëÁªú‰ºöÂêåÊó∂‰º∞ËÆ°VÂáΩÊï∞ÂíåadvantageÂáΩÊï∞ÔºåÂÆÉ‰ª¨ÁªìÂêàËµ∑Êù•ÂèØ‰ª•ÂæóÂà∞QÂáΩÊï∞„ÄÇ‰ªéÊû∂ÊûÑ‰∏äÊù•ËØ¥ÔºåËøôÊòØ‰∏Ä‰∏™‰∏ÄÂàÜ‰∏∫‰∫åÔºåÂÜçÂêà‰∫å‰∏∫‰∏ÄÁöÑËøáÁ®ã„ÄÇÂÆÉÁöÑÂá∫ÂèëÁÇπÊòØÂõ†‰∏∫ÂØπ‰∫éÂæàÂ§öÁä∂ÊÄÅÔºåÂÖ∂ÂÆûÂπ∂‰∏çÈúÄË¶Å‰º∞ËÆ°ÊØè‰∏™Âä®‰ΩúÁöÑÂÄº„ÄÇÂèØ‰ª•È¢ÑËßÅÂà∞ÔºåÂºïÂÖ•advantageÂáΩÊï∞ÂêéÔºåÂØπ‰∫éÊñ∞Âä†ÂÖ•ÁöÑÂä®‰ΩúÂèØ‰ª•ÂæàÂø´Â≠¶‰π†ÔºåÂõ†‰∏∫ÂÆÉ‰ª¨ÂèØ‰ª•Âü∫‰∫éÁé∞ÊúâÁöÑVÂáΩÊï∞Êù•Â≠¶‰π†„ÄÇÂÆÉÁõ¥Ëßâ‰∏äÁöÑÊÑè‰πâÂú®‰∫éÂ∞ÜQÂáΩÊï∞ÁöÑ‰º∞ËÆ°ÂàÜ‰∏∫‰∏§Ê≠•„ÄÇËøôÊ†∑ÔºåÂèØ‰ª•ÂÖà‰º∞ËÆ°Âì™‰∫õÁä∂ÊÄÅÊõ¥ËÉΩËé∑ÂæóÊõ¥Â§öÂõûÊä•ÔºåËÄå‰∏çÂèóËØ•Áä∂ÊÄÅ‰∏ã‰∏çÂêåÂä®‰ΩúÁöÑÂπ≤Êâ∞„ÄÇÊñá‰∏≠‰∏æ‰∫ÜÂÖ∏ÂûãÁöÑËµõËΩ¶Ê∏∏ÊàèÁöÑ‰æãÂ≠ê„ÄÇÂèØ‰ª•ÁúãÂà∞VÂáΩÊï∞‰∏ìÊ≥®‰∫éËøúÂ§ÑÔºàÂú∞Âπ≥Á∫øÔºâÂíåÂàÜÊï∞Ôºå‰πüÂ∞±ÊòØÈïøÊúüÁõÆÊ†áÔºåadvantageÂáΩÊï∞‰∏ìÊ≥®‰∫éÈôÑËøëÈöúÁ¢çÔºå‰πüÂ∞±ÊòØÁü≠ÊúüÁõÆÊ†á„ÄÇËøôËØ¥ÊòéVÂáΩÊï∞ÂíåadvantageÂáΩÊï∞ÂàÜÂà´Â≠¶‰π†Âà∞‰∫Ü‰∏§‰∏™Â±ÇÊ¨°ÁöÑÁ≠ñÁï•„ÄÇËøôÁßçÂàÜÂ±ÇÂ≠¶‰π†ÁöÑÂÅöÊ≥ïÊúâÂá†‰∏™Â•ΩÂ§ÑÔºö‰∏ÄÊòØVÂáΩÊï∞ÂèØ‰ª•ÂæóÂà∞Êõ¥Â§öÁöÑÂ≠¶‰π†Êú∫‰ºöÔºåÂõ†‰∏∫‰ª•ÂæÄ‰∏ÄÊ¨°Âè™Êõ¥Êñ∞‰∏Ä‰∏™Âä®‰ΩúÂØπÂ∫îÁöÑQÂáΩÊï∞„ÄÇ‰∫åÊòØVÂáΩÊï∞ÁöÑÊ≥õÂåñÊÄßÊõ¥Â•ΩÔºåÂΩìÂä®‰ΩúË∂äÂ§öÊó∂‰ºòÂäøË∂äÊòéÊòæ„ÄÇÁõ¥ËßÇ‰∏äÁúãÔºåÂΩìÊúâÊñ∞Âä®‰ΩúÂä†ÂÖ•Êó∂ÔºåÂÆÉÂπ∂‰∏çÈúÄË¶Å‰ªéÈõ∂ÂºÄÂßãÂ≠¶‰π†„ÄÇ‰∏âÊòØÂõ†‰∏∫QÂáΩÊï∞Âú®Âä®‰ΩúÂíåÁä∂ÊÄÅÁª¥Â∫¶‰∏äÁöÑÁªùÂØπÊï∞ÂÄºÂæÄÂæÄÂ∑ÆÂæàÂ§öÔºåËøô‰ºöÂºïËµ∑Âô™Â£∞ÂíåË¥™Â©™Á≠ñÁï•ÁöÑÁ™ÅÂèòÔºåËÄåÁî®ËØ•ÊñπÊ≥ïÂèØ‰ª•ÊîπÂñÑËøô‰∏™ÈóÆÈ¢ò„ÄÇ Â∞ÜËøô‰∫õÊîπËøõËÄÉËôëËøõÂéªÔºåÊàë‰ª¨ÂèØ‰ª•Êää‰∏äÈù¢ÁöÑÂõæÂÜçÂª∂‰º∏Âá∫ÂéªÔºö *** Nature 2016 „ÄäMastering the game of Go with deep neural networks and tree search„Äã** DRLÁöÑÁ¨¨‰∫åÊ≥¢È´òÊΩÆÂΩìÂ±ûNature 2016 ‰∏äÁöÑËÆ∫Êñá„ÄäMastering the Game of Go with Deep Neural Networks and Tree Search„ÄãÔºåÂÖ∂‰∏≠ÂèëË°®‰∫ÜAlphaGoÁöÑÁõ∏ÂÖ≥ÊàêÊûú„ÄÇÂÆÉÂ∫îÁî®‰∫ÜDRLÊäÄÊúØÂ∞ÜÂõ¥Ê£ãÊô∫ËÉΩÊ∞¥Âπ≥ËææÂà∞‰∫Ü‰∏Ä‰∏™ÂÖ®Êñ∞ÁöÑÈ´òÂ∫¶„ÄÇÊàë‰ª¨ÈÉΩÁü•ÈÅìÂú®ËøôÁ±ª‰ø°ÊÅØÂÆåÂÖ®ÂçöÂºàÊ∏∏Êàè‰∏≠‰∫∫Â∑•Êô∫ËÉΩËøüÊó©‰ºöÊàòËÉú‰∫∫ÔºàÂõ†‰∏∫Âú®Á±ª‰ºº‰∫éÂêØÂèëÂºèÊêúÁ¥¢ÈóÆÈ¢ò‰∏äÔºå‰∫∫ÁöÑÊô∫ËÉΩ‰ºöÂèóÂà∞Â§ßËÑëÂºÄÂèëÁöÑÁîüÁêÜÊûÅÈôêÈôêÂà∂ÔºåËÄåËÆ°ÁÆóËÉΩÂäõÁöÑÂèëÂ±ïÂèØ‰ª•‰ª•Êï∞ÈáèÁ∫ßÈÄüÂ∫¶Â¢ûÈïøÔºåÂÜçÂä†‰∏äÊúâÂêàÈÄÇÁöÑÊñπÊ≥ïÂá∫Áé∞Â∞±ÂèØ‰ª•‰ΩøÂÖ∂ÊêúÁ¥¢ÊïàÁéáÊûÅÂ§ßÊèêÈ´òÔºâÔºå‰ΩÜAlphaGo‰ºº‰πéËÆ©ÂÆÉÊèêÂâç‰∫ÜÂ•ΩÂ§öÂπ¥ÂÆûÁé∞„ÄÇAlphaGoËôΩÁÑ∂‰πüÂü∫‰∫éDRLÔºå‰ΩÜÂÖ∂ÊÑè‰πâ‰∏é‰πãÂâçÂü∫‰∫éDQNÁöÑÂ∑•‰ΩúÂ§ßÁõ∏ÂæÑÂ∫≠ÔºåÂê¶Âàô„ÄäNature„Äã‰πü‰∏ç‰ºöËÆ©ÂÆÉÂèë‰∏§Ê¨°„ÄÇÂ¶ÇÊûúËØ¥‰πãÂâçÁöÑÊúÄÂºÄÂßãÊèêÂá∫ÁöÑDQNËøòÊòØ‰∏ÄÁßçÁÆóÊ≥ïÁöÑËØùÔºåAlphaGoËøôÊó∂Â∞±Â∑≤ÁªèÊòØ‰∏ÄÂ•ó‰∏∫Âõ¥Ê£ãÁ≤æÂøÉËÆæËÆ°ÁöÑÁÆóÊ≥ïÊ°ÜÊû∂‰∫Ü„ÄÇÂâçÈù¢ÊèêÂà∞ËøáÔºåDQNÁöÑÊÑè‰πâÂú®‰∫éÁÆóÊ≥ïÂÖ∑ÊúâÈÄöÁî®ÊÄßÔºåËÄåAlphaGoÁöÑÊÑè‰πâÂú®‰∫éÂõ¥Ê£ãÈóÆÈ¢òÊú¨Ë∫´ÁöÑÊêúÁ¥¢Á©∫Èó¥ÈùûÂ∏∏‰πãÂ§ßÔºåÂêåÊó∂‰πüÊòØÁªèÂÖ∏ÁöÑNP-hardÈóÆÈ¢ò„ÄÇAlphaGoÈÄöËøáËíôÁâπÂç°Ê¥õÊêúÁ¥¢Ê†ëÔºàMonte-Carlo Tree SearchÔºåMCTSÔºâÂíåDRLÁªìÂêà‰ΩøÂæóËøô‰∏™Â§ßËßÑÊ®°ÊêúÁ¥¢ÈóÆÈ¢òÂú®ÂèØËÆ°ÁÆóËåÉÂõ¥ÂÜÖ„ÄÇÂÆÉÊ≤°ÊúâÁî®raw pixels‰ΩúËæìÂÖ•Ôºà‰πüÊó†ÂøÖË¶ÅÔºâÔºåËÄåÊòØ‰ΩøÁî®‰∫∫Â∑•ËÆæËÆ°ÁöÑÁâπÂæÅÁî®‰∫épolicy networkÂíåvalue networkÁöÑËÆ≠ÁªÉ„ÄÇÂÖ∂ÂÆûAlphaGoÊõ¥Â§öÊòØ‰∏™Â∑•Á®ã‰∏äÁöÑÊù∞‰Ωú„ÄÇÂÆÉÂü∫‰∫éÂâçÈù¢ÁöÑDRLÂü∫Á°Ä‰∏äÔºåÂÅö‰∫ÜÂæàÂ§öÈíàÂØπÂõ¥Ê£ãÈóÆÈ¢òÁöÑÁâπÊúâÊäÄÊúØÔºå‰∏îÁî®‰∫ÜÂàÜÂ∏ÉÂºèÁöÑÊäÄÊúØÂä†ÈÄüËÆ°ÁÆó„ÄÇÊÄª‰πãÔºåÂÆÉ‰ª¨Ë¶ÅÂ±ïÁ§∫ÁöÑÊòØDRL‰∏§ÊñπÈù¢ÁöÑËÉΩÂäõÔºåDQNÊòØÁÆóÊ≥ïÁöÑÈÄöÁî®ËÉΩÂäõÔºåAlphaGoÊòØÂØπ‰∫éÂèòÊÄÅÁ∫ßËßÑÊ®°ÊêúÁ¥¢ÈóÆÈ¢òÁöÑËÆ°ÁÆóÊúâÊïàÊÄß„ÄÇ AlphaGoÁöÑÂ§ß‰ΩìÊÄùÊÉ≥ÊòØ‰ΩøÁî®value networkÊù•ËØÑ‰º∞Ê£ãÁõò‰ΩçÁΩÆÔºåÁî®policy networkÊù•ÈÄâÊã©Âä®‰ΩúÔºåÂêåÊó∂ÁªìÂêà‰∫ÜÁõëÁù£Â≠¶‰π†ÂíåDRLÊäÄÊúØ„ÄÇÂÆÉËøòÂºïÂÖ•‰∫Ü‰∏ÄÁßçÁªìÂêàMCÊ®°ÊãüÂíåvalue/policy networkÁöÑÊêúÁ¥¢ÁÆóÊ≥ï„ÄÇ Êû∂ÊûÑ‰∏äÔºåvalue networkÁî®‰∫éËØÑ‰º∞‰ΩçÁΩÆÔºåpolicy networkÁî®‰∫éÈááÊ†∑Âä®‰Ωú„ÄÇÊµÅÁ®ã‰∏äÔºåÂ≠¶‰π†ÂàÜ‰∏∫Âá†‰∏™Èò∂ÊÆµÔºöÁ¨¨‰∏ÄÈò∂ÊÆµÂü∫‰∫é‰∫∫Á±ª‰∏ìÂÆ∂ÁöÑÊï∞ÊçÆÈõÜÈÄöËøáÁõëÁù£Â≠¶‰π†ËÆ≠ÁªÉSL policy network„ÄÇÂè¶Â§ñËÆ≠ÁªÉ‰∏Ä‰∏™ÂçïÁã¨ÁöÑÁ≠ñÁï•Áî®‰∫éÂú®‰πãÂêéÁöÑrollout‰∏≠Âø´ÈÄüÈÄâÂèñÂä®‰Ωú„ÄÇËøô‰∏ÄÊ≠•Êõ¥Â§öÊòØ‰∏∫‰∫ÜÁªìÂêà‰∫∫Á±ªÂ∑≤ÊúâÁªèÈ™åÔºàÊØïÁ´üÁ∫ØÈù†Ëá™Â≠¶‰π†Êúâ‰∫õÊÖ¢ÔºâÔºåÁî®‰∫éÂêéÈù¢Âá†Ê≠•‰ΩúÂÖàÈ™åÁü•ËØÜ„ÄÇÊé•ÁùÄÔºåÂ∞ÜSL policy networkÁöÑÂèÇÊï∞Êù•ÂàùÂßãÂåñRL policy network ÔºàËØ•policy networkÁî®‰∫é‰πãÂêéÂú®RL‰∏≠ÈÄöËøáself-playÂÅöÁ≠ñÁï•ÊêúÁ¥¢Ôºâ„ÄÇÁ¨¨‰∫åÈò∂ÊÆµÊòØÈÄöËøáRLÁöÑpolicy gradientÊñπÊ≥ïÂ≠¶‰π†Á≠ñÁï•ÔºåÈÄöËøáÈöèÊú∫Ê¢ØÂ∫¶‰∏äÂçáÔºàStochastic gradient ascentÔºâÁÆóÊ≥ïÊù•Êõ¥Êñ∞RL policy networkÂèÇÊï∞„ÄÇÁ¨¨‰∏âÈò∂ÊÆµÔºåÂ≠¶‰π†value networkÁî®‰∫éÈ¢ÑÊµãRL policy networkÁé©Ê∏∏ÊàèÊó∂ÁöÑËÉúÁÆóÔºåËøô‰∏ÄÊ≠•‰ΩøÁî®ÈöèÊú∫Ê¢ØÂ∫¶‰∏ãÈôçÔºàStochastic gradient descentÔºåSGDÔºâÊù•ÊúÄÂ∞èÂåñoutcomeÔºàÂØπÂΩìÂâçÁä∂ÊÄÅËÄåË®ÄÂõ¥Ê£ãÁªìÊùüÊó∂ÁöÑÂõûÊä•ÔºåÂç≥ËæìËµ¢Ôºâ‰∏éVÂáΩÊï∞‰πãÈó¥ÁöÑÂ∑ÆÔºàÁî®MSEË°®Á§∫Ôºâ„ÄÇÊúÄÂêéÔºåÁ¨¨ÂõõÈò∂ÊÆµ‰∏≠ÔºåÊúâ‰∫Ü‰∏äÈù¢ÁöÑpolicy networkÂíåvalue networkÔºåÂ∞±ÂèØ‰ª•ÊçÆÊ≠§Áî®MCSTÊù•ËøõË°åÊêúÁ¥¢‰∫Ü„ÄÇ Âú®ÊúÄÂêé‰∏Ä‰∏™Èò∂ÊÆµ‰∏≠ÔºåÁÆóÊ≥ï‰ºöÈÄöËøáMCÊ®°Êãü‰ªéÊ†πÁä∂ÊÄÅÊù•ÂæÄ‰∏ãÂçïÂêëÈÅçÂéÜÊêúÁ¥¢Ê†ëÔºåËøô‰∏ÄÈò∂ÊÆµÂèàÂèØ‰ª•ÂàÜ‰∏∫ÈÄâÂèñÔºàselectionÔºâÔºåÊâ©Â±ïÔºàexpansionÔºâÔºåËØÑ‰º∞ÔºàevaluationÔºâÂíåÂõûÊ∫ØÔºàbackupÔºâÂõõÊ≠•„ÄÇËøôÂÖ∂ÂÆû‰πüÊòØMCSTÁÆóÊ≥ïÊ°ÜÊû∂‰∏≠ÁöÑÁªèÂÖ∏ÁöÑÂõõ‰∏™Ê≠•È™§„ÄÇÂè™ÊòØAlphaGoÂú®Ëøô‰∏™MCTSÁÆóÊ≥ï‰∏≠ÁªìÂêà‰∫ÜpolicyÂíåvalue network„ÄÇÂÖ∂‰∏≠ÈÄâÂèñËøôÊ≠•Âü∫‰∫éÂâçÈù¢ÁöÑvalue networkÂèñQÂáΩÊï∞ÂÄºÊúÄÂ§ßÁöÑÂä®‰Ωú„ÄÇÊ≥®ÊÑèËøô‰∏ÄÊ≠•‰ΩøÁî®ÁöÑÊòØUCTÊóèÁÆóÊ≥ïÔºåÂÆÉÂú®Âä®‰ΩúÈÄâÂèñÊó∂Èô§QÂáΩÊï∞ÂÄºËøò‰ºöËÄÉËôë‰∏Ä‰∏™‰ª£Ë°®Êú™Áü•Á®ãÂ∫¶ÁöÑÈáèÔºåÁî®‰∫éËß£ÂÜ≥ËëóÂêçÁöÑexploration-exploitationÈóÆÈ¢ò„ÄÇÊØïÁ´üÔºåÊàë‰ª¨ÁöÑÊúüÊúõÊòØÁ®ãÂ∫è‰∏ç‰ªÖ‰ªÖÊòØÂ§çÂà∂‰∫∫Á±ªÁöÑÁªèÈ™åÔºåËÄå‰∏îËÉΩÂ§üË∂ÖË∂ä„ÄÇÁ¨¨‰∫åÊ≠•Êâ©Â±ïÊòØÈíàÂØπÊêúÁ¥¢Ê†ë‰∏≠ÁöÑÂè∂Â≠êÁªìÁÇπÔºå‰ΩøÁî®ÁöÑÊòØRL policy network‰∏≠Â≠¶‰π†Âà∞ÁöÑÁ≠ñÁï•„ÄÇÁ¨¨‰∏âÊ≠•ËØÑ‰º∞Êúâ‰∏§ÁßçÂÆåÂÖ®‰∏çÂêåÁöÑÊñπÂºèÔºö1. ÈÄöËøávalue network„ÄÇ2.ÈÄöËøáÈöèÊú∫rolloutÁõ¥Âà∞ÁªìÊùüÔºà‰ΩøÁî®fast rollout policyÔºå‰πüÂ∞±ÊòØ‰πãÂâçÁöÑSL policy networkÔºâÊâÄÂæóÂà∞ÁöÑÂõûÊä•„ÄÇËøô‰∏§ËÄÖÂèØÈÄöËøáÂèÇÊï∞ËøõË°åË∞ÉÂíå„ÄÇÊúÄÂêéÂõûÊ∫ØËøôÊ≠•Âç≥Ê†πÊçÆÂâçÈù¢ÁöÑÊêúÁ¥¢ËøõË°åQÂáΩÊï∞Êõ¥Êñ∞„ÄÇ ÊÄªÂæóÊù•ËØ¥ÂèØ‰ª•Â§ß‰ΩìÊ¶ÇÊã¨‰∏∫‰∏ãÂõæÔºö ÂèØ‰ª•ÁúãÂà∞Ôºå‰ªäÂ§©ÁöÑÁöÑ‰∫∫Â∑•Êô∫ËÉΩÂíåÊú∫Âô®Â≠¶‰π†È¢ÜÂüüÔºåÂ∑•Á®ãÂíåÂ≠¶ÊúØÂêåÊ†∑ÈáçË¶Å„ÄÇ‰∏ÄÊñπÈù¢ÂèØËÉΩÂõ†‰∏∫DLÁöÑÁâπÊÆäÊÄßÔºåÊØïÁ´üÂÆÉÂü∫‰∫éÁöÑÁ•ûÁªèÁΩëÁªú‰ªé‰∏ÄÂºÄÂßãÂ∞±ÊòØÂÅèÂ∑•Á®ãÁöÑÔºõÂè¶‰∏ÄÊñπÈù¢‰ªäÂ§©ÁöÑÂ∑•‰∏ö‰∏éÂ≠¶ÊúØÁªìÂêàÊõ¥Âä†Á¥ßÂØÜÔºå‰∫ß‰∏öÂåñÈÄüÂ∫¶Â§ßÂ§ßÂä†Âø´„ÄÇÊØîÂ¶ÇDRLÁöÑideaÂæàÂ•ΩÔºå‰ΩÜÂâçÊèêÊòØË¶ÅÊúâÂ∑•Á®ãËÉΩÂäõËØÅÊòéÂÆÉÂ•Ω„ÄÇÂç≥‰ΩøÊúâ‰∫∫Êó©Âá†Âπ¥ÊÉ≥Âà∞‰∫ÜËøô‰∏™ideaÔºåÂÆÉ‰ªç‰∏ç‰∏ÄÂÆöËÉΩ‰ΩøÂÆÉÂèëÂú®NatureËøôÊ†∑ÁöÑÈ´òÁ∫ßÂà´ÂàäÁâ©‰∏ä„ÄÇÂõ†‰∏∫‰ªäÂ§©ÁöÑDRLÊòØÂ∑•Á®ãÂíåÂ≠¶ÊúØÁöÑÂÖÖÂàÜÁªìÂêà„ÄÇÂè¶Â§ñÔºåËøôËøòÊèêÈÜíÊàë‰ª¨Ë¶ÅÈáçËßÜÂ≠¶ÁßëÊàñËÄÖËØ¥ÊòØÊñπÂêëÁöÑ‰∫§Âèâ„ÄÇÂæàÂ§öÊó∂ÂÄôÔºå‰∏ÄÁØáËÆ∫ÊñáÁöÑÂ≠¶ÊúØ‰ª∑ÂÄºÂèñÂÜ≥‰∫éÂÆÉËÉΩÁªôÂêé‰∫∫ÁïôÂ§öÂ∞ëÂèØ‰ª•ÁªßÁª≠Ê∑±Á©∂ÁöÑ‰∏úË•ø„ÄÇÈô§‰∫ÜÈÇ£‰∫õËÉΩËá™Êàê‰∏ÄÊ¥æÁöÑÊûÅÁ´ØÁâõ‰∫∫ÔºåÂ§ßÂ§öÊï∞Êó∂ÂÄôËÉΩËøûÊé•‰∏§‰∏™ÊàñÂ§ö‰∏™ÊñπÂêëÂπ∂ËØÅÊòéÂÖ∂‰ª∑ÂÄºÊâÄÂ∏¶Êù•ÁöÑÂΩ±ÂìçÂ∞±ÈùûÂ∏∏Ê∑±Ëøú‰∫Ü„ÄÇ]]></content>
      <categories>
        <category>Êú∫Âô®Â≠¶‰π†</category>
      </categories>
      <tags>
        <tag>Êú∫Âô®Â≠¶‰π†</tag>
        <tag>Âº∫ÂåñÂ≠¶‰π†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeÈ¢òËß£]]></title>
    <url>%2F2018%2F07%2F01%2FLeetCode%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[ÊúÄËøëÂÜô‰∫Ü‰∏Ä‰∏ãLeetCodeÔºåÊú¨ËèúüêîÂèëÁé∞LeetCode‰∏äÊúâ‰∫õÈ¢òÁõÆË¥®ÈáèËøòÊòØÊå∫È´òÁöÑÔºåÈúÄË¶Å‰ªîÁªÜÊÄùËÄÉÊÄùËÄÉÔºåÊâçËÉΩÊÉ≥Âà∞ÊØîËæÉÈ´òÊïàÁöÑÁöÑËß£Ê≥ï„ÄÇ Â∑≤ÁªèÂÜô‰∫ÜÂâç‰∏§ÁôæÈ¢ò‰∫ÜÔºå‰ª£Á†ÅÂú® GitHubÔºåÂè™Êï¥ÁêÜ‰∫ÜÈÉ®ÂàÜ‰ª£Á†ÅÔºåÂâ©‰∏ãÁöÑ‰ª£Á†Å‰ºöÈôÜÁª≠‰∏ä‰º†ÁöÑ„ÄÇ ‰πãÂêé‰ºöÈÄâÂá†ÈÅìÊàëÂÅöÁöÑËøáÁ®ã‰∏≠ÊúâÈóÆÈ¢òÊàñËÄÖÊàëËá™ËÆ§‰∏∫ÊØîËæÉÂ•ΩÁöÑÈ¢òÁõÆÂÜô‰∏ÄÂÜôÂàÜÊûê„ÄÇ]]></content>
      <categories>
        <category>Êú∫ËØï</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Êú∫ËØï</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÊµôÂ§ßÁ†îÁ©∂ÁîüÊú∫ËØï21-30È¢ò]]></title>
    <url>%2F2018%2F06%2F26%2F%E6%B5%99%E5%A4%A7%E7%A0%94%E7%A9%B6%E7%94%9F%E6%9C%BA%E8%AF%9521-30%E9%A2%98%2F</url>
    <content type="text"><![CDATA[ÁªüËÆ°ÂêåÊàêÁª©Â≠¶Áîü‰∫∫Êï∞ È¢òÁõÆÈìæÊé• ‰ª£Á†Å 12345678910111213141516171819202122232425262728/** @Author: sun000* @Date: 2018-06-25 16:12:55* @Last Modified by: sun000* @Last Modified time: 2018-06-25 16:15:53*/#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int s[105];int main() &#123; int n, tmp; while(scanf("%d", &amp;n) != EOF &amp;&amp; n) &#123; memset(s, 0, sizeof(s)); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;tmp); s[tmp]++; &#125; int tar; scanf("%d", &amp;tar); printf("%d\n", s[tar]); &#125; return 0;&#125; ÁªßÁª≠XXXÂÆöÂæã È¢òÁõÆÈìæÊé• ÂàÜÊûê ÊØèËæìÂÖ•‰∏Ä‰∏™Êï∞ÔºåÊ†áËÆ∞ÂÖ∂ËÉΩË¶ÜÁõñÁöÑÊâÄÊúâÊï∞ÊçÆÔºà‰∏çË¶ÅÈáçÂ§çÊ†áËÆ∞ÔºâÔºåÊ≥®ÊÑèÂèòÊç¢ËøáÁ®ã‰∏≠ÁöÑÊï∞ÊçÆ‰ºöÂèòÂæóÈùûÂ∏∏Â§ßÔºåËøôÈáåÊï∞ÊçÆÊ∞¥‰∫ÜÁÇπÔºåÊàëÁõ¥Êé•ÂºÄ‰∫ÜÂ§ßÊï∞ÁªÑÔºåÊúÄÂ•ΩÁî®setÊ†áËÆ∞„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142/** @Author: sun000* @Date: 2018-06-25 16:35:22* @Last Modified by: sun000* @Last Modified time: 2018-06-25 18:14:33*/#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;bool vis[1000005];//Á©∫Èó¥ÂºÄÂ§ß‰∏ÄÁÇπÔºåÊòØÂõ†‰∏∫ËôΩÁÑ∂ËæìÂÖ•‰∏çÂ§ßÔºå‰ΩÜÊòØÂú®ÂèòÊç¢ËøáÁ®ã‰∏≠ÂèØËÉΩ‰ºö‰∏ÄÁõ¥ÂèòÂ§ßint num[505], ans[505];int main(void) &#123; int n; while(scanf("%d", &amp;n) != EOF &amp;&amp; n) &#123; memset(vis, false, sizeof vis); vis[1] = true; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;num[i]); int tmp = num[i]; bool f = vis[tmp]; while(!vis[tmp]) &#123;//‰∏çË¶ÅÈáçÂ§çÊ†áËÆ∞ÔºåÊâÄ‰ª•Ê†áËÆ∞Âà∞Â∑≤ÁªèË¢´Ê†áËÆ∞ÁöÑÊï∞Â∞±Â•Ω‰∫Ü vis[tmp] = true; if(tmp &amp; 1) tmp = tmp * 3 + 1; tmp &gt;&gt;= 1; &#125; vis[num[i]] = f; &#125; int cnt = 0; for(int i = 0; i &lt; n; i++) if(!vis[num[i]]) ans[cnt++] = num[i]; for(int i = cnt - 1; i &gt;= 0; i--) printf("%d%c", ans[i], i == 0 ? '\n' : ' '); &#125; return 0;&#125; Head of a Gang È¢òÁõÆÈìæÊé• ÂàÜÊûê È¢òÊÑèÊùÄÔºåËØªÊáÇÈ¢òÁõÆÂ∞±Â•Ω‰∫ÜÔºåÁª¥Êä§‰∏Ä‰∏™Âπ∂Êü•ÈõÜÔºåÂèäÂÖ∂Áõ∏ÂÖ≥ÂèòÈáè ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** @Author: sun000* @Date: 2018-06-25 18:21:16* @Last Modified by: sun000* @Last Modified time: 2018-06-25 19:01:48*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;char name1[1005], name2[1005];int d[1005]; //ÊØè‰∏™‰∫∫ÊâÄËøûÁöÑËæπÁöÑÊùÉÈáçÂíåÔºåÁî®‰∫éÊâæÂà∞headmap&lt;string, int&gt; nameToId;string idToName[1005];int fa[1005], size[1005], tot[1005], head[1005]; //ÂàÜÂà´Ë°®Á§∫ÊØè‰∏™ÈõÜÂêàÁöÑ‰ª£Ë°®ÂÖÉÁ¥†Â∫èÂè∑ÔºåÈõÜÂêàÂ§ßÂ∞èÔºåÈõÜÂêà‰∏≠ÁöÑËæπÊùÉÊÄªÂíåÔºåÊØè‰∏™ÈõÜÂêàÁöÑheadbool vis[1005]; //Áî®‰∫éËæìÂá∫Ê†áËÆ∞ÔºåÊØè‰∏™ÈõÜÂêàÂè™ËæìÂá∫‰∏ÄÊ¨°void init() &#123; memset(vis, true, sizeof vis); for(int i = 0; i &lt; 1005; i++) &#123; fa[i] = i; head[i] = i; size[i] = 1; tot[i] = 0; &#125;&#125;int find(int x) &#123; if(x == fa[x]) return x; return fa[x] = find(fa[x]);&#125;void un(int x, int y, int t) &#123; x = find(x), y = find(y); if(x != y) &#123; fa[x] = y; vis[x] = true; vis[y] = false; tot[y] += tot[x]; size[y] += size[x]; &#125; tot[y] += t;&#125;int main(void) &#123; int n, k, t; while(scanf("%d%d", &amp;n, &amp;k) != EOF) &#123; init(); nameToId.clear(); memset(d, 0, sizeof d); int cnt = 0; for(int i = 0; i &lt; n; i++) &#123; scanf("%s %s %d", name1, name2, &amp;t); int u, v; string n1 = string(name1), n2 = string(name2); if(nameToId.find(n1) == nameToId.end()) &#123; nameToId[n1] = cnt; idToName[cnt++] = n1; &#125; u = nameToId[n1]; if(nameToId.find(n2) == nameToId.end()) &#123; nameToId[n2] = cnt; idToName[cnt++] = n2; &#125; v = nameToId[n2]; d[u] += t; d[v] += t; un(u, v, t); &#125; for(int i = 0; i &lt; cnt; i++) &#123; int f = find(i); if(d[i] &gt; d[f]) &#123; d[f] = d[i]; head[f] = i; &#125; &#125; string name[1005]; int c = 0; for(int i = 0; i &lt; cnt; i++) &#123; int now = find(i); if(!vis[now] &amp;&amp; tot[now] &gt; k &amp;&amp; size[now] &gt; 2) &#123; vis[now] = true; name[c++] = idToName[now]; &#125; &#125; sort(name, name + c); printf("%d\n", c); for(int i = 0; i &lt; c; i++) cout &lt;&lt; idToName[head[nameToId[name[i]]]] &lt;&lt; " " &lt;&lt; size[nameToId[name[i]]] &lt;&lt; endl; &#125; return 0;&#125; ÊØï‰∏öbg È¢òÁõÆÈìæÊé• ÂàÜÊûê ÁÆÄÂçïÁöÑÂä®ÊÄÅËßÑÂàí ÂÆö‰πâ\(dp[i][j]\)ÔºöÂâçi‰∏™‰∫∫Âú®jÊó∂ÂàªÂâçÊêû‚ôÇÂÆåÁöÑÊúÄÂ§ßÊ¨¢‚ôÇ‰πê \(dp[i][j] = max\{dp[i - 1][j], dp[i - 1][j - l] + h\},j \in [t, l]\) ÔºàÂèØÁî®Á©∫Èó¥ÂéãÁº©Ôºâ Ê≥®ÊÑèÁöÑ‰∏ÄÁÇπÔºåÂú®dp‰πãÂâçË¶ÅÔºåÂÖàÊåâÁÖßÁ¶ªÂºÄÊó∂Èó¥ËøõË°åÊéíÂ∫è„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738394041/** @Author: sun000* @Date: 2018-06-25 20:01:47* @Last Modified by: sun000* @Last Modified time: 2018-06-25 20:15:02*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int dp[2333];struct node &#123; int n, l, t;&#125;g[40];bool cmp(node a, node b) &#123; return a.t &lt; b.t;&#125;int main(void) &#123; int n; while(scanf("%d", &amp;n) != EOF &amp;&amp; n != -1) &#123; memset(dp, 0, sizeof dp); int ans = 0; for(int i = 0; i &lt; n; i++) scanf("%d%d%d", &amp;g[i].n, &amp;g[i].l, &amp;g[i].t); sort(g, g + n, cmp); for(int i = 0; i &lt; n; i++) &#123; for(int j = g[i].t; j &gt;= g[i].l; j--) &#123; dp[j] = max(dp[j], dp[j - g[i].l] + g[i].n); ans = max(ans, dp[j]); &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125; ÂºÄÈó®‰∫∫ÂíåÂÖ≥Èó®‰∫∫ È¢òÁõÆÈìæÊé• ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536/** @Author: sun000* @Date: 2018-06-25 20:17:58* @Last Modified by: sun000* @Last Modified time: 2018-06-25 20:23:41*/#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main(void) &#123; int n, h, m, s; string b, e, now; while(scanf("%d", &amp;n) != EOF) &#123; int bt = 0xffff, et = -1; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; now; scanf("%d:%d:%d", &amp;h, &amp;m, &amp;s); int t = h * 3600 + m * 60 + s; if(t &lt; bt) &#123; bt = t; b = now; &#125; scanf("%d:%d:%d", &amp;h, &amp;m, &amp;s); t = h * 3600 + m * 60 + s; if(t &gt; et) &#123; et = t; e = now; &#125; &#125; cout &lt;&lt; b &lt;&lt; " " &lt;&lt; e &lt;&lt; endl; &#125; return 0;&#125; ÊúÄÂ§ßËøûÁª≠Â≠êÂ∫èÂàó È¢òÁõÆÈìæÊé• ÂàÜÊûê Âü∫Á°ÄdpÈ¢òÁõÆ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243/** @Author: sun000* @Date: 2018-06-25 20:26:01* @Last Modified by: sun000* @Last Modified time: 2018-06-25 20:39:19*/#include &lt;cstdio&gt;long long int num[10005];int main(void) &#123; int n; while(scanf("%d", &amp;n) != EOF &amp;&amp; n) &#123; long long int ans = -0x7fffffff, dp = 0; for(int i = 0; i &lt; n; i++) scanf("%lld", &amp;num[i]); int b = 0, e = 0; int tb = 0, te = 0; for(int i = 0; i &lt; n; i++) &#123; if(dp &lt;= 0) &#123; dp = num[i]; tb = te = i; &#125; else &#123; te = i; dp += num[i]; &#125; if(dp &gt; ans) &#123; ans = dp; b = tb; e = te; &#125; &#125; if(ans &lt; 0) &#123; ans = 0; b = 0; e = n - 1; &#125; printf("%lld %lld %lld\n", ans, num[b], num[e]); &#125; return 0;&#125; A+B È¢òÁõÆÈìæÊé• ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031/** @Author: sun000* @Date: 2018-06-25 20:42:42* @Last Modified by: sun000* @Last Modified time: 2018-06-25 20:54:07*/#include &lt;cstdio&gt;int main(void) &#123; char c; long long int tmp, a = 0, b = 0; int f = 1; while(scanf("%lld%c", &amp;tmp, &amp;c) != EOF) &#123; b = b * 1000 + tmp * f; if(tmp &lt; 0) f = -1; if(c == ' ') &#123; a = b; b = 0; f = 1; &#125; else if(c == '\n') &#123; printf("%lld\n", a + b); a = b = 0; f = 1; &#125; &#125; return 0;&#125; Graduate Admission È¢òÁõÆÈìæÊé• ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** @Author: sun000* @Date: 2018-06-26 15:28:33* @Last Modified by: sun000* @Last Modified time: 2018-06-26 15:50:21*/#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; int idx, gE, gI; int c[5]; int rank;&#125; app[40005];int mRank[40005];bool cmpByRank(const node &amp;a, const node &amp;b) &#123; if (a.gE + a.gI == b.gE + b.gI) return a.gE &gt; b.gE; return a.gE + a.gI &gt; b.gE + b.gI;&#125;void Rank(int n) &#123; sort(app, app + n, cmpByRank); app[0].rank = 1; mRank[app[0].idx] = 1; for (int i = 1; i &lt; n; i++) &#123; if (app[i].gE + app[i].gI == app[i - 1].gE + app[i - 1].gI &amp;&amp; app[i].gE == app[i - 1].gE) app[i].rank = app[i - 1].rank; else app[i].rank = i + 1; mRank[app[i].idx] = app[i].rank; &#125;&#125;int quo[105];vector&lt;int&gt; ans[105];int main(void) &#123; int n, m, k; while (scanf("%d%d%d", &amp;n, &amp;m, &amp;k) != EOF) &#123; for (int i = 0; i &lt; m; i++) scanf("%d", &amp;quo[i]); for (int i = 0; i &lt; n; i++) &#123; app[i].idx = i; scanf("%d%d", &amp;app[i].gE, &amp;app[i].gI); for (int j = 0; j &lt; k; j++) scanf("%d", &amp;app[i].c[j]); &#125; Rank(n); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; k; j++) &#123; int s = app[i].c[j]; //school if (ans[s].size() &lt; quo[s] || mRank[ans[s].back()] == app[i].rank) &#123; ans[s].push_back(app[i].idx); break; &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) sort(ans[i].begin(), ans[i].end()); for (int i = 0; i &lt; m; i++) &#123; if(!ans[i].size()) printf("\n"); for (int j = 0; j &lt; ans[i].size(); j++) printf("%d%c", ans[i][j], j == ans[i].size() - 1 ? '\n' : ' '); ans[i].clear(); &#125; &#125; return 0;&#125; Median È¢òÁõÆÈìæÊé• ‰ª£Á†Å 123456789101112131415161718192021222324252627/** @Author: sun000* @Date: 2018-06-26 15:54:03* @Last Modified by: sun000* @Last Modified time: 2018-06-26 16:01:22*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int num[2000005];int main(void) &#123; int n, m; while(scanf("%d", &amp;n) != EOF) &#123; for(int i = 0; i &lt; n; i++) scanf("%d", &amp;num[i]); scanf("%d", &amp;m); for(int i = 0; i &lt; m; i++) scanf("%d", &amp;num[n + i]); n += m; sort(num, num + n); printf("%d\n", num[(n - 1) / 2]); &#125; return 0;&#125; EXCELÊéíÂ∫è È¢òÁõÆÈìæÊé• ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** @Author: sun000* @Date: 2018-06-26 16:04:46* @Last Modified by: sun000* @Last Modified time: 2018-06-26 16:11:49*/#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e5 + 5;struct node &#123; int idx, grade; string name;&#125;s[MAXN];bool cmpByIdx(const node &amp;a, const node &amp;b) &#123; return a.idx &lt; b.idx;&#125;bool cmpByName(const node &amp;a, const node &amp;b) &#123; if(a.name == b.name) return a.idx &lt; b.idx; return a.name &lt; b.name;&#125;bool cmpByGrade(const node &amp;a, const node &amp;b) &#123; if(a.grade == b.grade) return a.idx &lt; b.idx; return a.grade &lt; b.grade;&#125;int main(void) &#123; int n, c; while(scanf("%d%d", &amp;n, &amp;c) != EOF) &#123; for(int i = 0; i &lt; n; i++) cin &gt;&gt; s[i].idx &gt;&gt; s[i].name &gt;&gt; s[i].grade; if(c == 1) sort(s, s + n, cmpByIdx); else if(c == 2) sort(s, s + n, cmpByName); else sort(s, s + n, cmpByGrade); printf("Case:\n"); for(int i = 0; i &lt; n; i++) &#123; printf("%06d ", s[i].idx); cout &lt;&lt; s[i].name &lt;&lt; " " &lt;&lt; s[i].grade &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Êú∫ËØï</category>
      </categories>
      <tags>
        <tag>Êú∫ËØï</tag>
        <tag>ÊµôÂ§ß</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÊµôÂ§ßCADÊµãËØïÈ¢ò]]></title>
    <url>%2F2018%2F06%2F19%2F%E6%B5%99%E5%A4%A7CAD%E6%B5%8B%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[‰øùÁ†îÂ≠£‰∫ÜÔºåÊúâÂêåÂ≠¶ËÅîÁ≥ª‰∫ÜCADÁöÑËÄÅÂ∏àÂ∏ÉÁΩÆ‰∫ÜËøôÈÅìÈ¢òÁõÆÔºà‰∏çÁü•ÈÅì‰∏∫Âï•ËÄÅÂ∏àÊ≤°ÊúâËÆ©ÊàëÂÅöÔºâ„ÄÇ ËôΩÁÑ∂Ê≤°ÊúâË¶ÅÊ±ÇÊàëÂÅöÔºå‰∏çËøáÊàëËøòÊòØÁ®çÂæÆÁöÑÂÜô‰∫ÜÁÇπÔºåËß£ÂÜ≥‰∫Ü‰∏Ä‰∏ãËøô‰∏™Â∞èÈóÆÈ¢ò„ÄÇ È°πÁõÆË¶ÅÊ±Ç ÊµôÂ§ßcadÊµãËØïÈ¢òÁõÆ ËØ∑Â∞ΩÂø´ÂÆåÊàê‰∏ãËø∞ËØïÈ¢òÂπ∂Â∞ÜÁªìÊûúÂèëÂõûÔºö ÈóÆÈ¢òËØ¥ÊòéÔºö ÁªôÂá∫ÂàÜÊàêmÊÆµ ÁöÑn‰∏™ÊµÆÁÇπÊï∞ÔºåËæìÂÖ•Êï∞ÊçÆÂ∑≤ÊåâÊÆµÂè∑ÊúâÂ∫èÔºå‰ΩÜÊØèÊÆµÂÜÖÈÉ® Êó†Â∫è„ÄÇÁî®C/C++ ÁºñÂÜô‰∏Ä‰∏™ÂàÜÊÆµÂèåË∞ÉÊéíÂ∫è(Bitonic sort)ÂáΩÊï∞ÔºåÂØπÊØè‰∏ÄÊÆµÂÜÖÈÉ®ÁöÑÊµÆÁÇπÊï∞ËøõË°åÊéíÂ∫èÔºå‰ΩÜ ‰∏çË¶ÅÊîπÂèòÊÆµÈó¥ÁöÑ‰ΩçÁΩÆ„ÄÇ Êé•Âè£ÊñπÂºèÔºö void segmentedBitonicSort(float* data, int* seg_id, int* seg_start, int n, int m); ËæìÂÖ•Êï∞ÊçÆ‰∏≠ÔºådataÂåÖÂê´ÈúÄË¶ÅÂàÜÊÆµÊéíÂ∫èÁöÑn‰∏™floatÂÄºÔºåseg_idÁªôÂá∫data‰∏≠n‰∏™ÂÖÉÁ¥†ÂêÑ Ëá™ÊâÄÂú®ÁöÑ ÊÆµÁºñÂè∑„ÄÇseg_startÂÖ±Êúâm+1‰∏™ÂÖÉÁ¥†ÔºåÂâçm‰∏™ÂàÜÂà´Áªô Âá∫0..m-1ÂÖ±m‰∏™ÊÆµÁöÑËµ∑ Âßã‰ΩçÁΩÆÔºåseg_start[m]‰øùËØÅÁ≠â‰∫én„ÄÇ seg_id‰∏≠ÁöÑÂÖÉÁ¥†‰øùËØÅÂçïË∞É‰∏ç‰∏ãÈôçÔºåÂç≥ÂØπ‰ªªÊÑèÁöÑi&lt;jÔºåseg_id[i]&lt;=seg_id[j]„ÄÇ seg_idÊâÄÊúâÂÖÉ Á¥†ÂùáÂú®0Âà∞m-1ËåÉÂõ¥ÂÜÖ„ÄÇ ËæìÂá∫ÁªìÊûúË¶ÜÁõñdataÔºå‰øùËØÅÊØè‰∏ÄÊÆµÂÜÖÊéíÂ∫èÔºå‰ΩÜ‰∏çÊîπÂèòÊÆµÈó¥ÂÖÉÁ¥†ÁöÑÈ°∫Â∫è„ÄÇ Ê≥®ÊÑèÔºö 1„ÄÅÂøÖÈ°ª‰ΩøÁî®ÂèåË∞ÉÊéíÂ∫èÁÆóÊ≥ïËøõË°åÊéíÂ∫è„ÄÇ 2„ÄÅÂèØ‰ª•Áõ¥Êé•‰ΩøÁî®‰ªéÁΩë‰∏ä‰∏ãËΩΩÁöÑÂèåË∞ÉÊéíÂ∫è‰ª£Á†ÅÔºå‰ΩÜÈ°ªÊ≥®ÊòéÂá∫Â§Ñ„ÄÇ Ê†∑‰æãËæìÂÖ•Ôºö float data[5]={0.8, 0.2, 0.4, 0.6, 0.5}; int seg_id[5]={0, 0, 1, 1, 1} int seg_start[3]={0,2,5}; int n=5; int m=2; Ê†∑‰æãËæìÂá∫Ôºö float data[5]={0.2, 0.8, 0.4, 0.5, 0.6}; Âä†ÂàÜÊåëÊàòÔºàÈùûÂøÖÈúÄÔºâÔºö 1„ÄÅ‰∏çÈÄíÂΩíÔºösegmentedBitonicSortÂáΩÊï∞ÂèäÂÖ∂ÊâÄË∞ÉÁî®ÁöÑ‰ªª‰ΩïÂÖ∂‰ªñÂáΩÊï∞ÈÉΩ‰∏çÂæóÁõ¥Êé•ÊàñÈó¥Êé•Âú∞ËøõË°åÈÄíÂΩí„ÄÇ 2„ÄÅ‰∏çË∞ÉÁî®ÂáΩÊï∞ÔºösegmentedBitonicSort‰∏çË∞ÉÁî®Èô§Ê†áÂáÜÂ∫ìÂáΩÊï∞Â§ñÁöÑ‰ªª‰ΩïÂÖ∂‰ªñÂáΩÊï∞„ÄÇ 3„ÄÅÂÜÖÂ≠òÈ´òÊïàÔºösegmentedBitonicSortÂèäÂÖ∂ÊâÄË∞ÉÁî®ÁöÑ‰ªª‰ΩïÂÖ∂‰ªñÂáΩÊï∞ÈÉΩ‰∏çÂæóËøõË°åÂä®ÊÄÅÂÜÖÂ≠òÂàÜÈÖçÔºåÂåÖÊã¨malloc„ÄÅnewÂíåÈùôÊÄÅÂÆö‰πâÁöÑSTLÂÆπÂô®„ÄÇ 4„ÄÅÂèØÂπ∂Ë°åÔºösegmentedBitonicSortÊ∂âÂèäÂà∞ÁöÑÊâÄÊúâÊó∂Èó¥Â§çÊùÇÂ∫¶O(n)‰ª•‰∏äÁöÑ‰ª£Á†ÅÈÉΩÂÜô Âú®forÂæ™ ÁéØ‰∏≠ÔºåËÄå‰∏îÊØè‰∏™ËøôÊ†∑ÁöÑforÂæ™ÁéØÂÜÖÈÉ®ÁöÑÂæ™ÁéØÈ°∫Â∫èÂèØ ‰ª•‰ªªÊÑèÊîπÂèòÔºå‰∏çÂΩ±ÂìçÁ®ã Â∫èÁªìÊûú„ÄÇÊ≥®ÔºöËá™Â∑±ÊµãËØïÊó∂ÂèØ‰ª•Áî®rand()ÂÜ≥ÂÆöÂæ™ÁéØÈ°∫Â∫è„ÄÇ 5„ÄÅ‰∏çÈúÄÂÜÖÂ≠òÔºösegmentedBitonicSort‰∏çË∞ÉÁî®‰ªª‰ΩïÂáΩÊï∞ÔºàÂåÖÊã¨C/C++Ê†áÂáÜÂ∫ìÂáΩÊï∞ÔºâÔºå ‰∏ç‰ΩøÁî®ÂÖ®Â±ÄÂèòÈáèÔºåÊâÄÊúâÂ±ÄÈÉ®ÂèòÈáèÈÉΩÊòØint„ÄÅfloatÊàñÊåáÈíàÁ±ª ÂûãÔºåC++Á®ãÂ∫è‰∏ç‰ΩøÁî®new ÂÖ≥ÈîÆÂ≠ó„ÄÇ 6„ÄÅÁªùÂØπÈ≤ÅÊ£íÔºöÂú®ËæìÂÖ•Êï∞ÊçÆ‰∏≠ÂåÖÂê´NaNÊó∂Ôºà‰æãÂ¶Çsqrt(-1.f)ÔºâÔºå‰øùËØÅÈô§NaN‰ª•Â§ñ ÁöÑÊï∞ ÊçÆÊ≠£Á°ÆÊéíÂ∫èÔºåNaNÁöÑ‰∏™Êï∞‰øùÊåÅ‰∏çÂèò„ÄÇ ‰Ω†ÁöÑÁ®ãÂ∫èÊØèÊª°Ë∂≥‰ª•‰∏äÁöÑ‰∏Ä‰∏™Êù°‰ª∂ÈÉΩÂèØ‰ª•Ëé∑ÂæóÈ¢ùÂ§ñÁöÑÂä†ÂàÜ„ÄÇ Â∫îÊèê‰∫§ÁöÑÁªìÊûúÔºö ÁÆóÊ≥ïÊèèËø∞Ôºõ Â∞ùËØïËøáÂíåÂÆåÊàê‰∫ÜÁöÑÂä†ÂàÜÊåëÊàòÔºõ ÂèØ‰ª•Áã¨Á´ãËøêË°åÁöÑÊ∫ê‰ª£Á†ÅÔºõ ÊµãËØïÊï∞ÊçÆÔºõ ÊÄßËÉΩÂàÜÊûêÔºõ ÊµãËØïÁöÑËµ∑ÂßãÂíåÂÆåÊàêÊó∂Èó¥‰ª•ÂèäÂÆûÈôÖ‰ΩøÁî®ÁöÑÊó∂Èó¥„ÄÇ ÊèêÁ§∫Ôºö Âà©Áî®Â•ΩÁΩë‰∏äËµÑÊ∫ê„ÄÇ Â∞ΩÈáèÂà©Áî®ËæìÂÖ•‰∏≠ÁöÑÂÜó‰Ωô‰ø°ÊÅØ„ÄÇ Âà©Áî®Â•Ω‰ΩçÊìç‰Ωú„ÄÇ Ê≥®ÊÑèÔºöÊúâÂêåÂ≠¶ÊµãËØïÂêéÂ∞ÜËá™Â∑±ÁöÑÁ≠îÊ°àÊîæÂú®‰∫ÜÁΩë‰∏äÔºåÊàëÁúãÂà∞ÁöÑÂá†‰∏™ÂÆûÁé∞ÈÉΩÊòØÊúâÈóÆÈ¢òÁöÑÔºåËØ∑Ê≥®ÊÑèÁîÑÂà´„ÄÇ ÂÆåÊàêÊÉÖÂÜµ ÁõÆÂâçÊòØÂÆåÊàê‰∫ÜÊâÄÊúâÂä†ÂàÜÁÇπÔºàÂΩìÁÑ∂‰∫ÜÈô§‰∫Ü‰∏çËÉΩË∞ÉÁî®Â§ñÈÉ®ÂáΩÊï∞ÔºåÂè™ÊòØÊàëËßâÂæóËøô‰∏™Ê≤°ÊúâÂøÖË¶ÅÔºåÂõ†‰∏∫ÊàëË∞ÉÁî®ÁöÑÂáΩÊï∞Ê≤°ÊúâÈÄíÂΩíÔºåÂ¶ÇÊûúË¶ÅÂº∫Ë°åËß£ÂÜ≥Âä†ÂàÜÁÇπÁöÑËØùÔºåÁõ¥Êé•ÊääÂáΩÊï∞Â§çÂà∂Âà∞Ë∞ÉÁî®ÁöÑÂú∞ÊñπÂ∞±Â•Ω‰∫ÜÔºå‰ΩÜÊòØËøôÂæàÈöæÁúãÂïäÔºåÊâÄ‰ª•Âè™ËÉΩÂÅáË£ÖËß£ÂÜ≥‰∫ÜÊâÄÊúâÂä†ÂàÜÁÇπÔºâÔºå‰ΩÜÊòØÁâ∫Áâ≤‰∫Ü\([2,\frac{9}{2}]\)ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶Ôºå‰ΩÜÊòØËøô‰∏™ÁÆóÊ≥ïÊú¨Ë∫´ÁöÑÈáçÁÇπÂ∞±‰∏çÂú®‰∫éÊó∂Èó¥Â§çÊùÇÂ∫¶ÔºåËÄåÊòØÂº∫Ë∞ÉÈ´òÂ∫¶Âπ∂Ë°åÂåñÔºåËÄå‰∏îÊàë‰πüÊòØ‰∏∫‰∫ÜÂÆåÊàêÊâÄÊúâÁöÑÂä†ÂàÜÁÇπÔºåÂ∫îËØïËÄåÂ∑≤„ÄÇÂÜµ‰∏îÂ∏∏Êï∞ÂÄçÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶ÁöÑÁâ∫Áâ≤ÔºåÂú®‰ªé\(O(nlog(n))\)Âà∞\(O(n^2)\)ÁöÑÁâ∫Áâ≤Èù¢ÂâçÊ†πÊú¨‰∏çÁÆó‰ªÄ‰πà„ÄÇ ÂΩìÁÑ∂‰πüÊúâ‰∏çÁâ∫Áâ≤Êó∂Èó¥Â§çÊùÇÂ∫¶ÁöÑÔºå‰ΩÜÊòØÊ≤°ÊúâÂèñÊ∂àÈÄíÂΩíÁöÑÊñπÊ≥ïÔºåÊàëËßâÂæóËøòÊòØÊØîËæÉÂ•ΩÁöÑ„ÄÇÂ¶ÇÔºö‰º†ÈÄÅÈó® ÂÜçÊù•ËÆ≤ËÆ≤ÊàëÁöÑ‰∏ªË¶Å‰ºòÂåñÊñπÊ≥ïÔºåÂÖ∂ÂÆûÊàëÁöÑ‰ºòÂåñÊñπÊ≥ïÈùûÂ∏∏ÁÆÄÂçïÔºåÁîöËá≥ÂèØ‰ª•ËØ¥ÊòØÂæàÊó†ËÑë‰∫Ü„ÄÇ ÊàëÊ®°Êãü‰∫ÜÂÜíÊ≥°ÊéíÂ∫èÁöÑÁÆóÊ≥ïÔºåÂ∞ÜÂæÖÊéíÂ∫èÁöÑÂ∫èÂàóÂàÜÊÆµÔºåËßÜÊÉÖÂÜµÂàÜÊàê2ÊàñËÄÖ3ÊÆµÔºåÂÖÅËÆ∏ÊØèÊÆµÊúâÈáçÂè†Ôºå‰ΩÜÊòØÊâÄÊúâÁöÑÊÆµÂøÖÈ°ªË¶ÜÁõñÂéüÊù•ÁöÑÂ∫èÂàóÔºå‰∏îÊØè‰∏ÄÊÆµÁöÑÈïøÂ∫¶ÈÉΩÊòØ\(2^k\)ÁöÑ„ÄÇ ÁÑ∂ÂêéÂ∞±ÂèØ‰ª•Ê®°ÊãüÂÜíÊ≥°ÊéíÂ∫èÔºåÂ¶Ç‰∏ãÂõæËøõË°å‰ºòÂåñ‰∫ÜÔºåËøôÈáåÂ∫îËØ•Áîª‰∏Ä‰∏™ÂõæÂ∞±ÂæàÂ•ΩÁêÜËß£ÁöÑÔºå‰ΩÜÊòØÊàëÊØîËæÉÊáí-_-ÔºåÂ§ß‰Ω¨‰ª¨Ëá™Â∑±Áîª‰∏™ÂõæÂ∞±ÂæàÂÆπÊòìÁêÜËß£‰∫Ü„ÄÇ 1234567891011121314if(len == step) mySort(data + seg_start[i], len);else if (len &lt;= step + (step &gt;&gt; 1)) &#123; for (int j = 0; j &lt; 2; j++) &#123; mySort(data + seg_start[i], step); mySort(data + seg_start[i] + len - step, step); &#125;&#125;else &#123; for (int j = 0; j &lt; 3; j++) &#123; mySort(data + seg_start[i], step); mySort(data + seg_start[i] + (len - step) / 2, step); mySort(data + seg_start[i] + len - step, step); &#125;&#125; ‰ª£Á†Å ÊàëÁöÑGithubÊúâÊõ¥Âä†ËØ¶ÁªÜÁöÑ‰ª£Á†ÅÔºåËøòÊúâ‰∏Ä‰∏™ÂÖ∂‰ªñÁöÑËß£Ê≥ïÔºå‰ª•ÂèäÂØπÊãçÁöÑdebugÁ®ãÂ∫èÔºåÊàëÊ≤°ÊúâÊîæ‰∏äÊù•ÔºåÊúâÂÖ¥Ë∂£ÁöÑÂèØ‰ª•Ëá™Â∑±ÂéªÁúãÔºå‰º†ÈÄÅÈó® 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** @Author: sun000* @Date: 2018-06-03 09:18:30* @Last Modified by: sun000* @Last Modified time: 2018-06-03 16:05:17*/#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;void mySort(float *data, int n) &#123; //Â∞±ÊòØÊúÄÂü∫Á°ÄÁöÑÈïøÂ∫¶‰∏∫2^kÁöÑËß£Ê≥ï for (int unitLen = 2; unitLen &lt;= n; unitLen &lt;&lt;= 1) &#123; bool flag = true; for (int s = 0; s &lt; n; s += unitLen, flag ^= true) &#123; int e = s + unitLen; if (flag) &#123; for (int step = unitLen; step &gt; 1; step &gt;&gt;= 1) &#123; for (int s2 = s; s2 &lt; e; s2 += step) &#123; int e2 = s2 + step; int mid = (s2 + e2) &gt;&gt; 1; for (int i = 0; i &lt; (step &gt;&gt; 1); i++) &#123; if ((data[s2 + i] &gt; data[mid + i]) || (!isnan(data[s2 + i]) &amp;&amp; isnan(data[mid + i])) ) swap(data[s2 + i], data[mid + i]); &#125; &#125; &#125; &#125; else &#123; for (int step = unitLen; step &gt; 1; step &gt;&gt;= 1) &#123; for (int s2 = s; s2 &lt; e; s2 += step) &#123; int e2 = s2 + step; int mid = (s2 + e2) &gt;&gt; 1; for (int i = 0; i &lt; (step &gt;&gt; 1); i++) &#123; if ((data[s2 + i] &lt; data[mid + i]) || (isnan(data[s2 + i]) &amp;&amp; !isnan(data[mid + i])) ) swap(data[s2 + i], data[mid + i]); &#125; &#125; &#125; &#125; &#125; &#125;&#125;void segmentedBitonicSort(float * data, int* seg_id, int* seg_start, int n, int m) &#123; for (int i = 0; i &lt; m; i++) &#123; int len = seg_start[i + 1] - seg_start[i]; int step = 1 &lt;&lt; (int)log2(len); if(len == step) mySort(data + seg_start[i], len); else if (len &lt;= step + (step &gt;&gt; 1)) &#123; for (int j = 0; j &lt; 2; j++) &#123; mySort(data + seg_start[i], step); mySort(data + seg_start[i] + len - step, step); &#125; &#125; else &#123; for (int j = 0; j &lt; 3; j++) &#123; mySort(data + seg_start[i], step); mySort(data + seg_start[i] + (len - step) / 2, step); mySort(data + seg_start[i] + len - step, step); &#125; &#125; &#125;&#125;int main(void) &#123; int n, m; scanf("%d %d", &amp;n, &amp;m); float *data = new float[n]; int *seg_start = new int[m + 1]; for(int i = 0; i &lt; n; i++) scanf("%f", &amp;data[i]); for(int i = 0; i &lt; m + 1; i++) scanf("%d", &amp;seg_start[i]); segmentedBitonicSort(data, nullptr, seg_start, n, m); for (int i = 0; i &lt; m; i++) &#123; for (int j = seg_start[i]; j &lt; seg_start[i + 1]; j++) printf("%f ", data[j]); printf("\n"); &#125;&#125;]]></content>
      <categories>
        <category>Êú∫ËØï</category>
      </categories>
      <tags>
        <tag>ÂèåË∞ÉÊéíÂ∫è</tag>
        <tag>Âπ∂Ë°åÂ§ÑÁêÜ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÊµôÂ§ßÁ†îÁ©∂ÁîüÊú∫ËØï11-20È¢ò]]></title>
    <url>%2F2018%2F06%2F03%2F%E6%B5%99%E5%A4%A7%E7%A0%94%E7%A9%B6%E7%94%9F%E6%9C%BA%E8%AF%9511-20%E9%A2%98%2F</url>
    <content type="text"><![CDATA[ÁïÖÈÄöÂ∑•Á®ã È¢òÁõÆÈìæÊé• ÂàÜÊûê Âπ∂Êü•ÈõÜÂêàÊ±ÇËÅîÈÄöÈáè ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** @Author: sun000* @Date: 2018-05-31 19:07:17* @Last Modified by: sun000* @Last Modified time: 2018-05-31 19:23:08*/#include &lt;cstdio&gt;int fa[1010];int s;void init(int n) &#123; s = n; for(int i = 0; i &lt;= s; i++) fa[i] = i;&#125;int fin(int x) &#123; if(fa[x] == x) return x; return fa[x] = fin(fa[x]);&#125; void un(int x, int y) &#123; x = fin(x); y = fin(y); if(x != y) &#123; fa[x] = y; s--; &#125;&#125;int main(void) &#123; int n, m, u, v; while(scanf("%d", &amp;n) != EOF &amp;&amp; n) &#123; scanf("%d", &amp;m); init(n); for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d", &amp;u, &amp;v); un(u, v); &#125; printf("%d\n", s - 1); &#125; return 0;&#125; ÁªüËÆ°Â≠óÁ¨¶ È¢òÁõÆÈìæÊé• ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839/** @Author: sun000* @Date: 2018-05-31 20:35:27* @Last Modified by: sun000* @Last Modified time: 2018-05-31 20:40:16*/#include &lt;cstdio&gt;#include &lt;map&gt;using namespace std;map&lt;char, int&gt; m;char mm[10];int cnt;int main(void) &#123; char tmp; while(scanf("%c", &amp;tmp) != EOF &amp;&amp; tmp != '#') &#123; int cnt = 0; mm[cnt++] = tmp; m.clear(); m[tmp] = 0; while(scanf("%c", &amp;tmp), tmp != '\n') &#123; m[tmp] = 0; mm[cnt++] = tmp; &#125; scanf("%c", &amp;tmp); if(m.find(tmp) != m.end()) m[tmp] += 1; while(scanf("%c", &amp;tmp), tmp != '\n') &#123; if(m.find(tmp) != m.end()) m[tmp] += 1; &#125; for(int i = 0; i &lt; cnt; i++) printf("%c %d\n", mm[i], m[mm[i]]); &#125; return 0;&#125; Ê∏∏ËàπÂá∫Áßü È¢òÁõÆÈìæÊé• ÂàÜÊûê ËøôÈÅìÈ¢òÁõÆÁöÑÂ∫îËØ•ÊòØÊúâÈóÆÈ¢òÁöÑÔºå‰∏ÄËæÜËàπÂú®Ê≤°Ëøò‰πãÂâçÈáçÂ§çÂÄüÂá∫ÔºåÊú¨È¢òÊòØ‰ª•ÊúÄÂêé‰∏ÄÊ¨°‰∏∫ÂáÜÁöÑÔºå‰∏ÄËæÜËàπÊé•Ëß¶‰πãÂêéÔºåÁ´üÁÑ∂ÂèØ‰ª•ÈáçÂ§çËøò„ÄÇ‰∏çÂèØÊÄùËÆÆÔºåÂûÉÂúæÈ¢ò„ÄÇÊàëË¥¥ÁöÑ‰ª£Á†Å‰∏çËÉΩËøáÔºå‰ΩÜÊòØÊàëÊòØËá™Â∑±ÁöÑÁêÜËß£ÂÜôÁöÑ„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536/** @Author: sun000* @Date: 2018-05-31 20:42:41* @Last Modified by: sun000* @Last Modified time: 2018-05-31 20:52:43*/#include &lt;cstdio&gt;#include &lt;cstring&gt;int t[120];int main(void) &#123; int ids, h, m, ans, num; char op; memset(t, -1, sizeof(t)); while(scanf("%d", &amp;ids) != EOF &amp;&amp; ids != -1) &#123; scanf(" %c %d:%d", &amp;op, &amp;h, &amp;m); if(ids == 0) &#123; if(num) ans = (int)(1.0 * ans / num + 0.5); printf("%d %d\n", num, ans); ans = 0; num = 0; memset(t, -1, sizeof(t)); &#125; else &#123; if(op == 'S' &amp;&amp; t[ids] == -1) t[ids] = h * 60 + m; else if(t[ids] != -1) &#123; ans += h * 60 + m - t[ids]; t[ids] = -1; num++; &#125; &#125; &#125; return 0;&#125; ÁÆÄÂçïËÆ°ÁÆóÂô® È¢òÁõÆÈìæÊé• ÂàÜÊûê ËøôÈÅìÈ¢òÁõÆÁêÜËÆ∫‰∏äÊòØÂ∫îËØ•ÊòØËΩ¨Êç¢ÊàêÈÄÜÊ≥¢ÂÖ∞Ë°®ËææÂºèËÆ°ÁÆóÁöÑ„ÄÇË¶ÅÊù•ÈÇ£‰∏™stackÔºåÊìç‰ΩúÁöÑÊó∂ÂÄôË¶ÅÂà§Êñ≠ÂΩìÂâçÁ¨¶Âè∑ÂíåÊ†àÈ°∂Á¨¶Âè∑ÁöÑ‰ºòÂÖàÁ∫ß„ÄÇÊâÄ‰ª•PythonÂ§ßÊ≥ïÂ•Ω ‰ª£Á†Å 1234567while True: try: a=input() if a!="0": print("&#123;0:.2f&#125;".format(eval(a))) except: break A+B È¢òÁõÆÈìæÊé• ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** @Author: sun000* @Date: 2018-06-01 14:41:15* @Last Modified by: sun000* @Last Modified time: 2018-06-01 15:00:14*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int getNum(string str) &#123; if(str[0] == 'z') return 0; else if(str[0] == 'o') return 1; else if(str[0] == 't') return str[1] == 'w' ? 2 : 3; else if(str[0] == 'f') return str[1] == 'o' ? 4 : 5; else if(str[0] == 's') return str[1] == 'i' ? 6 : 7; else if(str[0] == 'e') return 8; return 9;&#125;int a, b;bool read() &#123; a = b = 0; string tmp; while(!cin.eof()) &#123; cin &gt;&gt; tmp; if( tmp == "+") break; a = a * 10 + getNum(tmp); &#125; while(!cin.eof()) &#123; cin &gt;&gt; tmp; if( tmp == "=") break; b = b * 10 + getNum(tmp); &#125; return (a &amp;&amp; b);&#125;int main(void) &#123; while(read()) printf("%d\n", a + b); return 0;&#125; ZOJ È¢òÁõÆÈìæÊé• ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738/** @Author: sun000* @Date: 2018-06-03 17:05:57* @Last Modified by: sun000* @Last Modified time: 2018-06-03 17:13:49*/#include &lt;cstdio&gt;#include &lt;cstring&gt;char str[110];int main(void) &#123; while(scanf("%s", str) != EOF) &#123; int z = 0, o = 0, j = 0; for(int i = 0; i &lt; strlen(str); i++) &#123; if(str[i] == 'Z') z++; else if(str[i] == 'O') o++; else j++; &#125; while(z || o || j) &#123; if(z) &#123; printf("Z"); z--; &#125; if(o) &#123; printf("O"); o--; &#125; if(j) &#123; printf("J"); j--; &#125; &#125; printf("\n"); &#125; return 0;&#125; XXXÂÆöÂæã È¢òÁõÆÈìæÊé• ‰ª£Á†Å 1234567891011121314151617181920212223/** @Author: sun000* @Date: 2018-06-03 17:14:50* @Last Modified by: sun000* @Last Modified time: 2018-06-03 17:23:14*/#include &lt;cstdio&gt;int solve(int x) &#123; if(x == 1) return 0; else if(x &amp; 1) return solve((x * 3 + 1) &gt;&gt; 1) + 1; else return solve(x &gt;&gt; 1) + 1;&#125;int main(void) &#123; int n; while(scanf("%d", &amp;n) != EOF &amp;&amp; n) printf("%d\n", solve(n)); return 0;&#125; ËøòÊòØA+B È¢òÁõÆÈìæÊé• ‰ª£Á†Å 12345678910111213141516171819/** @Author: sun000* @Date: 2018-06-03 17:24:49* @Last Modified by: sun000* @Last Modified time: 2018-06-03 17:26:34*/#include &lt;cstdio&gt;#include &lt;cmath&gt;int main(void) &#123; int a, b, k; while(scanf("%d%d%d", &amp;a, &amp;b, &amp;k) != EOF &amp;&amp; (a || b)) &#123; k = pow(10, k); if(a % k == b % k) printf("-1\n"); else printf("%d\n", a + b); &#125; return 0;&#125; ÊúÄÂ§ßÊä•ÈîÄÈ¢ùÂ∫¶ È¢òÁõÆÈìæÊé• ÂàÜÊûê Êö¥Âäõ‰∫åËøõÂà∂Êûö‰∏æÊâÄÊúâÂèëÁ•®ÁªÑÂêàÊÉÖÂÜµÊù•Â§ÑÁêÜ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** @Author: sun000* @Date: 2018-06-03 17:30:49* @Last Modified by: sun000* @Last Modified time: 2018-06-03 17:40:07*/#include &lt;cstdio&gt;double all[50];int main(void) &#123; double q, tmp; int n, m; char c; while(scanf("%lf%d", &amp;q, &amp;n) != EOF) &#123; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;m); bool flag = true; all[i] = 0; for(int j = 0; j &lt; m; j++) &#123; scanf(" %c:%lf", &amp;c, &amp;tmp); if(c != 'A' &amp;&amp; c != 'B' &amp;&amp; c != 'C') flag = false; if(tmp &gt; 600) flag = false; all[i] += tmp; &#125; if(all[i] &gt; 1000 || !flag) all[i] = 0; &#125; long long int g = 1 &lt;&lt; n; double ans = 0; for(int s = 0; s &lt; g; s++) &#123; tmp = 0; for(int j = 0; j &lt; n; j++) &#123; if(s &amp; (1 &lt;&lt; j)) &#123; tmp += all[j]; if(tmp &gt; q) break; &#125; &#125; if(tmp &lt;= q &amp;&amp; tmp &gt; ans) ans = tmp; &#125; printf("%.2f\n", ans); &#125; return 0;&#125; Êúâ‰∏ÄÁâàA+B È¢òÁõÆÈìæÊé• 123456789101112131415161718192021222324/** @Author: sun000* @Date: 2018-06-03 18:28:38* @Last Modified by: sun000* @Last Modified time: 2018-06-03 18:31:15*/#include &lt;cstdio&gt;void print(long long int num, int m) &#123; if(num / m) print(num / m, m); printf("%lld", num % m);&#125;int main(void) &#123; long long int a, b; int m; while(scanf("%d", &amp;m) != EOF &amp;&amp; m) &#123; scanf("%lld%lld", &amp;a, &amp;b); print(a + b, m); printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Êú∫ËØï</category>
      </categories>
      <tags>
        <tag>Êú∫ËØï</tag>
        <tag>ÊµôÂ§ß</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÊµôÂ§ßÁ†îÁ©∂ÁîüÊú∫ËØï1-10È¢ò]]></title>
    <url>%2F2018%2F05%2F30%2F%E6%B5%99%E5%A4%A7%E7%A0%94%E7%A9%B6%E7%94%9F%E6%9C%BA%E8%AF%951-10%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Ê¨ßÊãâÂõûË∑Ø È¢òÁõÆÈìæÊé• ÂàÜÊûê ÂÖàÂà§Êñ≠ÊØè‰∏™ÁÇπÁöÑÂ∫¶ÊòØÂÅ∂Êï∞ÔºåÁÑ∂ÂêéÁî®Âπ∂Êü•ÈõÜÂà§Êñ≠ËøûÈÄöÊÄßÔºåÊ≥®ÊÑèÂçï‰∏™ÁÇπÂàÜÁ¶ªÂá∫Êù•ÊòØÂèØ‰ª•ÁöÑ„ÄÇ Ê≥®ÔºöÁ¨¨‰∏ÄÊ¨°ÂÜôÊµôÂ§ßÁöÑÈ¢òÁõÆÔºåËôΩÁÑ∂È¢òÁõÆÈáåÈù¢ËØ¥‰∫ÜÈöèÂêéËæìÂÖ•0Ë°®Á§∫ËæìÂÖ•ÁªìÊùüÔºå‰ΩÜ‰∫ãÂÆûÊòØ‰∏äËøòÊòØË¶ÅEOFÂà§Êñ≠ÔºåÊàëËøôÈáåTLE‰∫ÜÂ•ΩÂá†Ê¨°„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** @Author: sun000* @Date: 2018-05-30 16:14:36* @Last Modified by: sun000* @Last Modified time: 2018-05-30 16:25:31*/#include &lt;cstdio&gt;#include &lt;cstring&gt;int fa[1010];int s;void init(int n) &#123; s = n; for(int i = 0; i &lt;= s; i++) fa[i] = i;&#125;int fin(int x) &#123; if(x == fa[x]) return x; return fa[x] = fin(fa[x]);&#125;void un(int x, int y) &#123; x = fin(x); y = fin(y); if(x != y) &#123; fa[x] = y; s--; &#125;&#125;int V[1010];bool vis[1010];int main(void) &#123; int n, m, u, v; while(scanf("%d", &amp;n) != EOF &amp;&amp; n) &#123; init(n); memset(V, 0, sizeof(V)); memset(vis, false, sizeof(vis)); scanf("%d", &amp;m); for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d", &amp;u, &amp;v); V[u]++; V[v]++; un(u, v); vis[u] = vis[v] = true; &#125; bool ans = true; for(int i = 1; i &lt;= n; i++) &#123; if(!vis[i]) s--; if(V[i] &amp; 1) &#123; ans = false; break; &#125; &#125; if(s != 1) ans = false; printf("%d\n", ans); &#125; return 0;&#125; Â••Ëøê‰ºöÊéíÂ∫èÈóÆÈ¢ò È¢òÁõÆÈìæÊé• ÂàÜÊûê Áõ¥Êé•ÊåâÁÖßÂõõÁßçÊÉÖÂÜµÊéíÂ∫èÁÑ∂ÂêéÔºåÁÑ∂ÂêéÁõ¥Êé•ËæìÂá∫Â∞±ÂèØ‰ª•‰∫ÜÔºåÁÆÄÂçïÁöÑÊ®°ÊãüÈ¢ò„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** @Author: sun000* @Date: 2018-05-30 16:26:13* @Last Modified by: sun000* @Last Modified time: 2018-05-30 16:53:47*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f;struct node &#123; int ids; int gold_cnt, medal_cnt, popu_cnt; int rank[4]; void print() &#123; int r = INF, m = -1; for(int i = 0; i &lt; 4; i++) &#123; if(rank[i] &lt; r) &#123; r = rank[i]; m = i + 1; &#125; &#125; printf("%d:%d\n",r, m); &#125;&#125;c[10010];bool cmp0(node a, node b) &#123; return a.ids &lt; b.ids;&#125;bool cmp1(node a, node b) &#123; return a.gold_cnt &gt; b.gold_cnt;&#125;bool cmp2(node a, node b) &#123; return a.medal_cnt &gt; b.medal_cnt;&#125;bool cmp3(node a, node b) &#123; return a.gold_cnt * b.popu_cnt &gt; b.gold_cnt * a.popu_cnt;&#125;bool cmp4(node a, node b) &#123; return a.medal_cnt * b.popu_cnt &gt; b.medal_cnt * a.popu_cnt;&#125;int main(void) &#123; int n, m; while(scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; for(int i = 0; i &lt; n; i++) &#123; c[i].ids = i; scanf("%d%d%d", &amp;c[i].gold_cnt, &amp;c[i].medal_cnt, &amp;c[i].popu_cnt); &#125; sort(c, c + n, cmp1); c[0].rank[0] = 1; for(int i = 1; i &lt; n; i++) &#123; if(c[i].gold_cnt == c[i - 1].gold_cnt) c[i].rank[0] = c[i - 1].rank[0]; else c[i].rank[0] = i + 1; &#125; sort(c, c + n, cmp2); c[0].rank[1] = 1; for(int i = 1; i &lt; n; i++) &#123; if(c[i].medal_cnt == c[i - 1].medal_cnt) c[i].rank[1] = c[i - 1].rank[1]; else c[i].rank[1] = i + 1; &#125; sort(c, c + n, cmp3); c[0].rank[2] = 1; for(int i = 1; i &lt; n; i++) &#123; if(c[i].gold_cnt * c[i - 1].popu_cnt == c[i - 1].gold_cnt * c[i].popu_cnt) c[i].rank[2] = c[i - 1].rank[2]; else c[i].rank[2] = i + 1; &#125; sort(c, c + n, cmp4); c[0].rank[3] = 1; for(int i = 1; i &lt; n; i++) &#123; if(c[i].medal_cnt * c[i - 1].popu_cnt == c[i - 1].medal_cnt * c[i].popu_cnt) c[i].rank[3] = c[i - 1].rank[3]; else c[i].rank[3] = i + 1; &#125; sort(c, c + n, cmp0); int k; for(int i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;k); c[k].print(); &#125; printf("\n"); &#125; return 0;&#125; ÁªßÁª≠ÁïÖÈÄöÈóÆÈ¢ò È¢òÁõÆÈìæÊé• ÂàÜÊûê ÊúÄÂ∞èÁîüÊàêÊ†ë ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** @Author: sun000* @Date: 2018-05-30 16:54:02* @Last Modified by: sun000* @Last Modified time: 2018-05-30 17:11:05*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;struct edge &#123; int u, v, w; edge(int mU = 0, int mV = 0, int mW = 0):u(mU),v(mV),w(mW)&#123;&#125;&#125;E[10000];bool cmp(edge a, edge b) &#123; return a.w &lt; b.w;&#125;int fa[110], s;void init(int n) &#123; s = n; for(int i = 0; i &lt;= n; i++) fa[i] = i;&#125;int fin(int x) &#123; if(fa[x] == x) return x; return fa[x] = fin(fa[x]);&#125;bool un(int x, int y) &#123; x = fin(x); y = fin(y); if(x != y) &#123; s--; fa[x] = y; return true; &#125; return false;&#125;int main(void) &#123; int n, op; while(scanf("%d", &amp;n) != EOF &amp;&amp; n) &#123; init(n); for(int i = 0; i &lt; n * (n - 1) / 2; i++) &#123; scanf("%d%d%d%d", &amp;E[i].u, &amp;E[i].v, &amp;E[i].w, &amp;op); if(op) un(E[i].u, E[i].v); &#125; long long int ans = 0; sort(E, E + n * (n - 1) / 2, cmp); for(int i = 0; i &lt; n * (n - 1)/ 2 &amp;&amp; s &gt; 1; i++) &#123; if(un(E[i].u, E[i].v)) ans += 1LL * E[i].w; &#125; printf("%lld\n", ans); &#125; return 0;&#125; ÁïÖÈÄöÈóÆÈ¢ò È¢òÁõÆÈìæÊé• ÂàÜÊûê ÊúÄÂ∞èÁîüÊàêÊ†ë ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** @Author: sun000* @Date: 2018-05-30 17:12:51* @Last Modified by: sun000* @Last Modified time: 2018-05-30 17:14:43*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;struct edge &#123; int u, v, w; edge(int mU = 0, int mV = 0, int mW = 0):u(mU),v(mV),w(mW)&#123;&#125;&#125;E[10000];bool cmp(edge a, edge b) &#123; return a.w &lt; b.w;&#125;int fa[110], s;void init(int n) &#123; s = n; for(int i = 0; i &lt;= n; i++) fa[i] = i;&#125;int fin(int x) &#123; if(fa[x] == x) return x; return fa[x] = fin(fa[x]);&#125;bool un(int x, int y) &#123; x = fin(x); y = fin(y); if(x != y) &#123; s--; fa[x] = y; return true; &#125; return false;&#125;int main(void) &#123; int n, m; while(scanf("%d%d", &amp;n, &amp;m) != EOF &amp;&amp; n) &#123; init(m); for(int i = 0; i &lt; n; i++) scanf("%d%d%d", &amp;E[i].u, &amp;E[i].v, &amp;E[i].w); long long int ans = 0; sort(E, E + n, cmp); for(int i = 0; i &lt; n &amp;&amp; s &gt; 1; i++) &#123; if(un(E[i].u, E[i].v)) ans += 1LL * E[i].w; &#125; if(s &gt; 1) printf("?\n"); else printf("%lld\n", ans); &#125; return 0;&#125; Grading È¢òÁõÆÈìæÊé• ‰ª£Á†Å 1234567891011121314151617181920212223242526272829/** @Author: sun000* @Date: 2018-05-31 09:53:13* @Last Modified by: sun000* @Last Modified time: 2018-05-31 09:58:42*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int main(void) &#123; int p, t, g1, g2, g3, gj; while(scanf("%d%d%d%d%d%d", &amp;p, &amp;t, &amp;g1, &amp;g2, &amp;g3, &amp;gj) != EOF) &#123; if(abs(g1 - g2) &lt;= t) printf("%.1f\n", (g1 + g2) / 2.0); else &#123; if(abs(g1 - g3) &lt;= t &amp;&amp; abs(g2 - g3) &lt;= t) printf("%.1f\n", 1.0 * max(g1, max(g2, g3))); else if(abs(g1 - g3) &lt;= t) printf("%.1f\n", (g1 + g3) / 2.0); else if(abs(g2 - g3) &lt;= t) printf("%.1f\n", (g2 + g3) / 2.0); else printf("%.1f\n", 1.0 * gj); &#125; &#125; return 0;&#125; Sharing È¢òÁõÆÈìæÊé• ÂàÜÊûê Âè™ÊúâÁ¨¨‰∏Ä‰∏™ÂÖ¨ÂÖ±ËäÇÁÇπÁî±‰∏§‰∏™ÂÖ∂‰ªñËäÇÁÇπÊåáÂêë„ÄÇÈô§‰∫ÜÁâπ‰æãÔºåÊù•ÈÇ£‰∏™Â≠óÁ¨¶‰∏≤ÂÆåÂÖ®Áõ∏ÂêåÔºåÂàôÂºÄÂßãÁöÑÈ¶ñÂú∞ÂùÄÂ∞±‰∏ÄÊ†∑„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031/** @Author: sun000* @Date: 2018-05-31 10:08:43* @Last Modified by: sun000* @Last Modified time: 2018-05-31 10:14:07*/#include &lt;cstdio&gt;#include &lt;cstring&gt;bool vis[1000010];int main(void) &#123; int s1, s2, n; int a, b; char c; int ans; while(scanf("%d%d%d", &amp;s1, &amp;s2, &amp;n) != EOF) &#123; memset(vis, false, sizeof(vis)); if(s1 == s2) ans = s1; vis[s1 + 1] = vis[s2 + 1] = true; for(int i = 0; i &lt; n; i++) &#123; scanf("%d %c %d", &amp;a, &amp;c, &amp;b); if(vis[b + 1]) ans = b; else vis[b + 1] = true; &#125; if(ans == -1) printf("-1\n"); else printf("%05d\n", ans); &#125; return 0;&#125; ÊâæÂá∫Áõ¥Á≥ª‰∫≤Â±û È¢òÁõÆÈìæÊé• ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** @Author: sun000* @Date: 2018-05-31 12:14:20* @Last Modified by: sun000* @Last Modified time: 2018-05-31 12:53:51*/#include &lt;cstdio&gt;#include &lt;cstring&gt;const int INF = 0x3f3f;int fa[30], ma[30];int dfs(int tar,int now) &#123; if(now == tar) return 0; if(fa[now] &gt;= 0) &#123; int tmp = dfs(tar, fa[now]); if(tmp &lt; INF) return tmp + 1; &#125; if(ma[now] &gt;= 0) &#123; int tmp = dfs(tar, ma[now]); if(tmp &lt; INF) return tmp + 1; &#125; return INF;&#125;void print(int k, bool flag) &#123; if(k == 0) printf("-\n"); else if(k == 1) printf("%s\n", flag ? "parent" : "child"); else if(k == 2) printf("%s\n", flag ? "grandparent" : "grandchild"); else &#123; for(int i = 0; i &lt; k - 2; i++) printf("great-"); printf("%s\n", flag ? "grandparent" : "grandchild"); &#125;&#125;void solve(char a, char b) &#123; int ans = dfs(a - 'A', b - 'A'); if(ans &lt; INF) print(ans, true); else &#123; ans = dfs(b - 'A', a - 'A'); if(ans &lt; INF) print(ans, false); else printf("-\n"); &#125;&#125;int main(void) &#123; int n, m; char op[5]; while(scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; memset(fa, -1, sizeof(fa)); memset(ma, -1, sizeof(ma)); for(int i = 0; i &lt; n; i++) &#123; scanf("%s", op); if(op[1] != '-') fa[op[0] - 'A'] = op[1] - 'A'; if(op[2] != '-') ma[op[0] - 'A'] = op[2] - 'A'; &#125; for(int i = 0; i &lt; m; i++) &#123; scanf("%s", op); solve(op[0], op[1]); &#125; &#125; return 0;&#125; ÂØªÊâæÂ§ßÂØåÁøÅ È¢òÁõÆÈìæÊé• ‰ª£Á†Å 12345678910111213141516171819202122232425/** @Author: sun000* @Date: 2018-05-31 12:54:34* @Last Modified by: sun000* @Last Modified time: 2018-05-31 13:02:09*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int v[100010];int main(void) &#123; int n, m; while(scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; for(int i = 0; i &lt; n; i++) scanf("%d", &amp;v[i]); sort(v, v + n); for(int i = n - 1; i &gt;= 0 &amp;&amp; m; i--, m--) printf("%d%c", v[i], (i &gt; 0 &amp;&amp; m &gt; 1) ? ' ' :'\n'); &#125; return 0;&#125; ‰∫åÂèâÊêúÁ¥¢Ê†ë È¢òÁõÆÈìæÊé• ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** @Author: sun000* @Date: 2018-05-31 13:10:40* @Last Modified by: sun000* @Last Modified time: 2018-05-31 13:41:12*/#include &lt;cstdio&gt;#include &lt;cstring&gt;struct node &#123; int num; node *l, *r; node(int mNum = -1):num(mNum)&#123;l = r = nullptr;&#125; void rel() &#123; if(l != nullptr) &#123; l -&gt; rel(); delete l; &#125; if(r != nullptr) &#123; r -&gt; rel(); delete r; &#125; &#125;&#125;*root;char str[20];node* build() &#123; node* r = new node(str[0] - '0'); node * pre = nullptr; node * ptr = r; for(int i = 1; i &lt; strlen(str); i++) &#123; pre = nullptr, ptr = r; int num = str[i] - '0'; while(ptr != nullptr) &#123; pre = ptr; if(ptr -&gt; num &gt; num) ptr = ptr -&gt; l; else ptr = ptr -&gt; r; &#125; node *tmp = new node(num); if(pre -&gt; num &gt; num) pre -&gt; l = tmp; else pre -&gt; r = tmp; &#125; return r;&#125;void release(node* k) &#123; k -&gt; rel(); delete k;&#125;bool ans = true;void dfsCheck(node *a, node * b) &#123; if(!ans || (!a &amp;&amp; !b)) return; if((a &amp;&amp; !b) || (b &amp;&amp; !a)) &#123; ans = false; return; &#125; if(a -&gt; num == b -&gt; num) &#123; dfsCheck(a -&gt; l, b -&gt; l); if(!ans) return; dfsCheck(a -&gt; r, b -&gt; r); &#125; else ans = false;&#125; bool solve() &#123; ans = true; node* tmpR = build(); dfsCheck(root, tmpR); release(tmpR); return ans;&#125;int main(void) &#123; int n; while(scanf("%d", &amp;n) != EOF &amp;&amp; n) &#123; scanf("%s", str); root = build(); for(int i = 0; i &lt; n; i++) &#123; scanf("%s", str); printf("%s\n", solve() ? "YES" : "NO"); &#125; release(root); &#125; return 0;&#125; ÁÅ´ÊòüA+B È¢òÁõÆÈìæÊé• ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** @Author: sun000* @Date: 2018-05-31 14:03:03* @Last Modified by: sun000* @Last Modified time: 2018-05-31 14:23:34*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int prime[30] = &#123;2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113&#125;;int a[30], b[30];int la, lb;bool read() &#123; char c; la = lb = 0; if(scanf("%d%c", &amp;a[la++], &amp;c) == EOF) return false; else &#123; while(c == ',') scanf("%d%c", &amp;a[la++], &amp;c); scanf("%d%c", &amp;b[lb++], &amp;c); while(c == ',') scanf("%d%c", &amp;b[lb++], &amp;c); &#125; for(int l = 0, r = la - 1; l &lt; r; l++, r--) swap(a[l], a[r]); for(int l = 0, r = lb - 1; l &lt; r; l++, r--) swap(b[l], b[r]); return true;&#125;int ans[30];int cnt;void solve() &#123; cnt = 0; int na, nb, nc = 0; for(int i = 0, j = 0; i &lt; la || j &lt; lb; i++, j++) &#123; if(i &gt;= la) na = 0; else na = a[i]; if(j &gt;= lb) nb = 0; else nb = b[i]; nc += na + nb; ans[cnt] = nc % prime[cnt]; nc /= prime[cnt]; cnt++; &#125; if(nc) ans[cnt++] = nc;&#125;int main(void) &#123; while(read()) &#123; solve(); for(int i = cnt - 1; i &gt;= 0; i--) printf("%d%c", ans[i], i ? ',' : '\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Êú∫ËØï</category>
      </categories>
      <tags>
        <tag>Êú∫ËØï</tag>
        <tag>ÊµôÂ§ß</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BP-NeuralNetworkÊâãÂÜôÊï∞Â≠óËØÜÂà´]]></title>
    <url>%2F2018%2F05%2F21%2FBP-NeuralNetwork%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Êàë‰∏ä‰∏ÄÁØáÂçöÂÆ¢‰∏≠ÂÜô‰∫ÜBPÁÆóÊ≥ïÁöÑ‰∏Ä‰∫õÊï∞Â≠¶ÂÖ¨ÂºèÁöÑÊé®ÂØºÔºå‰ΩÜÊòØÂÖ∂‰∏≠ÁöÑ‰ª£Á†Å‰∏çÂ§üÂΩ¢ÂºèÂåñÔºåÂè™ËÉΩËß£ÂÜ≥ÁâπÂÆöÁöÑÈóÆÈ¢ò„ÄÇÊâÄ‰ª•ËøôÊ¨°ÂÜô‰∫Ü‰∏Ä‰∏™ÈÄÇÂêàÊõ¥Â§öÈóÆÈ¢òÁöÑ‰ª£Á†Å„ÄÇ BPÂéüÁêÜÂ∞±‰∏çÂ§öËØ¥‰∫Ü„ÄÇÂèØ‰ª•Áúã‰∏ä‰∏ÄÁØáÂçöÂÆ¢„ÄÇ‰º†ÈÄÅÈó® ËøôÊ¨°ÊàëÂÅöÁöÑ‰∏ªË¶ÅÊòØËß£ÂÜ≥ÊâãÂÜôËØÜÂà´ÈóÆÈ¢ò„ÄÇ ‰∏ªË¶ÅÊòØ‰∏∫‰∫ÜÁªÉ‰π†BPÁöÑÂΩ¢ÂºèÂåñÂÜôÊ≥ïÔºåÊâÄ‰ª•‰πüÊ≤°Êúâ‰∫§ÂèâÈ™åËØÅ‰ªÄ‰πàÁöÑ„ÄÇ‰∏ªË¶ÅÊòØÂÆûÁé∞Âê¥ÊÅ©ËææËÄÅÂ∏àÁöÑdeep learning‰∏≠ÁöÑÁ®ãÂ∫èÊµÅÁ®ã„ÄÇ ‰∏ªË¶ÅÊµÅÁ®ãÂõæÔºö Âú®ÂÜô‰ª£Á†ÅÁöÑËøáÁ®ã‰∏≠ÂèëÁé∞ÁöÑ‰∏ªË¶ÅÂá†‰∏™ÈóÆÈ¢òÊòØÔºö ÊúâÁöÑÊó∂ÂÄôÂ∞ÜÊï∞ÊçÆËøõË°å‰∏≠ÂøÉÂåñÔºåÂèçËÄå‰ºö‰ΩøÊ®°ÂûãÂèòÂ∑Æ„ÄÇÊàëÂú®ËøôÈáåÂàöÂºÄÂßãÂØπXËøõË°å‰∫Ü‰∏≠ÂøÉÂåñÔºå‰ΩÜÊòØÁªìÊûúÂπ∂‰∏çÂ•ΩÔºà‰πüÊúâÂèØËÉΩÊòØÊàëÁöÑÊâìÂºÄÊñπÂºè‰∏çÂØπ„ÄÇ„ÄÇ„ÄÇÔºâ Á¨¨‰∫å‰∏™ÈóÆÈ¢òÂ∞±ÊòØÔºåÂú®Â§öÂàÜÁ±ªÊ®°Âûã‰∏≠„ÄÇÁõ¥Êé•‰ΩøÁî®‰∫åÂàÜÁ±ªÁöÑÊçüÂ§±ÂáΩÊï∞ÔºåÂπ∂‰∏çÊòØÂæàÂ•Ω„ÄÇÂ∞±ÊãøËøô‰∏™‰æãÂ≠êÊù•ËØ¥ÔºåËøôÈáå‰∏ÄÂÖ±Êúâ10‰∏™Ê†áÁ≠æÔºåÂØπ‰∫éÊØè‰∏Ä‰∏™Ê†∑Êú¨Â∞±Âè™Êúâ‰∏Ä‰∏™Ê†áÁ≠æÊòØÂØπÁöÑÔºåÂ¶ÇÊûúÁõ¥Êé•‰ΩøÁî®ÊúÄÊú¥Á¥†ÁöÑÊçüÂ§±ÂáΩÊï∞,ÈÇ£‰πà‰πüÂ∞±ÊòØÊØè‰∏ÄÁßçÂàÜÁ±ªÁöÑÊçüÂ§±ÁöÑÊùÉÈáçÊòØ‰∏ÄÊ†∑ÁöÑ„ÄÇ‰ΩÜÊòØËØØÂàÜÁ±ªÁöÑÊÉÖÂÜµÊúâ9ÁßçÔºåËÄåÊ≠£Á°ÆÁöÑÂè™Êúâ‰∏ÄÁßçÔºåÈÇ£‰πà‰πüÂ∞±ÂØºËá¥‰∫ÜÊ≠£Á°ÆÂàÜÁ±ªÂíåÈîôËØØÂàÜÁ±ªÁöÑÊçüÂ§±ÊùÉÂÄº‰∏çÂπ≥Ë°°„ÄÇÊâÄ‰ª•ÂàÜÁ±ªÂáÜÁ°ÆÁéáÈùûÂ∏∏Â∑Æ„ÄÇÊàëÁõÆÂâçËøòÊ≤°ÊúâÂ≠¶‰π†Âà∞Ê≠£Á°ÆÁöÑËß£ÂÜ≥ÊñπÊ≥ï„ÄÇËá™Â∑±YYÁöÑÊñπÂºèÔºåÊòØÂú®ËÆ°ÁÆóÊçüÂ§±ÂáΩÊï∞ÁöÑÊó∂ÂÄôÔºåÁªôÊ≠£Ê†∑Êú¨‰πò‰∏ä‰∏Ä‰∏™ÊùÉÂÄº„ÄÇÊàëÈÄâÁöÑÊòØ1024‰∏çË¶ÅÈóÆÊàë‰∏∫‰ªÄ‰πà„ÄÇÂ∏åÊúõÂú®‰ª•ÂêéÁöÑÂ≠¶‰π†‰∏≠ËÉΩÂ§üËß£ÂÜ≥Ëøô‰∏™ÈóÆÈ¢ò„ÄÇ ËøôÈáåÊàëÂ∑≤ÁªèÊâæÂà∞‰∫ÜËß£ÂÜ≥ÊñπÊ≥ïÔºåÊúâ‰∏Ä‰∏™Âè´softmaxÁöÑÁÆóÊ≥ïÔºåÂèØ‰ª•ÈÄöËøáCross-entropyÊù•ËÆ°ÁÆóloss functionÔºå‰∏çËøáÊàëÁöÑ‰ª£Á†ÅÊöÇÊó∂ËøòÊ≤°Êúâ‰øÆÊîπÔºåÊâÄ‰ª•Êàë‰ª£Á†Å‰∏≠ÁöÑlossÂáΩÊï∞ÊòØÈîôËØØÁöÑ„ÄÇ ‰ª£Á†ÅÔºö 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#!/usr/bin/env python3import numpy as npimport matplotlib.pyplot as pltfrom sklearn import datasetsfrom sklearn.metrics import classification_report # Ëøô‰∏™ÂåÖÊòØËØÑ‰ª∑Êä•Âëädef sigmoid(z): return 1 / (1 + np.exp(-z))def linear(z): return zdef sigmoid_gradient(z): return sigmoid(z) * (1 - sigmoid(z))def linear_gradient(z): return np.ones(z.shape, keepdims=True)def activate(z, method=linear): return method(z)def activate_gradition(z, method=linear_gradient): return method(z)def transform_target(Y): y_matrix = [] for k in range(0, 10): y_matrix.append((Y == k).astype(int)) return np.array(y_matrix)def paraments_init(layer_dims): np.random.seed(7) L = len(layer_dims) # ÊÄªÁöÑÊ∑±Â∫¶ w = [0] # ‰øùÂ≠òÊØè‰∏ÄÂ±ÇÁöÑw,ÂÖàÊîæÂÖ•‰∏Ä‰∏™0ÊòØ‰∏∫‰∫ÜÊúâÊïàÂèÇÊï∞‰∏ãÊ†á‰ªé1ÂºÄÂßãÔºåÊñπ‰æøÊìç‰Ωú b = [0] # ‰øùÂ≠òÊØè‰∏ÄÂ±ÇÁöÑb,ÂÖàÊîæÂÖ•‰∏Ä‰∏™0ÊòØ‰∏∫‰∫ÜÊúâÊïàÂèÇÊï∞‰∏ãÊ†á‰ªé1ÂºÄÂßãÔºåÊñπ‰æøÊìç‰Ωú for l in range(1, L): w.append(np.random.randn(layer_dims[l - 1], layer_dims[l])) b.append(np.zeros((layer_dims[l], 1))) return w, b # ËøîÂõûÂèÇÊï∞listdef forward(W, b, X, activation): # ÂâçÂêë‰º†Êí≠ Z = [0] A = [X] L = len(W) for l in range(1, L): Z.append(W[l].T @ A[l - 1] + b[l]) A.append(activate(Z[l], activation[l])) return Z, Adef cost(h, Y): return -np.mean(1024 * Y * np.log(h) + (1 - Y) * np.log(1 - h))def backward(W, b, Z, A, Y, activation_gradition, learning_rate=0.01): L = len(W) m = Y.shape[1] dA = - 1024 * Y / A[L - 1] + (1 - Y) / (1 - A[L - 1]) for l in reversed(range(1, L)): dZ = dA * activate_gradition(Z[l], activation_gradition[l]) dW = A[l - 1] @ dZ.T / m db = np.mean(dZ, axis=1, keepdims=True) dA = W[l] @ dZ W[l] -= learning_rate * dW b[l] -= learning_rate * db return W, bdef BP_model(X, Y, layer_dims, activation, activation_gradition, learning_rate=0.01, epoch=1000): W, b = paraments_init(layer_dims) L = len(layer_dims) costs = [] for e in range(epoch): Z, A = forward(W, b, X, activation) if e % 50 == 0: costs.append(cost(A[L - 1], Y)) W, b = backward(W, b, Z, A, Y, activation_gradition, learning_rate) return W, b, costsdef predict(W, b, X, activation): Z, A = forward(W, b, X, activation) h = np.argmax(A[len(A) - 1], axis=0) return hdef cal_accuracy(h, Y_raw): return np.mean((h == Y_raw).astype(int)) * 100def main(): # Êï∞ÊçÆÂä†ËΩΩ digits = datasets.load_digits() X = digits.data.T Y_raw = digits.target Y = transform_target(Y_raw) # Êï∞ÊçÆÂàÜÂâ≤ random_index = np.arange(X.shape[1]) np.random.shuffle(random_index) test_m = (int)(X.shape[1] * 0.3) test_X = X[:, 0:test_m] test_Y = Y[:, 0:test_m] test_Y_raw = Y_raw[0:test_m] X = X[:, test_m:] Y = Y[:, test_m:] Y_raw = Y_raw[test_m:] # ÁΩëÁªúÂÆö‰πâ layer_dims = [X.shape[0], 30, 15, Y.shape[0]] activation = [linear, sigmoid, sigmoid, sigmoid] activation_gradition = [linear_gradient, sigmoid_gradient, sigmoid_gradient, sigmoid_gradient] # ËÆ≠ÁªÉ W, b, costs = BP_model(X, Y, layer_dims, activation, activation_gradition, 0.015, 8000) # ÊçüÂ§±ÂáΩÊï∞Âõæ # plt.plot(costs) # plt.show() # ÂáÜÁ°ÆÂ∫¶ h = predict(W, b, X, activation) print(classification_report(Y_raw, h)) print(cal_accuracy(h, Y_raw)) # È¢ÑÊµã test_h = predict(W, b, test_X, activation) print(classification_report(test_Y_raw, test_h)) print(cal_accuracy(test_h, test_Y_raw))if __name__ == '__main__': main() ÂÆûÈ™åÁªìÊûúÔºö]]></content>
      <categories>
        <category>Êú∫Âô®Â≠¶‰π†</category>
      </categories>
      <tags>
        <tag>Êú∫Âô®Â≠¶‰π†</tag>
        <tag>Á•ûÁªèÁΩëÁªú</tag>
        <tag>ÊâãÂÜôËØÜÂà´</tag>
        <tag>ÂèçÂêë‰º†Êí≠ÁÆóÊ≥ï</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BP-NeuralNetwork-ÂéüÁêÜÂèäÂÆûÁé∞]]></title>
    <url>%2F2018%2F05%2F18%2FBP-NeuralNetwork-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[ÂéÜÂè≤ 1969Âπ¥M.MinskyÂíåS.PapertÊâÄËëóÁöÑ„ÄäÊÑüÁü•Êú∫„Äã‰∏Ä‰π¶Âá∫ÁâàÔºåÂÆÉÂØπÂçïÂ±ÇÁ•ûÁªèÁΩëÁªúËøõË°å‰∫ÜÊ∑±ÂÖ•ÂàÜÊûêÔºåÂπ∂‰∏î‰ªéÊï∞Â≠¶‰∏äËØÅÊòé‰∫ÜËøôÁßçÁΩëÁªúÂäüËÉΩÊúâÈôêÔºåÁîöËá≥‰∏çËÉΩËß£ÂÜ≥Ë±°&quot;ÂºÇÊàñ&quot;ËøôÊ†∑ÁöÑÁÆÄÂçïÈÄªËæëËøêÁÆóÈóÆÈ¢ò„ÄÇÂêåÊó∂Ôºå‰ªñ‰ª¨ËøòÂèëÁé∞ÊúâËÆ∏Â§öÊ®°ÂºèÊòØ‰∏çËÉΩÁî®ÂçïÂ±ÇÁΩëÁªúËÆ≠ÁªÉÁöÑÔºåËÄåÂØπ‰∫éÂ§öÂ±ÇÁΩëÁªúÂàôÊ≤°ÊúâË°å‰πãÊúâÊïàÁöÑ‰ΩéÂ§çÊùÇÂ∫¶ÁÆóÊ≥ïÔºåÊúÄÂêé‰ªñ‰ª¨ÁîöËá≥ËÆ§‰∏∫Á•ûÁªèÂÖÉÁΩëÁªúÊó†Ê≥ïÂ§ÑÁêÜÈùûÁ∫øÊÄßÈóÆÈ¢ò„ÄÇÁÑ∂ËÄå‰∫é1974Âπ¥ÔºåPaul WerbosÈ¶ñÊ¨°ÁªôÂá∫‰∫ÜÂ¶Ç‰ΩïËÆ≠ÁªÉ‰∏ÄËà¨ÁΩëÁªúÁöÑÂ≠¶‰π†ÁÆóÊ≥ï‚Äîback propagation„ÄÇËøô‰∏™ÁÆóÊ≥ïÂèØ‰ª•È´òÊïàÁöÑËÆ°ÁÆóÊØè‰∏ÄÊ¨°Ëø≠‰ª£ËøáÁ®ã‰∏≠ÁöÑÊ¢ØÂ∫¶ÔºåËÆ©‰ª•‰∏äÊàë‰ª¨ÁöÑÊé®ÂØºÂæó‰ª•ÂÆûÁé∞ÔºÅÔºÅ ‰∏çÂ∑ßÁöÑÊòØÔºåÂú®ÂΩìÊó∂Êï¥‰∏™‰∫∫Â∑•Á•ûÁªèÁΩëÁªúÁ§æÁæ§‰∏≠Êó†‰∫∫Áü•ÊôìPaulÊâÄÊèêÂá∫ÁöÑÂ≠¶‰π†ÁÆóÊ≥ï„ÄÇÁõ¥Âà∞80Âπ¥‰ª£‰∏≠ÊúüÔºåBPÁÆóÊ≥ïÊâçÈáçÊñ∞Ë¢´David Rumelhart„ÄÅGeoffrey HintonÂèäRonald Williams„ÄÅDavid ParkerÂíåYann LeCunÁã¨Á´ãÂèëÁé∞ÔºåÂπ∂Ëé∑Âæó‰∫ÜÂπøÊ≥õÁöÑÊ≥®ÊÑèÔºåÂºïËµ∑‰∫Ü‰∫∫Â∑•Á•ûÁªèÁΩëÁªúÈ¢ÜÂüüÁ†îÁ©∂ÁöÑÁ¨¨‰∫åÊ¨°ÁÉ≠ÊΩÆ„ÄÇ ÁÆÄ‰ªã Â•Ω‰∫ÜÔºåÁé∞Âú®ËÆ©Êàë‰ª¨Êù•‰∫ÜËß£‰∏Ä‰∏ãBPÁ•ûÁªèÁΩëÁªúÊòØÂ¶Ç‰ΩïÂ≠¶‰π†ÁöÑ„ÄÇ ËÆ°ÁÆóÂõæ È¶ñÂÖàÔºåÊàë‰ª¨Êù•ËÆ≤‰∏ÄËÆ≤ËÆ°ÁÆóÂõæÁöÑÊ¶ÇÂøµ„ÄÇÊàëÂ∞Ü\(e = (a + b) \times (b+1)\)ÁîªÊàê‰∏ÄÂº†ËÆ°ÁÆóÂõæ„ÄÇÂ¶Ç‰∏ãÔºö ÂÅáËÆæËæìÂÖ•a=2Ôºåb=1ÔºåÂú®ËøôÁßçÊÉÖÂÜµ‰∏ãÔºåÊàë‰ª¨ÂæàÂÆπÊòìÊ±ÇÂá∫Áõ∏ÈÇªËäÇÁÇπ‰πãÈó¥ÁöÑÂÅèÂØºÂÖ≥Á≥ª: Áî®ÈìæÂºèÊ≥ïÂàô \[\frac{\partial e}{\partial a} =\frac{\partial e}{\partial c} \frac{\partial c}{\partial a} \] \[\frac{\partial e}{\partial b} = \frac{\partial e}{\partial c} \frac{\partial c}{\partial b} + \frac{\partial e}{\partial d} \frac{\partial d}{\partial b}\] \(\frac{\partial e}{\partial a}\)ÁöÑÂÄºÂ∞±ÊòØeÂà∞aË∑ØÂæÑ‰∏äÁöÑÂÅèÂØºÊï∞‰πòÁßØÔºåÁ±ª‰ººÁöÑÔºå\(\frac{\partial e}{\partial b}\)ÊòØ‰ªéeÂà∞bÁöÑ‰∏§Êù°Ë∑ØÂæÑÁöÑÂÅèÂØºÊï∞‰πòÁßØÂíå„ÄÇÁ±ª‰ººÁöÑÂèØ‰ª•Êé®Âá∫ÁΩëÁä∂ÁªìÊûÑÁöÑÂÅèÂØºÊï∞Ê±ÇÊ≥ï„ÄÇËøô‰πüÊòØTensorFlowÁöÑÂÆûÁé∞ÂéüÁêÜ‰πã‰∏Ä„ÄÇ ËøôÁßçÊÉÖÂÜµ‰∏ãÂÅèÂØºÂæàÂÆπÊòìÊ±ÇÂæóÔºåÂõ†‰∏∫Êàë‰ª¨Â∑≤ÁªèÁü•ÈÅìÁΩëÁªúÁöÑÂáΩÊï∞ÂÖ≥Á≥ªÂºèÔºåe=Ôºàa+bÔºâ*Ôºàb+1ÔºâÔºåËøôÊòØ‰∏Ä‰∏™Ê≤°ÊúâÊùÉÂÄºÂπ≤È¢ÑÔºåÂ∑≤Áü•ËæìÂÖ•‰∏éËæìÂá∫‰πãÈó¥ÂÖ≥Á≥ªÁöÑÁΩëÁªú„ÄÇÂÆûÈôÖÂΩì‰∏≠Êàë‰ª¨Âè™ÊòØÁü•ÈÅìe‰∏éËæìÂá∫‰πãÈó¥ÁöÑÂÖ≥Á≥ªÔºåÂ∞±ÊòØ‰∏äÈù¢ËØ¥ÁöÑC=Ôºày-tÔºâ^2ÔºåËÄå‰∏î‰ºöÊúâÊàêÂçÉ‰∏ä‰∏áÁöÑÊùÉÂÄºÂíåÂÅèÁΩÆÂπ≤È¢ÑÊ±ÇÂØºÁöÑËøáÁ®ã„ÄÇÈÇ£‰πàÊç¢‰∏™ÊÄùË∑ØÔºåËÉΩ‰∏çËÉΩÊ±ÇËæìÂá∫ÂØπÁªìÊûúÁöÑÂÅèÂØºÂë¢Ôºü ÂÜçÂà©Áî®‰∏äÂõæÁöÑÂÖ≥Á≥ª„ÄÇËäÇÁÇπcÂØπeÂÅèÂØº2Âπ∂Â∞ÜÁªìÊûúÂ†ÜÊîæËµ∑Êù•ÔºåËäÇÁÇπdÂØπeÂÅèÂØº3Âπ∂Â∞ÜÁªìÊûúÂ†ÜÊîæËµ∑Êù•ÔºåËá≥Ê≠§Á¨¨‰∫åÂ±ÇÂÆåÊØïÔºåÊ±ÇÂá∫ÂêÑËäÇÁÇπÊÄªÂ†ÜÊîæÈáèÂπ∂ÁªßÁª≠Âêë‰∏ã‰∏ÄÂ±ÇÂèëÈÄÅ„ÄÇËäÇÁÇπcÂêëaÂèëÈÄÅ21Âπ∂ÂØπÂ†ÜÊîæËµ∑Êù•ÔºåËäÇÁÇπcÂêëbÂèëÈÄÅ21Âπ∂Â†ÜÊîæËµ∑Êù•ÔºåËäÇÁÇπdÂêëbÂèëÈÄÅ\(3*1\)Âπ∂Â†ÜÊîæËµ∑Êù•ÔºåËá≥Ê≠§Á¨¨‰∏âÂ±ÇÂÆåÊØïÔºåËäÇÁÇπaÂ†ÜÊîæËµ∑Êù•ÁöÑÈáè‰∏∫2ÔºåËäÇÁÇπbÂ†ÜÊîæËµ∑Êù•ÁöÑÈáè‰∏∫\(2*1+3*1=5\), Âç≥È°∂ÁÇπeÂØπbÁöÑÂÅèÂØºÊï∞‰∏∫5„ÄÇÁÆÄË¶ÅÁöÑÊ¶ÇÊã¨ÔºåÂ∞±ÊòØ‰ªéÊúÄ‰∏äÂ±ÇÁöÑËäÇÁÇπeÂºÄÂßãÔºå‰ª•Â±Ç‰∏∫Âçï‰ΩçËøõË°åÂ§ÑÁêÜ„ÄÇÂØπ‰∫éeÁöÑ‰∏ã‰∏ÄÂ±ÇÁöÑÊâÄÊúâÂ≠êËäÇÁÇπÔºåÂ∞Ü1‰πò‰ª•eÂà∞Êüê‰∏™ËäÇÁÇπË∑ØÂæÑ‰∏äÁöÑÂÅèÂØºÂÄºÔºåÂπ∂Â∞ÜÁªìÊûú‚ÄúÂ†ÜÊîæ‚ÄùÂú®ËØ•Â≠êËäÇÁÇπ‰∏≠„ÄÇÁ≠âeÊâÄÂú®ÁöÑÂ±ÇÊåâÁÖßËøôÊ†∑‰º†Êí≠ÂÆåÊØïÂêéÔºåÁ¨¨‰∫åÂ±ÇÁöÑÊØè‰∏Ä‰∏™ËäÇÁÇπÈÉΩ‚ÄúÂ†ÜÊîæ&quot;‰∫õÂÄºÔºåÁÑ∂ÂêéÊàë‰ª¨ÈíàÂØπÊØè‰∏™ËäÇÁÇπÔºåÊääÂÆÉÈáåÈù¢ÊâÄÊúâ‚ÄúÂ†ÜÊîæ‚ÄùÁöÑÂÄºÊ±ÇÂíåÔºåÂ∞±ÂæóÂà∞‰∫ÜÈ°∂ÁÇπeÂØπËØ•ËäÇÁÇπÁöÑÂÅèÂØº„ÄÇÁÑ∂ÂêéÂ∞ÜËøô‰∫õÁ¨¨‰∫åÂ±ÇÁöÑËäÇÁÇπÂêÑËá™‰Ωú‰∏∫Ëµ∑ÂßãÈ°∂ÁÇπÔºåÂàùÂßãÂÄºËÆæ‰∏∫È°∂ÁÇπeÂØπÂÆÉ‰ª¨ÁöÑÂÅèÂØºÂÄºÔºå‰ª•&quot;Â±Ç&quot;‰∏∫Âçï‰ΩçÈáçÂ§ç‰∏äËø∞‰º†Êí≠ËøáÁ®ãÔºåÂç≥ÂèØÊ±ÇÂá∫È°∂ÁÇπeÂØπÊØè‰∏ÄÂ±ÇËäÇÁÇπÁöÑÂÅèÂØºÊï∞„ÄÇ ÁÆóÊ≥ïÊµÅÁ®ã Âú®ËøôÈáåÊàë‰∏æ‰∏Ä‰∏™‰æãÂ≠êÔºåÂÖ≥‰∫éÁî®‰∏§Â±ÇBPÁ•ûÁªèÁΩëÁªúÊù•Ê±ÇËß£ÂºÇÊàñ(XOR)„ÄÇ ÂæàÊòæÁÑ∂ËøôÊòØ‰∏Ä‰∏™ÈùûÁ∫øÊÄßÊñπÁ®ãÁöÑÊ±ÇËß£ËøáÁ®ã„ÄÇ ÂÅáËÆæÂΩìÂâçÊúâÂ¶Ç‰∏ãÁΩëÁªúÔºö ÂÆö‰πâÊùÉÂÄº\(w^{(1)},w^{(2)}\)ÂàÜÂà´ÊòØËæìÂÖ•Â±ÇÂà∞ÈöêËóèÂ±ÇÔºåÈöêËóèÂ±ÇÂà∞ËæìÂá∫Â±ÇÁöÑÈìæÊé•ÊùÉÔºåÂÖ∂‰∏≠ÈòàÂÄºbÂú®\(w\)‰∏≠ÈöêÂΩ¢Ë°®ËææÔºåÂÅèÁΩÆËäÇÁÇπ\(x_0,h_0\)ÁöÑÂÄºÂßãÁªà‰∏∫1„ÄÇ ÂÖ∂‰∏≠\(w^{(1)}_{ij}\)Ë°®Á§∫ËæìÂÖ•ËäÇÁÇπ\(x_i\)ÂíåÈöêËóèËäÇÁÇπ\(h_j\)‰πãÈó¥ÁöÑËøûÊé•ÊùÉÔºåÁ±ª‰ººÁöÑÔºöÂÖ∂‰∏≠\(w^{(2)}_{ij}\)Ë°®Á§∫ËæìÈöêËóèËäÇÁÇπ\(h_i\)ÂíåËæìÂá∫ËäÇÁÇπ\(o_j\)‰πãÈó¥ÁöÑËøûÊé•ÊùÉ„ÄÇ ÂÆö‰πâ‰ª£‰ª∑ÂáΩÊï∞Ôºö \[Cost(h)= \frac{1}{2} \sum_i^m(h-y)^2\] ËøôÊòØÊúÄÊôÆÈÄöÁöÑ‰ª£‰ª∑ÂáΩÊï∞ÔºåÂΩìÁÑ∂Âú®logstical regressionÈáåÈù¢ËøòÊúâÂÖ∂‰ªñÁöÑÂÆö‰πâÊñπÊ≥ïÔºåËøôÈáåÂ∞±‰∏çÂ§öËØ¥‰∫Ü„ÄÇ ÂÆö‰πâÊøÄÊ¥ªÂáΩÊï∞Ôºö \[sigmoid(x)=\frac{1}{1+e^{-x}}\] ÂêåÊ†∑ÊøÄÊ¥ªÂáΩÊï∞‰πü‰∏çÊòØÂîØ‰∏ÄÁöÑÔºåËøòÊúâtanhÁ≠âÂÖ∂‰ªñÁöÑÈÄâÊã©ÔºåËøôÂè™ÊòØÊúÄÊôÆÈÄöÁöÑ‰∏ÄÁßç„ÄÇ ÊøÄÊ¥ªÂáΩÊï∞ÁöÑÊ¢ØÂ∫¶: \[dsigmoid(x) = \frac{\partial sigmoid(x)}{\partial x}=sigmoid(x) \times (1 - sigmoid(x))\] ÂÆö‰πâ‰∏Ä‰∏™Á•ûÁªèÂçïÂÖÉÁöÑÁªìÊûÑÂ¶Ç‰∏ãÔºö ÂÖ∂‰∏≠\(z=w^TX+b, a=sigmoid(z)\) Âú®ÊâßË°åËøáÁ®ã‰∏≠bÈöêËóèÂú®w‰∏≠ÔºåaÊòØËØ•Á•ûÁªèÂÖÉÁöÑËæìÂá∫Ôºå‰πüÊòØ‰∏ã‰∏ÄÂ±ÇÁ•ûÁªèÂÖÉÁöÑËæìÂÖ•„ÄÇ Ê≥®ÊÑèÔºöÊàëËøôÈáåÊâÄËÆ≤ÁöÑBPÊòØÁ¥ØÁßØBPÔºåÊòØÁªºÂêàÂºÄÁªøÊâÄÊúâÁöÑÊ†∑Êú¨ÁöÑ‰ª£‰ª∑ÂáΩÊï∞„ÄÇËøòÊúâ‰∏ÄÁßçBPÁÆóÊ≥ïÂè´ÂÅöÊ†áÂáÜBPÊØèÊ¨°ÂØπ‰∏Ä‰∏™Èò≥ÂéÜËøõË°åÊ¢ØÂ∫¶‰∏ãÈôçÔºåÈÄÇÁî®‰∫éÊ†∑Êú¨Êõ¥Â§öÁöÑÊÉÖÂÜµÔºåÂÖ∑‰ΩìÁªÜËäÇËøôÈáåÂ∞±‰∏çÂ§öËØ¥‰∫Ü„ÄÇ ÈöêËóèÂ±Ç -&gt; ËæìÂá∫Â±ÇÔºö ÂèçÂêë‰º†Êí≠ÁÆóÊ≥ïÔºåËØ¥ÁöÑÂ∞±ÊòØËØØÂ∑ÆÂèçÂìç‰º†Êí≠„ÄÇÊâÄ‰ª•Êàë‰ª¨ÂÖàÊù•ËÄÉËôë\(w^{(2)}\)Âç≥ÈöêËóèÂ±ÇÂíåËæìÂá∫Â±Ç‰πãÈó¥ÁöÑÂèÇÊï∞Â¶Ç‰ΩïÊ¢ØÂ∫¶‰∏ãÈôç„ÄÇ ‰∏∫‰∫ÜË°®ËææÊñπ‰æøÔºåÂú®ËøôÈÉ®ÂàÜ\(w^{(2)}\)ÊàëÂ∞±Áõ¥Êé•ÂÜôÂÅö\(w\)‰∫Ü ‰ª•\(w_{11}\)ÔºàÂ¶ÇÂõæ‰∏≠Á∫¢ËæπÔºâ‰Ωú‰∏∫‰æãÂ≠ê: Ë¶ÅÊõ¥Êñ∞\(w_{11}\)ÔºåÂÖ≥ÈîÆÂú®‰∫éÊ±ÇÂΩìÂâçÁä∂ÊÄÅÔºåÂÖ≥‰∫é\(w_{11}\)ÁöÑÊ¢ØÂ∫¶Ôºå‰πüÂ∞±ÊòØ\(\frac{\partial Cost}{\partial w_{11}}\) \[\frac{\partial Cost}{\partial w_{11}} = \frac{\partial Cost}{\partial h_1} \frac{\partial h_1}{\partial z_2} \frac{\partial z_2}{\partial w_{11}} ,(ËøôÈáåÁöÑh_1Â∞±ÊòØÁ•ûÁªèÂçïÂÖÉÁªìÊûÑ‰∏≠ÁöÑa_{21}ÔºåÂ∞±ÊòØËæìÂá∫Â±ÇÁöÑa1)\] Êàë‰ª¨ÂÖàÊù•Ê±Ç$ $: \[\frac{\partial Cost}{\partial h_1} =\sum_0^m(h_1^{(i)}-y_1^{(i)})\] ÁÑ∂ÂêéÊòØ$ $: \[\frac{\partial h_1}{\partial z_2} =dsigmoid(z_2)\] ËøôÈáåÂÆö‰πâÔºö \[\sigma^{(2)}_1= \frac{\partial Cost}{\partial h_1} \frac{\partial h_1}{\partial z_1} \] Ë°®Á§∫Âú®Á¨¨‰∏Ä‰∏™ËæìÂá∫Â±ÇÁ•ûÁªèÂÖÉ‰∫ßÁîüÁöÑËØØÂ∑Æ ÊúÄÂêéÊòØ\(\frac{\partial z_2}{\partial w_{11}}\),Ëøô‰∏ÄÈ°πÂæàÁÆÄÂçïÔºåËøôÂ∞±ÊòØ\(a_{11}\)Âç≥ÔºåÈöêËóèÂ±ÇÁöÑÁ¨¨‰∏Ä‰∏™ËæìÂá∫ÔºàÈô§ÂéªÂÅèÁΩÆÂçïÂÖÉÔºâ„ÄÇ ÂêëÈáèÂåñ‰ª£Á†ÅË°®Á§∫Ôºö 12sigma2 = (h - y) * dsigmoid(z2) # (ny, m)dw2 = (a1 @ sigma2.T) / m # (h, n_y) ËæìÂÖ•Â±Ç -&gt; ÈöêËóèÂ±Ç: \(w^{(1)}\)ÁöÑÊõ¥Êñ∞ÂÖ∂ÂÆûÂíå\(w^{(2)}\)Á±ª‰ºº„ÄÇ‰ª•‰∏ã\(w_{(1)}\)‰πüÁÆÄÂÜô‰Ωú\(w\) ‰ª•\(w_{11}\)ÔºàÂ¶ÇÂõæ‰∏≠Á∫¢ËæπÔºâ‰Ωú‰∏∫‰æãÂ≠ê: ÂÄºÂæóÊ≥®ÊÑèÁöÑÔºå‰πüÊòØÂíå\(w^{(2)}\)Êõ¥Êñ∞‰∏çÂêåÁöÑÊòØÔºöËøôÈáåÁöÑËØØÂ∑ÆÊù•‰∏éËøû‰∏™Âú∞ÊñπÔºå‰∏Ä‰∏™ÊòØ\(o_1\)Ôºå‰∏Ä‰∏™ÊòØ\(o_2\) \[\frac{\partial Cost}{\partial w_{11}} = \frac{\partial Cost}{\partial a_1} \frac{\partial a_1}{\partial z_1} \frac{\partial z_1}{\partial w_{11}} \] ÂÖàÊù•Ê±Ç\(\frac{\partial Cost}{\partial a_1}\) \[\frac{\partial Cost}{\partial a_1} = \frac{\partial Cost}{\partial z_2}\frac{\partial z_2}{\partial a_1}=\sigma_2 \frac{\partial z_2}{\partial a_1}\] ËøôÈáåÁöÑ\(z_2, \sigma_2\)ÈÉΩÊòØÁü©ÈòµÔºåÊúÄÂêéÁöÑ‰πòÊ≥ï‰πüÊòØÁü©Èòµ‰πòÊ≥ïÔºåË°®Á§∫ËØØÂ∑ÆÊù•Ëá™Â§ö‰∏™Á•ûÁªèÂçïÂÖÉÔºåÂç≥Êù•Ëá™‰∏äÂõæ‰∏≠‰∏§Êù°ÁªøËæπ \[\frac{\partial a_1}{\partial z_1} = dsigmoid(z_1) \] \[\frac{\partial z_1}{\partial w_{11}}=x_1\] ÂêëÈáèÂåñ‰ª£Á†ÅË°®Á§∫Ôºö 12sigma1 = w2[1:, :].reshape(hidden_size, ny) @ sigma2 * dsigmoid(z1)dw1 = (X @ sigma1.T) / m # (n, h) ‰æãÂ≠ê ÊúÄÂêéÊòØÊ±ÇËß£ÂºÇÊàñÁ≠âÈÄªËæëËøêÁÆóÁöÑÁ•ûÁªèÁΩëÁªúÂèäÂÖ∂BPËÆ≠ÁªÉËøáÁ®ãÁöÑ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#!/usr/bin/env pythonimport numpy as npimport matplotlib.pyplot as pltX = np.array([[0, 0, 1, 1], [1, 0, 1, 0]])y = np.array([[0, 0, 1, 0], # ‰∏é [1, 1, 0, 1], # ‰∫éÈùû [1, 0, 1, 1], # Êàñ [0, 1, 0, 0], # ÊàñÈùû [0, 1, 1, 0]]) # ÂºÇÊàñhidden_size = 5 # ÈöêËóèÂ±ÇËäÇÁÇπÊï∞ÈáèÔºà‰∏çÂåÖÊã¨ÂÅèÁΩÆÂçïÂÖÉÔºâdef sigmoid(z): return 1 / (1 + np.exp(-z))def dsigmoid(z): # sigmoidÁöÑÊ¢ØÂ∫¶ return sigmoid(z) * (1 - sigmoid(z))def forward(w1, w2, X, y): # ÂâçÂêë‰º†Êí≠ (n, m) = X.shape z1 = w1.T @ np.concatenate((np.ones(m).reshape(1, m), X)) a1 = sigmoid(z1) z2 = w2.T @ np.concatenate((np.ones(m).reshape(1, m), a1)) h = sigmoid(z2) cost = np.mean(np.power((h - y), 2)) / 2 return z1, a1, z2, h, cost # ÊâÄÊúâËøîÂõû‰∏çÂåÖÂê´ÂÅèÁΩÆÂçïÂÖÉÁöÑ‰ø°ÊÅØÔºåÂõ†‰∏∫ÂÅèÊâßÂçïÂÖÉ‰∏çÈúÄË¶ÅÊ¢ØÂ∫¶‰∏ãÈôçdef back_regression(w1, w2, X, y, epoch=1000, learning_rate=0.01): # ÂèçÂêë‰º†Êí≠ (n, m) = X.shape # ÁâπÂæÅÊï∞Èáè, Ê†∑Êú¨Êï∞Èáè ny = y.shape[0] cost_list = [] for i in range(epoch): z1, a1, z2, h, cost = forward(w1, w2, X, y) cost_list.append(cost) # Ê±ÇÊ¢ØÂ∫¶ # ÈöêËóèÂ±Ç -&gt; ËæìÂá∫Â±Ç sigma2 = (h - y) * dsigmoid(z2) # (ny, m) dw2 = (a1 @ sigma2.T) / m # (h, n_y) # ËæìÂÖ•Â±Ç -&gt; ÈöêËóèÂ±Ç sigma1 = w2[1:, :].reshape(hidden_size, ny) @ sigma2 * dsigmoid(z1) dw1 = (X @ sigma1.T) / m # (n, h) # ÂÅèÁΩÆÂçïÂÖÉ‰∏çÂèò dw2 = np.concatenate((np.zeros(ny).reshape(1, ny), dw2)) dw1 = np.concatenate( (np.zeros(hidden_size).reshape(1, hidden_size), dw1)) # ÂèÇÊï∞Êõ¥Êñ∞ w1 = w1 - learning_rate * dw1 w2 = w2 - learning_rate * dw2 return w1, w2, cost_listdef main(): w1 = np.random.randn(X.shape[0] + 1, hidden_size) w2 = np.random.randn(hidden_size + 1, y.shape[0]) z1, a1, z2, h, cost = forward(w1, w2, X, y) w1, w2, costs = back_regression(w1, w2, X, y, 20000, 0.1) z1, a1, z2, h, cost = forward(w1, w2, X, y) print(h) # ÁîªÂá∫‰ª£‰ª∑ÂáΩÊï∞ÂèòÂåñÂõæ fig, ax = plt.subplots(figsize=(8, 6)) ax.plot(costs) plt.show()if __name__ == '__main__': main() ÂèÇËÄÉ Áü•‰πéhttps://www.zhihu.com/question/27239198?rf=24827633 Charlotte77ÁöÑÂçöÂÆ¢http://www.cnblogs.com/charlotte77/p/5629865.html Ê≥®ÔºöÊõ¥ËØ¶ÁªÜÁöÑÊé®ÂØºËøáÁ®ãÂèØ‰ª•ÁúãËØ•ÂçöÂÆ¢]]></content>
      <categories>
        <category>Êú∫Âô®Â≠¶‰π†</category>
      </categories>
      <tags>
        <tag>Êú∫Âô®Â≠¶‰π†</tag>
        <tag>Á•ûÁªèÁΩëÁªú</tag>
        <tag>ÂèçÂêë‰º†Êí≠ÁÆóÊ≥ï</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Â∏∏ËßÅÈöèÊú∫ÂèòÈáèÂèäÂÖ∂Ê¶ÇÁéáÂàÜÂ∏É]]></title>
    <url>%2F2018%2F05%2F16%2F%E5%B8%B8%E8%A7%81%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%2F</url>
    <content type="text"><![CDATA[Â∏∏Áî®ÁöÑÁ¶ªÊï£ÂûãÈöèÊú∫ÂèòÈáèÂèäÂÖ∂Ê¶ÇÁéáÂàÜÂ∏É Ôºà0-1ÔºâÂàÜÂ∏ÉÔºà‰ºØÂä™Âà©ÂàÜÂ∏É(Bernoulli distribution)„ÄÅ‰∏§ÁÇπÂàÜÂ∏ÉÔºâ Â¶ÇÊûúÈöèÊú∫ÂèòÈáèÔº∏ Âè™ÂèØËÉΩÂèñÔºê‰∏éÔºë‰∏§‰∏™ÂÄºÔºåÂÖ∂Ê¶ÇÁéáÂàÜÂ∏É‰∏∫Ôºö \[P\{X = 0\} = 1- p, P\{X = 1\} = p, 0 &lt; p &lt; 1\] ÊàñËÄÖÂÜôÊàê \[P\{X = k\} = p^k(1-p)^{1-k}, k = 0, 1, 0 &lt; p &lt;1\] ÂàôÁß∞ÈöèÊú∫ÂèòÈáèÔº∏ Êúç‰ªéÔºàÔºêÔºçÔºëÔºâÂàÜÂ∏ÉÊàñ‰∏§ÁÇπÂàÜÂ∏ÉÔºéÂÆÉÁöÑÊ¶ÇÁéáÂàÜÂ∏É‰πüÂèØ‰ª•ÂÜôÊàê X 0 1 P 1-p p ‰∫åÈ°πÂàÜÂ∏É Âú®ÔΩéÈáç‰ºØÂä™Âà©ËØïÈ™å‰∏≠ÔºåÂ¶ÇÊûú‰ª•Ôº∏Ë°®Á§∫‰∫ã‰ª∂Ôº° Âá∫Áé∞ÁöÑÊ¨°Êï∞ÔºåÂàôÔº∏ÊòØ‰∏Ä‰∏™Á¶ªÊï£ÂûãÈöèÊú∫ÂèòÈáèÔºåÂÆÉÁöÑÊâÄÊúâÂèØËÉΩÂèñÂÄºÊòØ\(0,1,2,‚Ä¶,n.ËÆæÔº∞(Ôº°)Ôºù pÔºàÔºêÔºú pÔºúÔºëÔºâ\)„ÄÇÂÖ∏Âûã‰æãÂ≠êÊòØÊâîÁ°¨Â∏ÅÔºåÁ°¨Â∏ÅÊ≠£Èù¢Êúù‰∏äÊ¶ÇÁéá‰∏∫p, ÈáçÂ§çÊâînÊ¨°Á°¨Â∏ÅÔºåkÊ¨°‰∏∫Ê≠£Èù¢ÁöÑÊ¶ÇÁéáÂç≥‰∏∫‰∏Ä‰∏™‰∫åÈ°πÂàÜÂ∏ÉÊ¶ÇÁéá„ÄÇÊ¶ÇÁéáÂáΩÊï∞‰∏∫ \[P\{X=k\}=C_n^kp^k(1-p)^{n-k}\] Â§öÈ°πÂºèÂàÜÂ∏É Êää‰∫åÈ°πÂàÜÂ∏ÉÂÖ¨ÂºèÂÜçÊé®ÂπøÔºåÂ∞±ÂæóÂà∞‰∫ÜÂ§öÈ°πÂàÜÂ∏É„ÄÇÊØîÂ¶ÇÊâîÈ™∞Â≠êÔºå‰∏çÂêå‰∫éÊâîÁ°¨Â∏ÅÔºåÈ™∞Â≠êÊúâ6‰∏™Èù¢ÂØπÂ∫î6‰∏™‰∏çÂêåÁöÑÁÇπÊï∞ÔºåËøôÊ†∑ÂçïÊ¨°ÊØè‰∏™ÁÇπÊï∞Êúù‰∏äÁöÑÊ¶ÇÁéáÈÉΩÊòØ1/6ÔºàÂØπÂ∫îp1~p6ÔºåÂÆÉ‰ª¨ÁöÑÂÄº‰∏ç‰∏ÄÂÆöÈÉΩÊòØ1/6ÔºåÂè™Ë¶ÅÂíå‰∏∫1‰∏î‰∫íÊñ•Âç≥ÂèØÔºåÊØîÂ¶Ç‰∏Ä‰∏™ÂΩ¢Áä∂‰∏çËßÑÂàôÁöÑÈ™∞Â≠êÔºâ,ÈáçÂ§çÊâînÊ¨°ÔºåÂ¶ÇÊûúÈóÆÊúâxÊ¨°ÁÇπÊï∞kÊúù‰∏äÁöÑÊ¶ÇÁéáÂ∞±ÊòØÔºö(Âè™Êäï‰∏ÄÊ¨°kÊúù‰∏äÁöÑÊ¶ÇÁéá) \[P\{X=k\}=C_n^kp_k^k(1-p_k)^{n-k}\] Âá†‰ΩïÂàÜÂ∏É ËÆæËØïÈ™åÔº•Âè™Êúâ‰∏§‰∏™ÂèØËÉΩÁöÑÂØπÁ´ãÁöÑÁªìÊûúÔº° ÂèäÔº°ÈùûÔºåÂπ∂‰∏î\(Ôº∞(Ôº°)Ôºù pÔºåÔº∞(\overline{Ôº°}ÔºâÔºùÔºëÔºç pÔºåÂÖ∂‰∏≠ÔºêÔºú ÔΩêÔºúÔºë\)ÔºéÂ∞ÜËØïÈ™åÔº•Áã¨Á´ãÂú∞ÈáçÂ§çËøõË°å‰∏ãÂéªÔºåÁõ¥Âà∞‰∫ã‰ª∂Ôº°ÂèëÁîü‰∏∫Ê≠¢ÔºéÂ¶ÇÊûú‰ª•Ôº∏Ë°®Á§∫ÊâÄÈúÄË¶ÅÁöÑËØïÈ™åÊ¨°Êï∞ÔºåÂàôÔº∏ÊòØ‰∏Ä‰∏™ÈöèÊú∫ÂèòÈáèÔºåÂÆÉÂèØËÉΩÂèñÁöÑÂÄºÊòØÔºëÔºåÔºíÔºåÔºìÔºå‚ãØÔºéÁî±‰∫é‰∫ã‰ª∂ÔΩõÔº∏ Ôºù ÔΩãÔΩùË°®Á§∫ÂâçÔΩãÔºçÔºëÊ¨°ËØïÈ™å‰∏≠‰∫ã‰ª∂Ôº°ÈÉΩÊ≤°ÊúâÂèëÁîüÔºåËÄåÂú®Á¨¨ÔΩãÊ¨°ËØïÈ™å‰∏≠‰∫ã‰ª∂Ôº° ÂèëÁîüÔºåÂõ†Ê≠§ \[P\{X=k\}=(1-p)^{k-1}p, k = 1, 2, 3,...\] Êàë‰ª¨Áß∞ÈöèÊú∫ÂèòÈáèXÊúç‰ªéÂá†‰ΩïÂàÜÂ∏É„ÄÇ Ê≥äÊùæÂàÜÂ∏É ËÆæÈöèÊú∫ÂèòÈáèÔº∏ ÁöÑÊâÄÊúâÂèØËÉΩÂèñÂÄº‰∏∫\(0,1,2,...\)ÔºåÂπ∂‰∏î \[P\{X=k\}=\frac{\lambda^ke^{-\lambda}}{k!},k=0,1,2,3...\] ÂÖ∂‰∏≠ŒªÔºûÔºêÊòØÂ∏∏Êï∞ÔºåÂàôÁß∞ÈöèÊú∫ÂèòÈáèÔº∏Êúç‰ªéÂèÇÊï∞‰∏∫ŒªÁöÑÊ≥äÊùæÂàÜÂ∏ÉÔºåËÆ∞‰ΩúÔº∏ÔΩûœÄÔºàŒªÔºâÔºéÊòìÁü• \[\frac{\lambda^ke^{-\lambda}}{k!} &gt; 0, k = 0, 1, 2,...\] \[\sum_{k=0}^{‚àû}\frac{\lambda^ke^{-\lambda}}{k!} =e^{-\lambda}\sum_{k=0}^{‚àû}\frac{\lambda^k}{k!}=e^{-\lambda} \times e^\lambda = 1\] Âú®ÂÆûÈôÖÈóÆÈ¢ò‰∏≠ÁªèÂ∏∏‰ºöÈÅáÂà∞Êúç‰ªéÊ≥äÊùæÂàÜÂ∏ÉÁöÑÈöèÊú∫ÂèòÈáèÔºé‰æãÂ¶ÇÔºåÂú®‰∏Ä‰∏™Èïø‰∏∫œÑÁöÑÊó∂Èó¥Èó¥ÈöîÂÜÖÊüêÁîµËØù‰∫§Êç¢Âè∞Êî∂Âà∞ÁöÑÁîµËØùÂëºÂè´Ê¨°Êï∞ÔºõÊüêÂåªÈô¢Âú®‰∏ÄÂ§©ÂÜÖÊù•ÊÄ•ËØäÁöÑÁóÖ‰∫∫Êï∞ÔºõÊüê‰∏ÄÊú¨‰π¶ÁöÑ‰∏ÄÈ°µ‰∏≠ÁöÑÂç∞Âà∑ÈîôËØØÊï∞Á≠âÈÉΩÊúç‰ªéÊ≥äÊùæÂàÜÂ∏ÉÔºé ÂΩì‰∫åÈ°πÂàÜÂ∏ÉÁöÑnÂæàÂ§ßËÄåpÂæàÂ∞èÊó∂ÔºåÊ≥äÊùæÂàÜÂ∏ÉÂèØ‰Ωú‰∏∫‰∫åÈ°πÂàÜÂ∏ÉÁöÑËøë‰ººÔºåÂÖ∂‰∏≠Œª‰∏∫np„ÄÇ Â∏∏Áî®ÁöÑÁ¶ªÊï£ÂûãÈöèÊú∫ÂèòÈáèÂèäÂÖ∂Ê¶ÇÁéáÂàÜÂ∏É ÂùáÂåÄÂàÜÂ∏É ËÆæËøûÁª≠ÂûãÈöèÊú∫ÂèòÈáèÔº∏ ÁöÑÊ¶ÇÁéáÂØÜÂ∫¶‰∏∫ \[f(x) = \begin{cases} \frac{1}{b-a}, a &lt; x &lt;b\\0 ,ÂÖ∂‰ªñ\\ \end{cases} \] ÂàôÁß∞Ôº∏Âú®Âå∫Èó¥ÔºªÔΩÅÔºåÔΩÇÔºΩ‰∏äÊúç‰ªéÂùáÂåÄÂàÜÂ∏ÉÔºéÔº∏ ÁöÑÂàÜÂ∏ÉÂáΩÊï∞‰∏∫ \[F(x) = \begin{cases} 0, x &lt;a\\ \frac{x-a}{b-a}, a \leq x &lt;b\\1 ,b\leq x\\ \end{cases} \] Ôº∏ÁöÑÊ¶ÇÁéáÂØÜÂ∫¶ÂíåÂàÜÂ∏ÉÂáΩÊï∞ÁöÑÂõæÂΩ¢ÂàÜÂà´Â¶ÇÂõæÊâÄÁ§∫Ôºö ÊåáÊï∞ÂàÜÂ∏É ËÆæËøûÁª≠ÂûãÈöèÊú∫ÂèòÈáèÔº∏ ÂÖ∑ÊúâÊ¶ÇÁéáÂØÜÂ∫¶ \[f(x)=\begin{cases} \frac{1}{\theta}e^{-\frac{x}{\theta}}, x&gt;0\\0,x \leq 0\end{cases}\] ÂÖ∂‰∏≠Œ∏ÔºûÔºêÊòØÂ∏∏Êï∞ÔºåÂàôÁß∞Ôº∏Êúç‰ªéÂèÇÊï∞‰∏∫Œ∏ÁöÑÊåáÊï∞ÂàÜÂ∏ÉÔºéÔº∏ÁöÑÂàÜÂ∏ÉÂáΩÊï∞‰∏∫ \[F(x)=\begin{cases} 1-e^{-\frac{x}{\theta}}, x&gt;0\\0,x \leq 0\end{cases}\] Ôº∏ÁöÑÊ¶ÇÁéáÂØÜÂ∫¶ÂèäÂàÜÂ∏ÉÂáΩÊï∞ÁöÑÂõæÂΩ¢ÂàÜÂà´Â¶ÇÂõæÊâÄÁ§∫Ôºö ÂÆûÈôÖÈóÆÈ¢ò‰∏≠ÁöÑËÆ∏Â§öÈöèÊú∫ÂèòÈáèÔºå‰æãÂ¶ÇÁîµÂ≠êÂÖÉ‰ª∂ÁöÑÂØøÂëΩÔºåÊóÖÂÆ¢Âú®ËΩ¶Á´ôÂîÆÁ•®Â§ÑË¥≠‰π∞ËΩ¶Á•®ÈúÄË¶ÅÁ≠âÂæÖÁöÑÊó∂Èó¥Á≠âÈÉΩÂèØ‰ª•ÁúãÊàêÊòØÊúç‰ªéÊåáÊï∞ÂàÜÂ∏É„ÄÇ Ê≠£ÊÄÅÂàÜÂ∏É ËÆæÈöèÊú∫ÂèòÈáèÔº∏ ÂÖ∑ÊúâÊ¶ÇÁéáÂØÜÂ∫¶ \[f(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{\frac{(x- \mu)^2}{2\sigma^2}},-‚àû &lt; x &lt; +‚àû\] ÂÖ∂‰∏≠ŒºÔºåœÉÔºàœÉÔºûÔºêÔºâ‰∏∫Â∏∏Êï∞ÔºåÂàôÁß∞Ôº∏Êúç‰ªéÂèÇÊï∞‰∏∫ŒºÔºåœÉÁöÑÊ≠£ÊÄÅÂàÜÂ∏ÉÔºåËÆ∞‰ΩúÔº∏ÔΩû ÔºÆÔºàŒºÔºåœÉÔºíÔºâÔºéÔº∏ÁöÑÂàÜÂ∏ÉÂáΩÊï∞‰∏∫ \[F(x;\mu,\sigma)=\frac{1}{\sigma\sqrt{2\pi}}{\int_{-‚àû}^x(-\frac{(x-\mu)^2}{2\sigma^2}dx)}\] ÂÆÉ‰ª¨ÁöÑÂõæÂΩ¢ÂàÜÂà´Â¶ÇÂõæÊâÄÁ§∫Ôºö ÂÆπÊòìÁúãÂà∞Ê¶ÇÁéáÂØÜÂ∫¶Êõ≤Á∫øÔΩôÔºù ÔΩÜ(ÔΩò)ÂÖ≥‰∫éÁõ¥Á∫øÔΩòÔºù ŒºÂØπÁß∞ÔºåÂπ∂Âú®ÔΩòÔºù ŒºÂ§ÑÂèñÂæóÊúÄÂ§ßÂÄº\(\frac{1}{\sqrt{2\pi}\sigma}\),Âú®Ê®™ÂùêÊ†áÔΩòÔºù Œº¬± œÉÂ§ÑÊúâÊãêÁÇπÔºå‰ª•ÔΩòËΩ¥‰∏∫Ê∞¥Âπ≥Ê∏êËøëÁ∫øÔºé Â¶ÇÊûúŒºÔºùÔºêÔºåœÉÔºùÔºëÔºåÂàôÁß∞Ôº∏Êúç‰ªéÊ†áÂáÜÊ≠£ÊÄÅÂàÜÂ∏ÉÔºåËÆ∞‰ΩúÔº∏~ÔºÆ(0,1)ÔºéÂÆÉÁöÑÊ¶ÇÁéáÂØÜÂ∫¶ÂèäÂàÜÂ∏ÉÂáΩÊï∞ÂàÜÂà´ËÆ∞‰ΩúœÜÔºàÔΩòÔºâ‰∏éŒ¶ÔºàÔΩòÔºâÔºåÂç≥ \[\varphi(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}, (-‚àû &lt; x &lt; +‚àû) \] \[\Phi(x)=F(x;0,1)=\frac{1}{\sqrt{2\pi}}\int_{-‚àû}^x{e^{-\frac{x^2}{2}}dx}\] ÂèÇËÄÉËµÑÊñôÔºöÊ¶ÇÁéáËÆ∫‰∏éÊï∞ÁêÜÁªüËÆ° ÂêâÊûóÂ§ßÂ≠¶]]></content>
      <categories>
        <category>Êú∫Âô®Â≠¶‰π†</category>
      </categories>
      <tags>
        <tag>Êú∫Âô®Â≠¶‰π†</tag>
        <tag>Ê¶ÇÁéáËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop-MapReduceÂÖ•Èó®]]></title>
    <url>%2F2018%2F05%2F14%2FHadoop-MapReduce%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[ËΩ¨Ëá™CSDNÔºõÊîπ‰∫ÜÂá†‰∏™Á¨îËØØ ÂéüÂçöÂÆ¢ÈìæÊé• MapReduceÊòØÁî®‰∫éÊï∞ÊçÆÂ§ÑÁêÜÁöÑ‰∏ÄÁßçÁºñÁ®ãÊ®°ÂûãÔºåÁÆÄÂçï‰ΩÜË∂≥Â§üÂº∫Â§ßÔºå‰∏ìÈó®‰∏∫Âπ∂Ë°åÂ§ÑÁêÜÂ§ßÊï∞ÊçÆËÄåËÆæËÆ°„ÄÇ ÈÄö‰øóÁêÜËß£MapReduce ‰æãÂ¶Ç‰ªéÂ§ßÈáèÂéÜÂè≤Êï∞ÊçÆ‰∏≠ÊâæÂá∫ÂæÄÂπ¥ÊúÄÈ´òÊ∞îÊ∏©ÔºåNCDCÂÖ¨ÂºÄ‰∫ÜËøáÂéªÊØè‰∏ÄÂπ¥ÁöÑÊâÄÊúâÊ∞îÊ∏©Á≠âÂ§©Ê∞îÊï∞ÊçÆÁöÑÊ£ÄÊµãÔºåÊØè‰∏ÄË°åËÆ∞ÂΩï‰∏ÄÊù°ËßÇÊµãËÆ∞ÂΩïÔºåÊ†ºÂºèÂ¶Ç‰∏ãÔºö MapReduce-1 ‰∏∫‰∫Ü‰ΩøÁî®MapReduceÊâæÂá∫ÂéÜÂè≤‰∏äÊØèÂπ¥ÁöÑÊúÄÈ´òÊ∏©Â∫¶ÔºåÊàë‰ª¨Â∞ÜË°åÊï∞‰Ωú‰∏∫mapËæìÂÖ•ÁöÑkeyÔºåÊØè‰∏ÄË°åÁöÑÊñáÊú¨‰Ωú‰∏∫mapËæìÂÖ•ÁöÑvalueÔºö MapReduce-2 ‰∏äÂõæ‰∏≠Á≤ó‰ΩìÈÉ®ÂàÜÂàÜÂà´Ë°®Á§∫Âπ¥‰ªΩÂíåÊ∏©Â∫¶„ÄÇmapÂáΩÊï∞ÂØπÊØè‰∏ÄË°åËÆ∞ÂΩïËøõË°åÂ§ÑÁêÜÔºåÊèêÂèñÂá∫ÔºàÂπ¥‰ªΩÔºåÊ∏©Â∫¶ÔºâÂΩ¢ÂºèÁöÑÈîÆÂÄºÂØπÔºå‰Ωú‰∏∫mapÁöÑËæìÂá∫ 12345(1950,0)(1950,22)(1950,-11)(1949,111)(1947,78) ÂæàÊòéÊòæÔºåÊúâ‰∫õÊï∞ÊçÆÊòØËÑèÔºàÈîôËØØÔºâÁöÑÔºåÊØîÂ¶ÇÊúâ‰∫õÂπ¥‰ªΩÁöÑÊ∞îÊ∏©‰∏¢Â§±ÔºåÊàñËÄÖ‰∏çÂú®ÁêÜËÆ∫ËåÉÂõ¥ÂÜÖÔºåÂõ†Ê≠§map‰πüÊòØËøõË°åËÑèÊï∞ÊçÆÂ§ÑÁêÜÂíåËøáÊª§ÁöÑÂ•ΩÂú∞Êñπ„ÄÇÂú®mapËæìÂá∫Ë¢´‰º†ËæìÂà∞reduce‰πãÂâçÔºåMapReduceÊ°ÜÊû∂‰ºöÂØπÈîÆÂÄºÂØπËøõË°åÊéíÂ∫èÔºåÊ†πÊçÆkeyËøõË°åÂàÜÁªÑÔºåÁîöËá≥Âú®keyÁõ∏ÂêåÁöÑ‰∏ÄÁªÑÂÜÖÂÖàÁªüËÆ°Âá∫ÊúÄÈ´òÊ∞îÊ∏©ÔºåÊâÄ‰ª•reduceÊî∂Âà∞ÁöÑÊï∞ÊçÆÊ†ºÂºèÂÉèËøôÊ†∑Ôºö 12(1949,[111,78](1950,[0,22,-11] Â¶ÇÊûúÊúâÂ§ö‰∏™map‰ªªÂä°ÂêåÊó∂ËøêË°åÔºàÈÄöÂ∏∏ÈÉΩÊòØÁöÑÔºåËøôÂ∞±ÊòØMapReduceÊù•Âπ∂Ë°åËÆ°ÁÆóÁöÑÂéüÂõ†ÔºâÔºåÈÇ£‰πàÊØè‰∏™map‰ªªÂä°ÂÆåÊàêÂêéÔºåÈÉΩ‰ºöÂêëreduceÂèëÈÄÅ‰∏äÈù¢Ê†ºÂºèÁöÑÊï∞ÊçÆÔºåÂèëÈÄÅÊï∞ÊçÆÁöÑËøáÁ®ãÂè´shuffle„ÄÇ mapÁöÑËæìÂá∫‰ºö‰Ωú‰∏∫reduceÁöÑËæìÂÖ•ÔºåreduceÊî∂Âà∞ÁöÑÊòØkeyÂä†‰∏ä‰∏Ä‰∏™ÂàóË°®ÔºåÁÑ∂ÂêéÂØπËøô‰∏™ÂàóË°®ËøõË°åÂ§ÑÁêÜÔºåÂ§©Ê∞îÊï∞ÊçÆÁöÑ‰æãÂ≠ê‰∏≠ÔºåÂ∞±ÊòØÊâæÂá∫ÊúÄÂ§ßÂÄº‰Ωú‰∏∫ÊúÄÈ´òÊ∞îÊ∏©„ÄÇÊúÄÂêéreduceËæìÂá∫Âç≥‰∏∫ÊØèÂπ¥ÊúÄÈ´òÊ∞îÊ∏©Ôºö 12(1949,111)(1950,22) Êï¥‰∏™MapReduceÊï∞ÊçÆÊµÅÂ¶Ç‰∏ãÂõæÔºö MapReduce-3 ÂÖ∂‰∏≠ÁöÑ3‰∏™ÈªëÂúàÂúàÂàÜÂà´‰∏∫mapÔºåshuffleÂíåreduceËøáÁ®ã„ÄÇÂú®Hadoop‰∏≠ÔºåmapÂíåreduceÁöÑÊìç‰ΩúÂèØ‰ª•Áî±Â§öÁßçËØ≠Ë®ÄÊù•ÁºñÂÜôÔºå‰æãÂ¶ÇJava„ÄÅPython„ÄÅRubyÁ≠â„ÄÇ Âú®ÂÆûÈôÖÁöÑÂàÜÂ∏ÉÂºèËÆ°ÁÆó‰∏≠Ôºå‰∏äËø∞ËøáÁ®ãÁî±Êï¥‰∏™ÈõÜÁæ§ÂçèË∞ÉÂÆåÊàêÔºåÊàë‰ª¨ÂÅáËÆæÁé∞Âú®Êúâ5Âπ¥Ôºà2011-2015ÔºâÁöÑÂ§©Ê∞îÊï∞ÊçÆÔºåÂàÜÂ∏ÉÂ≠òÊîæÂú®3‰∏™Êñá‰ª∂‰∏≠: weather1.txtÔºåweather2.txtÔºåweather3.txt„ÄÇÂÜçÂÅáËÆæÊàë‰ª¨Áé∞Âú®Êúâ‰∏Ä‰∏™3Âè∞Êú∫Âô®ÁöÑÈõÜÁæ§ÔºåbÂπ∂‰∏îmap‰ªªÂä°ÂÆû‰æãÊï∞Èáè‰∏∫3ÔºåreduceÂÆû‰æãÊï∞Èáè2„ÄÇÈÇ£‰πàÂÆûÈôÖËøêË°åMapReduceÂÅö‰Ωú‰∏öÊó∂ÔºåÊï¥‰∏™ÊµÅÁ®ãÁ±ª‰ºº‰∫éËøôÊ†∑Ôºö MapReduce-4 Ê≥®ÊÑèÂà∞2014Âπ¥ÁöÑÊï∞ÊçÆÂàÜÂ∏ÉÂú®‰∏§‰∏™‰∏çÂêåÁöÑÊñá‰ª∂‰∏≠ÔºåÈªÑËâ≤ÁöÑÁ≤óÁ∫øÈÉ®ÂàÜÔºå‰ª£Ë°®2014Âπ¥ÁöÑ2‰∏™map‰Ωú‰∏öÁöÑËæìÂá∫ÈÉΩÁªü‰∏Ä‰º†ËæìÂà∞‰∏Ä‰∏™reduceÔºåÂõ†‰∏∫‰ªñ‰ª¨ÁöÑkeyÁõ∏ÂêåÔºà2014Ôºâ„ÄÇÂÖ∂ÂÆûËøô‰∏™ËøáÁ®ãÈùûÂ∏∏Â•ΩÁêÜËß£ÔºåÁé∞ÂÆûÁîüÊ¥ª‰∏≠ÔºåÊØîÂ¶ÇÊúüÊú´ËÄÉËØïÂÆå‰∫ÜÔºåÈÇ£ËÄÉÂç∑Áî±‰∏çÂêåÁöÑËÄÅÂ∏àÊâπÊîπÔºåÂÆåÊàêÂêéÂ¶ÇÊûúÊÉ≥Áü•ÈÅìÂÖ®Âπ¥Á∫ßÊúÄÈ´òÂàÜÔºåÈÇ£‰πàÂèØ‰ª•Ëøô‰πàÂÅöÔºö ÂêÑ‰∏™ËÄÅÂ∏àÊ†πÊçÆËá™Â∑±ÊâπÊîπËøáÁöÑÊâÄÊúâËØïÂç∑ÂàÜÊï∞Êï¥ÁêÜÂá∫Êù•ÔºàmapÔºâ: 1=&gt;(course,[score1,score2,...]) ÂêÑ‰∏™ËÄÅÂ∏àÊääÊúÄÈ´òÂàÜÊ±áÊä•ÁªôÁ≥ª‰∏ª‰ªªÔºàshuffleÔºâ Á≥ª‰∏ª‰ªªÁªüËÆ°ÊúÄÈ´òÂàÜÔºàreduceÔºâ 1=&gt;(courese, highest_score) ÂΩìÁÑ∂ÔºåÂ¶ÇÊûúË¶ÅÂ§öÈó®ËØæÁ®ãÊ∑∑Âú®‰∏ÄËµ∑ÔºåÁ≥ª‰∏ª‰ªªÂ∑•‰ΩúÈáèÂ§™Â§ßÔºå‰∫éÊòØÂâØ‰∏ª‰ªª‰πü‰∏äÔºàÁõ∏ÂΩì‰∫é2‰∏™reduceÔºâÔºåÂàôËÄÅÂ∏àÂú®Ê±áÊä•ÊúÄÈ´òÂàÜÁöÑÊó∂ÂÄôÔºåÁõ∏ÂêåËØæÁ®ãË¶ÅÊ±áÊä•ÁªôÂêå‰∏Ä‰∏™‰∫∫ÔºàÁõ∏Âêåkey‰º†ËæìÁªôÂêå‰∏Ä‰∏™reduceÔºâÔºå‰æãÂ¶ÇÊï∞Â≠¶Ëã±ËØ≠Ê±áÊä•Áªô‰∏ª‰ªªÔºåÊîøÊ≤ªÊ±áÊä•ÁªôÂâØ‰∏ª‰ªª„ÄÇ ÂÆû‰æãÂèä‰ª£Á†ÅÂÆûÁé∞ life is short , show me the code MapReduceÁöÑÊ¶ÇÂøµÊ°ÜÊû∂ÊúâGoogleÊèêÂá∫ÔºåHadoopÊèê‰æõ‰∫ÜÁªèÂÖ∏ÁöÑÂºÄÊ∫êÂÆûÁé∞„ÄÇ‰ΩÜÊòØÂπ∂‰∏çÊòØHadoopÁâπÊúâÁöÑÔºå‰æãÂ¶ÇÂú®ÊñáÊ°£ÂûãÊï∞ÊçÆÂ∫ìMongoDB‰∏≠ÔºåÂèØ‰ª•ÈÄöËøáJSÊù•ÁºñÂÜôMap-ReduceÔºåÂØπÊï∞ÊçÆÂ∫ì‰∏≠ÁöÑÊï∞ÊçÆËøõË°åÂ§ÑÁêÜ„ÄÇÊàë‰ª¨ËøôÈáå‰ª•Hadoop‰∏∫‰æãËØ¥Êòé„ÄÇ Êï∞ÊçÆÂáÜÂ§á È¶ñÂÖàÂ∞ÜÊú¨Âú∞ÁöÑÊñá‰ª∂‰∏ä‰º†Âà∞HDFSÔºö 1hadoop fs -copyFromLocal /home/data/hadoop_book_input/ hdfs://master:9000/input ÂèØ‰ª•Êü•ÁÆ°ÁêÜÁïåÈù¢Êü•ÁúãÊòØÂê¶ÊàêÂäü‰∏ä‰º†Ôºö MapReduce-5 Êü•Áúã‰∏Ä‰∏ãÊï∞ÊçÆÂÜÖÂÆπÔºö 1hadoop fs -text hdfs://master:9000/input/ncdc/sample.txt MapReduce-6 ÁºñÂÜôJava‰ª£Á†Å È¶ñÂÖàÂÆûÁé∞MapperÁ±ªÔºåMapperÂú®Êñ∞ÁâàÊú¨Hadoop‰∏≠ÊîπÂèò‰∏∫Á±ªÔºàÊóßÁâà‰∏∫Êé•Âè£ÔºâÂÆö‰πâÂ¶Ç‰∏ãÔºö 1234567891011121314151617181920212223242526272829303132333435// ÊîØÊåÅÊ≥õÂûãÔºåÊ≥õÂûãÂÆö‰πâmapËæìÂÖ•ËæìÂá∫ÁöÑÈîÆÂÄºÁ±ªÂûãpublic class Mapper &lt;KEYIN, VALUEIN, KEYOUT, VALUEOUT&gt; &#123; public Mapper() &#123; &#125; // map‰ªªÂä°ÂºÄÂßãÁöÑÊó∂ÂÄôË∞ÉÁî®‰∏ÄÊ¨°ÔºåÁî®‰∫éÂÅöÂáÜÂ§áÂ∑•‰Ωú protected void setup(Context context) throws IOException, InterruptedException &#123; // Á©∫ÂÆûÁé∞ &#125; // mapÈÄªËæë ÈªòËÆ§Áõ¥Êé•Â∞ÜËæìÂÖ•ËøõË°åÁ±ªÂûãËΩ¨Êç¢ÂêéËæìÂá∫ protected void map(KEYIN key, VALUEIN value, Context context) throws IOException, InterruptedException &#123; context.write((KEYOUT) key, (VALUEOUT) value); &#125; // ‰ªªÂä°ÁªìÊùüÂêéË∞ÉÁî®‰∏ÄÊ¨°ÔºåÊ∏ÖÁêÜÂ∑•‰ΩúÔºå‰∏ésetupÂØπÂ∫î protected void cleanup(Context context ) throws IOException, InterruptedException &#123; // Á©∫ÂÆûÁé∞ &#125; // mapÁöÑÂÆûÈôÖËøêË°åËøáÁ®ãÂ∞±ÊòØË∞ÉÁî®runÊñπÊ≥ïÔºå‰∏ÄËà¨Áî®‰∫éÈ´òÁ∫ßÂÆûÁé∞ÔºåÊõ¥Á≤æÁªÜÂú∞ÊéßÂà∂ ‰ªªÂä°ÁöÑÊâßË°åËøáÁ®ã, ‰∏ÄËà¨ÊÉÖÂÜµ‰∏çÈúÄË¶ÅË¶ÜÁõñËøô‰∏™ÊñπÊ≥ï public void run(Context context) throws IOException, InterruptedException &#123; // ÂáÜÂ§áÂ∑•‰Ωú setup(context); try &#123; // ÈÅçÂéÜÂàÜÈÖçÁªôËØ•‰ªªÂä°ÁöÑÊï∞ÊçÆÔºåÂæ™ÁéØË∞ÉÁî®map while (context.nextKeyValue()) &#123; map(context.getCurrentKey(), context.getCurrentValue(), context); &#125; &#125; finally &#123; // Ê∏ÖÁêÜÂ∑•‰Ωú cleanup(context); &#125; &#125;&#125; ÂÆûÁé∞‰∏≠Êàë‰ª¨Âè™Ë¶ÜÁõñmapÊñπÊ≥ïÔºåÂÖ∂‰ªñ‰øùÁïô‰∏çÂèò„ÄÇÂÖ∑‰ΩìÂÆûÁé∞Â¶Ç‰∏ãÔºö 12345678910111213141516171819202122232425262728293031323334353637public class MaxTemperatureMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt; &#123; // 9999‰ª£Ë°®Êï∞ÊçÆ‰∏¢Â§± private static final int MISSING = 9999; @Override public void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123; // Ë°å‰Ωú‰∏∫ËæìÂÖ•ÂÄº keyÂú®ËøôÈáåÊöÇÊó∂‰∏çÈúÄË¶Å‰ΩøÁî® String line = value.toString(); // ÊèêÂèñÂπ¥‰ªΩ String year = line.substring(15, 19); // ÊèêÂèñÊ∞îÊ∏© int airTemperature = parseTemperature( line ); String quality = line.substring(92, 93); // ËøáÊª§ËÑèÊï∞ÊçÆ boolean isRecordClean = airTemperature != MISSING &amp;&amp; quality.matches("[01459]"); if ( isRecordClean ) &#123; // ËæìÂá∫ÔºàÂπ¥‰ªΩÔºåÊ∏©Â∫¶ÔºâÂØπ context.write(new Text(year), new IntWritable(airTemperature)); &#125; &#125; private int parseTemperature(String line)&#123; int airTemperature; if (line.charAt(87) == '+') &#123; // parseInt doesn't like leading plus signs airTemperature = Integer.parseInt(line.substring(88, 92)); &#125; else &#123; airTemperature = Integer.parseInt(line.substring(87, 92)); &#125; return airTemperature; &#125;&#125; Êé•ÁùÄÂÆûÁé∞ReducerÔºåÁúãÁúãÂÆö‰πâÔºö 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Reducer&lt;KEYIN,VALUEIN,KEYOUT,VALUEOUT&gt; &#123; // Reducer‰∏ä‰∏ãÊñáÁ±ªÂÆö‰πâ public abstract class Context implements ReduceContext&lt;KEYIN,VALUEIN,KEYOUT,VALUEOUT&gt; &#123; &#125; // ÂàùÂßãÂåñ Âú®Reduce‰ªªÂä°ÂºÄÂßãÊó∂Ë∞ÉÁî®‰∏ÄÊ¨° protected void setup(Context context ) throws IOException, InterruptedException &#123; // Á©∫ÂÆûÁé∞ &#125; /** * map shuffleËøáÊù•ÁöÑÊï∞ÊçÆ‰∏≠ÔºåÊØè‰∏Ä‰∏™keyË∞ÉÁî®‰∏ÄÊ¨°Ëøô‰∏™ÊñπÊ≥ï */ @SuppressWarnings("unchecked") protected void reduce(KEYIN key, Iterable&lt;VALUEIN&gt; values, Context context ) throws IOException, InterruptedException &#123; // ÈªòËÆ§Â∞ÜÊâÄÊúâÁöÑÂÄº‰∏Ä‰∏ÄËæìÂá∫ for(VALUEIN value: values) &#123; context.write((KEYOUT) key, (VALUEOUT) value); &#125; &#125; protected void cleanup(Context context ) throws IOException, InterruptedException &#123; // Á©∫ÂÆûÁé∞ Êî∂Â∞æÂ∑•‰Ωú &#125; // ReducerÁöÑËøêË°åÈÄªËæë ‰æõÊõ¥È´òÁ∫ßÁöÑÂÆöÂà∂ public void run(Context context) throws IOException, InterruptedException &#123; setup(context); try &#123; // ÈÅçÂéÜËæìÂÖ•key while (context.nextKey()) &#123; reduce(context.getCurrentKey(), context.getValues(), context); // ‰∏Ä‰∏™keyÂ§ÑÁêÜÂÆåË¶ÅËΩ¨Âêë‰∏ã‰∏Ä‰∏™keyÊó∂ÔºåÈáçÁΩÆÂÄºÈÅçÂéÜÂô® Iterator&lt;VALUEIN&gt; iter = context.getValues().iterator(); if(iter instanceof ReduceContext.ValueIterator) &#123; ((ReduceContext.ValueIterator&lt;VALUEIN&gt;)iter).resetBackupStore(); &#125; &#125; &#125; finally &#123; cleanup(context); &#125; &#125;&#125; Êàë‰ª¨ÁöÑReducerÂÆûÁé∞‰∏ªË¶ÅÊòØÊâæÂá∫ÊúÄÈ´òÊ∞îÊ∏©Ôºö 1234567891011121314151617181920public class MaxTemperatureReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; &#123; @Override public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException &#123; int maxValue = findMax( values ); context.write(key, new IntWritable(maxValue)); &#125; private static int findMax(Iterable&lt;IntWritable&gt; values)&#123; int maxValue = Integer.MIN_VALUE; for (IntWritable value : values) &#123; maxValue = Math.max(maxValue, value.get()); &#125; return maxValue; &#125;&#125; MapperÂíåReducerÂÆûÁé∞ÂêéÔºåÈúÄË¶Å‰∏Ä‰∏™ÂÖ•Âè£Êèê‰∫§‰Ωú‰∏öÂà∞HadoopÈõÜÁæ§ÔºåÂú®Êñ∞ÁâàÊú¨‰∏≠Ôºå‰ΩøÁî®YARNÊ°ÜÊû∂Êù•ËøêË°åMapReduce‰Ωú‰∏ö„ÄÇ‰Ωú‰∏öÈÖçÁΩÆÂ¶Ç‰∏ãÔºö 1234567891011121314151617181920212223242526272829public class MaxTemperature &#123; public static void main(String[] args) throws Exception &#123; if (args.length != 2) &#123; System.err.println("Usage: MaxTemperature &lt;input path&gt; &lt;output path&gt;"); System.exit(-1); &#125; // ËÆæÁΩÆjarÂåÖÂèä‰Ωú‰∏öÂêçÁß∞ Job job = new Job(); job.setJarByClass(MaxTemperature.class); job.setJobName("Max temperature"); // ËæìÂÖ•ËæìÂá∫Ë∑ØÂæÑ FileInputFormat.addInputPath(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); // ËÆæÁΩÆMapperÂíåReducerÂÆûÁé∞ job.setMapperClass(MaxTemperatureMapper.class); job.setReducerClass(MaxTemperatureReducer.class); // ËÆæÁΩÆËæìÂá∫Ê†ºÂºè job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); // Á≠âÂæÖ‰Ωú‰∏öÂÆåÊàêÂêéÈÄÄÂá∫ System.exit(job.waitForCompletion(true) ? 0 : 1); &#125;&#125; ËæìÂÖ•ËæìÂá∫Ë∑ØÂæÑ‰ΩøÁî®FileInputFormat/FileOutputFormatÁöÑÈùôÊÄÅÊñπÊ≥ïÊù•ËÆæÁΩÆÔºåÂú®ËøêË°å‰Ωú‰∏ö‰πãÂâçÔºåËæìÂá∫ÁõÆÂΩï‰∏çËÉΩÂ≠òÂú®ÔºåËøôÊòØ‰∏∫‰∫ÜÈÅøÂÖçË¶ÜÁõñÊï∞ÊçÆÂØºËá¥Êï∞ÊçÆ‰∏¢Â§±„ÄÇËøêË°å‰πãÂâçÂ¶ÇÊûúÊ£ÄÊµãÂà∞ÁõÆÂΩïÂ∑≤ÁªèÂ≠òÂú®Ôºå‰Ωú‰∏öÂ∞ÜÊó†Ê≥ïËøêË°å„ÄÇ OKÔºåÊääÈ°πÁõÆÊâìÂåÖÔºåÂ¶ÇÊûú‰ΩøÁî®EclipseÔºå‰ΩøÁî®ExportÂäüËÉΩ„ÄÇÂ¶ÇÊûú‰ΩøÁî®MavenÂºÄÂèëÔºåÂàôÁõ¥Êé•ËøêË°åpackageÂëΩ‰ª§„ÄÇÂÅáËÆæÊàë‰ª¨ÊúÄÂêéÁöÑjarÂåÖ‰∏∫max-temp.jar.ÊääjarÂåÖ‰∏ä‰º†Âà∞‰Ω†ÁöÑÈõÜÁæ§Êú∫Âô®‰∏äÔºåÊàñËÄÖÊîæÂú®ÂÆâË£Ö‰∫ÜHadoopÁöÑÂÆ¢Êà∑Á´ØÊú∫Âô®‰∏äÔºåËøôÈáåÂÅáËÆæjarÂåÖÊîæÂú®/opt/jobÁõÆÂΩï‰∏ã„ÄÇ ËøêË°å È¶ñÂÖàÊää‰Ωú‰∏öjarÂåÖÊîæÂà∞CLASSPATHÔºö 12cd /opt/jobexport HADOOP_CLASSPATH=max-temp.jar ËøêË°å: 1hadoop MaxTemperature /input/ncdc/sample.txt /output hadoop‰ºöËá™Âä®ÊääHADOOP_CLASSPATËÆæÁΩÆÁöÑË∑ØÂæÑÂä†ÂÖ•Âà∞CLASSPATH‰∏≠ÔºåÂêåÊó∂ÊääHADOOPÁõ∏ÂÖ≥ÁöÑ‰æùËµñÂåÖ‰πüÂä†ÂÖ•CLASSPATHÔºåÁÑ∂ÂêéÂêØÂä®‰∏Ä‰∏™JVMËøêË°åMaxTemperatureËøô‰∏™Â∏¶ÊúâmainÊñπÊ≥ïÁöÑÁ±ª„ÄÇ ÁªìÊûúÂ¶Ç‰∏ãÔºö MapReduce-7 MapReduce-8 Êó•Âøó‰∏≠ÂèØ‰ª•ÁúãÂà∞‰Ωú‰∏öÁöÑ‰∏Ä‰∫õËøêË°åÊÉÖÂÜµÔºå‰æãÂ¶Çmap‰ªªÂä°Êï∞ÈáèÔºåreduce‰ªªÂä°Êï∞ÈáèÔºå‰ª•ÂèäËæìÂÖ•ËæìÂá∫ÁöÑËÆ∞ÂΩïÊï∞ÔºåÂèØ‰ª•ÁúãÂà∞Ë∑üÂÆûÈôÖÊÉÖÂÜµÂÆåÂÖ®ÂêªÂêà„ÄÇ Êàë‰ª¨Áúã‰∏Ä‰∏ãËæìÂá∫ÁõÆÂΩï/output: 1hadoop fs -ls /output MapReduce-9 ÂèØ‰ª•ÁúãÂà∞ËØ•ÁõÆÂΩï‰∏ãÊúâ‰∏™ÊàêÂäüÊ†áËØÜÊñá‰ª∂_SUCCESSÂíåÁªìÊûúËæìÂá∫Êñá‰ª∂part-r-0000ÔºåÊØè‰∏™reducer‰ºöËæìÂá∫‰∏Ä‰∏™Êñá‰ª∂„ÄÇÊü•Áúã‰∏Ä‰∏ãËøô‰∏™ËæìÂá∫Êñá‰ª∂ÁöÑÂÜÖÂÆπÔºö 1hadoop fs -text hdfs://master:9000/output/part-r-00000 Â¶Ç‰∏äÂõæÊâÄÁ§∫ÔºåÊàë‰ª¨ÊàêÂäüÂæóÂà∞‰∫Ü1949Âíå1950Âπ¥ÁöÑÊúÄÈ´òÊ∏©Â∫¶ÔºåÊó†ÈúÄÁÆ°ÁªìÊûúÊòØÂê¶ÂêàÁêÜÔºåÂè™Ë¶ÅÊåâÁÖßÊàë‰ª¨ÊÉ≥Ë¶ÅÁöÑÈÄªËæëËøêË°åÂç≥ÂèØ„ÄÇ YARNÁÆ°ÁêÜÁïåÈù¢‰πüÂèØ‰ª•ÁúãÂà∞ËØ•‰Ωú‰∏öÁöÑÊÉÖÂÜµÔºö MapReduce-10 Ëøõ‰∏ÄÊ≠•ÁêÜËß£MapReduce ‰∏Ä‰∏™MapReduce‰Ωú‰∏öÈÄöÂ∏∏ÂåÖÊã¨ËæìÂÖ•Êï∞ÊçÆ„ÄÅMapReduceÁ®ãÂ∫è‰ª•Âèä‰∏Ä‰∫õÈÖçÁΩÆ‰ø°ÊÅØ„ÄÇHadoopÊää‰Ωú‰∏öÂàÜËß£‰∏∫taskËøêË°åÔºåtaskÂàÜ‰∏∫map‰ªªÂä°Âíåreduce‰ªªÂä°ÔºåÂú®Êñ∞ÁâàÊú¨ÁöÑHadoop‰∏≠ÔºåËøô‰∫õTaskÈÄöËøáËµÑÊ∫êÁÆ°ÁêÜÊ°ÜÊû∂ËøõË°åË∞ÉÂ∫¶ÔºåÂ¶ÇÊûú‰ªªÂä°Â§±Ë¥•ÔºåMapReduceÂ∫îÁî®Ê°ÜÊû∂‰ºöÈáçÊñ∞ËøêË°å‰ªªÂä°„ÄÇ ‰Ωú‰∏öÁöÑËæìÂÖ•Ë¢´ÂàíÂàÜ‰∏∫Âõ∫ÂÆöÂ§ßÂ∞èÁöÑÂàÜÁâáÔºåÂè´input splitsÔºåÁÆÄÁß∞splits„ÄÇÁÑ∂Âêé‰∏∫ÊØè‰∏Ä‰∏™splitÂàÜÂùóÂàõÂª∫‰∏Ä‰∏™map‰ªªÂä°Ôºåmap‰ªªÂä°ÂØπÊØè‰∏ÄÊù°ËÆ∞ÂΩïËøêË°åÁî®Êà∑ÂÆö‰πâÁöÑmapÂáΩÊï∞„ÄÇÂàíÂàÜ‰∏∫split‰πãÂêéÔºå‰∏çÂêåÈÖçÁΩÆÁöÑÊú∫Âô®Â∞±ÂèØ‰ª•Ê†πÊçÆËá™Â∑±ÁöÑËµÑÊ∫êÂèäËøêÁÆóËÉΩÂäõËøêË°åÈÄÇÂΩìÁöÑ‰ªªÂä°ÔºåÂç≥‰ΩøÊòØÁõ∏ÂêåÈÖçÁΩÆÁöÑÊú∫Âô®ÔºåÊúÄÂêéËøêË°åÁöÑ‰ªªÂä°Êï∞‰πüÂæÄÂæÄ‰∏çÁ≠âÔºåËøôÊ†∑ËÉΩÊúâÊïàÂà©Áî®Êï¥‰∏™ÈõÜÁæ§ÁöÑËÆ°ÁÆóËÉΩÂäõ„ÄÇ‰ΩÜÊòØsplit‰πü‰∏çÂ∑≤Â§™Â§öÔºåÂê¶Âàô‰ºöËÄóË¥πÂæàÂ§öÊó∂Èó¥Âú®ÂàõÂª∫map‰ªªÂä°‰∏äÔºåÈÄöÂ∏∏ËÄåË®ÄÔºåÊåâÈõÜÁæ§BlockÂ§ßÂ∞èÔºàÈªòËÆ§‰∏∫128MÔºâÊù•ÂàíÂàÜsplitÊòØÂêàÁêÜÁöÑ„ÄÇ Hadoop‰ºöÊäämap‰ªªÂä°ËøêË°åÂú®Ë∑ùÁ¶ªÊï∞ÊçÆÊúÄËøëÁöÑËäÇÁÇπ‰∏äÔºåÊúÄÂ•ΩÁöÑÊÉÖÂÜµÊòØÁõ¥Êé•Âú®Êï∞ÊçÆÔºàsplitÔºâÊâÄÂú®ÁöÑËäÇÁÇπ‰∏äËøêË°åmap‰ªªÂä°ÔºåËøôÊ†∑‰∏çÈúÄË¶ÅÂç†Áî®Â∏¶ÂÆΩÔºåËøô‰∏Ä‰ºòÂåñÂè´ÂÅöÊï∞ÊçÆÊú¨Âú∞‰ºòÂåñÔºàdata locality optimization)„ÄÇ‰∏ãÂõæÁöÑmapÈÄâÂùÄÊñπÊ°à‰ªéÊúÄ‰ºòÂà∞ÊúÄÊ¨°‰∏∫aÔºåbÔºåcÔºö MapReduce-11 ÂÖ≥‰∫éHadoopÂ¶Ç‰ΩïË°°Èáè‰∏§‰∏™ÈõÜÁæ§ËäÇÁÇπÁöÑË∑ùÁ¶ªÔºåÂèÇËÄÉÂè¶‰∏ÄÊâπÂçöÂÆ¢ Ê∑±ÂÖ•ÁêÜËß£HDFSÔºöHadoopÂàÜÂ∏ÉÂºèÊñá‰ª∂Á≥ªÁªü„ÄÇ‰ΩÜÊòØËäÇÁÇπË∑ùÁ¶ª‰∏çÊòØÂàÜÈÖçtaskËÄÉËôëÁöÑÂîØ‰∏ÄÂõ†Á¥†ÔºåËøò‰ºöËÄÉËôëËäÇÁÇπÂΩìÂâçË¥üËΩΩÁ≠âÂõ†Á¥†„ÄÇ Reduce‰ªªÂä°ÈÄöÂ∏∏Êó†Ê≥ïÂà©Áî®Êú¨Âú∞Êï∞ÊçÆÁöÑ‰ºòÂåñÔºåÂ§ßÂ§öÊï∞ÊÉÖÂÜµ‰∏ãÔºåreduceÁöÑËæìÂÖ•ÈÉΩÊù•Ëá™ÈõÜÁæ§ÁöÑÂÖ∂‰ªñËäÇÁÇπ„ÄÇreduceÈíàÂØπÊØè‰∏Ä‰∏™keyËøêË°åreduceÂáΩÊï∞‰πãÂêéÔºåËæìÂá∫ÁªìÊûúÈÄöÂ∏∏‰øùÂ≠òÂú®HDFS‰∏≠ÔºåÂπ∂‰∏îÂ≠òÂÇ®‰∏ÄÂÆöÁöÑÂâØÊú¨Êï∞ÔºåÁ¨¨‰∏Ä‰∏™ÂâØÊú¨Â≠òÂú®ËøêË°åreduce‰ªªÂä°ÁöÑÊú¨Âú∞Êú∫Âô®ÔºåÂÖ∂‰ªñÂâØÊú¨Ê†πÊçÆHDFSÂÜôÂÖ•ÁöÑÁÆ°ÈÅìÂàÜÂà´ÂÜôÂÖ•ËäÇÁÇπÔºåÂÖ≥‰∫éÊõ¥Â§öHDFSÁöÑÊï∞ÊçÆÂÜôÂÖ•ÊµÅÁ®ãÔºåÂèÇËÄÉËøôÈáå„ÄÇ ‰∏ãÂõæÊòØ‰∏Ä‰∏™ÂçïreduceÁöÑÊï∞ÊçÆÊµÅÁ§∫‰æãÔºö MapReduce-12 Â¶ÇÊûúÊúâÂ§ö‰∏™reduce‰ªªÂä°ÔºåÈÇ£‰πàmap‰ªªÂä°ÁöÑËæìÂá∫Âà∞Â∫ïËØ•‰º†ËæìÂà∞Âì™‰∏Ä‰∏™reduce‰ªªÂä°Âë¢ÔºüÂÜ≥ÂÆöÊüê‰∏™keyÁöÑÊï∞ÊçÆÔºàkey,[value1, value2,...])ËØ•ÂèëÈÄÅÁªôÈÇ£‰∏™reduceÁöÑËøáÁ®ãÂè´partition„ÄÇÈªòËÆ§ÊÉÖÂÜµ‰∏ãÔºåMapReduce‰ΩøÁî®keyÁöÑÂìàÂ∏åÂáΩÊï∞ËøõË°åÂàÜÊ°∂ÔºåËøôÈÄöÂ∏∏Â∑•‰ΩúÁöÑÂæàÂ•Ω„ÄÇÂ¶ÇÊûúÈúÄË¶ÅËá™Ë°åÊåáÂÆöÂàÜÂå∫ÂáΩÊï∞ÔºåÂèØ‰ª•Ëá™Â∑±ÂÆûÁé∞‰∏Ä‰∏™PartitionerÂπ∂ÈÖçÁΩÆÂà∞‰Ωú‰∏ö‰∏≠„ÄÇkeyÁõ∏ÂêåÁöÑmap‰ªªÂä°ËæìÂá∫‰∏ÄÂÆö‰ºöÂèëÈÄÅÂà∞Âêå‰∏Ä‰∏™reduce‰ªªÂä°„ÄÇmap‰ªªÂä°ÁöÑËæìÂá∫Êï∞ÊçÆ‰º†ËæìÂà∞reduce‰ªªÂä°ÊâÄÂú®ËäÇÁÇπÁöÑËøáÁ®ãÔºåÂè´ÂÅöshuffle„ÄÇ‰∏ãÈù¢ÊòØ‰∏Ä‰∏™Êõ¥ÈÄöÁî®ÁöÑMapReduceÊï∞ÊçÆÊµÅÂõæÔºö MapReduce-13 ÂΩìÁÑ∂ÔºåÊúâ‰∫õ‰Ωú‰∏ö‰∏≠Êàë‰ª¨ÂèØËÉΩÊ†πÊú¨‰∏çÈúÄË¶ÅÊúâreduce‰ªªÂä°ÔºåÊâÄÊúâÂ∑•‰ΩúÂú®map‰ªªÂä°Âπ∂Ë°åÊâßË°åÂÆå‰πãÂêéÂ∞±ÂÆåÊØï‰∫ÜÔºå‰æãÂ¶ÇHadoopÊèê‰æõÁöÑÂπ∂Ë°åÂ§çÂà∂Â∑•‰ΩúdistcpÔºåÂÖ∂ÂÜÖÈÉ®ÂÆûÁé∞Â∞±ÊòØÈááÁî®‰∏Ä‰∏™Âè™ÊúâMapperÔºåÊ≤°ÊúâReducerÁöÑMapReduce‰Ωú‰∏öÔºåÂú®mapÂÆåÊàêÊñá‰ª∂Â§çÂà∂‰πãÂêé‰Ωú‰∏öÂ∞±ÂÆåÊàê‰∫ÜÔºåÂ¶Ç‰∏ãÂõæÊâÄÁ§∫Ôºö MapReduce-14 Âú®‰∏äÈù¢ËÆ°ÁÆóÊúÄÈ´òÂ§©Ê∞îÁöÑ‰æãÂ≠ê‰∏≠ÔºåÊØè‰∏™mapÂ∞ÜÊØè‰∏ÄÊù°ËÆ∞ÂΩïÊâÄ‰∫ßÁîüÁöÑÔºàÂπ¥‰ªΩÔºåÊ∏©Â∫¶ÔºâËÆ∞ÂΩïÈÉΩshuffleÂà∞reduceËäÇÁÇπÔºåÂΩìÊï∞ÊçÆÈáèËæÉÂ§ßÊó∂ÔºåÂ∞ÜÂç†Áî®ÂæàÂ§öÂ∏¶ÂÆΩÔºåËÄóË¥πÂæàÈïøÊó∂Èó¥„ÄÇ‰∫ãÂÆû‰∏äÔºåÂèØ‰ª•Âú®map‰ªªÂä°ÊâÄÂú®ÁöÑËäÇÁÇπ‰∏äÂÅöÊõ¥Â§öÂ∑•‰Ωú„ÄÇmap‰ªªÂä°ËøêË°åÂÆå‰πãÂêéÔºåÂèØ‰ª•ÊääÊâÄÊúâÁªìÊûúÊåâÂπ¥‰ªΩÂàÜÁªÑÔºåÂπ∂ÁªüËÆ°Âá∫ÊØè‰∏ÄÂπ¥ÁöÑÊúÄÈ´òÊ∏©Â∫¶ÔºàÁ±ª‰ºº‰∫ésql‰∏≠ÁöÑ 1select max(temperature) from table group by year ÔºâÔºåËøô‰∏™ÊúÄÈ´òÊ∏©Â∫¶ÊòØÂ±ÄÈÉ®ÁöÑÔºåÂè™Âú®Êú¨‰ªªÂä°Èáç‰∫ßÁîüÁöÑÊï∞ÊçÆÂÅöÊØîËæÉ„ÄÇÂÅöÂÆåÂ±ÄÈÉ®ÁªüËÆ°‰πãÂêéÔºåÂ∞ÜÁªìÊûúÂèëÈÄÅÁªôreduceÂÅöÊúÄÁªàÁöÑÊ±áÊÄªÔºåÊâæÂá∫ ÂÖ®Â±ÄÊúÄÈ´òÊ∏©Â∫¶„ÄÇËøáÁ®ãÁ§∫ÊÑèÂõæÂ¶Ç‰∏ãÔºö MapReduce-15 Ëøô‰πàÂÅö‰πãÊâÄ‰ª•Á¨¶ÂêàÈÄªËæëÔºåÊòØÂü∫‰∫é‰ª•‰∏ãÁöÑ‰∫ãÂÆûÔºö 1max(0,20,10,25,15)=max(max(0,20,10) , max(25,15)) Á¨¶Âêà‰∏äËø∞ÊÄßË¥®ÁöÑÂáΩÊï∞Áß∞‰∏∫ÊòØcommutativeÂíåassociativeÔºåÊúâÊó∂ÂÄô‰πüÊàê‰∏∫ÊòØdistributive„ÄÇÂ¶ÇÊûúÊòØËÆ°ÁÆóÂπ≥ÂùáÊ∏©Â∫¶ÔºåÂàô‰∏çËÉΩ‰ΩøÁî®Ëøô‰∏ÄÁöÑÊñπÂºè„ÄÇ ‰∏äËø∞ÁöÑÂ±ÄÈÉ®ËÆ°ÁÆóÂú®Hadoop‰∏≠‰ΩøÁî®CombinerÊù•Ë°®Á§∫„ÄÇ‰∏∫‰∫ÜÂú®‰Ωú‰∏ö‰∏≠‰ΩøÁî®CombinerÔºåÊàë‰ª¨ÈúÄË¶ÅÊòéÁ°ÆÊåáÂÆöÔºåÂú®ÂâçÈù¢ÁöÑ‰æãÂ≠ê‰∏≠ÔºåÂèØ‰ª•Áõ¥Êé•‰ΩøÁî®Reducer‰Ωú‰∏∫CombinerÔºåÂõ†‰∏∫‰∏§ËÄÖÈÄªËæëÊòØ‰∏ÄÊ†∑ÁöÑÔºö 1234// ËÆæÁΩÆMapperÂíåReducerÂÆûÁé∞job.setMapperClass(MaxTemperatureMapper.class);job.setCombinerClass(MaxTemperatureReducer.class);job.setReducerClass(MaxTemperatureReducer.class); Hadoop Streaming HadoopÂÆåÂÖ®ÂÖÅËÆ∏Êàë‰ª¨‰ΩøÁî®Java‰ª•Â§ñÁöÑËØ≠Ë®ÄÊù•ÁºñÂÜômapÂíåreduceÂáΩÊï∞„ÄÇHadoop Streaming‰ΩøÁî®UnixÊ†áÂáÜÊµÅ‰Ωú‰∏∫HadoopÂíåÂÖ∂‰ªñÂ∫îÁî®Á®ãÂ∫èÁöÑÊé•Âè£„ÄÇÊï∞ÊçÆÊµÅÁöÑÂ§ßËá¥Á§∫ÊÑèÂõæÂ¶Ç‰∏ãÔºö MapReduce-16 Êï¥‰∏™Êï∞ÊçÆÂú®Hadoop MapReduce‰∏éRubyÂ∫îÁî®„ÄÅÊ†áÂáÜËæìÂÖ•ËæìÂá∫‰πãÈó¥ÊµÅËΩ¨ÔºåÂõ†Ê≠§Âè´Streaming„ÄÇÊàë‰ª¨ÁªßÁª≠‰ΩøÁî®ÂâçÈù¢Ê∞îÊ∏©ÁöÑ‰æãÂ≠êÊù•ËØ¥ÊòéÔºåÂÖà‰ΩøÁî®rubyÊù•ÁºñÂÜômapÂíåreduceÔºåÁÑ∂Âêé‰ΩøÁî®unixÁöÑÁÆ°ÈÅìÊù•Ê®°ÊãüÊï¥‰∏™ËøáÁ®ãÔºåÊúÄÂêéËøÅÁßªÂà∞Hadoop‰∏äËøêË°å„ÄÇ RubyÁâàÊú¨ÁöÑmapÂáΩÊï∞‰ªéÊ†áÂáÜÊµÅ‰∏≠ËØªÂèñÊï∞ÊçÆÔºåËøêÁÆóÂêéÂ∞ÜÁªìÊûúËæìÂá∫Âà∞Ê†áÂáÜËæìÂá∫ÊµÅÔºö 123456#!/usr/bin/rubySTDIN.each_line do |line| val = line year , temp , q = val[15,4],val[87,5],val[92,1] puts "#&#123;year&#125;\t#&#123;temp&#125;" if (temp != "+9999" &amp;&amp; q =~/[01459]/)end ÈÄªËæë‰∏éJavaÁâàÊú¨ÂÆåÂÖ®‰∏ÄÊ†∑ÔºåSTDINÊòØrubyÁöÑÊ†áÂáÜËæìÂÖ•Ôºåeach_lineÈíàÂØπÊØè‰∏ÄË°åËøõË°åÊìç‰ΩúÔºåÈÄªËæëÂ∞ÅË£ÖÂú®doÂíåend‰πãÈó¥„ÄÇputsÊòØrubyÊ†áÂáÜËæìÂá∫ÂáΩÊï∞ÔºåÊâìÂç∞tabÂàÜÂâ≤ÁöÑËÆ∞ÂΩïÂà∞Ê†áÂáÜËæìÂá∫ÊµÅ„ÄÇ Âõ†‰∏∫Ëøô‰∏™ËÑöÊú¨‰∏éÊ†áÂáÜËæìÂÖ•ËæìÂá∫‰∫§‰∫íÔºåÊâÄ‰ª•ÂæàÂÆπÊòìÁªìÂêàlinuxÁöÑÁÆ°ÈÅìÊù•ÊµãËØïÔºö 1cat input/ncdc/sample.txt | ruby max_temp_map.rb MapReduce-17 ‰∏ÄÊ†∑Áî®rubyËÑöÊú¨Êù•ÂÆåÊàêreduceÁöÑÂäüËÉΩÔºö 123456789101112last_key , max_val = nil , -1000000STDIN.each_line do |line| key , val = line.split("\t") if last_key &amp;&amp; last_key != key puts "#&#123;last_key&#125;\t#&#123;max_val&#125;" last_key , max_val = key , val.to_i else last_key , max_val = key,[max_val , val.to_i].max endend# Â§ÑÁêÜÊúÄÂêé‰∏Ä‰∏™keyÁöÑËæìÂá∫put "#&#123;last_key&#125;\t#&#123;max_val&#125;" if last_key mapÂ§ÑÁêÜÂÆå‰πãÂêéÔºåÂêå‰∏Ä‰∏™keyÁöÑ‰∏ÄÁªÑÈîÆÂÄºÂØπ‰∏≠ÔºåvalueÊòØÊéíÂ∫èÁöÑÔºåÊâÄ‰ª•ÂΩìÂâçËØªÂà∞ÁöÑkeyÂ¶ÇÊûú‰∏çÂêå‰∫é‰∏ä‰∏Ä‰∏™keyÔºåË°®Á§∫Ëøô‰∏™keyÁöÑÊâÄÊúâÂÄºÈÉΩÂ§ÑÁêÜÂÆå‰∫ÜÔºàÂâçÊñáÊèêÂà∞‰ºöÂú®ÂàáÊç¢key‰πãÂâçresetËæìÂÖ•Ôºâ„ÄÇÊàë‰ª¨‰ΩøÁî®sortÂëΩ‰ª§Êù•Êõø‰ª£MapReduce‰∏≠ÁöÑÊéíÂ∫èËøáÁ®ãÔºåÊäämapÁöÑÊ†áÂáÜËæìÂá∫‰Ωú‰∏∫sortÁöÑËæìÂÖ•ÔºåsortÈÄöËøáÁÆ°ÈÅìËøûÊé•Âà∞mapÔºö 1cat /home/data/hadoop_book_input/ncdc/sample.txt| ruby max_temp_map.rb | sort | ruby max_temp_reduce.rb ËæìÂá∫ÁªìÊûúÂ¶Ç‰∏ãÂõæÔºå‰∏éÂâçÊñáÂÆåÂÖ®‰∏ÄËá¥„ÄÇ MapReduce-18 ÂæàÂ•ΩÔºåÊàë‰ª¨Âú®Hadoop‰∏äËøêË°åËøô‰∏™‰Ωú‰∏ö„ÄÇÈùûJavaËØ≠Ë®ÄÁöÑMapReduce‰Ωú‰∏öÔºåÈúÄË¶Å‰ΩøÁî®Hadoop StreamingÊù•ËøêË°å„ÄÇHadoop Streaming‰ºöË¥üË¥£‰Ωú‰∏öÁöÑTaskÂàÜËß£ÔºåÊääËæìÂÖ•Êï∞ÊçÆ‰Ωú‰∏∫Ê†áÂáÜËæìÂÖ•ÊµÅ‰º†ÈÄíÁªôRubyÂÜôÁöÑmapËÑöÊú¨ÔºåÂπ∂Êé•ÂèóÊù•Ëá™mapËÑöÊú¨ÁöÑÊ†áÂáÜËæìÂá∫ÔºåÊéíÂ∫èÂêéshuffleÂà∞reduceËäÇÁÇπ‰∏äÔºåÂπ∂‰ª•Ê†áÂáÜËæìÂÖ•‰º†ÈÄíÁªôreduceÔºåÊúÄÂêéÊääreduceÁöÑÊ†áÂáÜËæìÂá∫‰øùÂ≠òÂà∞HDFSÊñá‰ª∂‰∏≠„ÄÇ Êàë‰ª¨‰ΩøÁî®hadoop jarÂëΩ‰ª§,ÂêåÊó∂ÊåáÂÆöËæìÂÖ•ËæìÂá∫ÁõÆÂΩïÔºåËÑöÊú¨‰ΩçÁΩÆÁ≠â„ÄÇ 1hadoop jar /home/hadoop-2.6.0/share/hadoop/tools/lib/hadoop-streaming-2.6.0.jar -files max_temp_map.rb,max_temp_reduce.rb -input /input/ncdc/sample.txt -output /output/max-tem-ruby -mapper max_temp_map.rb -reducer max_temp_reduce.rb -fileÂèÇÊï∞ÊääËøô‰∫õÊñá‰ª∂‰∏ä‰º†Âà∞ÈõÜÁæ§‰∏≠„ÄÇÊ≥®ÊÑèmapÂíåreduceËÑöÊú¨ÈúÄË¶ÅÂú®CLASSPATH‰∏ãÔºåÊàëÊòØÂú®ÂΩìÂâçÁõÆÂΩï‰∏ãËøêË°åÁöÑÔºåÈªòËÆ§Âä†ÂÖ•Âà∞Á±ªË∑ØÂæÑ‰∏≠„ÄÇÂè¶Â§ñËØ∑Á°Æ‰øùÈõÜÁæ§‰∏≠ÁöÑÊâÄÊúâÊú∫Âô®ÈÉΩÂÆâË£Ö‰∫ÜrubyÔºåÂê¶ÂàôÂèØËÉΩÂá∫Áé∞Á±ª‰ººsubprocess failed with code 127„ÄÇËøôÈáåÁöÑËæìÂá∫Êñá‰ª∂ÊòØ/outp/max-tem-rubyÔºåMapReduce‰∏çÂÖÅËÆ∏Â§ö‰∏™‰Ωú‰∏öËæìÂá∫Âà∞Âêå‰∏Ä‰∏™ÁõÆÂΩï„ÄÇ Êü•ÁúãËæìÂá∫Êñá‰ª∂Ôºå‰∏éJavaÁâàÊú¨ÂÆåÂÖ®‰∏ÄËá¥„ÄÇOKÔºåÊàë‰ª¨ËÆæÁΩÆcombinerÔºåÁÑ∂ÂêéÂú®Â§ßÁöÑÊï∞ÊçÆÈõÜ‰∏äÊÑüÂèó‰∏Ä‰∏ãÔºö 1hadoop jar /home/hadoop-2.6.0/share/hadoop/tools/lib/hadoop-streaming-2.6.0.jar -files max_temp_map.rb,max_temp_reduce.rb -input /input/ncdc/all -output /output/max-tem-all -mapper max_temp_map.rb -combiner x_temp_reduce.rb -reducer max_temp_reduce.rb MapReduce-19]]></content>
      <categories>
        <category>Êï∞ÊçÆÂàÜÊûê</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>MapReduce</tag>
        <tag>Â§ßÊï∞ÊçÆ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Code Jam Round1C-C]]></title>
    <url>%2F2018%2F05%2F05%2FGoogle-Code-Jam-Round1C-C%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ:Ant Stack Problem Scott has an ant farm containing N ants. Each ant has a certain length and weight. Today, as a challenge for the ants, Scott has placed some food at the top of the ant farm. The ants will try to reach it by arranging themselves into a vertical stack, with each ant in the stack directly holding the next on its back. In this way, each ant bears the weight of all ants above it. Scott's ants are very strong for their size and are able to carry up to 6 times their own weight. For example, an ant that weights 8 milligrams can carry two other ants weighing 24 milligrams each! Each ant also has a body length; the exact lengths are not important, except that they are all different. The stack must be linear. Each ant except for the top ant must be directly below exactly one ant, and each ant except for the bottom ant must be directly above exactly one ant. The lengths of the ants in the stack must be strictly decreasing from the bottom to the top of the stack; this ensures that each new ant that joins the stack will be able to climb up to the top. For each ant, the sum of the weights of all the ants above it in the stack must be no more than 6 times the weight of that ant. What is the maximum number of these ants that can form such a stack? Input The first line of the input gives the number of test cases, T. T test cases follow. Each begins with one line with an integer N: the number of ants in the colony. Then, a second line follows containing N integers W1, W2, ..., WN, where Wi is the weight in milligrams of the i-th ant. The ants are listed in strictly increasing order of length. Notice that no actual length values are given; only the order is important. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum number of the given ants that can form a stack that obeys the rules above. Limits 7 ‚â§ T ‚â§ 100. Time limit: 15 seconds per test set. Memory limit: 1GB. Test set 1 (Visible) For exactly 6 cases, N = 100; for the other T - 6 cases, 2 ‚â§ N ‚â§ 50. 1 ‚â§ Wi ‚â§ 1000, for all i. Test set 2 (Hidden) For exactly 6 cases, \(N= 10^5\); for the other T - 6 cases, 2 ‚â§ N ‚â§ 500. 1 ‚â§ Wi ‚â§ \(10^9\), for all i. Sample Input 3 2 9 1 3 8 4 100 9 10 10 10 10 10 10 10 10 100 Output Case #1: 1 Case #2: 3 Case #3: 8 In Sample Case #1, there are two ants. The first weighs 9 mg; the second weighs 1 mg, and is longer than the first ant. The first ant is strong enough to hold the second ant (since it can hold up to 9 √ó 6 mg), but it cannot, because the second ant is longer. The second ant is not strong enough to hold the first ant (since it can only hold up to 1 √ó 6 mg, which is less than 9 mg). So it is only possible to make a &quot;stack&quot; of one of the two ants. In Sample Case #2, it is possible for all three ants to form a stack, with the third holding up the second, which holds up the first. In Sample Case #3, the optimal solution has the ninth ant on the bottom, and then seven of the other ants above it. ÂàÜÊûê ÂæàÂÆπÊòìÊÉ≥Âà∞ÊòØ‰∏Ä‰∏™Âä®ÊÄÅËßÑÂàí\(dp[i]\)Ôºöi‰∏™ËöÇËöÅÂæóÂú®‰∏ÄËµ∑ÊúÄÂ∞èÁöÑÈáçÈáè \(dp[j - 1] &lt;= w[i] * 6\)ÔºöËã•ÂΩìÂâçÁöÑËöÇËöÅÂèØ‰ª•ÊîØÊíëËµ∑j-1‰∏™ËöÇËöÅÔºå \(dp[j] &gt;= dp[j - 1] + w[i]\)Ëã•‰ª•ÂΩìÂâçÁöÑËöÇËöÅÊõøÊç¢j‰∏™ËöÇËöÅ‰∏≠ÁöÑËöÇËöÅÔºåÂèØ‰ª•‰ΩøËöÇËöÅÁöÑÊÄªÈáçÈáèÂáèÂ∞è ËøôÈáåÂÖ∂ÂÆûÊòØ‰∏Ä‰∏™ÊªöÂä®Êï∞ÁªÑÔºåÂ§çÊùÇÂ∫¶ÊòØ\(O(N^2)\) ‰ΩÜÊòØÊ≥®ÊÑèÂà∞‰∫ãÂÆû‰∏äÊòØ‰∏§Â±ÇÂæ™ÁéØÂ±ÇÂæ™ÁéØÊûö‰∏æn‰∏™ËöÇËöÅÔºåÂÜÖÂ±ÇÂæ™ÁéØÊòØÁ≠îÊ°àkÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶ÊòØ\(O(n*k)\) ÈÇ£‰πàkÊúÄÂ§ßÊòØÂ§öÂ∞ëÂë¢Ôºü ËÄÉËôëÊúÄÊûÅÁ´ØÁöÑÊÉÖÂÜµÔºö ËöÇËöÅ‰ªé‰∏äÂæÄ‰∏ãÁöÑÈáçÈáèÂàÜÂà´ÊòØ1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 4, 4, 5, 6, ‚Ä¶ Âõ†‰∏∫\(w \leq 10^9\)ÂÜô‰∏Ä‰∏™Á®ãÂ∫èÂ∞±Áü•ÈÅì KÊúÄÂ§ßÊòØ139 ÊâÄ‰ª•Êó∂Èó¥Â§çÊùÇÂ∫¶Â§ü„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637/** @Author: sun000* @Date: 2018-05-05 17:43:30* @Last Modified by: sun000* @Last Modified time: 2018-05-05 18:15:47*/#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAX_N = 1e5 + 10;long long int w[MAX_N], dp[MAX_N];int main(void) &#123; int t, n; scanf("%d", &amp;t); for(int ca = 1; ca &lt;= t; ca++) &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) scanf("%lld", &amp;w[i]); memset(dp, 0x7f, sizeof dp); dp[0] = 0; int ans = 0; for(int i = 1; i &lt;= n; i++) &#123; for(int j = ans + 1; j &gt; 0; j--) &#123; if(dp[j - 1] &lt;= w[i] * 6 &amp;&amp; dp[j] &gt;= dp[j - 1] + w[i]) &#123; dp[j] = dp[j - 1] + w[i]; if(ans &lt; j) ans = j; &#125; &#125; &#125; printf("Case #%d: %d\n", ca, ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NCPC2017-I-Import-SPaghetti]]></title>
    <url>%2F2018%2F03%2F08%2FNCPC2017-I-Import-SPaghetti%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ You just graduated from programming school and nailed a Python programming job. The Ô¨Årst day at work you realize that you have inherited a mess. The spaghetti design pattern was chosen by the previous maintainer, who recently Ô¨Çed the country. You try to make sense of the code, but immediately discover that different Ô¨Åles depend cyclically on each other. Testing the code, in fact running the code, has not yet been attempted. As you sit down and think, you decide that the Ô¨Årst thing to do is to eliminate the cycles in the dependency graph. So you start by Ô¨Ånding a shortest dependency cycle. Input The Ô¨Årst line of input contains a number n, 1 ‚â§ n ‚â§ 500, the number of Ô¨Åles. Then follows one line with n names of Ô¨Åles. Each name is a string with at least 1 and at most 8 lower case letters ‚Äòa‚Äô to ‚Äòz‚Äô. Then follow n sections, one section per Ô¨Åle name, in the order they were given on the second line. Each section starts with one line containing the name of the Ô¨Åle and an integer k, followed by k lines, each starting with ‚Äúimport‚Äù. Each ‚Äúimport‚Äù line is a comma-space separated line of dependencies. No Ô¨Åle imports the same Ô¨Åle more than once, and every Ô¨Åle imported is listed in the second line of the input. Comma-space separated means that every line will start with ‚Äúimport‚Äù, then have a list of class names separated by ‚Äú,‚Äù (see sample inputs for examples). Output If the code base has no cyclic dependencies, output ‚ÄúSHIP IT‚Äù. Otherwise, output a line containing the names of Ô¨Åles in a shortest cycle, in the order of the cycle. If there are many shortest cycles, any one will be accepted. Sample Input 1 123456789104 a b c d a 1 import d, b, c b 2 import d import c c 1 import c d 0 Sample Output 1 1c Sample Input 2 1234567891011125 classa classb myfilec execd libeclassa 2 import classb import myfilec, libe classb 1 import execd myfilec 1 import libe execd 1 import libe libe 0 Sample Output 2 1SHIP IT Sample Input 3 1234567891011125 classa classb myfilec execd libe classa 2 import classb import myfilec, libe classb 1 import execd myfilec 1 import libe execd 1 import libe, classa libe 0 Sample Output 3 1classa classb execd ÂàÜÊûê È¢òÊÑèÊòØÂú®‰∏Ä‰∏™Âõæ‰∏äÊ±ÇÊúÄÂ∞èÁéØÔºåÊúÄÂ∞èÁéØÁöÑÊ±ÇÊ≥ïÊòØÁî®ÊúÄÁü≠Ë∑ØÔºåÂÖàÁî®FloydÁÆóÊ≥ïÂ§ÑÁêÜÊØè‰∏§ÁÇπ‰πãÈó¥ÁöÑÊúÄÁü≠Ë∑Ø(Êó∂Èó¥Â§çÊùÇÂ∫¶ÊòØo(n3)Ôºå Êûö‰∏æÊØè‰∏ÄÊù°Ëæπi‚Üíj:G[i][j]ÂàôÂåÖÂê´ÁùÄ‰∏ÄÊù°ËæπÁöÑÊúÄÂ∞èÁéØÊòØÔºöjÂà∞iÁöÑÊúÄÁü≠Ë∑ØÂä†‰∏äËøôÊù°Ëæπ„ÄÇ ËÆæÊúÄÂ∞èÁéØÁöÑÈïøÂ∫¶ÊòØansÂàôans=min(ans,G[i][j]+dis[j][i]) Ê≥®ÊÑèÂà§Êñ≠Ëá™ÁéØÂºóÊ¥õ‰ºäÂæ∑Ê±ÇÊúÄÂ∞èÁéØ‰∏çËÉΩÂ§ÑÁêÜËá™ÁéØÁöÑÊÉÖÂÜµ Â§ÑÁêÜÂÆåÊúÄÂ∞èÁéØË¶ÅËæìÂá∫Ë∑ØÂæÑ„ÄÇ ËøôÈáåÂ∞±Ê∂âÂèäÂà∞‰∫ÜFloydËÆ∞ÂΩïË∑ØÂæÑÁöÑÔºö path[i][j]:iÂà∞jÁöÑÊúÄÁü≠Ë∑ØÂøÖÈ°ªÁªèËøápath[i][j] Ôºö ËøôÊ†∑Â∞±ËÉΩÂú®FlodyÁöÑËøáÁ®ã‰∏≠ËÆ∞ÂΩïËØ•Êï∞ÁªÑÔºåÈÇ£‰πàÂ¶Ç‰ΩïËæìÂá∫Âë¢Ôºü ÊòæÁÑ∂ÂæàÂÆπÊòìÊÉ≥Âà∞,ÈÄíÂΩíËæìÂá∫„ÄÇËØ¶ÊÉÖÁúã‰ª£Á†Å ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/** @Author: sun000* @Date: 2017-10-12 11:11:45* @Last Modified by: sun000* @Last Modified time: 2017-10-22 12:50:20*/#include &lt;map&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 510;const int INF = 0x3f3f3f3f;int n;int G[MAXN][MAXN], dis[MAXN][MAXN];map&lt;string, int&gt; name_to_id;string id_to_name[MAXN];void init() &#123; memset(G, 0x3f, sizeof(G)); memset(dis, 0x3f, sizeof(dis)); for(int i = 0; i &lt; n; i++) G[i][i] = dis[i][i] = 0;&#125;bool flag;string gg;void build() &#123; flag = false; char name[100]; int cnt, now; for(int i = 0; i &lt; n; i++) &#123; scanf("%s%d", name, &amp;cnt); // printf("name = %s cnt = %d\n", name, cnt); now = name_to_id[(string)name]; for(int j = 0; j &lt; cnt; j++) &#123; scanf("%s", name); while(scanf("%s", name)) &#123; int len = strlen(name); if(name[len - 1] == ',') &#123; name[len - 1] = '\0'; if (name_to_id[string(name)] == now)&#123; flag = true; gg = (string)name; &#125; G[now][name_to_id[string(name)]] = 1; dis[now][name_to_id[string(name)]] = 1; &#125; else &#123; if (name_to_id[string(name)] == now)&#123; flag = true; gg = (string)name; &#125; G[now][name_to_id[string(name)]] = 1; dis[now][name_to_id[string(name)]] = 1; break; &#125; &#125; &#125; &#125;&#125;int path[MAXN][MAXN];void output(int i, int j) &#123; if(path[i][j] == -1) cout&lt;&lt; id_to_name[j] &lt;&lt; ' '; else&#123; output(i,path[i][j]); output(path[i][j],j); &#125; &#125;void Floyd() &#123; int r1, r2; memset(path, -1, sizeof(path)); if(flag) &#123; cout &lt;&lt; gg &lt;&lt; endl; return; &#125; int ans = INF; for(int k = 0; k &lt; n; k++) &#123; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(i == j) continue; if(dis[i][j] &gt; dis[i][k]+ dis[k][j]) &#123; dis[i][j] = dis[i][k] + dis[k][j]; path[i][j] = k; &#125; if(ans &gt; G[j][i] + dis[i][j]) &#123; ans = G[j][i] + dis[i][j]; r1 = i, r2 = j; &#125; &#125; &#125; &#125; if(ans &gt;= INF) printf("SHIP IT\n"); else &#123; cout &lt;&lt; id_to_name[r1] &lt;&lt; ' '; output(r1, r2); printf("\n"); &#125;&#125;void show() &#123; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) printf("%d\t", G[i][j]); printf("\n"); &#125;&#125;int main(void) &#123; // freopen("in.txt", "r", stdin); char tmp[20]; scanf("%d", &amp;n); init(); for(int i = 0; i &lt; n; i++) &#123; scanf("%s", tmp); name_to_id[(string)tmp] = i; id_to_name[i] = (string)tmp; &#125; build(); Floyd(); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>ÂõæËÆ∫</tag>
        <tag>ÊúÄÁü≠Ë∑Ø</tag>
        <tag>ÊúÄÂ∞èÁéØ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode4-Median of Two Sorted Arrays]]></title>
    <url>%2F2018%2F03%2F08%2FLeetCode4-Median-of-Two-Sorted-Arrays%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example 1: 123nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2: 1234nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 ÂàÜÊûê ÂàÜÂ•áÂÅ∂ËÄÉËôëÔºå‰∫åÂàÜÂú®Á¨¨‰∏Ä‰∏™Arrays‰∏≠ÈÄâÊã©ÁöÑÊï∞ÈáèkÔºåÁÑ∂ÂêéÂèØ‰ª•ÂîØ‰∏ÄÁ°ÆÂÆöÂú®Á¨¨‰∫å‰∏™Arrays‰∏≠ÁöÑÊï∞ÈáèÔºåkÁöÑÈÄâÊã©ÊòØÊª°Ë∂≥‰∫åÂàÜÁöÑÔºåÂΩìÁ¨¨‰∏Ä‰∏™Arrays‰∏≠ÈÄâÊã©ÁöÑÊúÄÂ§ßÁöÑÊï∞ÊçÆÔºåÂ∞è‰∫éÁ≠â‰∫éArrays‰∏≠Ê≤°ÊúâÈÄâÊã©ÁöÑÊúÄÂ∞èÊï∞ÊçÆÔºåÊó∂ÔºåËØ¥ÊòéÂΩìÂâçkÊª°Ë∂≥Êù°‰ª∂ÔºåÁÑ∂ÂêéÂ∑¶ËæπÁïåÂèòÂ§ßÔºå‰∏ÄÁõ¥‰∫åÂàÜÈÄâÂá∫Êª°Ë∂≥Ë¶ÅÊ±ÇÁöÑÊúÄÂ§ßÁöÑkÔºåÂÖ∂‰∏≠‰∏§‰∏™Arrays‰∏≠Êúâ‰∏Ä‰∏™ÂÖ®‰∏çÈÄâÊàñÂàôÂÖ®ÈÄâÂú®ËÆ°ÁÆóÁ≠îÊ°àÁöÑÊó∂ÂÄôË¶ÅÁâπÊÆäÂ§ÑÁêÜ„ÄÇ ‰ª£Á†ÅÔºàC++Ôºâ 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: bool check(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int a) &#123; int l1 = nums1.size(), l2 = nums2.size(), b; if((l1 + l2) &amp; 1) b = (l1 + l2 + 1) / 2 - a; else b = (l1 + l2) / 2 - a; if(!a || b &gt;= l2) return true; else if(b &lt; 0) return false; return nums1[a - 1] &lt;= nums2[b]; &#125; double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int l1 = nums1.size(), l2 = nums2.size(); int m = (l1 + l2) / 2; int l = 0, r = l1 + 1; int k = 0; while(r - l &gt; 1) &#123; k = (l + r) / 2; if(check(nums1, nums2, k)) l = k; else r = k; &#125; if((l1 + l2) &amp; 1) &#123; int a = l, b = m + 1 - l; if(!a) return nums2[b - 1]; else if(!b) return nums1[a - 1]; return max(nums1[a - 1], nums2[b - 1]); &#125; else &#123; int a = l, b = m - l; int aa, bb; if(!a) aa = nums2[b - 1]; else if(!b) aa = nums1[a - 1]; else aa = max(nums1[a - 1], nums2[b - 1]); if(a == l1) bb = nums2[b]; else if(b == l2) bb = nums1[a]; else bb = min(nums1[a], nums2[b]); return (aa + bb) / 2.0; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>Êú∫ËØï</category>
      </categories>
      <tags>
        <tag>‰∫åÂàÜ</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LatexÊï∞Â≠¶Á¨¶Âè∑]]></title>
    <url>%2F2017%2F10%2F09%2FLatex%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[Á¨¶Âè∑ ÁºñÁ†Å Á¨¶Âè∑ ÁºñÁ†Å Á¨¶Âè∑ ÁºñÁ†Å Á¨¶Âè∑ ÁºñÁ†Å \(\alpha\) \alpha \(\beta\) \beta \(\gamma\) \gamma \(\delta\) \delta \(\epsilon\) \epsilon \(\varepsilon\) \varepsilon \(\zeta\) \zeta \(\eta\) \eta \(\theta\) \theta \(\vartheta\) \vartheta \(\iota\) \iota \(\kappa\) \kappa \(\lambda\) \lambda \(\mu\) \mu \(\nu\) \nu \(\xi\) \xi \(\omicron\) \omicron \(\pi\) \pi \(\varpi\) \varpi \(\rho\) \rho \(\varrho\) \varrho \(\sigma\) \sigma \(\varsigma\) \varsigma \(\tau\) \tau \(\upsilon\) \upsilon \(\phi\) \phi \(\varphi\) \varphi \(\chi\) \chi \(\psi\) \psi \(\omega\) \omega \(\Gamma\) \Gamma \(\Delta\) \Delta \(\Theta\) \Theta \(\Lambda\) \Lambda \(\Xi\) \Xi \(\Pi\) \Pi \(\Sigma\) \Sigma \(\Upsilon\) \Upsilon \(\Phi\) \Phi \(\Psi\) \Psi \(\Omega\) \Omega \(\leq\) \leq \(\geq\) \geq \(\equiv\) \equiv \(\models\) \models \(\prec\) \prec \(\succ\) \succ \(\sim\) \sim \(\perp\) \perp \(\preceq\) \preceq \(\succeq\) \succeq \(\simeq\) \simeq \(\mid\) \mid \(\ll\) \ll \(\gg\) \gg \(\asymp\) \asymp \(\parallel\) \parallel \(\subset\) \subset \(\supset\) \supset \(\approx\) \approx \(\bowtie\) \bowtie \(\subseteq\) \subseteq \(\supseteq\) \supseteq \(\cong\) \cong \(\sqsubset\) \sqsubset \(\sqsupset\) \sqsupset \(\neq\) \neq \(\smile\) \smile \(\sqsubseteq\) \sqsubseteq \(\sqsupseteq\) \sqsupseteq \(\doteq\) \doteq \(\frown\) \frown \(\in\) \in \(\ni\) \ni \(\propto\) \propto \(\vdash\) \vdash \(\dashv\) \dashv \(\leftarrow\) \leftarrow \(\longleftarrow\) \longleftarrow \(\Leftarrow\) \Leftarrow \(\Longleftarrow\) \Longleftarrow \(\rightarrow\) \rightarrow \(\longrightarrow\) \longrightarrow \(\Rightarrow\) \Rightarrow \(\Longrightarrow\) \Longrightarrow \(\uparrow\) \uparrow \(\Uparrow\) \Uparrow \(\downarrow\) \downarrow \(\Downarrow\) \Downarrow \(\leftrightarrow\) \leftrightarrow \(\longleftrightarrow\) \longleftrightarrow \(\Leftrightarrow\) \Leftrightarrow \(\Longleftrightarrow\) \Longleftrightarrow \(\updownarrow\) \updownarrow \(\Updownarrow\) \Updownarrow \(\mapsto\) \mapsto \(\longmapsto\) \longmapsto \(\nearrow\) \nearrow \(\searrow\) \searrow \(\nwarrow\) \nwarrow \(\swarrow\) \swarrow \(\hookleftarrow\) \hookleftarrow \(\hookrightarrow\) \hookrightarrow \(\leftharpoonup\) \leftharpoonup \(\rightharpoonup\) \rightharpoonup \(\leftharpoondown\) \leftharpoondown \(\rightharpoondown\) \rightharpoondown \(\sum\) \sum \(\prod\) \prod \(\coprod\) \coprod \(\int\) \int \(\oint\) \oint \(\bigcap\) \bigcap \(\bigcup\) \bigcup \(\bigsqcup\) \bigsqcup \(\bigvee\) \bigvee \(\bigwedge\) \bigwedge \(\bigodot\) \bigodot \(\bigotimes\) \bigotimes \(\bigoplus\) *** \(\biguplus\) \biguplus \(\lfloor\) \lfloor \(\rfloor\) \rfloor \(\lceil\) \lceil \(\rceil\) \rceil \(\langle\) \langle \(\rangle\) \rangle \(\backslash\) \backslash \(\boxdot\) \boxdot \(\boxplus\) \boxplus \(\boxtimes\) \boxtimes \(\square\) \square \(\blacksquare\) \blacksquare \(\boxminus\) \boxminus \(\lozenge\) \lozenge \(\blacklozenge\) \blacklozenge \(\circlearrowright\) \circlearrowright \(\circlearrowleft\) \circlearrowleft \(\leftrightharpoons\) \leftrightharpoons \(\centerdot\) \centerdot \(\Vdash\) \Vdash \(\Vvdash\) \Vvdash \(\vDash\) \vDash \(\twoheadrightarrow\) \twoheadrightarrow \(\twoheadleftarrow\) \twoheadleftarrow \(\leftleftarrows\) \leftleftarrows \(\rightrightarrows\) \rightrightarrows \(\upuparrows\) \upuparrows \(\downdownarrows\) \downharpoonleft \(\upharpoonright\) \upharpoonright \(\upharpoonleft\) \upharpoonleft \(\downharpoonright\) \downharpoonright \(\downharpoonleft\) \downharpoonleft \(\rightarrowtail\) \rightarrowtail \(\leftarrowtail\) \leftarrowtail \(\rightleftarrows\) \rightleftarrows \(\leftrightarrows\) \leftrightarrows \(\Lsh\) \Lsh \(\Rsh\) \Rsh \(\rightsquigarrow\) \rightsquigarrow \(\leftrightsquigarrow\) \leftrightsquigarrow \(\looparrowleft\) \looparrowleft \(\looparrowright\) \looparrowright \(\circeq\) \circeq \(\succsim\) \succsim ÂÖàÊõ¥Êñ∞Ëøô‰πàÂ§ö„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇ]]></content>
      <categories>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces-Gym-101201F-Illumination]]></title>
    <url>%2F2017%2F10%2F09%2FCodeForces-Gym-101201F-Illumination%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ You inherited a haunted house. Its floor plan is an n-by-n square grid with l lamps in fixedlocations and no interior walls. Each lamp can either illuminate its row or its column, but not bothsimultaneously. The illumination of each lamp extends by r squares in both directions, so a lampunobstructed by an exterior wall of the house can illuminate as many as 2r + 1 squares. If a square is illuminated by more than one lamp in its row, or by more than one lamp in its column,the resulting bright spot will scare away ghosts forever, diminishing the value of your property. Isit possible for all lamps to illuminate a row or column, without scaring any ghosts? Note that asquare illuminated by two lamps, one in its row and the other in its column, will not scare awaythe ghosts. Input The first line of input contains three positive integers, n, r and l \((1 \leqslant n, r, l \leqslant 1,000)\). Each of the next l lines contains two positive integers ri and ci \((1 \leqslant r_i,c_i \leqslant n)\), indicating that there is a lamp in row \(r_i\) and column \(c_i\). It is guaranteed that all lamps are in distinct locations. Output Print, on a single line, YES if it is possible to illuminate all lamps as stated above; otherwise, print NO. ÂàÜÊûê ÂÖ∏ÂûãÁöÑ2-SATÈóÆÈ¢ò ÊØè‰∏™ÁÅØÊ≥°Êúâ‰∏§‰∏™Áä∂ÊÄÅÔºåÁä∂ÊÄÅ‰πãÈó¥Áõ∏‰∫íÂΩ±Âìç„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;int n, r, l;struct node &#123; int x, y;&#125; p[1010];vector&lt;int&gt; G[2010], rG[2010], vs;bool used[2010];int cmp[2010];void addedge(int u, int v) &#123; G[u].push_back(v); rG[v].push_back(u);&#125;void build() &#123; for (int i = 0; i &lt; l; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (p[i].y == p[j].y &amp;&amp; abs(p[i].x - p[j].x) &lt;= 2 * r) &#123; addedge(i, l + j); addedge(j, l + i); &#125; if (p[i].x == p[j].x &amp;&amp; abs(p[i].y - p[j].y) &lt;= 2 * r) &#123; addedge(l + i, j); addedge(l + j, i); &#125; &#125; &#125;&#125;void dfs(int v) &#123; used[v] = true; for (int i = 0; i &lt; (int)G[v].size(); ++i) &#123; if (!used[G[v][i]]) dfs(G[v][i]); &#125; vs.push_back(v);&#125;void rdfs(int v, int k) &#123; used[v] = true; cmp[v] = k; for (int i = 0; i &lt; (int)rG[v].size(); ++i) &#123; if (!used[rG[v][i]]) rdfs(rG[v][i], k); &#125;&#125;int scc() &#123; memset(used, 0, sizeof(used)); vs.clear(); for (int i = 0; i &lt; 2 * l; ++i) &#123; if (!used[i]) dfs(i); &#125; memset(used, 0, sizeof(used)); int k = 0; for (int i = vs.size() - 1; i &gt;= 0; --i) &#123; if (!used[vs[i]]) rdfs(vs[i], k++); &#125; return k;&#125;int main(void) &#123; scanf("%d%d%d", &amp;n, &amp;r, &amp;l); for (int i = 0; i &lt; l; i++) scanf("%d%d", &amp;p[i].x, &amp;p[i].y); build(); scc(); for (int i = 0; i &lt; l; i ++) &#123; if (cmp[i] == cmp[l + i]) &#123; printf("NO\n"); return 0; &#125; &#125; printf("YES\n"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
        <tag>ÂõæËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NAIPC-2017-A]]></title>
    <url>%2F2017%2F10%2F09%2FNAIPC-2017-A%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ You are teaching a class in programming, and you want to cover balanced parentheses. You‚Äôve got a great visual aid, a sign with a very long, balanced string of parentheses. But, alas, somehow, your visual aid has been broken into pieces, and some pieces may be missing! You‚Äôve got to try to put it back together as best you can. Given the string of parentheses on each piece, what is the longest balanced string you can form by concatenating some of them in some order? Each piece may be used at most once, and the pieces cannot be reversed. A balanced string of parentheses is defined as: The empty string ABAB where AA and BB are both balanced strings of parentheses (AA) where AA is a balanced string of parentheses Input Each input will consist of a single test case. Note that your program may be run multiple times on different inputs. The first line of input will contain a single integer nn (1‚â§n‚â§3001‚â§n‚â§300), which is the number of pieces. Each of the next nn lines will hold a single string ss (1‚â§|s|‚â§3001‚â§|s|‚â§300), which consists only of the characters ‚Äô(‚Äô and ‚Äô)‚Äô. This describes one of the pieces. Output Output a single integer, which is the length of the longest string of balanced parentheses you can form from the pieces. Note that the empty string is technically a balanced string of parentheses, so it is always possible to form a string of length at least 00 (although the empty string is not a very effective visual aid!). Example sample input1 12343())((())() sample output1 110 sample input2 1234565))))))(())((( sample output2 12 ÂàÜÊûê È¢òÊÑèÊòØÁªôÂÆön‰∏™Áî±Êã¨Âè∑ÁªÑÊàêÁöÑÂ≠óÁ¨¶‰∏≤ÔºåÈóÆÈÄâÊã©‰∏Ä‰∫õÂ≠óÁ¨¶‰∏≤Êù•ÊãºÊé•ÔºåËÉΩÂæóÂà∞ÁöÑÊã¨Âè∑ÂåπÈÖçÁöÑÊúÄÈïøÁöÑÊúÄÈïøÁöÑÂ≠óÁ¨¶‰∏≤ÁöÑÈïøÂ∫¶„ÄÇ ÂÖàÂ∞ÜÊØè‰∏™Â≠óÁ¨¶‰∏≤‰∏≠Â∑≤ÁªèËÉΩÂ§üÂåπÈÖçÁöÑÊã¨Âè∑Ê∂àÂéªÔºåÂæóÂà∞‰∏Ä‰∏™))...(((ËøôÁßçÁ±ªÂûãÁöÑÂ≠óÁ¨¶‰∏≤ dp[i][j] Ë°®Á§∫Â§ÑÁêÜÂÆåÂâçi‰∏™Â≠óÁ¨¶‰∏≤ÔºåÂ∑¶Êã¨Âè∑ËøòÂâ©‰∏ãÁöÑj‰∏™Â≠óÁ¨¶‰∏≤ÁöÑÊúÄÂ§ßÈïøÂ∫¶ \(dp[i + 1][j] = max(dp[i][j], dp[i][j + p[i].r - p[i].l] + p[i].w\) ÁªìÊûÑ‰Ωìp{l:Â§ÑÁêÜÂêéÂ∑¶Êã¨Âè∑‰∏™Êï∞, r: Â§ÑÁêÜÂêéÂè≥Êã¨Âè∑‰∏™Êï∞, w:ÂéüÂ≠óÁ¨¶‰∏≤ÁöÑÈïøÂ∫¶} Ëøô‰∏™È¢òÁõÆÁöÑÈáçÁÇπÂú®‰∫éÊéíÂ∫èÔºåÂæàÂÆπÊòìÂ∞±ËÉΩÊÉ≥Âà∞ËøôÊ†∑ÁöÑdpÊñπÁ®ã ÊéíÂ∫èÔºöÂè™ÊúâÂ∑¶Êã¨Âè∑ÁöÑÊéíÂú®ÊúÄÂâçÈù¢ÔºåÂè™ÊúâÂè≥Êã¨Âè∑ÁöÑÊéíÂú®ÊúÄÂêéÈù¢ÔºåÁÑ∂ÂêéÂØπ‰∫é‰∏≠ Èó¥ÁöÑ‰ΩøÂ∑¶Êã¨Âè∑Â¢ûÂä†ÁöÑÊéíÂú®ÂáèÂ∞ëÁöÑ‰πãÂâçÔºåÂØπ‰∫éÈÉΩÂ¢ûÂä†ÊàñËÄÖÈÉΩÂáèÂ∞ëÁöÑÁöÑÔºåÂè≥Êã¨Âè∑Â∞ëÁöÑÊéíÂú®ÂâçÈù¢„ÄÇÔºàËøôÈáåÂ∞±ÊòØ‰∏Ä‰∏™Ë¥™ÂøÉÔºâ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123;//È¢ÑÂ§ÑÁêÜÂêéÁöÑÂ≠óÁ¨¶‰∏≤ÁöÑÂ∑¶Êã¨Âè∑ÂíåÂè≥Êã¨Âè∑ÁöÑ‰∏™Êï∞ËøòÊúâÂéüÂ≠óÁ¨¶‰∏≤ÁöÑÈïøÂ∫¶ int l, r, w;&#125; p[310];bool cmp(node a, node b) &#123; if(a.r == 0 &amp;&amp; b.r != 0) return true; else if(a.r != 0 &amp;&amp; b.r == 0) return false; else if(a.r == 0 &amp;&amp; b.r == 0) return a.l &lt; b.l; if(a.l == 0 &amp;&amp; b.l != 0) return false; else if(a.l != 0 &amp;&amp; b.l == 0) return true; else if(a.l == 0 &amp;&amp; b.l == 0) return a.r &lt; b.r; if(a.l - a.r &gt;= 0 &amp;&amp; b.l - b.r &gt;= 0) return a.r &lt; b.r; if (a.l - a.r &gt;= 0 &amp;&amp; b.l - b.r &lt; 0) return true; if (b.l - b.r &gt;= 0 &amp;&amp; a.l - a.r &lt; 0) return false; return a.r - a.l &lt; b.r - b.l;&#125;int dp[310][90010];char tmp[310];int main(void) &#123; int n; int cntl, cntr; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; cntl = cntr = 0; scanf("%s", tmp); p[i].w = (int)strlen(tmp); for (int j = 0; j &lt; p[i].w; j++) &#123; if (tmp[j] == '(') cntl++; else &#123; if (cntl) cntl--; else cntr++; &#125; &#125; p[i].l = cntl; p[i].r = cntr; &#125; sort(p, p + n, cmp); memset(dp, -0x3f, sizeof(dp)); dp[0][0] = 0; for (int i = 0; i &lt; n ; i++) &#123; for(int j = 0; j &lt; p[i].l; j++) dp[i + 1][j] = dp[i][j]; for (int j = p[i].l; j &lt;= 90000 &amp;&amp; j + p[i].r - p[i].l &lt;= 90000; j++) dp[i + 1][j] = max(dp[i][j], dp[i][j + p[i].r - p[i].l] + p[i].w); &#125; printf("%d\n", dp[n][0]);&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Ë¥™ÂøÉ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces-868C-Qualification-Rounds]]></title>
    <url>%2F2017%2F10%2F08%2FCodeForces-868C-Qualification-Rounds%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ Snark and Philip are preparing the problemset for the upcoming pre-qualification round for semi-quarter-finals. They have a bank of nproblems, and they want to select any non-empty subset of it as a problemset. k experienced teams are participating in the contest. Some of these teams already know some of the problems. To make the contest interesting for them, each of the teams should know at most half of the selected problems. Determine if Snark and Philip can make an interesting problemset! Input The first line contains two integers n, k (1 ‚â§ n ‚â§ 105, 1 ‚â§ k ‚â§ 4) ‚Äî the number of problems and the number of experienced teams. Each of the next n lines contains k integers, each equal to 0 or 1. The j-th number in the i-th line is 1 if j-th team knows i-th problem and 0 otherwise. Output Print &quot;YES&quot; (quotes for clarity), if it is possible to make an interesting problemset, and &quot;NO&quot; otherwise. You can print each character either upper- or lowercase (&quot;YeS&quot; and &quot;yes&quot; are valid when the answer is &quot;YES&quot;). Examples input 1234565 31 0 11 1 01 0 01 0 01 0 0 output 1NO input 12343 21 01 10 1 output 1YES Note In the first example you can't make any interesting problemset, because the first team knows all problems. In the second example you can choose the first and the third problems. ÂàÜÊûê Áî±‰∫éÈòü‰ºçÁöÑÊï∞ÈáèÊúÄÂ§öÂè™Êúâ4‰∏™ÔºåÈÇ£‰πàÂØπ‰∫é‰∏ÄÈÅìÈ¢òÁõÆÁöÑÁä∂ÊÄÅÊúÄÂ§ö‰πüÂè™Êúâ16ÁßçÔºåÂÅáËÆæÂ≠òÂú®‰∏ÄÈÅìÈ¢òÁõÆÊâÄÊúâÁöÑÈòü‰ºçÈÉΩ‰∏ç‰ºöÔºåÈÇ£‰πàÂè™Ë¶ÅÈÄâËøô‰∏ÄÈÅìÈ¢òÊòØËÇØÂÆöÂèØ‰ª•ÁöÑ„ÄÇ Áé∞Âú®ËÄÉËôëÊ≤°ÊúâÊâÄÊúâ‰∫∫ÈÉΩ‰∏ç‰ºöÁöÑÈ¢òÁõÆÔºåÂàôËá≥Â∞ëÂÖàÈÄâ‰∏ÄÈÅìÈ¢òÁõÆÔºàÂπ∂‰∏îËøôÈÅìÈ¢òÁõÆËá≥Â∞ëË¢´‰∏Ä‰∏™Èòü‰ºçÁü•ÈÅìÔºâÔºåÂÅáËÆæËøôÈÅìÈ¢òÁõÆÁöÑÁä∂ÊÄÅÊòØ‚Äú1000‚ÄùÂàôÁé∞Âú®Ëá≥Â∞ëË¶ÅÈÄâÊã©‰∏ÄÈÅìÈ¢òÁõÆÊù•ÊäµÊ∂àÁ¨¨‰∏Ä‰∏™Èòü‰ºçÔºåÂõ†‰∏∫Á¨¨‰∏Ä‰∏™Èòü‰ºçÂ∑≤ÁªèÁü•ÈÅì‰∫Ü‰∏ÄÈÅìÈ¢òÁõÆ‰∫ÜÔºåÁé∞Âú®Ëá≥Â∞ëË¶ÅÈÄâ‰∏Ä‰∏™‚Äú0***‚ÄùÁöÑÈ¢òÁõÆÔºåËã•Â≠òÂú®ËøôÊ†∑ÁöÑÈ¢òÁõÆÂàôÁ≠îÊ°àËÇØÂÆöÊòØ‚ÄúYES‚ÄùÁöÑÔºåÁé∞Âú®ËÄÉËôëÊõ¥Âä†Â§çÊùÇÁöÑÊÉÖÂÜµ„ÄÇ Á≠îÊ°àÂ≠òÂú®ÂΩì‰∏î‰ªÖÂΩìÂ≠òÂú®‰∏§ÈÅìÈ¢òÁõÆÁöÑÁä∂ÊÄÅÊòØaÂíåb‰∏îa&amp;b = 0 ÂøÖË¶ÅÊÄßÊòæËÄåÊòìËßÅ„ÄÇ ÂØπ‰∫éÂÖÖÂàÜÊÄßÔºöÁî±‰∏äÈù¢ÁöÑ‰æãÂ≠êËÄÉËôëË∑üÂÆ∂Â§çÊùÇÁ≠âÊÉÖÂÜµÔºåÂΩìÊàë‰ª¨ÈÄâÊã©‰∫Ü‰∏ÄÈÅìÈ¢òÁõÆÂêéÔºåÂú®ÈÄâÊã©Á¨¨‰∫åÈÅìÈ¢òÁõÆÁöÑÊó∂ÂÄôÂøÖÈ°ªÈÄâÊã©‰∏ÄÈÅìÈ¢òÊäµÊ∂àÁ¨¨‰∏ÄÈÅìÁä∂ÊÄÅ‰∏äÊòØ1Èòü‰ºçÔºåËøô‰∏™Êó∂ÂÄôËÇØÂÆöË¶ÅÂÖàÈÄâÊã©Ëøô‰∫õ‰ΩçÁΩÆ‰∏∫0ÁöÑÔºåËã•Â≠òÂú®ÂÖ∂‰ªñÁ≠îÊ°àÔºåÈÄâÊã©‰∫Ü‰∏∫1ÁöÑÔºåÂàô1Â¢ûÂä†‰∫ÜÔºåÈ¢òÁõÆË¶ÅÊ±ÇÊØè‰∏™Èòü‰ºçÁöÑ0ÊØî1Â§öÔºåÂàôÈÄöËøá‰∫§Êç¢ÈÄâÊã©È¢òÁõÆÁöÑÈ°∫Â∫èÔºåËøô‰∏™Êó∂ÂÄôËÇØÂÆöË¶ÅÈÄâ‰∏Ä‰∏™Âú®Á¨¨‰∏ÄÊ¨°ÈÄâÊã©ÁöÑÊó∂ÂÄô‰∏∫1ÁöÑÈòü‰ºçÔºåÊ≠§Êó∂‰∏∫0ÁöÑÈ¢òÁõÆ„ÄÇ ÂÖ±Êúâ16ÁßçÁä∂ÊÄÅ16*16Êûö‰∏æ‰∏Ä‰∏ãÂ∞±Â•Ω‰∫Ü ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int n, k;bool vis[20];int main(void) &#123; memset(vis, false, sizeof(vis)); scanf("%d%d", &amp;n, &amp;k); int gg; for (int i = 0; i &lt; n; i++) &#123; int tmp = 0; for (int j = 0; j &lt; k; j++) &#123; scanf("%d", &amp;gg); tmp = tmp * 2 + gg; &#125; vis[tmp] = true; &#125; bool flag = false; if (vis[0]) flag = true; else &#123; for(int i = 0; i &lt; 16; i++) &#123; if(vis[i]) &#123; for(int j = 0; j &lt; i; j++) &#123; if(vis[j] &amp;&amp; !(i &amp; j)) &#123; flag = true; break; &#125; &#125; &#125; if(flag) break; &#125; &#125; if(flag) printf("YES\n"); else printf("NO\n"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Êï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces-869c-The-Intriguing-Obsession]]></title>
    <url>%2F2017%2F10%2F08%2FCodeForces-869c-The-Intriguing-Obsession%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ ‚ÄîThis is not playing but duty as allies of justice, Nii-chan! ‚Äî Not allies but justice itself, Onii-chan! With hands joined, go everywhere at a speed faster than our thoughts! This time, the Fire Sisters ‚Äî Karen and Tsukihi ‚Äî is heading for somewhere they've never reached ‚Äî water-surrounded islands! There are three clusters of islands, conveniently coloured red, blue and purple. The clusters consist of a, b and c distinct islands respectively. Bridges have been built between some (possibly all or none) of the islands. A bridge bidirectionally connects two different islands and has length 1. For any two islands of the same colour, either they shouldn't be reached from each other through bridges, or the shortest distance between them is at least 3, apparently in order to prevent oddities from spreading quickly inside a cluster. The Fire Sisters are ready for the unknown, but they'd also like to test your courage. And you're here to figure out the number of different ways to build all bridges under the constraints, and give the answer modulo 998 244 353. Two ways are considered different if a pair of islands exist, such that there's a bridge between them in one of them, but not in the other. Input The first and only line of input contains three space-separated integers a, b and c (1 ‚â§ a, b, c ‚â§ 5 000) ‚Äî the number of islands in the red, blue and purple clusters, respectively. Output Output one line containing an integer ‚Äî the number of different ways to build bridges, modulo 998 244 353. Examples input 11 1 1 output 18 input 11 2 2 output 163 input 11 3 5 output 13264 input 16 2 9 output 1813023575 Note In the first example, there are 3 bridges that can possibly be built, and no setup of bridges violates the restrictions. Thus the answer is 23 = 8. In the second example, the upper two structures in the figure below are instances of valid ones, while the lower two are invalid due to the blue and purple clusters, respectively. img ÂàÜÊûê Áî±‰∫é‰ªªÊÑè‰∏§ÁßçÈ¢úËâ≤ÁöÑÂΩ±ÂìçÊòØÁã¨Á´ãÁöÑÔºåÊâÄ‰ª•ÂèØ‰ª•ÁªºÂêàËÄÉËôë‰ªªÊÑè‰∏§ÁßçÈ¢úËâ≤‰πãÈó¥ÁöÑËøûÊé•ÊÉÖÂÜµÔºåÁÑ∂ÂêéÊää‰∏â‰∏™Êï∞‰πòËµ∑Êù•ÔºåÂ∞±ÊòØÊúÄÂêéÁöÑÁ≠îÊ°à„ÄÇ ËÄÉËôë‰∏§ÁßçÈ¢úËâ≤‰πãÈó¥ÁöÑÊñπÊ°àÊï∞ÁõÆ„ÄÇ dp[i][j]Ë°®Á§∫ÁöÑÊòØ‰∏§ÁßçÈ¢úËâ≤ÂàÜÂà´‰∏∫i‰∏™Âíåj‰∏™‰πãÈó¥ÁöÑÈ¢úËâ≤ÔºåÂàôÁé∞Âú®ËÄÉËôëiË°®Á§∫ÁöÑÈ¢úËâ≤Â¢ûÂä†‰∫Ü‰∏Ä‰∏™ÁÇπÔºåÂàôËøô‰∏™ÁÇπÂíåjË°®Á§∫ÁöÑÈ¢úËâ≤Áõ∏ËøûÁöÑÊñπÊ°àÊï∞ÁõÆÊòØ\(j * dp[i][j - 1]\),Ëã•‰∏ç‰∏éj‰∏≠‰ªªÊÑè‰∏Ä‰∏™È¢úËâ≤Áõ∏ËøûÂàôÊòØ\(dp[i][j]\) Âàô\[dp[i + 1][j] = j * dp[i ][j - 1] + dp[i ][j]\] Âç≥\[dp[i][j] = j * dp[i - 1][j - 1] + dp[i - 1][j]\] ‰ª£Á†Å 12345678910111213141516171819202122232425#include &lt;cstdio&gt;const long long int MOD = 998244353;const int MAXN = 5e3 + 10;int dp[MAXN][MAXN];void init() &#123; for(int i = 0; i &lt; MAXN; i++) dp[i][0] = dp[0][i] = 1; for(int i = 1; i &lt; MAXN; i++) &#123; for(int j = 1; j &lt; MAXN; j++) &#123; dp[i][j] = (j * 1LL * dp[i - 1][j - 1] + dp[i - 1][j]) % MOD; &#125; &#125;&#125;int main(void) &#123; init(); int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); int ans = ((1LL * dp[a][b] * dp[a][c]) % MOD) * dp[b][c] % MOD; printf("%d\n", ans); return 0; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>ÊûÑÈÄ†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU5242-Game]]></title>
    <url>%2F2017%2F09%2F12%2FHDU5242-Game%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ Problem Description It is well known that Keima Katsuragi is The Capturing God because of his exceptional skills and experience in ''capturing'' virtual girls in gal games. He is able to play k games simultaneously. One day he gets a new gal game named ''XX island''. There are n scenes in that game, and one scene will be transformed to different scenes by choosing different options while playing the game. All the scenes form a structure like a rooted tree such that the root is exactly the opening scene while leaves are all the ending scenes. Each scene has a value , and we use wi as the value of the i-th scene. Once Katsuragi entering some new scene, he will get the value of that scene. However, even if Katsuragi enters some scenes for more than once, he will get wi for only once. For his outstanding ability in playing gal games, Katsuragi is able to play the game k times simultaneously. Now you are asked to calculate the maximum total value he will get by playing that game for k times. Input The first line contains an integer T(T‚â§20), denoting the number of test cases. For each test case, the first line contains two numbers n,k(1‚â§k‚â§n‚â§100000), denoting the total number of scenes and the maximum times for Katsuragi to play the game ''XX island''. The second line contains n non-negative numbers, separated by space. The i-th number denotes the value of the i-th scene. It is guaranteed that all the values are less than or equal to 231‚àí1. In the following n‚àí1 lines, each line contains two integers a,b(1‚â§a,b‚â§n), implying we can transform from the a-th scene to the b-th scene. We assume the first scene(i.e., the scene with index one) to be the opening scene(i.e., the root of the tree). Output For each test case, output ''Case #t:'' to represent the t-th case, and then output the maximum total value Katsuragi will get. Sample Input 1234567891011121325 24 3 2 1 11 21 52 32 45 34 3 2 1 11 21 52 32 4 Sample Output 12Case #1: 10Case #2: 11 ÂàÜÊûê ËøôÈ¢òÊòØ‰∏Ä‰∏™Ë¥™ÂøÉÔºåÁî±‰∫éÊØèÊ¨°ÈÄâÊã©ÁöÑË∑ØÂæÑËÇØÂÆöÊòØ‰ªéÊ†πËäÇÁÇπÂà∞‰∏Ä‰∏™Âè∂ÁªìÁÇπÁöÑÔºåÂàôÈ¶ñÂÖàdfsËÆ°ÁÆóÂá∫‰ªéÊ†πËäÇÁÇπÂà∞Âè∂Â≠êËäÇÁÇπÁöÑË∑ØÂæÑ‰∏äÊâÄÊúâÁÇπÁöÑÊùÉÂÄºÂíåÔºåÁÑ∂ÂêéÂ∞ÜÂè∂ÁªìÁÇπÊåâÁÖßË∑ØÂæÑÊùÉÂÄºÂíåÁöÑ‰ªéÂ§ßÂà∞Â∞èÊéíÂ∫èÔºåÁÑ∂ÂêéÊ†πÊçÆËøô‰∏™È°∫Â∫èÂêë‰∏äËµ∞Âà∞Ê†πËäÇÁÇπÊàñÂàôËµ∞Âà∞Ë¢´ÈÄâÊã©ÁöÑËäÇÁÇπÔºåËÆ°ÁÆóÊùÉÂÄºÂíåÔºåÁÑ∂ÂêéËÆ°ÁÆóÂá∫cntÔºàÂè∂ÁªìÁÇπ‰∏™Êï∞Ôºâ‰∏™ÊùÉÂÄºÂíåÔºåÁÑ∂Âêé‰ªéÂ§ßÂà∞Â∞èÊéíÂ∫èÔºåÈÄâÂâçkÊù°Ë∑ØÂ∞±ÊòØÊúÄ‰ºòÁöÑË∑Ø„ÄÇ Ë¥™ÂøÉËØÅÊòéÔºöËÄÉËôë‰∏ÄËà¨ÊÉÖÂÜµÔºåÊúâ‰∏ÄÈ¢óÂ≠êÊ†ëÔºöaÊúâ‰∏§‰∏™Â≠êËäÇÁÇπbÂíåcÔºåÂÅáËÆæÊ†πËäÇÁÇπÂà∞bÁöÑË∑ØÂæÑÊùÉÂÄºÂíåÊØîËæÉÂ§ßÔºåÂàôÈÄâÊã©bÂêë‰∏äËµ∞Âà∞‰∏Ä‰∏™Â∑≤ÁªèË¢´ÈÄâÊã©ÁöÑËäÇÁÇπÊàñËÄÖÊ†πËäÇÁÇπËÇØÂÆöÊØîcË¶ÅÊõ¥‰ºòÔºåÂõ†‰∏∫bÂíåcÁöÑÊúÄËøëÂÖ¨ÂÖ±Á•ñÂÖàÊòØaÁöÑÊ†πËäÇÁÇπÔºå‰∏îÊúÄËøëÂÖ¨ÂÖ±Á•ñÂÖàÂà∞bÂíåcÁöÑË∑ØÂæÑÈÉΩÊ≤°ÊúâË¢´ÊüìËâ≤ÔºåÂàôËÄÉËôëÊõ¥Â§çÊùÇÁöÑÊÉÖÂÜµÔºåÂèØ‰ª•ÂèëÁé∞ÔºåÂØπ‰∫éÂêå‰∏ÄÊ£µÂ≠êÊ†ë‰πã‰∏≠ÔºåÂè∂Â≠êÂà∞Â≠êÊ†ëÊ†πËäÇÁÇπÁöÑË∑ØÂæÑÊùÉÂÄºÂíåÁöÑÂÅèÂ∫èÂÖ≥Á≥ªÂíåÊ†πËäÇÁÇπÂà∞ËØ•Âè∂ËäÇÁÇπÁöÑË∑ØÂæÑÊùÉÂÄºÂíåÁöÑÂÅèÂ∫èÂÖ≥Á≥ªÊòØÁõ∏ÂêåÁöÑ„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e5 +10;vector&lt;int&gt; G[MAXN];long long int val[MAXN], g[MAXN]; int fa[MAXN], d[MAXN], cnt;bool vis[MAXN]; bool cmp(int a, int b) &#123; return val[a] &gt; val[b];&#125;void dfs(int s) &#123; for(int i = 0; i &lt; G[s].size(); i++) &#123; val[G[s][i]] += val[s]; dfs(G[s][i]); &#125; if(!G[s].size()) d[cnt++] = s;&#125;long long int getNum(int k) &#123; long long int ret = 0; while(!vis[k]) &#123; ret += g[k]; vis[k] = true; k = fa[k]; &#125; return ret;&#125;int main(void) &#123; int t, n, k, u, v; scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; cas++) &#123; scanf("%d%d", &amp;n, &amp;k); for(int i = 1; i &lt;= n; i++) &#123; G[i].clear(); vis[i] = false; scanf("%lld", &amp;val[i]); g[i] = val[i]; &#125; for(int i = 0; i &lt; n- 1; i++) &#123; scanf("%d%d", &amp;u, &amp;v); fa[v] = u; G[u].push_back(v); &#125; cnt = 0; dfs(1); sort(d, d + cnt, cmp); for(int i = 0; i &lt; cnt; i++) &#123; val[i] = getNum(d[i]); &#125; sort(val, val + cnt); long long int ans = 0; for(int i = cnt - 1; i &gt;= cnt - k; i--) ans += val[i]; printf("Case #%d: %lld\n",cas, ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Ë¥™ÂøÉ</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU5245-Joyful]]></title>
    <url>%2F2017%2F09%2F12%2FHDU5245-Joyful%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ Problem Description Sakura has a very magical tool to paint walls. One day, kAc asked Sakura to paint a wall that looks like an M√óN matrix. The wall has M√óN squares in all. In the whole problem we denotes (x,y) to be the square at the x-th row, y-th column. Once Sakura has determined two squares (x1,y1) and (x2,y2), she can use the magical tool to paint all the squares in the sub-matrix which has the given two squares as corners. However, Sakura is a very naughty girl, so she just randomly uses the tool for K times. More specifically, each time for Sakura to use that tool, she just randomly picks two squares from all the M√óN squares, with equal probability. Now, kAc wants to know the expected number of squares that will be painted eventually. Input The first line contains an integer T(T‚â§100), denoting the number of test cases. For each test case, there is only one line, with three integers M,N and K. It is guaranteed that 1‚â§M,N‚â§500, 1‚â§K‚â§20. Output For each test case, output ''Case #t:'' to represent the t-th case, and then output the expected number of squares that will be painted. Round to integers. Sample Input 12323 3 14 4 2 Sample Output 12Case #1: 4Case #2: 8 Hint The precise answer in the first test case is about 3.56790123. ÂàÜÊûê ËÆ°ÁÆóÂá∫ÊØè‰∏Ä‰∏™Ê†ºÂ≠êË¢´‰∏äËâ≤ÁöÑÊ¶ÇÁéáÔºåÁ¥ØÂä†ÂõõËàç‰∫îÂÖ•Â∞±ÊòØÁ≠îÊ°àÔºåÊØè‰∏™Ê†ºÂ≠êË¢´‰∏äËâ≤ÁöÑÊ¶ÇÁéáÂ∞±ÊòØ1ÂáèÂéª‰∏çË¢´‰∏äËâ≤ÁöÑÊ¶ÇÁéáÁöÑkÊ¨°Êñπ„ÄÇËÆ°ÁÆó‰∏Ä‰∏™Ê†ºÂ≠ê‰∏çË¢´‰∏äËâ≤ÁöÑÊ¶ÇÁéáÁî®Âà∞‰∏Ä‰∏™ÂÆπÊñ•ÂÆöÁêÜ„ÄÇ ËÆ°ÁÆó‰∏§Ê¨°ÈÄâÊã©ÈÉΩÈÄâÂú®ËØ•Ê†ºÂ≠ê‰∏ÄÈù¢ÁöÑÊ¶ÇÁéáÔºåÁ¥ØÂä†Âõõ‰∏™Èù¢ÁöÑÊ¶ÇÁéáÔºåÁî±‰∫éÁ¥ØÂä†ÁöÑÊó∂ÂÄôÈáçÂ§çËÆ°ÁÆó‰∫ÜÂú®Ê†ºÂ≠êÁöÑÂõõ‰∏™ËßíÁöÑÊ¶ÇÁéáÔºåÂàôÁî®ÂÆπÊñ•ÂÆöÂäõÂáèÂéª„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;double q_pow(double a, int b) &#123; double ans = 1.0, tmp = a; while(b) &#123; if(b &amp; 1) ans = ans * tmp; tmp = tmp * tmp; b &gt;&gt;= 1; &#125; return ans;&#125;int main(void) &#123; int t, k; double n, m; scanf("%d", &amp;t); int nn, mm; for(int cas = 1; cas &lt;= t; cas++) &#123; double ans = 0.5; scanf("%lf%lf%d", &amp;n, &amp;m, &amp;k); nn= (int)n, mm = (int)m; for(int i = 1; i &lt;= nn; i++) &#123; for(int j = 1; j &lt;= mm; j++) &#123; ans += 1.0 - q_pow((m * (i - 1) * m * (i - 1) + m * (n - i) * m * (n - i) + n * (j - 1) * n * (j - 1) + n * (m - j) * n * (m - j) - ((double)i - 1) * (j - 1) * (i - 1) * (j - 1) - (n - i) * (m - j) * (n - i) * (m - j) - (n - i) * (j - 1) * (n - i) * (j - 1) - (i - 1) * (m - j) * (i - 1) * (m - j)) / (n * m * n * m), k); &#125; &#125; printf("Case #%d: %d\n", cas, (int)ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Êï∞Â≠¶</tag>
        <tag>ÂÆπÊñ•</tag>
        <tag>Ê¶ÇÁéá</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6146 Pokemon-GO]]></title>
    <url>%2F2017%2F08%2F25%2FHDU6146-Pokemon-GO%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ Problem Description ‰ºóÊâÄÂë®Áü•ÔºåÂ∫¶Â∫¶ÁÜäÊúÄËøëÊ≤âËø∑‰∫é Pok√©mon GO„ÄÇ ‰ªäÂ§©ÂÆÉÂÜ≥ÂÆöË¶ÅÊäì‰ΩèÊâÄÊúâÁöÑÁ≤æÁÅµÁêÉÔºÅ ‰∏∫‰∫Ü‰∏çËÆ©Â∫¶Â∫¶ÁÜäÂ§±ÊúõÔºåÁ≤æÁÅµÁêÉÂ∑≤ÁªèË¢´‰∫ãÂÖàÊîæÁΩÆÂú®‰∏Ä‰∏™2*NÁöÑÊ†ºÂ≠ê‰∏äÔºåÊØè‰∏Ä‰∏™Ê†ºÂ≠ê‰∏äÈÉΩÊúâ‰∏Ä‰∏™Á≤æÁÅµÁêÉ„ÄÇÂ∫¶Â∫¶ÁÜäÂèØ‰ª•ÈÄâÊã©‰ªªÊÑè‰∏Ä‰∏™Ê†ºÂ≠êÂºÄÂßãÊ∏∏ÊàèÔºåÊäìÊçïÊ†ºÂ≠ê‰∏äÁöÑÁ≤æÁÅµÁêÉÔºåÁÑ∂ÂêéÁßªÂä®Âà∞‰∏Ä‰∏™Áõ∏ÈÇªÁöÑËá≥Â∞ëÊúâ‰∏Ä‰∏™ÂÖ¨ÂÖ±ÁÇπÁöÑÊ†ºÂ≠ê‰∏äÁªßÁª≠ÊäìÊçï„ÄÇ‰æãÂ¶ÇÔºå(2, 2) ÁöÑÁõ∏ÈÇªÊ†ºÂ≠êÊúâ(1, 1), (2, 1) Âíå (1, 2) Á≠âÁ≠â„ÄÇ Áé∞Âú®Â∫¶Â∫¶ÁÜäÂ∏åÊúõÁü•ÈÅìÂ∞ÜÊâÄÊúâÁ≤æÁÅµÁêÉÈÉΩÊäìÂà∞Âπ∂‰∏îÊ≠•Êï∞ÊúÄÂ∞ëÁöÑÊñπÊ°àÊï∞ÁõÆ„ÄÇ‰∏§‰∏™ÊñπÊ°àË¢´ËÆ§‰∏∫ÊòØ‰∏çÂêåÔºåÂΩì‰∏î‰ªÖÂΩì‰∏§‰∏™ÊñπÊ°àËá≥Â∞ëÊúâ‰∏ÄÊ≠•ÊâÄÂú®ÁöÑÊ†ºÂ≠êÊòØ‰∏çÂêåÁöÑ„ÄÇ Input Á¨¨‰∏ÄË°å‰∏∫TÔºåË°®Á§∫ËæìÂÖ•Êï∞ÊçÆÁªÑÊï∞„ÄÇ ÊØèÁªÑÊï∞ÊçÆÂåÖÂê´‰∏Ä‰∏™Êï∞N„ÄÇ ‚óè1‚â§T‚â§100 ‚óè1‚â§N‚â§10000 Output ÂØπÊØèÁªÑÊï∞ÊçÆËæìÂá∫ÊñπÊ°àÊï∞ÁõÆÔºåÁªìÊûúÂØπ 1 000 000 007 ÂèñÊ®°„ÄÇ Sample Input 12343123 Sample Output 12322496 ÂàÜÊûê DP[i][0]Ôºö‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫iÁöÑÂõæ‰ªéÂ∑¶‰∏äËßíÂá∫ÂèëÔºåÊâÄÊúâÁöÑÊñπÊ°àÊï∞„ÄÇ DP[i][1]Ôºö‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫iÁöÑÂõæ‰ªéÂ∑¶‰∏äËßíÂá∫ÂèëÂõûÂà∞Â∑¶‰∏ãËßíÁöÑÊñπÊ°àÊï∞„ÄÇ ÂàôÊòæÁÑ∂Ë¶ÅÂõûÂà∞‰∏ãÈù¢ÂàôÔºå‰ªéÁ¨¨‰∏Ä‰∏™ÁÇπÂá∫ÂèëËøõÂÖ•[i - 1]ÁöÑÂâ©‰ΩôÈÉ®ÂàÜÊúâ‰∏§ÁßçËµ∞Ê≥ïÔºåÂç≥ dp[i][1] = 2 * dp[i - 1][0] Â¶ÇÊûú‰∏çË¶ÅÊ±ÇÂõûÂà∞Â∑¶‰∏ãËßíÔºåÂàô dp[i][0] = ((dp[i - 1][1] + dp[i - 1][0] + dp[i - 2][0] * 2 ) * 2 ÂÖ∂‰∏≠ÊØè‰∏ÄÈ°πÁöÑÊÑè‰πâÔºö dp[i - 1][1]:ÂÖàÂêëÂè≥Ëµ∞ÔºåÊúÄÂêéÂõûÂà∞Â∑¶‰∏ãËßí dp[i - 1][0]:ÂÖàÂêë‰∏ãËµ∞ÔºåÁÑ∂ÂêéËµ∞Ââ©‰∏ãÁöÑÂè≥ËæπÂâ©‰ΩôÈÉ®ÂàÜ dp[i - 2][0]:ÂÖàÂú®ÊúÄÂºÄÂßãÁöÑÁî∞Â≠óÊ†ºÈáåËµ∞‰∏Ä‰∏™ÂèâÔºå‰∫§ÂèâÁöÑËµ∞ÂÆåÁî∞Â≠óÊ†ºÔºåÁÑ∂ÂêéËµ∞Ââ©‰∏ãÁöÑÈÉ®ÂàÜ„ÄÇ ÊúÄÂêéÁªüËÆ°Á≠îÊ°àÊó∂ÔºåÊûö‰∏æËµ∑ÁÇπÁÑ∂ÂêéÊääÂõæÂàÜÊàêÂ∑¶Âè≥‰∏§ÈÉ®ÂàÜÔºåÂ∞±ÂèØ‰ª•Áî®dpÈáåÁöÑÊï∞ÂÄºÊù•ÁªüËÆ°Á≠îÊ°à„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstring&gt;const long long int MOD = 1e9 + 7;const int MAXN = 1e4 + 10;long long int dp[MAXN][2];int main(void) &#123; dp[1][0] = 1; dp[1][1] = 1; dp[2][0] = 6; dp[2][1] = 2; for(int i = 3; i &lt; MAXN; i++) &#123; dp[i][1] = dp[i - 1][1] * 2 % MOD; dp[i][0] = (((dp[i - 1][1] + dp[i - 1][0]) % MOD + dp[i - 2][0] * 2 % MOD) % MOD) * 2 % MOD; &#125; int t, n; scanf("%d", &amp;t); while(t--) &#123; scanf("%d", &amp;n); if(n == 1) &#123; printf("2\n"); continue; &#125; long long int ans = dp[n][0]; for(int i = 2; i &lt; n; i++) &#123; ans = (ans + (dp[i][1] * dp[n - i][0] % MOD + dp[n - i + 1][1] * dp[i - 1][0] % MOD) % MOD) % MOD; &#125; ans = (ans * 4) % MOD; printf("%I64d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6134-Battlestation-Operational]]></title>
    <url>%2F2017%2F08%2F25%2FHDU6134-Battlestation-Operational%2F</url>
    <content type="text"><![CDATA[ËΩ¨ËΩΩÈìæÊé•Ôºöhttp://blog.csdn.net/v5zsq/article/details/77338191 È¢òÁõÆÈìæÊé• È¢òÁõÆ Problem Description The Death Star, known officially as the DS-1 Orbital Battle Station, also known as the Death Star I, the First Death Star, Project Stardust internally, and simply the Ultimate Weapon in early development stages, was a moon-sized, deep-space mobile battle station constructed by the Galactic Empire. Designed to fire a single planet-destroying superlaser powered by massive kyber crystals, it was the pet project of the Emperor, Darth Vader, and its eventual commander Grand Moff Wilhuff Tarkin to expound the military philosophy of the aptly named Tarkin Doctrine. ‚Äî Wookieepedia In the story of the Rogue One, the rebels risked their lives stolen the construction plan of the Death Star before it can cause catastrophic damage to the rebel base. According to the documents, the main weapon of the Death Star, the Superlaser, emits asymmetric energy in the battlefield that cause photons to annihilate and burns everything in a single shot. You are assigned the task to estimate the damage of one shot of the Superlaser. Assuming that the battlefield is an n√ón grid. The energy field ignited by the Superlaser is asymmetric over the grid. For the cell at i-th row and j-th column, ‚åài/j‚åâ units of damage will be caused. Furthermore, due to the quantum effects, the energies in a cell cancel out if gcd(i,j)‚â†1 or i&lt;j. The figure below illustrates the damage caused to each cell for n=100. A cell in black indicates that this cell will not be damaged due to the quantum effects. Otherwise, different colors denote different units of damages. img Your should calculate the total damage to the battlefield. Formally, you should compute f(n)=‚àëi=1n‚àëj=1i‚åàij‚åâ[(i,j)=1], where [(i,j)=1] evaluates to be 1 if gcd(i,j)=1, otherwise 0. Input There are multiple test cases. Each line of the input, there is an integer n (1‚â§n‚â§106), as described in the problem. There are up to 104 test cases. Output For each test case, output one integer in one line denoting the total damage of the Superlaser, f(n) mod 109+7. Sample Input 12341 2310 Sample Output 1234138110 ÂàÜÊûê img ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 1000005#define mod 1000000007typedef long long ll;int prime[maxn],mu[maxn],euler[maxn],res,d[maxn],temp[maxn];void Moblus(int n=1000000)&#123; mu[1]=euler[1]=d[1]=1; res=0; for(int i=2;i&lt;=n;i++) &#123; if(!temp[i]) &#123; prime[res++]=i; mu[i]=-1; euler[i]=i-1; temp[i]=i; d[i]=2; &#125; for(int j=0;j&lt;res&amp;&amp;i*prime[j]&lt;=n;j++) &#123; if(i%prime[j]==0) &#123; mu[i*prime[j]]=0; euler[prime[j]*i]=euler[i]*prime[j]; temp[i*prime[j]]=temp[i]*prime[j]; d[i*prime[j]]=d[i/temp[i]]*(d[temp[i]]+1); break; &#125; mu[i*prime[j]]=-mu[i]; euler[prime[j]*i]=euler[i]*(prime[j]-1); temp[i*prime[j]]=prime[j]; d[i*prime[j]]=2*d[i]; &#125; &#125;&#125;void inc(int &amp;x,int y)&#123; x=x+y&gt;=mod?x+y-mod:x+y;&#125;void dec(int &amp;x,int y)&#123; x=x-y&lt;0?x-y+mod:x-y;&#125;int ans[maxn];void init(int n=1000000)&#123; for(int i=1;i&lt;=n;i++) for(int j=i;j&lt;=n;j+=i) if(mu[j/i]==-1)dec(ans[j],d[i]); else if(mu[j/i]==1)inc(ans[j],d[i]); for(int i=1;i&lt;=n;i++) inc(ans[i],euler[i]),dec(ans[i],1),inc(ans[i],ans[i-1]);&#125;int main()&#123; Moblus(); for(int i=2;i&lt;=1000000;i++)d[i]+=d[i-1]; init(); int n; while(~scanf("%d",&amp;n)) printf("%d\n",ans[n]); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Êï∞Â≠¶</tag>
        <tag>Ëé´ÊØî‰πåÊñØÂèçÊºî</tag>
        <tag>ÁßØÊÄßÂáΩÊï∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6107-Typesetting]]></title>
    <url>%2F2017%2F08%2F14%2FHDU6107-Typesetting%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ Problem Description Yellowstar is writing an article that contains N words and 1 picture, and the i-th word contains ai characters. The page width is fixed to W characters. In order to make the article look more beautiful, Yellowstar has made some rules: The fixed width of the picture is pw. The distance from the left side of the page to the left side of the photo fixed to dw, in other words, the left margin is dw, and the right margin is W - pw - dw. The photo and words can't overlap, but can exist in same line. The relative order of words cannot be changed. Individual words need to be placed in a line. If two words are placed in a continuous position on the same line, then there is a space between them. Minimize the number of rows occupied by the article according to the location and height of the image. However, Yellowstar has not yet determined the location of the picture and the height of the picture, he would like to try Q different locations and different heights to get the best look. Yellowstar tries too many times, he wants to quickly know the number of rows each time, so he asked for your help. It should be noted that when a row contains characters or pictures, the line was considered to be occupied. Input The first line of the input gives the number of test cases T; T test cases follow. Each case begins with one line with four integers N, W, pw, dw : the number of words, page width, picture width and left margin. The next line contains N integers ai, indicates i-th word consists of ai characters. The third line contains one integer Q. Then Q lines follow, each line contains the values of xi and hi, indicates the starting line and the image height of the image. Limits T‚â§10 1‚â§N,W,Q‚â§105 1‚â§pw,ai‚â§W 0‚â§dw‚â§W‚àípw Output For each query, output one integer denotes the minimum number of rows. Sample Input 123456789101122 7 4 31 331 22 25 23 8 2 31 1 311 1 Sample Output 12342331 ÂàÜÊûê Âú®Âõ∫ÂÆöÊüê‰∏™ÂÆΩÂ∫¶ÁöÑÂâçÊèê‰∏ãÔºåÈ¢ÑÂ§ÑÁêÜ‰ª•Á¨¨i‰∏™ÂçïËØçÂºÄÂßãÔºå‰∏ÄË°åÂÜÖÊúÄÂ§öËÉΩÊîæÁΩÆÁöÑÂçïËØç‰∏™Êï∞„ÄÇÂõ†‰∏∫È°µÈù¢ÂÆΩÂ∫¶ÔºåÂõæÁâáÁöÑÂ∑¶Âè≥ËæπË∑ùÈÉΩÂõ∫ÂÆö‰∫ÜÔºåÊâÄ‰ª•Âè™Ë¶ÅÈ¢ÑÂ§ÑÁêÜËøô3ÁßçÂÆΩÂ∫¶„ÄÇÁî®\(f_{i,j}\)Ë°®Á§∫‰ªéÁ¨¨i‰∏™ÂçïËØçÂºÄÂßãÔºåÂç†Áî®\(2^j\)Ë°åËÉΩÊîæÁΩÆÁöÑÊúÄÂ§ßÂçïËØç‰∏™Êï∞„ÄÇÂõæÁâáÊúÄÂ§öÂ∞Ün‰∏™ÂçïËØçÂàíÂàÜÊàê3ÈÉ®ÂàÜÔºåÊØèÈÉ®ÂàÜÈÉΩ‰ΩøÁî®ÂÄçÂ¢ûÂç≥ÂèØÂÆåÊàêÂø´ÈÄüÊü•ËØ¢„ÄÇ‰∏∫‰∫ÜÊñπ‰æøÔºåÂèØ‰ª•Ê∑ªÂä†Á¨¨n+1‰∏™ÂçïËØçÔºåÂçïËØçÈïøÂ∫¶Â§ß‰∫éÈ°µÈù¢ÂÆΩÂ∫¶‰∏îËØ•ÂçïËØç‰∏çÂç†ÊçÆË°å„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ O((n+q)log(n) ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/** @Author: sun000* @Date: 2017-08-11 13:14:44* @Last Modified by: sun000* @Last Modified time: 2017-08-11 20:00:59*/#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAXN = 1e5 + 10;int n, w, pw, dw;int dp[3][MAXN][19];int l[MAXN], b[20];void init() &#123; memset(dp, 0, sizeof(dp)); int pl = 0, pr = 0, len = 0; for (; pl &lt; n; pl++) &#123; for(;pr &lt; n; pr++) &#123; if(len + l[pr] &gt; w + 1) break; else len += l[pr]; &#125; //printf("$$ %d %d %d\n", pl, pr, len); dp[0][pl][0] = pr - pl; len -= l[pl]; &#125; pl = 0, pr = 0, len = 0; for (; pl &lt; n; pl++) &#123; for(;pr &lt; n; pr++) &#123; if(len + l[pr] &gt; dw + 1) break; else len += l[pr]; &#125; //printf("$$ %d %d %d\n", pl, pr, len); dp[1][pl][0] = pr - pl; len -= l[pl]; &#125; pl = 0, pr = 0, len = 0; for (; pl &lt; n; pl++) &#123; for(;pr &lt; n; pr++) &#123; if(len + l[pr] &gt; w - dw - pw + 1) break; else len += l[pr]; &#125; //printf("$$ %d %d %d\n", pl, pr, len); dp[2][pl][0] = pr - pl; len -= l[pl]; &#125; for(int i = 0; i &lt; n; i++) dp[1][i][0] = dp[1][i][0] + dp[2][ i + dp[1][i][0] ][0]; for (int j = 1; j &lt; 18; j++) &#123; for (int i = 0; i &lt; n; i++) &#123; dp[0][i][j] = dp[0][i][j - 1] + dp[0][i + dp[0][i][j - 1]][j - 1]; dp[1][i][j] = dp[1][i][j - 1] + dp[1][i + dp[1][i][j - 1]][j - 1]; &#125; &#125;&#125;int query(int x, int h) &#123; int ret = 0, ans = 0; int tx = x, tl = 0; while (tx) &#123; if (tx &amp; 1) ret += dp[0][ret][tl]; tx &gt;&gt;= 1; tl++; &#125; if (ret &gt;= n) &#123; ret = 0; while (ret &lt; n) &#123; for (int i = 1; i &lt; 17; i++) &#123; if (dp[0][ret][i] == dp[0][ret][i + 1]) &#123; ans += b[i - 1]; ret += dp[0][ret][i - 1]; break; &#125; &#125; &#125; return ans + h; &#125; tx = h, tl = 0; while (tx) &#123; if (tx &amp; 1) ret += dp[1][ret][tl]; tx &gt;&gt;= 1; tl++; &#125; ans = x + h; if (ret &gt;= n) return ans; while (ret &lt; n) &#123; for (int i = 1; i &lt; 17; i++) &#123; if (dp[0][ret][i] == dp[0][ret][i + 1]) &#123; ans += b[i - 1]; ret += dp[0][ret][i - 1]; break; &#125; &#125; &#125; return ans;&#125;int main(void) &#123; // freopen("in.txt", "r", stdin); // freopen("out.txt", "w", stdout); b[0] = 1; for (int i = 1; i &lt; 20; i++) b[i] = b[i - 1] &lt;&lt; 1; int t, q, x, h; scanf("%d", &amp;t); while (t--) &#123; memset(dp, 0, sizeof(dp)); scanf("%d%d%d%d", &amp;n, &amp;w, &amp;pw, &amp;dw); for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;l[i]); l[i]++; &#125; init(); scanf("%d", &amp;q); for (int i = 0; i &lt; q; i++) &#123; scanf("%d%d", &amp;x, &amp;h); printf("%d\n", query(x - 1, h)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>ÂÄçÂ¢ûÊ≥ï</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6103-Kirinriki]]></title>
    <url>%2F2017%2F08%2F14%2FHDU6103-Kirinriki%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ Problem Description We define the distance of two strings A and B with same length n is \(dis(A,B)=\sum_{i=0}^{(n‚àí1)}{|A_i‚àíB_{n‚àí1‚àíi}|}\) The difference between the two characters is defined as the difference in ASCII. You should find the maximum length of two non-overlapping substrings in given string S, and the distance between them are less then or equal to m. Input The first line of the input gives the number of test cases T; T test cases follow. Each case begins with one line with one integers m : the limit distance of substring. Then a string S follow. Limits T‚â§100 0‚â§m‚â§5000 Each character in the string is lowercase letter, 2‚â§|S|‚â§5000 ‚àë|S|‚â§20000 Output For each test case output one interge denotes the answer : the maximum length of the substring. Sample Input 12315abcdefedcb Sample Output 123455Hint[0, 4] abcde[5, 9] fedcbThe distance between them is abs(&apos;a&apos; - &apos;b&apos;) + abs(&apos;b&apos; - &apos;c&apos;) + abs(&apos;c&apos; - &apos;d&apos;) + abs(&apos;d&apos; - &apos;e&apos;) + abs(&apos;e&apos; - &apos;f&apos;) = 5 ÂàÜÊûê ÂÆπÊòìÂæóÂà∞ÂèñÂá∫ÁöÑÂ≠ó‰∏≤ÊòØ‰∏Ä‰∏™ÂõûÊñá‰∏≤ÔºåÂΩìÂõûÊñá‰∏≤ÁöÑÂØπÁß∞ËΩ¥Âõ∫ÂÆöÁöÑÊó∂ÂÄôÔºåËÆ°ÁÆóÂá∫ÊúâÂ§öÂ∞ëÊª°Ë∂≥Êù°‰ª∂ÁöÑÂõûÊñá‰∏≤ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶ÊòØO(n)ÁöÑÔºöÂè™Ë¶ÅÁª¥Êä§Âõõ‰∏™ÊåáÈíàÔºåÂ∑¶Âè≥ÂêÑ‰∏§‰∏™ÔºåÊåáÈíàÂè™‰ºöÂæÄÂ§ñÁßªÂä®ÔºåËã•Êª°Ë∂≥Êù°‰ª∂ÔºåÂàôÂ§ñÊåáÈíàÂæÄÂ§ñÁßªÂä®ÔºåÂê¶ÂàôÂÜÖËÑÇÈíàÂêëÂ§ñÁßªÂä®‰∏ÄÁõ¥Âà∞Êª°Ë∂≥Êù°‰ª∂‰∏∫Ê≠¢ÔºåÈÇ£‰πàÊÄªÁöÑÊó∂Èó¥Â§çÊùÇÁöÑÊòØ\(O(n^2)\)ÁöÑ„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** @Author: sun000* @Date: 2017-08-11 11:24:20* @Last Modified by: sun000 * @Last Modified time: 2017-08-11 11:41:25*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;char str[5010];int dis(char a, char b) &#123; int d = a - b; if(d &lt; 0) d = -d; return d;&#125;int main(void) &#123; int t, m; scanf("%d", &amp;t); while(t--) &#123; scanf("%d", &amp;m); scanf("%s", str); int len = strlen(str); int ls, le, rs, re; int ans = 0; for(int mid = 0; mid &lt; len; mid++) &#123; ls = le = mid, rs = re = mid + 1; int d = 0; for(;le &gt;= 0 &amp;&amp; re &lt; len; le--, re++) &#123; d += dis(str[le], str[re]); while(d &gt; m) &#123; d -= dis(str[ls], str[rs]); ls--; rs++; &#125; ans = max(ans, re - rs + 1); &#125; ls = le = mid - 1, rs = re = mid + 1; d = 0; for(;le &gt;= 0 &amp;&amp; re &lt; len; le--, re++) &#123; d += dis(str[le], str[re]); while(d &gt; m) &#123; d -= dis(str[ls], str[rs]); ls--; rs++; &#125; ans = max(ans, re - rs + 1); &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Êö¥Âäõ</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6053-TrickGCD]]></title>
    <url>%2F2017%2F08%2F14%2FHDU6053-TrickGCD%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ Problem Description You are given an array A , and Zhu wants to know there are how many different array B satisfy the following conditions? 1‚â§Bi‚â§Ai For each pair( l , r ) (1‚â§l‚â§r‚â§n) , gcd(bl,bl+1...br)‚â•2 Input The first line is an integer T(1‚â§T‚â§10) describe the number of test cases. Each test case begins with an integer number n describe the size of array A. Then a line contains n numbers describe each element of A You can assume that 1‚â§n,Ai‚â§105 Output For the kth test case , first output &quot;Case #k: &quot; , then output an integer as answer in a single line . because the answer may be large , so you are only need to output answer mod 109+7 Sample Input 123144 4 4 4 Sample Output 1Case #1: 17 ÂàÜÊûê Êûö‰∏ægcdÁÑ∂ÂêéÁî®Ëé´ÊØî‰πåÊñØÂèçÊºîÊù•ËÆ°ÁÆó„ÄÇ ËÆæ: ‚Äã f(d): gcdÊòØdÊó∂ÁöÑÊñπÊ°àÊï∞Èáè ‚Äã F(n): gcdÊòØnÁöÑÂÄçÊï∞ÁöÑÊñπÊ°àÊï∞Èáè Âàô \[F(n)=\sum_{d|n}f(d) \\f(n)=\sum_{d|n}\mu(d)F(\frac{n}{d})\\f(n)=\sum_{d|n}\mu(\frac{n}{d})F(n)\] ÈÇ£‰πàÈóÆÈ¢òÂ∞±ÂèòÊàê‰∫ÜÂ¶Ç‰ΩïÂø´ÈÄüÁöÑÊ±ÇÂá∫F(n) ‚Äã \[F(n) = \sum_{i=1}^{n}{Ai/n}\] ÂÆπÊòìÁúãÂá∫ËøôÊ†∑ËÆ°ÁÆóFÁöÑÂ§çÊùÇÂ∫¶ÊòØ\(O(n^2)\)ÁöÑÔºåËøôÈúÄË¶Å‰ºòÂåñ„ÄÇ Êàë‰ª¨Áî®‰∏Ä‰∏™preÊ†áËÆ∞ÔºåÂ¶ÇÊûúÊúâ‰∏Ä‰∏™Êï∞tmpÂàôpre[tmp]++,ÊúÄÂêéÂ§ÑÁêÜÊàêÂâçÁºÄÂíåÁöÑÂΩ¢Âºèpre[i] += pre[i - 1]„ÄÇ ÈÇ£‰πàpre[i]Â∞±Ë°®Á§∫iÂèäÂÖ∂‰πãÂâçÂá∫Áé∞‰∫ÜÂá†‰∏™Êï∞Â≠ó„ÄÇÈÇ£‰πàÊàë‰ª¨Êûö‰∏æF(n)ÈáågcdÊòØnÁöÑÂÄçÊï∞ÁöÑËøô‰∏™‚ÄúÂÄçÊï∞k‚ÄùÂàô\(F(n)=\sum{k^{pre[(k+1)*n-1]-pre[k*n-1]}}‚Äã\) ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** @Author: sun000* @Date: 2017-08-07 16:13:26* @Last Modified by: sun000* @Last Modified time: 2017-08-07 17:09:34*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 2e5 + 10;const int INF = 0x3f3f3f3f;const long long int MOD = 1e9 + 7;int U[MAXN];void mobus()&#123; bool mark[MAXN]; int prime[MAXN]; int pcnt = 0; memset(mark, 0, sizeof(mark)); U[1] = 1; for (int i = 2; i &lt; MAXN; i++) &#123; if (mark[i] == 0) &#123; prime[pcnt++] = i; U[i] = -1; &#125; for (int j = 0; j &lt; pcnt &amp;&amp; i * prime[j] &lt; MAXN; j++) &#123; int tmp = i * prime[j]; mark[tmp] = 1; if (i % prime[j] == 0) &#123; U[tmp] = 0; break; &#125; U[tmp] = -U[i]; &#125; &#125;&#125;long long int pre[MAXN], F[MAXN];long long int q_pow(long long int a, int b) &#123; long long int ans = 1, temp = a; while (b) &#123; if (b &amp; 1) ans = ans * temp % MOD; temp = temp * temp % MOD; b &gt;&gt;= 1; &#125; return ans;&#125;int main(void) &#123; //freopen("in.txt", "r", stdin); //freopen("out.txt", "w", stdout); int t, n, temp; mobus(); scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; cas++) &#123; memset(pre, 0, sizeof(pre)); scanf("%d", &amp;n); int mi = INF, ma = -INF; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;temp); mi = min(mi, temp); ma = max(ma, temp); pre[temp]++; &#125; for (int i = 1; i &lt; MAXN; i++) pre[i] += pre[i - 1]; for (int d = 1; d &lt;= mi; d++) &#123; F[d] = 1; for (int k = 1; k &lt;= ma / d; k++) F[d] = (F[d] * q_pow((long long int)k, pre[(k + 1) * d - 1] - pre[k * d - 1])) % MOD; &#125; long long int ans = 0; for(int d = 2; d &lt;= mi; d++) for(int num = 1; num * d &lt;= ma; num++) ans = (ans + (long long int)U[num] * F[d * num] % MOD) % MOD; printf("Case #%d: %lld\n", cas, ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Êï∞Â≠¶</tag>
        <tag>Ëé´ÊØî‰πåÊñØÂèçÊºî</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6050 Funny Function]]></title>
    <url>%2F2017%2F08%2F08%2FHDU6050-Funny-Function%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ Problem Description Function Fx,ysatisfies: For given integers N and M,calculate Fm,1 modulo 1e9+7. Input There is one integer T in the first line. The next T lines,each line includes two integers N and M . 1&lt;=T&lt;=10000,1&lt;=N,M&lt;2^63. Output For each given N and M,print the answer in a single line. Sample Input 12322 23 3 Sample Output 12233 ÂàÜÊûê ËøôÊòØ‰∏Ä‰∏™Êï∞Â≠¶Êé®ÂØºÈ¢òÔºåÈ¶ñÂÖà‰∏çÈöæÂèëÁé∞ÂØπ‰∫éÊØè‰∏Ä‰∏™iÈÉΩÊúâ\(F_{i,j}=F_{i,j-1}+2*F_{i,j-2}\)Âàô\(F_{i,j}+F_{i,j-1}=2*(F_{i,j-1}+F_{i,j-2})\)Âç≥ \[ F_{i,j}+F_{i,j-1}=4*(F_{i,j-2}+F_{i,j-3}) \] ÂàôÂØπ‰∫éÊØè‰∏ÄË°åÔºåÊØè‰∏§‰∏™ËøûÁª≠ÁöÑ‰∏§È°πÁúãÊàê‰∏ÄÈ°πÔºåÈÇ£‰πàÁé∞Âú®ÂØπ‰∫énÊàë‰ª¨ÂàÜÂ•áÂÅ∂Êù•ËÄÉËôëÔºåÈ¶ñÂÖàËÄÉËôë ÂΩìn‰∏∫ÂÅ∂Êï∞Êó∂ \[F_{i,1}=\sum_{k=1}^{n}{F_{i-1,k}} = F_{i-1,1}+F_{i-1,2}+‚Ä¶‚Ä¶F_{i-1,n-1}+F_{i-1,n}\] \[=\left(F_{i-1,1}+F_{i-1,2}\right)+4*\left(F_{i-1,1}+F_{i-1,2}\right)‚Ä¶‚Ä¶+4^{\frac{n}{2}-1}*\left(F_{i-1,1}+F_{i-1,2}\right)\] ‚Äã \[=\frac{2^n- 1}{3}*F_{i-1,1}+\frac{2^n- 1}{3}*F_{i-1,2}\] ‚Äã \[F_{i,2}=\sum_{k=2}^{n+1}{F_{i-1,k}}=F_{i-1,2}+F_{i-1,3}+‚Ä¶‚Ä¶F_{i-1,n}+F_{i-1,n+1}\] ‚Äã \[=\left(F_{i-1,2}+F_{i-1,3}\right)+4*\left(F_{i-1,2}+F_{i-1,3}\right)‚Ä¶‚Ä¶+4^{\frac{n}{2}-1}*\left(F_{i-1,2}+F_{i-1,3}\right)\] ‚Äã \[=\frac{2^n-1}{3}*\left(F_{i-1,2}+F_{i-1,3}\right)=\frac{2*\left(2^n-1\right)}{3}*F_{i-1,1}+\frac{2*\left(2^n-1\right)}{3}*F_{i-1,2}\] ÂΩìn‰∏∫Â•áÊï∞Êó∂ \[F_{i,1}=\sum_{k=1}^{n}{F_{i-1,k}} = F_{i-1,1}+F_{i-1,2}+‚Ä¶‚Ä¶F_{i-1,n-1}+F_{i-1,n}\] ‚Äã \[=F_{i-1,1}+\left(F_{i-1,2}+F_{i-1,3}\right)+4*\left(F_{i-1,2}+F_{i-1,3}\right)‚Ä¶‚Ä¶+4^{\frac{n-1}{2}-1}*\left(F_{i-1,2}+F_{i-1,3}\right)\] ‚Äã \[=F_{i-1,1}+\left(F_{i-1,2}+F_{i-1,3}\right)\frac{2^{n-1}-1}{3}=F_{i-1,1}+\left(F_{i-1,1}+F_{i-1,2}\right)\frac{2^n-2}{3}\] ‚Äã \[=\frac{2^n+1}{3}*F_{i-1,1}+\frac{2^n-2}{3}*F_{i-1,2}\] ‚Äã \[F_{i,2}=\sum_{k=2}^{n+1}{F_{i-1,k}}=F_{i-1,2}+F_{i-1,3}+‚Ä¶‚Ä¶F_{i-1,n}+F_{i-1,n+1}\] ‚Äã \[=F_{i-1,2}+\left(F_{i-1,3}+F_{i-1,4}\right)+4*\left(F_{i-1,3}+F_{i-1,4}\right)‚Ä¶‚Ä¶+4^{\frac{n-1}{2}-1}*\left(F_{i-1,3}+F_{i-1,4}\right)\] ‚Äã \[=F_{i-1,2}+\left(F_{i-1,3}+F_{i-1,4}\right)\frac{2^{n-1}-1}{3}=F_{i-1,2}+\left(F_{i-1,1}+F_{i-1,2}\right)\frac{2^{n+1}-4}{3}\] ‚Äã \[=\frac{2^{n+1}-4}{3}*F_{i-1,1}+\frac{2^{n+1}-1}{3}*F_{i-1,2}\] ËøôÊ†∑Â∞±ÂèØ‰ª•Áî®Áü©ÈòµÂø´ÈÄüÂπÇÂú®o(log(n))ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏ãÊ±ÇËß£‰∫Ü„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** @Author: sun000* @Date: 2017-08-07 12:38:12* @Last Modified by: sun000 * @Last Modified time: 2017-08-07 13:41:28*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const long long int mod = 1e9 + 7;const long long int inv3 = 333333336;//Èô§3ÂèñÊ®°Ë¶ÅÊ±ÇÈÄÜÂÖÉstruct MAT&#123; int r, c; long long int mx[2][2]; MAT()&#123;&#125; MAT(int rr = 0, int cc = 0):r(rr),c(cc)&#123;&#125; friend MAT operator *(MAT ta, MAT tb)&#123; MAT tc(ta.r, tb.c); for(int i = 0; i &lt; tc.r; i++) for(int j = 0; j &lt; tc.c; j++)&#123; tc.mx[i][j] = 0; for(int k = 0; k &lt; tb.r; k++) tc.mx[i][j] = (tc.mx[i][j] + ta.mx[i][k] * tb.mx[k][j] % mod) % mod; &#125; return tc; &#125; friend MAT operator ^(MAT ta, long long int num)&#123; MAT ret(ta.r, ta.c); memset(ret.mx, 0, sizeof(ret.mx)); for(int i = 0; i &lt; ta.r; i++) ret.mx[i][i] = 1; while(num)&#123; if(num &amp; 1) ret = ta * ret; num &gt;&gt;= 1; ta = ta * ta; &#125; return ret; &#125;&#125;;long long int q_pow(long long int a, long long int b) &#123; long long int ans = 1, temp = a; while(b) &#123; if(b &amp; 1) ans = (ans * temp) % mod; temp = (temp * temp) % mod; b &gt;&gt;= 1; &#125; return ans;&#125;MAT getMAT(long long int n) &#123; if(n == 1) return 1; MAT m(2, 2); if(n &amp; 1) &#123; m.mx[0][0] = (q_pow(2, n) + 1) * inv3 % mod; m.mx[0][1] = (((q_pow(2, n + 1) - 4 ) * inv3 % mod) + mod) % mod; m.mx[1][0] = (((q_pow(2, n) - 2) * inv3 % mod) + mod) % mod; m.mx[1][1] = (((q_pow(2, n + 1) - 1) * inv3 % mod) + mod) % mod; &#125;else &#123; m.mx[0][0] = m.mx[1][0] = ((q_pow(2, n) - 1) * inv3 % mod + mod) % mod; m.mx[0][1] = m.mx[1][1] = (((q_pow(2, n) - 1) * 2 % mod) * inv3 % mod + mod) % mod; &#125; //printf("-----\n%lld %lld\n%lld %lld\n-----\n", m.mx[0][0], m.mx[0][1], m.mx[1][0], m.mx[1][1]); //getchar(); return m;&#125;long long int solve(long long int n, long long int m) &#123; MAT s(2, 2); MAT g(2, 2); g = getMAT(n); s.mx[0][0] = s.mx[0][1] = 1; s.mx[1][0] = s.mx[1][1] = 0; MAT ans = s * (g ^ (m - 1)); return ans.mx[0][0];&#125;int main(void) &#123; // freopen("in.txt", "r", stdin); // freopen("out.txt", "w", stdout); int t; long long int n, m; scanf("%d", &amp;t); while(t--) &#123; scanf("%lld%lld", &amp;n, &amp;m); printf("%lld\n", solve(n, m)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Êï∞Â≠¶</tag>
        <tag>Áü©ÈòµÂø´ÈÄüÂπÇ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6044 Limited Permutation]]></title>
    <url>%2F2017%2F07%2F26%2FHDU6044-Limited-Permutation%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ Problem Description As to a permutation p1,p2,‚ãØ,pn from 1 to n, it is uncomplicated for each 1‚â§i‚â§n to calculate (li,ri) meeting the condition that min(pL,pL+1,‚ãØ,pR)=pi if and only if li‚â§L‚â§i‚â§R‚â§ri for each 1‚â§L‚â§R‚â§n. Given the positive integers n, (li,ri) (1‚â§i‚â§n), you are asked to calculate the number of possible permutations p1,p2,‚ãØ,pn from 1 to n, meeting the above condition. The answer may be very large, so you only need to give the value of answer modulo 109+7. Input The input contains multiple test cases. For each test case: The first line contains one positive integer n, satisfying 1‚â§n‚â§106. The second line contains n positive integers l1,l2,‚ãØ,ln, satisfying 1‚â§li‚â§i for each 1‚â§i‚â§n. The third line contains n positive integers r1,r2,‚ãØ,rn, satisfying i‚â§ri‚â§n for each 1‚â§i‚â§n. It's guaranteed that the sum of n in all test cases is not larger than 3‚ãÖ106. Warm Tips for C/C++: input data is so large (about 38 MiB) that we recommend to use fread() for buffering friendly. 1size_t fread(void *buffer, size_t size, size_t count, FILE *stream); // reads an array of count elements, each one with a size of size bytes, from the stream and stores them in the block of memory specified by buffer; the total number of elements successfully read is returned. Output For each test case, output &quot;Case #x: y&quot; in one line (without quotes), where x indicates the case number starting from 1 and y denotes the answer of corresponding case. Sample Input 3 1 1 3 1 3 3 5 1 2 2 4 5 5 2 5 5 5 Sample Output Case #1: 2 Case #2: 3 ÂàÜÊûê Ê≥®ÊÑèÂà∞È¢òÁõÆ‰∏≠ÔºöÊúân‰∏™Âå∫Èó¥ÔºåÂØπ‰∫éÁ¨¨i‰∏™Âå∫Èó¥[li,ri]Êúâli&lt;=i&lt;=ri,ÂØπ‰∫é‰ªªÊÑè1&lt;=L&lt;=i&lt;=R&lt;=nÔºåÂΩìÂâç‰ªÖÂΩìli&lt;=L&lt;=i&lt;=R&lt;=riÊó∂P[i]=min(P[L],P[L+1],...,P[R])ÔºåÂç≥ÂØπ‰∫éP[i]‰∏ÄÂÆöÊúâP[i]&gt;P[li-1]‰∏îP[i]&gt;P[ri+1]Ôºå‰πüÂ∞±ÊòØËØ¥Âå∫Èó¥\([l_i,r_i]\)(Èô§‰∫Ü[1,n])‰∏ÄÂÆöË¢´Êüê‰∏™Âå∫Èó¥[lj,rj]ÂåÖÂê´,‰∏îj=li-1Êàñj=ri+1 Âç≥Âå∫Èó¥jÂèØÂàÜÊàê[lj,j-1]Âíå[j+1,rj]„ÄÇ Ê≥®ÊÑèÂà∞‰∏Ä‰∏™ÈùûÂ∏∏Â∑ßÂ¶ôÁöÑÁÇπÔºöÊàë‰ª¨Â∞ÜÂå∫Èó¥ÊåâÁÖßLÂçáÂ∫èÔºåRÈôçÂ∫èÁöÑÈ°∫Â∫èÊéíÂ∫èÔºöÂæóÂà∞ÁöÑËøô‰∏™Â∫èÂàóÊÅ∞Â•ΩÂ∞±ÊòØËøôÂèØÁ¨õÂç°Â∞îÊ†ëÁöÑÂÖàË∑üDFSÂ∫è ÂàôÊàë‰ª¨dfsÂæÄ‰∏ãËµ∞ÔºåÊØè‰∏Ä‰∏™Âå∫Èó¥ÂíåÁªôÂÆöÁöÑÂå∫Èó¥ÊÅ∞Â•ΩÊòØ‰∏Ä‰∏ÄÂØπÂ∫îÁöÑÔºåÂê¶ÂàôÊûÑ‰∏çÊàêÁ¨õÂç°Â∞îÊ†ëÔºåÂàôÊó†Á≠îÊ°à„ÄÇ Ëã•Â≠òÂú®‰∏ÄÊ£µÁ¨õÂç°Â∞îÊ†ëÔºà‰∏çËÉΩÁúüÁöÑÂéªÂª∫Ê†ëÔºå‰ºöÁàÜÂÜÖÂ≠òÔºåggÔºâÔºåÂàôËøôÊ£µÁ¨õÂç°Â∞îÊ†ëÊòØÂîØ‰∏ÄÁöÑ„ÄÇÊØèÊ£µÂ≠êÊ†ëÈÉΩÂü∫‰∫éÁõ∏‰ººÁöÑÂ≠êÈóÆÈ¢òÔºåÊâÄ‰ª•Êàë‰ª¨Âè™ÈúÄË¶ÅÂú®ÂêàÂπ∂Â≠êÊ†ëÊó∂ËÆ°ÁÆóÂ≠êÊ†ëÁöÑÁªÑÂêàÂç≥ÂèØ„ÄÇ‰æãÂ¶Ç u Êúâ‰∏§‰∏™ÂÑøÂ≠ê v1 Âíå v2 ÔºåÂÆÉ‰ª¨ÁöÑÂ≠êÊ†ëÂØπÂ∫îÁöÑÊñπÊ°àÊï∞ÂàÜÂà´‰∏∫ f(v1) Âíå f(v2) ÔºåÂ≠êÊ†ëÂ§ßÂ∞èÂàÜÂà´‰∏∫ s(v1) Âíå s(v2) ÔºåÂàô u ÁöÑÂ≠êÊ†ëÂØπÂ∫îÁöÑÊñπÊ°àÊï∞‰∏∫ \(f(u)=C(s(v1)+s(v2), s(v1))*f(v1)*f(v2)\) C(a, b)ÊòØÊ±ÇÁªÑÂêàÊï∞ÁöÑÊÑèÊÄùÔºåË¶ÅÂèñÊ®°ÔºåÊâÄ‰ª•Ë¶ÅÊ±ÇÈÄÜÂÖÉ„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/** @Author: sun000* @Date: 2017-07-26 20:13:20* @Last Modified by: sun000* @Last Modified time: 2017-07-26 21:58:52*/#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e6 + 10;const long long int MOD = 1e9 + 7;namespace fastIO &#123; const int MAXN = 4e7; char buf[MAXN]; int p, len;//ÊåáÂêëÂΩìÂâçËØªÂà∞ÁöÑ‰ΩçÂ≠êÁöÑÊåáÈíà void begin() &#123; p = 0; len = fread(buf, 1, MAXN, stdin); &#125; inline bool isNum(char c) &#123; if('0' &lt;= c &amp;&amp; c &lt;= '9') return true; return false; &#125; inline bool read(int &amp;t) &#123; t = 0; while(p &lt; len &amp;&amp; !isNum(buf[p])) p++; if(p &gt;= len) return false; while(isNum(buf[p])) t = t * 10 + buf[p++] -'0'; return true; &#125;&#125;int n;struct node &#123; int l, r, id; node *lson, *rson; node()&#123;&#125; node(int _l, int _r):l(_l),r(_r)&#123; lson = rson = NULL; &#125;&#125;s[MAXN], *root;bool cmp(const node &amp;a,const node &amp;b) &#123; if(a.l == b.l) return a.r &gt; b.r; return a.l &lt; b.l;&#125;int inv[MAXN];void init()&#123; inv[1] = 1; for (int i = 2; i &lt; MAXN; i++) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;&#125;long long int C(int a, int b) &#123; // printf("c(%d %d)\n", a, b); b = min(b, a - b); if(!b) return 1; long long int temp = 1; long long int B = (long long int)b; long long int A = (long long int)a; for(long long int i = 0; i &lt; B; i++) temp = (temp * (A - i) % MOD * (long long int)inv[i + 1]) % MOD; return temp;&#125;bool flag;int cnt;long long int dfs(int l, int r) &#123; if(!flag) return 0; if(l &gt; r) return 1; if(s[cnt].l == l &amp;&amp; s[cnt].r == r) &#123; node now = s[cnt++]; long long int temp = (C(now.r - now.l, now.id - now.l) * dfs(now.l, now.id - 1) % MOD) * dfs(now.id + 1, now.r) % MOD; if(temp == 0) flag = false; return temp; &#125; else &#123; flag = false; return 0; &#125;&#125;long long int solve() &#123; flag = true; cnt = 0; sort(s, s + n, cmp); return dfs(1, n);&#125;int main(void) &#123; init(); fastIO::begin(); int cas = 1; while(fastIO::read(n)) &#123; for(int i = 0; i &lt; n; i++) fastIO::read(s[i].l), s[i].id = i + 1; for(int i = 0; i &lt; n; i++) fastIO::read(s[i].r); printf("Case #%d: %lld\n", cas++, solve()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Êï∞Â≠¶</tag>
        <tag>ÂõæËÆ∫</tag>
        <tag>ÊêúÁ¥¢</tag>
        <tag>Â§öÊ†°</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6040 Hints of sd0061]]></title>
    <url>%2F2017%2F07%2F26%2FHDU6040-Hints-of-sd0061%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ Problem Description sd0061, the legend of Beihang University ACM-ICPC Team, retired last year leaving a group of noobs. Noobs have no idea how to deal with m coming contests. sd0061 has left a set of hints for them. There are n noobs in the team, the i-th of which has a rating ai. sd0061 prepares one hint for each contest. The hint for the j-th contest is a number bj, which means that the noob with the (bj+1)-th lowest rating is ordained by sd0061 for the j-th contest. The coach asks constroy to make a list of contestants. constroy looks into these hints and finds out: bi+bj‚â§bk is satisfied if bi‚â†bj, bi]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Êï∞Â≠¶</tag>
        <tag>Â§öÊ†°</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6035 Colorful Tree]]></title>
    <url>%2F2017%2F07%2F26%2FHDU6035-Colorful-Tree%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ Problem Description There is a tree with n nodes, each of which has a type of color represented by an integer, where the color of node i is ci. The path between each two different nodes is unique, of which we define the value as the number of different colors appearing in it. Calculate the sum of values of all paths on the tree that has n(n‚àí1)2 paths in total. Input The input contains multiple test cases. For each test case, the first line contains one positive integers n, indicating the number of node. (2‚â§n‚â§200000) Next line contains n integers where the i-th integer represents ci, the color of node i. (1‚â§ci‚â§n) Each of the next n‚àí1 lines contains two positive integers x,y (1‚â§x,y‚â§n,x‚â†y), meaning an edge between node x and node y. It is guaranteed that these edges form a tree. Output For each test case, output &quot;Case #x: y&quot; in one line (without quotes), where x indicates the case number starting from 1 and y denotes the answer of corresponding case. Sample Input 3 1 2 1 1 2 2 3 6 1 2 1 3 2 1 1 2 1 3 2 4 2 5 3 6 Sample Output Case #1: 6 Case #2: 29 ÂàÜÊûê ‚Äã ÂçïÁã¨ËÄÉËôëÊØè‰∏ÄÁßçÈ¢úËâ≤ÔºåÁ≠îÊ°àÂ∞±ÊòØÂØπ‰∫éÊØèÁßçÈ¢úËâ≤Ëá≥Â∞ëÁªèËøá‰∏ÄÊ¨°ËøôÁßçÁöÑË∑ØÂæÑÊù°Êï∞‰πãÂíå„ÄÇÂèçËøáÊù•ÊÄùËÄÉÂè™ÈúÄË¶ÅÊ±ÇÊúâÂ§öÂ∞ëÊù°Ë∑ØÂæÑÊ≤°ÊúâÁªèËøáËøôÁßçÈ¢úËâ≤Âç≥ÂèØ„ÄÇÁõ¥Êé•ÂÅöÂèØ‰ª•ÈááÁî®ËôöÊ†ëÁöÑÊÄùÊÉ≥Ôºà‰∏çÁî®ÁúüÊ≠£Âª∫Âá∫Êù•ÔºâÔºåÂØπÊØèÁßçÈ¢úËâ≤ÁöÑÁÇπÊåâÁÖß dfs Â∫èÂàóÊéí‰∏™Â∫èÔºåÂ∞±ËÉΩÊ±ÇÂá∫Ëøô‰∫õÁÇπÊääÂéüÊù•ÁöÑÊ†ëÂàíÂàÜÊàêÁöÑÂùóÁöÑÂ§ßÂ∞è„ÄÇËøô‰∏™ËøáÁ®ãÂÆûÈôÖ‰∏äÂèØ‰ª•Áõ¥Êé•‰∏ÄÊ¨° dfs Ê±ÇÂá∫„ÄÇ Ëøô‰∫õÈÉΩÊòØÂÆòÊñπÈ¢òËß£ÔºåÂÖ∂ÂÆûÊàëÂ∞±ÊòØDFSÁûéËÆ∞ÂΩï‰∫Ü‰∏Ä‰∫õÂÄºÊêû‰∫ÜÈ´òÂ∞±Â•Ω‰∫ÜÔºåÁúã‰ª£Á†ÅÂ∞±ËÉΩÁúãÊáÇÔºåÈÉΩÊúâÊ≥®Èáä„ÄÇÂíåÂÆòÊñπÈ¢òËß£‰∏ÄÊ†∑ËΩ¨ÂåñÔºåÊ±ÇÂèçÈù¢ÁöÑË∑ØÂæÑÊï∞ÈáèÔºåÊ±ÇÊ≥ïÂ¶Ç‰ª£Á†ÅDFS„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** @Author: sun000* @Date: 2017-07-25 10:27:08* @Last Modified by: sun000* @Last Modified time: 2017-07-25 11:16:17*/#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 2e5 + 10;vector&lt;int&gt; g[MAXN];int del[MAXN];//ËÆ∞ÂΩïÂΩìÂâçÊØè‰∏™È¢úËâ≤Â∑≤ÁªèÂàÜÂá∫Êù•ÁöÑÂùóÁöÑÂ§ßÂ∞èbool vis[MAXN];int col[MAXN], n;long long int ans;//ËÆ∞ÂΩïÁöÑÊòØÂèçÈù¢Ôºå‰∏çÁªèËøáÊüê‰∏™È¢úËâ≤ÁöÑË∑ØÂæÑÊï∞Èáèint cnt; //Êó∂Èó¥Êà≥void addEdge(int u, int v) &#123; g[u].push_back(v);&#125;long long int cal(long long int k) &#123; if(k == 0) return 0; return k * (k - 1) / 2;&#125;void dfs(int u) &#123; cnt++; int v, now = cnt; int pre = del[col[u]];//‰∏çÂú®ËøôÊù°Ë∑ØÁöÑÂ≠êÊ†ëÈáåÁöÑÂ∑≤ÁªèÂàÜÂá∫Êù•Âùó for(int i = 0; i &lt; g[u].size(); i++) &#123; v = g[u][i]; if(!vis[v]) &#123; vis[v] = true;; dfs(v); int temp = cnt - now - (del[col[u]] - pre); //ÈáçÊñ∞ÂõûÂà∞uÁöÑvÂ≠êÊ†ëÁöÑÂ§ßÂ∞è-ÔºàvÂ≠êÊ†ëÈáå+‰πãÂâçÂàÜÂá∫ÁöÑÂùóÁöÑÊÄªÂíåÔºâ+‰∏çÊòØvÂ≠êÊ†ëÁöÑÂùóÁöÑÊï∞Èáè ans += cal(temp); del[col[u]] += temp; &#125; &#125; del[col[u]]++;//Âä†‰∏äuÈ¢úËâ≤Êú¨Ë∫´&#125;int main(void) &#123; int cas = 1; while(scanf("%d", &amp;n) != EOF) &#123; ans = 0, cnt = 0; memset(vis, false, sizeof(vis)); memset(del, 0, sizeof(del)); for(int i = 1; i &lt;= n; i++) &#123; g[i].clear(); scanf("%d", &amp;col[i]); &#125; int u, v; for(int i = 0; i &lt; n - 1; i++) &#123; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); &#125; vis[1] = true; dfs(1); long long int tot = 0; memset(vis, false, sizeof(vis)); for(int i = 1; i &lt;= n; i++) &#123;//ÊúÄÂêéËÆ°ÁÆóÊ†πËäÇÁÇπÊâÄÂú®ÁöÑÂêÑÁßçÈ¢úËâ≤ÁöÑÂàÜÂùóÊï∞Èáè if(!vis[col[i]]) &#123; tot += cal(n); ans += cal(n - del[col[i]]); vis[col[i]] = true; &#125; &#125; printf("Case #%d: %lld\n", cas++, tot - ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>ÂõæËÆ∫</tag>
        <tag>DFS</tag>
        <tag>Â§öÊ†°</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces832D. Misha, Grisha-and-Underground]]></title>
    <url>%2F2017%2F07%2F24%2FCodeForces832D-Misha-Grisha-and-Underground%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ Misha and Grisha are funny boys, so they like to use new underground. The underground has n stations connected with n - 1 routes so that each route connects two stations, and it is possible to reach every station from any other. The boys decided to have fun and came up with a plan. Namely, in some day in the morning Misha will ride the underground from station s to station f by the shortest path, and will draw with aerosol an ugly text &quot;Misha was here&quot; on every station he will pass through (including s and f). After that on the same day at evening Grisha will ride from station t to station f by the shortest path and will count stations with Misha's text. After that at night the underground workers will wash the texts out, because the underground should be clean. The boys have already chosen three stations a, b and c for each of several following days, one of them should be station s on that day, another should be station f, and the remaining should be station t. They became interested how they should choose these stations s, f, tso that the number Grisha will count is as large as possible. They asked you for help. Input The first line contains two integers n and q (2 ‚â§ n ‚â§ 105, 1 ‚â§ q ‚â§ 105) ‚Äî the number of stations and the number of days. The second line contains n - 1 integers p2, p3, ..., *p**n* (1 ‚â§ pi ‚â§ n). The integer pi means that there is a route between stations *p**i* and i. It is guaranteed that it's possible to reach every station from any other. The next q lines contains three integers a, b and c each (1 ‚â§ a, b, c ‚â§ n) ‚Äî the ids of stations chosen by boys for some day. Note that some of these ids could be same. Output Print q lines. In the i-th of these lines print the maximum possible number Grisha can get counting when the stations s, t and f are chosen optimally from the three stations on the i-th day. Examples input 3 2 1 1 1 2 3 2 3 3 output 2 3 input 4 1 1 2 3 1 2 3 output 2 Note In the first example on the first day if s = 1, f = 2, t = 3, Misha would go on the route 1 -&gt; 2, and Grisha would go on the route 3 -&gt; 1 -&gt;2. He would see the text at the stations 1 and 2. On the second day, if s = 3, f = 2, t = 3, both boys would go on the route 3 -&gt; 1 -&gt; 2. Grisha would see the text at 3 stations. In the second examle if s = 1, f = 3, t = 2, Misha would go on the route 1 -&gt; 2 -&gt; 3, and Grisha would go on the route 2 -&gt; 3 and would see the text at both stations. ÂàÜÊûê Êûö‰∏æfÊòØÂì™‰∏Ä‰∏™ÁÇπÔºå Ê±ÇÂá∫s-&gt;f, t-&gt;f,s-&gt;tÁöÑÈïøÂ∫¶Ôºå\(l_0,l_1,l_2\)Âàô\(ans = (l_0 + l_1 - l_2) / 2 + 1\) ÁÆÄÂçïËØÅÊòéÔºö Â¶ÇÂõæs-fÂíåt-fÁöÑË∑ØÂæÑ‰∏äÁöÑÂÖ¨ÂÖ±ÈïøÂ∫¶ÊòØ$(l_0 + l_1 - l_2) / 2 $Âä†‰∏äÊú¨Ë∫´ÁöÑÁÇπÂ∞±ÊòØans‰∫Ü IMG_2558 LCAÂ∞±Áî®Âú®Ê±ÇË∑ØÂæÑ‰∏äÔºåÊØîÂ¶ÇÔºöË¶ÅÊ±ÇaÂà∞bÁöÑË∑ØÂæÑÈïøÂ∫¶ deep[a] +deep[b] - 2 * deep[ lca(a, b)] ÈôÑ‰∏äÂÄçÂ¢ûÊ≥ïLCAÈìæÊé•http://sun000.cn/2017/07/24/ÂÄçÂ¢ûÊ≥ïLCA/ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int head[100010], cnt;int fa[100010][20];//ËäÇÁÇπiÁöÑ2^j‰∏™‰∫∫Á•ñÂÖàÊòØ‰ªÄ‰πàint deep[100010]; //deep‰øùÂ≠òÊØè‰∏™ËäÇÁÇπÁöÑÊ∑±Â∫¶ÔºåCNT‰∏∫‰øùÂ≠òÂõæÁöÑËôöÊãüÊåáÈíàint n, m, root; // root‰∏∫Ê†πËäÇÁÇπÁºñÂè∑struct node &#123; int next, v;&#125; e[1000010];void add(int a, int b)&#123; e[cnt].v = b; e[cnt].next = head[a]; head[a] = cnt; cnt++;&#125;void dfs(int x) &#123;//ËÆ°ÁÆóÊØè‰∏Ä‰∏™ËäÇÁÇπÁöÑÊ∑±Â∫¶ for (int i = head[x]; i; i = e[i].next) &#123; int v = e[i].v; if (!deep[v]) &#123; deep[v] = deep[x] + 1; fa[v][0] = x; dfs(v); &#125; &#125;&#125;void init() &#123; memset(deep, 0, sizeof(deep)); deep[1] = 1; dfs(root); cnt = 1; for (int i = 1; i &lt; 20; i++) for (int j = 1; j &lt;= n; j++) fa[j][i] = fa[fa[j][i - 1]][i - 1];&#125;int lca(int x, int y) &#123; if (deep[x] &lt; deep[y]) swap(x, y); // Â¶ÇÊûúÊ∑±Â∫¶‰∏çÂêå Ë∞ÉÂà∞Âêå‰∏ÄÊ∑±Â∫¶ for (int i = 19; i &gt;= 0; i--) &#123; if (deep[fa[x][i]] &gt;= deep[y]) x = fa[x][i]; &#125; if (x == y) return x; for (int i = 19; i &gt;= 0; i--) if (fa[x][i] != fa[y][i]) &#123;//ÂêåÊó∂Âêë‰∏äË∑≥ x = fa[x][i]; y = fa[y][i]; &#125; return fa[x][0];&#125;int getlen(int a, int b) &#123; int l = lca(a, b); return deep[a] +deep[b] - 2 * deep[l];&#125;int main()&#123; int q; scanf("%d%d", &amp;n, &amp;q); int temp; for (int i = 2; i &lt;= n; i++) &#123; scanf("%d", &amp;temp); add(i, temp); add(temp, i); &#125; root = 1; init(); for (int i = 0; i &lt; q; i++) &#123; int ans = -1; int x, y, z; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); int xy = getlen(x, y); int xz = getlen(x, z); int yz = getlen(y, z); ans = max(ans, xy + xz - yz); ans = max(ans, xy + yz - xz); ans = max(ans, yz + xz - xy); printf("%d\n", ans / 2 + 1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>ÂõæËÆ∫</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂÄçÂ¢ûÊ≥ïLCA]]></title>
    <url>%2F2017%2F07%2F24%2F%E5%80%8D%E5%A2%9E%E6%B3%95LCA%2F</url>
    <content type="text"><![CDATA[ÁÆÄ‰ªã ‰ªäÂ§©Â≠¶‰π†‰∫Ü‰∏Ä‰∏™ÂÄçÂ¢ûÊ≥ïLCAÂÆûÁé∞Ëµ∑Êù•ÂæàÊñπ‰æøÔºåËÄå‰∏îÁÆóÊ≥ïÂ§çÊùÇÂ∫¶\(log_2(d)\)ÂÖ∂‰∏≠dÊòØÊ†ëÁöÑÊ∑±Â∫¶ÔºåÂÖ∂ÂÆûÂÜôÊ≥ï‰πüÂæàÁÆÄÂçïÔºåÂ∞±ÊòØÁî®‰∏Ä‰∏™Ôºö fa[i][j]Êï∞ÁªÑÁî®Êù•ËÆ∞ÂΩïiÊ†áÂè∑ÁöÑËäÇÁÇπÁöÑÁ¨¨\(2^j\)‰∏™Á•ñÂÖà ÂæàÂÆπÊòìÂ∞±ËÉΩÂæóÂà∞fa[i][j]ÁöÑÈÄíÊé®ÂºèÂ≠êÊòØÔºö fa[i][j] = fa[fa[i][j - 1]][j - 1] Ê†πÊçÆ‰∫åËøõÂà∂ÁöÑÂéüÁêÜÔºåiÂèØ‰ª•ÈÄöËøá‰∫åËøõÂà∂Âêë‰∏äË∑≥Âà∞Ëææ‰ªª‰ΩïÁ•ñÂÖà„ÄÇ Êü•ËØ¢ËøáÁ®ãlca(u, v) uÂíåvÊâÄÂú®ÁöÑÊ†ëÁöÑÂ±ÇÊï∞Â¶ÇÊûú‰∏ÄÊ†∑Ôºå‰ª§u'=u„ÄÇÂê¶ÂàôÈúÄË¶ÅÂπ≥Ë°°Êìç‰ΩúÔºàÂÅáËÆæuÊõ¥Ê∑±ÔºâÔºåÂÖàÊâæÂà∞uÁöÑ‰∏Ä‰∏™Á•ñÂÖàu', ‰ΩøÂæóu'ÁöÑÂ±ÇÊï∞Âíåv‰∏ÄÊ†∑ÔºåÊ≠§Êó∂lca(u,v)=lca(u',v) „ÄÇ ËØÅÊòéÂæàÁÆÄÂçïÔºöÂ¶ÇÊûúLCA(u,v)=v , ÈÇ£‰πàu'‰∏ÄÂÆöÁ≠â‰∫év ;Â¶ÇÊûúLCA(u,v)=k Ôºåk!=v ÔºåÈÇ£‰πàk ÁöÑÊ∑±Â∫¶‰∏ÄÂÆöÂ∞è‰∫é v Ôºå u„ÄÅu'„ÄÅv ‰∏ÄÂÆöÂú®kÁöÑÂ≠êÊ†ë‰∏≠ÔºõÁªº‰∏äÊâÄËø∞Ôºålca(u,v)=lca(u',v)‰∏ÄÂÆöÊàêÁ´ã„ÄÇ Ê≠§Êó∂u' Âíå v ÁöÑÁ•ñÂÖàÂ∫èÂàó‰∏≠‰∏ÄÂºÄÂßãÁöÑÈÉ®ÂàÜ‰∏ÄÂÆöÊúâÊâÄÈáçÂè†ÔºåÈáçÂè†ÈÉ®ÂàÜÁöÑÊúÄÂêé‰∏Ä‰∏™ÂÖÉÁ¥†Ôºà‰πüÂ∞±ÊòØÊ∑±Â∫¶ÊúÄÊ∑±Ôºå‰∏éu'„ÄÅvÊúÄËøëÁöÑÂÖÉÁ¥†ÔºâÂ∞±ÊòØÊâÄÊ±ÇÁöÑlca(u,v)„ÄÇËøôÈáåfaÊï∞ÁªÑÂ∞±ÂèØ‰ª•Ê¥æ‰∏äÁî®Âú∫‰∫Ü„ÄÇÊâæÂà∞Á¨¨‰∏Ä‰∏™‰∏çÈáçÂè†ÁöÑËäÇÁÇπkÔºålca(u,v)=fa[k][0] „ÄÇ ÊâækÁöÑËøáÁ®ãÂà©Áî®‰∫åËøõÂà∂Ë¥™ÂøÉÊÄùÊÉ≥ÔºåÂÖàÂ∞ΩÂèØËÉΩË∑≥Âà∞ÊúÄ‰∏äÂ±ÇÁöÑÁ•ñÂÖàÔºåÂ¶ÇÊûú‰∏§Á•ñÂÖàÁõ∏Á≠âÔºåËØ¥ÊòéÂÆåÂÖ®ÂèØ‰ª•Ë∑≥Â∞èÁÇπÔºåË∑≥ÁöÑË∑ùÁ¶ªÈô§2ÔºåËøôÊ†∑‰∏ÄÊ≠•Ê≠•Ë∑≥‰∏ãÂéª‰∏ÄÂÆöÂèØ‰ª•ÊâæÂà∞k„ÄÇ Ê®°Áâà ‚Äã ‰æãÈ¢ò 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int head[100010], cnt;int fa[100010][20];//ËäÇÁÇπiÁöÑ2^j‰∏™‰∫∫Á•ñÂÖàÊòØ‰ªÄ‰πàint deep[100010]; //deep‰øùÂ≠òÊØè‰∏™ËäÇÁÇπÁöÑÊ∑±Â∫¶ÔºåCNT‰∏∫‰øùÂ≠òÂõæÁöÑËôöÊãüÊåáÈíàint n, m, root; // root‰∏∫Ê†πËäÇÁÇπÁºñÂè∑struct node &#123; int next, v;&#125; e[1000010];void add(int a, int b)&#123; e[cnt].v = b; e[cnt].next = head[a]; head[a] = cnt; cnt++;&#125;void dfs(int x) &#123;//ËÆ°ÁÆóÊØè‰∏Ä‰∏™ËäÇÁÇπÁöÑÊ∑±Â∫¶ for (int i = head[x]; i; i = e[i].next) &#123; int v = e[i].v; if (!deep[v]) &#123; deep[v] = deep[x] + 1; fa[v][0] = x; dfs(v); &#125; &#125;&#125;void init() &#123; memset(deep, 0, sizeof(deep)); deep[1] = 1; dfs(root); cnt = 1; for (int i = 1; i &lt; 20; i++) for (int j = 1; j &lt;= n; j++) fa[j][i] = fa[fa[j][i - 1]][i - 1];&#125;int lca(int x, int y) &#123; if (deep[x] &lt; deep[y]) swap(x, y); // Â¶ÇÊûúÊ∑±Â∫¶‰∏çÂêå Ë∞ÉÂà∞Âêå‰∏ÄÊ∑±Â∫¶ for (int i = 19; i &gt;= 0; i--) &#123; if (deep[fa[x][i]] &gt;= deep[y]) x = fa[x][i]; &#125; if (x == y) return x; for (int i = 19; i &gt;= 0; i--) if (fa[x][i] != fa[y][i]) &#123;//ÂêåÊó∂Âêë‰∏äË∑≥ x = fa[x][i]; y = fa[y][i]; &#125; return fa[x][0];&#125;int getlen(int a, int b) &#123; int l = lca(a, b); return deep[a] +deep[b] - 2 * deep[l];&#125;int main()&#123; int q; scanf("%d%d", &amp;n, &amp;q); int temp; for (int i = 2; i &lt;= n; i++) &#123; scanf("%d", &amp;temp); add(i, temp); add(temp, i); &#125; root = 1; init(); for (int i = 0; i &lt; q; i++) &#123; int ans = -1; int x, y, z; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); int xy = getlen(x, y); int xz = getlen(x, z); int yz = getlen(y, z); ans = max(ans, xy + xz - yz); ans = max(ans, xy + yz - xz); ans = max(ans, yz + xz - xy); printf("%d\n", ans / 2 + 1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>ÂõæËÆ∫</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yet another card game]]></title>
    <url>%2F2017%2F07%2F23%2FYet-another-card-game%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ Petr and Snuke are playing a cooperative card game. The game is played with special cards: each card is labeled with some positive integer. The integers on cards are not necessarily distinct. At the beginning of the game Petr is holding some cards in his hand and Snuke is holding all the other cards in his hand. You are given int[]s petr and snuke that describe the state at the beginning of the game: the elements of petr are the numbers on Petr's cards and the elements of snuke are the numbers on Snuke's cards. During the game the players will place some of their cards onto a pile. Initially, the pile is empty. The players take alternating turns, Petr goes first. In each turn, if the current player has no cards in his hand, the game ends. Otherwise, the player must make exactly one valid move. There are three types of valid moves: If the pile is empty, the player may choose any card and place it onto the pile. If the pile is not empty, the player may choose any card and place it on top of the pile. However, this move is only valid if the number on the new card is strictly greater than the number on the card that was previously on the top of the pile. The player may always choose one of his cards and eat it. Petr and Snuke have a common goal: they want to create a pile with as many cards as possible. Return the size of the pile at the end of the game, assuming that they cooperate and play the game optimally. Input The first line contains integer n ‚Äî number of cards of Petr and Snuke (1 ‚â§ n ‚â§ 50). Next line contains numbers f1, f2... *f**n* ‚Äî numbers written on Petr's cards. Next line contains numbers s1, s2... *s**n* ‚Äî numbers written on Snuke's cards. 1 ‚â§ fi, si ‚â§ 100. Output Output integer ‚Äî the maximum size of the pile, that can be created. Examples input 2 2 5 3 1 output 3 input 5 1 1 1 1 1 1 1 1 1 1 output 1 input 5 1 4 6 7 3 1 7 1 5 7 output 6 ÂàÜÊûê Âä®ÊÄÅËßÑÂàíÔºåÂÆö‰πâdp[i][j]ËÆ∞ÂΩïÁ¨¨iÊ¨°Êìç‰Ωú‰∏ãÂ†ÜÈ°∂‰∏∫ÊúÄÂ§ßÊòØjÁöÑÊÉÖÂÜµ‰∏ãÁöÑsize ËΩ¨ÁßªÊñπÁ®ãËßÅ‰ª£Á†ÅÔºåÂèØ‰ª•ÊªöÂä®Êï∞ÁªÑÔºåÊàëÂÜôÁöÑÊúâÁÇπ‰∏ëÔºå‰ΩÜÊòØÊÑèÊÄùÊòØÈÇ£‰πà‰∏™ÊÑèÊÄù„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243/** @Author: sun000* @Date: 2017-07-23 13:31:11* @Last Modified by: sun000* @Last Modified time: 2017-07-23 14:07:04*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int dp[105][105];//Á¨¨iÊ¨°Êìç‰ΩúÂêépileÈ°∂ÊúÄÂ§ßÊòØjÁöÑÊúÄÂ§ßsizeint f[55], s[55];int main(void) &#123; int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;f[i]); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;s[i]); memset(dp, 0, sizeof(dp)); for (int i = 1; i &lt;= 2 * n; i++) &#123; for (int j = 0; j &lt; n; j++) for (int k = 0; k &lt; f[j]; k++) dp[i + 1][f[j]] = dp[i][f[j]] = max(dp[i][f[j]], dp[i - 1][k] + 1); i++; for (int j = 0; j &lt; n; j++) for (int k = 0; k &lt; s[j]; k++) dp[i + 1][s[j]] = dp[i][s[j]] = max(dp[i][s[j]], dp[i - 1][k] + 1); &#125; int ans = -1; for (int i = 0; i &lt;= 100; i++) ans = max(ans, dp[n * 2][i]); printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 3760 Ideal Path]]></title>
    <url>%2F2017%2F07%2F22%2FHDU-3760-Ideal-Path%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ Problem Description New labyrinth attraction is open in New Lostland amusement park. The labyrinth consists of n rooms connected by m passages. Each passage is colored into some color ci. Visitors of the labyrinth are dropped from the helicopter to the room number 1 and their goal is to get to the labyrinth exit located in the room number n. Labyrinth owners are planning to run a contest tomorrow. Several runners will be dropped to the room number 1. They will run to the room number n writing down colors of passages as they run through them. The contestant with the shortest sequence of colors is the winner of the contest. If there are several contestants with the same sequence length, the one with the ideal path is the winner. The path is the ideal path if its color sequence is the lexicographically smallest among shortest paths. Andrew is preparing for the contest. He took a helicopter tour above New Lostland and made a picture of the labyrinth. Your task is to help him find the ideal path from the room number 1 to the room number n that would allow him to win the contest. Note A sequence (a1, a2, ‚Ä¶, ak) is lexicographically smaller than a sequence (b1, b2, ‚Ä¶, bk) if there exists i such that ai &lt; bi, and aj = bj for all j &lt; i. Input The input begins with an integer T. The next T blocks each represents a case. The first line of each case contains integers n and m - the number of rooms and passages, respectively (2 ‚â§ n ‚â§ 100 000, 1 ‚â§ m ‚â§ 200 000). The following m lines describe passages, each passage is described with three integer numbers: ai, bi, and ci - the numbers of rooms it connects and its color (1 ‚â§ ai, bi ‚â§ n, 1 ‚â§ ci ‚â§ 109). Each passage can be passed in either direction. Two rooms can be connected with more than one passage, there can be a passage from a room to itself. It is guaranteed that it is possible to reach the room number n from the room number 1. Output For each case, the first line of the output must contain k - the length of the shortest path from the room number 1 to the room number n. The second line must contain k numbers - the colors of passages in the order they must be passed in the ideal path. Sample Input 1 4 6 1 2 1 1 3 2 3 4 3 2 3 1 2 4 4 3 1 1 Output 2 1 3 ÂàÜÊûê ÂÖàBFSÊ±ÇÂá∫ÊâÄÊúâÁöÑÊúÄÁü≠Ë∑ØÔºåÁÑ∂ÂêéÂú®ÊúÄÁü≠Ë∑ØÊûÑÊàêÁöÑÂõæ‰∏äÂàÜÂ±ÇÊêúÁ¥¢ÔºåÊ±ÇÂá∫Â≠óÂÖ∏Â∫èÊúÄÂ∞èÁöÑË∑ØÂæÑ„ÄÇÂà§Êñ≠‰∏Ä‰∏™ÁÇπÊòØÂê¶Âú®ÊúÄÁü≠Ë∑Ø‰∏äÔºöÂè™Ë¶ÅÊ±ÇÂá∫Ëµ∑ÁÇπÂà∞Ëøô‰∏ÄÁÇπÁöÑÊúÄÁü≠Ë∑ØaÂíåÁªàÁÇπÂà∞Ëøô‰∏ÄÁÇπÁöÑÊúÄÁü≠Ë∑ØbÂ¶ÇÊûúa+bÁ≠â‰∫éËµ∑ÁÇπÂà∞ÁªàÁÇπÁöÑÊúÄÁü≠Ë∑ØLÂàôËøô‰∏ÄÁÇπÂú®ÊúÄÁü≠Ë∑Ø‰∏ä„ÄÇËá≥‰∫éÂàÜÂ±ÇÁöÑËØùÔºåÊâÄÂú®ÁöÑÂ±ÇÂ∞±ÊòØËµ∑ÁÇπÂà∞Ëøô‰∏ÄÁÇπÁöÑÊúÄÁü≠Ë∑Ø„ÄÇmapÂéªÈáçÂ∞è‰ºòÂåñ„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/** @Author: sun000* @Date: 2017-07-22 12:46:55* @Last Modified by: sun000* @Last Modified time: 2017-07-22 22:00:56*/#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;const int MAXN = 1e5 + 10 ;const int MAXM = 4e5 + 10;struct EDGE &#123; int v, w, next;&#125; edge[MAXM * 2];int head[MAXN], cnt;int dis[2][MAXN];bool vis[MAXN];void init() &#123; memset(head, -1, sizeof(head)); cnt = 0;&#125;void add(int u, int v, int w) &#123; edge[cnt].v = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt++;&#125;int n, m;int L;//ÊúÄÁü≠Ë∑Øvoid bfs_clolr() &#123; memset(vis, false, sizeof(vis)); queue&lt;int&gt; q; q.push(1); vis[1] = true; int temp[MAXN]; int u, v, w, pre = 1, now, d = 1, minw; while (!q.empty() &amp;&amp; d &lt;= L) &#123; minw = 0x3f3f3f3f; for (int i = 0; i &lt; pre; i++) &#123; u = q.front(); q.pop(); temp[i] = u; for (int j = head[u]; j != -1; j = edge[j].next) &#123; v = edge[j].v; w = edge[j].w; if (dis[0][v] == d &amp;&amp; dis[0][v] + dis[1][v] == L) &#123; minw = min(minw, w); &#125; &#125; &#125; printf("%d%c", minw, d == L ? '\n' : ' '); now = 0; for (int i = 0; i &lt; pre; i++) &#123; u = temp[i]; for (int j = head[u]; j != -1; j = edge[j].next) &#123; v = edge[j].v; w = edge[j].w; if (dis[0][v] == d &amp;&amp; dis[0][v] + dis[1][v] == L &amp;&amp; minw == w &amp;&amp; !vis[v]) &#123; q.push(v); vis[v] = true; now++; &#125; &#125; &#125; d++; pre = now; &#125;&#125;void bfs(int src, int k) &#123; memset(vis, false, sizeof(vis)); queue&lt;int&gt; q; q.push(src); dis[k][src] = 0; int u, v; while (!q.empty()) &#123; u = q.front(); q.pop(); for (int i = head[u]; i != -1; i = edge[i].next) &#123; v = edge[i].v; if (!vis[v]) &#123; dis[k][v] = min(dis[k][v], dis[k][u] + 1); vis[v] = true; q.push(v); &#125; &#125; &#125; if (k == 0) L = dis[k][n];&#125;void solve() &#123; memset(dis, 0x3f, sizeof(dis)); bfs(1, 0); bfs(n, 1); printf("%d\n", L); bfs_clolr();&#125;map&lt;pair&lt;int, int&gt;, int&gt; mm;int main() &#123; int u, v, w, t; scanf("%d", &amp;t); while (t--) &#123; scanf("%d%d", &amp;n, &amp;m); init(); mm.clear(); while (m--) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); if (u == v) continue; if (u &gt; v) swap(u, v); pair&lt;int, int&gt; temp = make_pair(u, v); if (mm.count(temp)) mm[temp] = min(mm[temp], w); else mm[temp] = w; &#125; for (map&lt;pair&lt;int, int&gt;, int&gt;::iterator it = mm.begin(); it != mm.end(); it++) &#123; add((it -&gt; first).first, (it -&gt; first).second, it -&gt; second); add((it -&gt; first).second, (it -&gt; first).first, it -&gt; second); &#125; solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>ÂõæËÆ∫</tag>
        <tag>ÊúÄÁü≠Ë∑Ø</tag>
        <tag>ÊêúÁ¥¢</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A+B]]></title>
    <url>%2F2017%2F07%2F22%2FA%2BB%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ Andrew is studying in the seventh grade. The class has recently learned about periodic decimals, so Andrew is very curious how to work with them. Recall that a periodic decimal is the way to represent rational numbers by specifying the preperiod and the period of its infinite decimal representation. For example, 1 / 7 = 0.(142857), 1 / 12 = 0.08(3). There are some numbers that have two representations as periodic decimals, those that are actually finite decimals such as 0.(9) = 1.(0). In this problem such numbers must be represented as ending with zeroes, so 0.(9) is an incorrect periodic decimal for the purpose of this problem. Now Andrew wants to add two numbers given as periodic decimals. The sum of two periodic decimals is always again a periodic decimal, but the length of the period can be quite big. Therefore Andrew only asks you to find some particular digits of the sum. You have to output digits at positions a1, a2, ..., *a**n*. To simplify the task, Andrew only wants to add numbers of the form 0.(Œ±) where Œ± is a period. Input The input contains multiple test cases. The first line of the input contains t ‚Äî the number of tests in the input. The first two lines of each test case contain periods of the two numbers to add, the periods contain digits from 0 to 9. The length of each period is at most 200. The following line contains n ‚Äî the number of queries, the line with n integers *a**i* follows (1 ‚â§ n ‚â§ 300 000, 1 ‚â§ *a**i* ‚â§ 1018). The total length of periods of all numbers in the input doesn't exceed 200 000. The sum of n in the input doesn't exceed 300 000. Output For each *a**i* in the test case print a digits that is at the *a**i*-th position after the decimal point in the sum of two periodic decimals specified in the input. Positions are numbered from 1. Do not separate digits by spaces. Print answer for each test case on a separate line. Example input 2 142857 3 10 1 2 3 4 5 6 7 8 9 10 4 5 3 1 2 3 output 4761904761 000 ÂàÜÊûê Áõ¥Êé•Êö¥ÂäõÊ®°ÊãüÔºåÊúâ‰∏Ä‰∏™ÂùëÁÇπÂ∞±ÊòØ(9)+(9)Âπ∂‰∏çÊòØÊØè‰∏Ä‰ΩçÈÉΩÊòØ9Ôºå‰∏çÈúÄË¶ÅÊõøÊç¢Êàê0ÔºåÂõ†‰∏∫ÊúÄÂêé‰∏Ä‰ΩçÊ∞∏ËøúÈÉΩÊòØ8„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;cstring&gt;char a[100100], b[100100];int g;int gcd(int a, int b) &#123; if (!b) return a; return gcd(b, a % b);&#125;void init() &#123; int la = strlen(a); int lb = strlen(b); g = la / gcd(la, lb) * lb; for (int i = 1; i &lt; g / la; i++) for (int j = 0; j &lt; la; j++) a[i * la + j] = a[j]; for (int i = 1; i &lt; g / lb; i++) for (int j = 0; j &lt; lb; j++) b[i * lb + j] = b[j]; a[g] = b[g] = '\0'; int gg = 0, now; for (int i = g - 1; i &gt;= 0; i--) &#123; now = (a[i] - '0' + b[i] - '0') + gg; a[i] = '0' + now % 10; gg = now / 10; &#125; if (!gg) &#123; bool flag = true; for (int i = 0; i &lt; g; i++) if (a[i] != '9') &#123; flag = false; break; &#125; if (flag) &#123; for (int i = 0; i &lt; g; i++) a[i] = '0'; return; &#125; &#125; while (gg) &#123; for (int i = g - 1; i &gt;= 0; i--) &#123; now = a[i] - '0' + gg; a[i] = '0' + now % 10; gg = now / 10; &#125; &#125;&#125;int main(void) &#123; int t, m; long long int q; scanf("%d", &amp;t);// while (t--) &#123; scanf("%s", a); scanf("%s", b); init(); scanf("%d", &amp;m); for (int i = 0; i &lt; m; i++) &#123; scanf("%lld", &amp;q); q = (q - 1) % (long long int)g; printf("%c", a[(int)q]); &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Êö¥Âäõ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hash Code Hacker]]></title>
    <url>%2F2017%2F07%2F22%2FHash-Code-Hacker%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ According to Java standard library documentation, the hash code of String is computed ass[0]31^(n-1) + s[1]31^(n-2) + ... + s[n-1] Here s[i] is the i-th character of the string, n is the length of the string, and ÀÜ indicates exponentiation.Computation uses signed 32-bit integers in two‚Äôs complement form. Heather is going to hack the servers of Not Entirely Evil Recording Company (NEERC). To performan attack she needs k distinct query strings that have equal hash codes. Unfortunately, NEERC serversaccept query string containing lower- and uppercase English letters only. Heather hired you to write a program that generates such query strings for her. Input The single line of the input file contains integer k ‚Äî the number of required query strings to generate(2 ‚â§ k ‚â§ 1000). Output Output k lines. Each line should contain a single query string. Each query string should be non-emptyand its length should not exceed 1000 characters. Query string should contain only lower- and uppercaseEnglish letters. All query strings should be distinct and should have equal hash codes. Example Input 4 Output edHs mENAGeS fEHs edIT ÂàÜÊûê ËßÇÂØüÊ†∑‰æãÔºåÂæàÂÆπÊòìÂèëÁé∞hash(&quot;Hs&quot;)=hash(&quot;IT&quot;)ÔºåÂæóÂà∞ËßÑÂæãhash(&quot;Aa&quot;)=hash(&quot;BB&quot;),hash(&quot;Bb&quot;)=hash(&quot;CC&quot;)........Áî±‰∫éÊúÄÂ§ßÁöÑkÊòØ1000ÂàôÊúÄÂ§öÂèñ10ÂØπÔºåÁî®‰∫åËøõÂà∂Êûö‰∏æÊØè‰∏ÄÂØπÊòØ‰ªÄ‰πàÂ∞±ËÉΩÂæóÂà∞Á≠îÊ°à‰∫Ü„ÄÇ ‰ª£Á†Å 12345678910111213141516171819#include &lt;cstdio&gt;char a[10][3] = &#123;"Aa", "Bb", "Cc", "Dd", "Ee", "Ff", "Gg", "Hh", "Ii", "Jj"&#125;;char b[10][3] = &#123;"BB", "CC", "DD", "EE", "FF", "GG", "HH", "II", "JJ", "KK"&#125;;int main(void) &#123; int k; scanf("%d", &amp;k); for(int i = 0; i &lt; k; i++) &#123; for(int j = 0; j &lt; 10; j++) &#123; if((i &gt;&gt; j) &amp; 1) printf("%s", a[j]); else printf("%s", b[j]); &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>ÊûÑÈÄ†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ëé´Èòü]]></title>
    <url>%2F2017%2F07%2F13%2F%E8%8E%AB%E9%98%9F%2F</url>
    <content type="text"><![CDATA[ËΩ¨ËΩΩËá™ ÊëòË¶Å Ëé´ÈòüÁÆóÊ≥ïÊòØ‰∏Ä‰∏™ÂØπ‰∫éÂå∫Èó¥„ÄÅÊ†ëÊàñÂÖ∂‰ªñÁªìÊûÑÁ¶ªÁ∫øÔºàÂú®Á∫øÔºâÁª¥Êä§ÁöÑÁÆóÊ≥ïÔºåÊ≠§ÁÆóÊ≥ïÂü∫‰∫é‰∏Ä‰∫õÂü∫Êú¨ÁÆóÊ≥ïÔºå‰æãÂ¶ÇÊö¥ÂäõÁª¥Êä§ÔºåÊ†ëÁä∂Êï∞ÁªÑÔºåÂàÜÂùóÔºåÊúÄÂ∞èÊõºÂìàÈ°øË∑ùÁ¶ªÁîüÊàêÊ†ëÔºåÂØπÂÖ∂ËøõË°åÊèâÂêà‰ªéËÄå‰∫ßÁîüÁöÑ‰∏Ä‰∏™ÁÆÄÂçïÊòìÊáÇ‰∏îÁü≠Â∞èÂ•ΩÂÜôÁöÑÁÆóÊ≥ï„ÄÇÊ≠§ÁÆóÊ≥ïÂú®ÂæàÂ§öÊÉÖÂÜµ‰∏ãÂèØ‰ª•ÂæàËΩªÊùæÁöÑÂàáÊéâ‰∏Ä‰∫õÂ§çÊùÇËÄå‰∏îÈöæÂÜôÁöÑÊï∞ÊçÆÁªìÊûÑÈóÆÈ¢ò„ÄÇ ÂÖ≥ÈîÆËØç Á®ãÂ∫èËÆæËÆ°„ÄÅÁÆóÊ≥ï„ÄÅÁÆóÊ≥ï‰ºòÂåñÔºåÊö¥ÂäõÁÆóÊ≥ïÔºåÂàÜÂùóÁÆóÊ≥ïÔºåÊúÄÂ∞èÊõºÂìàÈ°øË∑ùÁ¶ªÁîüÊàêÊ†ë„ÄÇ ËÉåÊôØ ‰ºóÊâÄÂë®Áü•ÔºåÂú®OIÁ´ûËµõ„ÄÅËΩØ‰ª∂ÁöÑËÆæËÆ°‰∏≠ÈÉΩ‰ºöË¶ÅÊ±ÇÊàë‰ª¨ÂéªÂ§ÑÁêÜÂêÑÁßçÂêÑÊ†∑ÁöÑÊ£òÊâãÁöÑÈóÆÈ¢òÔºåËÄåËøô‰∫õÈóÆÈ¢ò‰πã‰∏≠ÔºåÊúâ‰∏ÄÂ§ßÁ±ªÂ∞±ÊòØÁª¥Êä§ÈóÆÈ¢òÔºöÊØîÂ¶ÇËØ¥ÂØπ‰∫é‰∏Ä‰∏™Â∫èÂàóÁöÑÁª¥Êä§ÔºåÂØπ‰∫éÊ£µ‰∫åÂèâÊàñËÄÖÂ§öÂèâÊ†ëÁöÑÁª¥Êä§‚Ä¶‚Ä¶Ëøô‰∫õÈóÆÈ¢òÂæÄÂæÄ‰ºöÈúÄË¶ÅÊàë‰ª¨Âéª‰ΩøÁî®‰∏Ä‰∏™ÊàñÂ§ö‰∏™È´òÁ´ØÁöÑÊï∞ÊçÆÁªìÊûÑÂ§çÂêàÊù•ÂÆåÁæéËß£ÂÜ≥ÔºåÈÄöÂ∏∏È¢òÁõÆÁöÑ‰ª£Á†ÅÂçÅÂàÜÂÜóÈïøËÄå‰∏îÂá∫ÈîôÂèØËÉΩÊÄßÂçÅÂàÜÂ§ßÔºåÊòØÂπøÂ§ßOIer„ÄÅAcmer„ÄÅCoderÊâÄÂÆ≥ÊÄïÁöÑÈ¢òÁõÆ„ÄÇÈÇ£‰πàÊúâÊ≤°Êúâ‰∏ÄÁßçÊñπÊ≥ïÂèØ‰ª•Êó¢ÁÆÄÂçïÂèàÂø´Êç∑ÁöÑËß£ÂÜ≥ËøôÁ±ªÈóÆÈ¢òÔºàËøôÁ±ªÈóÆÈ¢ò‰∏≠ÁöÑ‰∏ÄÂ§ßÈÉ®ÂàÜÔºâÂë¢ÔºüËé´ÈòüÁÆóÊ≥ïÂ∞±ËØûÁîüËæ£ÔºÅ ÁêÜËÆ∫1 Â∫èÂàóËé´ÈòüÔºöÊàë‰ª¨Áé∞Âú®Êúâ‰∏Ä‰∏™Èïø‰∏∫nÁöÑÈùôÊÄÅÁöÑÂ∫èÂàóÔºåÂØπ‰∫éÂ∫èÂàóÔºåÊàë‰ª¨ÊúâmÊ¨°Êü•ËØ¢ÔºåÊàë‰ª¨Ë¶ÅÂä®ÊÄÅÊü•ËØ¢lÂà∞r‰πãÈó¥Â§ß‰∫éaÂ∞è‰∫ébÁöÑÊï∞ÁöÑ‰∏™Êï∞‰ª•ÂèäÁßçÁ±ª„ÄÇÈÅáÂà∞‰∫ÜËøô‰∏™ÈóÆÈ¢òÊàë‰ª¨ÈÄöÂ∏∏ÈúÄË¶Å‰ΩøÁî®‰π¶Â•óÊ†ëÁöÑÊï∞ÊçÆÁªìÊûÑÔºåÂç≥‰∏ÄÈ¢ó‰ª•Ëá™Âπ≥Ë°°‰∫åÂèâÊü•ÊâæÊ†ë‰∏∫ËäÇÁÇπÁöÑÁ∫øÊÆµÊ†ëÔºàÊó∂Èó¥Â§çÊùÇÂ∫¶Â§ßÁ∫¶ÊòØO(mlognlogn)ÔºâÔºåËÄå‰∏îÁî±‰∫éÁ©∫Èó¥ÈôêÂà∂ÔºåÊàë‰ª¨ËøòÂøÖÈ°ªÂä®ÊÄÅÂàõÂª∫Á∫øÊÆµÊ†ëÁöÑËäÇÁÇπÔºåËøôÊ†∑‰∏ÄÊù•ÂçÅÂàÜÈöæÂÜôÔºå‰∏Ä‰∫õÂ§ßÁ∫¶Ë¶Å‰∏™400-500Ë°åÔºåË∞ÉËØïËµ∑Êù•‰πüÂæàÂõ∞Èöæ„ÄÇËøôÊó∂ÂÄôÊàë‰ª¨Êù•ËÄÉËôëÊö¥ÂäõÁÆóÊ≥ïÔºåÂ¶ÇÊûúÊö¥ÂäõÁöÑÂ§ÑÁêÜÈ¢òÁõÆ‰∏≠ÁöÑÈóÆÈ¢òÈÇ£‰πàÂ§çÊùÇÂ∫¶ÊòØÂ§öÂ∞ëÂë¢ÔºüËøô‰∏™‰∏çÈöæËÆ°ÁÆóÔºåÂØπ‰∫éÊØè‰∏™ËØ¢ÈóÆÊàë‰ª¨ÈÉΩË¶ÅO(n)ÁöÑÊó∂Èó¥Â§ÑÁêÜ,‰∏ÄÂÖ±Êúâm‰∏™ËØ¢ÈóÆÔºåÈÇ£‰πàÊö¥ÂäõÂ§ÑÁêÜÁöÑÂ§çÊùÇÂ∫¶Â∞±ÊòØO(nm)ÁöÑÔºåÊòéÊòæÂ§ÑÁêÜÈóÆÈ¢òËä±Ë¥πÁöÑÊó∂Èó¥Êàë‰ª¨ÊòØ‰∏çËÉΩÊé•ÂèóÁöÑ„ÄÇËøôÊòØÊàë‰ª¨ÊÉ≥Âà∞ÂèØ‰ª•‰∫§Êç¢ËØ¢ÈóÆÂíåËØ¢ÈóÆ‰πãÈó¥ÁöÑÂÖàÂêéÊ¨°Â∫èÔºåËøôÊ†∑ÊØèÊ¨°ËØ¢ÈóÆÂú®Ââç‰∏ÄÊ¨°ËØ¢ÈóÆÁöÑÂü∫Á°Ä‰∏äËΩ¨ÁßªÂ∞±ÂèØ‰ª•ËäÇÁúÅ‰∏Ä‰∫õÊó∂Èó¥‰∫Ü„ÄÇ ‰ΩÜÊòØÂ¶Ç‰ΩïÈáçÊñ∞ÊéíÂàóËØ¢ÈóÆ‰πãÈó¥ÁöÑÈ°∫Â∫èÊòØ‰∏Ä‰∏™ÈóÆÈ¢ò„ÄÇÊàë‰ª¨ÈúÄË¶ÅËøõË°å‰∏Ä‰∫õÁêÜËÆ∫ÂàÜÊûê„ÄÇÊàë‰ª¨ÂÜç‰∏ä‰∏Ä‰∏™ËØ¢ÈóÆÁöÑÂü∫Á°Ä‰∏äÊö¥ÂäõÂú∞Áª¥Êä§‰∏Ä‰∏™ËØ¢ÈóÆÔºàÂÅáËÆæ‰∏ä‰∏Ä‰∏™ËØ¢ÈóÆËØ¢ÈóÆÂå∫Èó¥‰∏∫[l0,r0]ÔºåËøô‰∏™ËØ¢ÈóÆÂå∫Èó¥‰∏∫[l,r]ÔºâÔºåÈÇ£‰πàÊàë‰ª¨ÊâÄË∞ìÁöÑÊö¥ÂäõÁª¥Êä§Â∞±ÊòØÂÖàÊääÁé∞ÊúâÁ≠îÊ°àÁöÑÂè≥ËæπÁïå‰ªér0ÁßªÂä®Âà∞rÔºåÂÜçÊääÂ∑¶ËæπÁïå‰ªél0ÁßªÂä®Âà∞lÔºåÈÇ£‰πàÊàë‰ª¨ÁöÑÊÄªËä±Ë¥πÊòØO(|l-l0|+|r-r0|)„ÄÇ‰ªîÁªÜÁúã‰∏ÄÁúãÔºåÊ≤°ÈîôÔºåËøôÂ∞±ÊòØÊàë‰ª¨ÁöÑÊõºÂìàÈ°øË∑ùÁ¶ªÁöÑËÆ°ÁÆóÂÖ¨ÂºèÔºåÊúâ‰∫ÜËøô‰∏™ÊÄùË∑ØÔºåÊàë‰ª¨Â∞±ÂèØ‰ª•‰ªéÂõæÂΩ¢ÁöÑËßíÂ∫¶Êù•ÊÄùËÄÉ‰∫ÜÔºåÂØπ‰∫é‰∏Ä‰∏™ËØ¢ÈóÆ[l,r]Êàë‰ª¨ÂèØ‰ª•Â∞ÜÂÆÉÊò†Â∞Ñ‰∏∫Âπ≥Èù¢‰∏äÂú®(l,r)‰ΩçÁΩÆÁöÑÁÇπÔºåÈÇ£‰πà‰∏§‰∏™ËØ¢ÈóÆ‰πãÈó¥ËΩ¨ÁßªÁöÑ‰ª£‰ª∑Â∞±ÊòØËØ¢ÈóÆÊâÄÂØπÂ∫îÁöÑÁÇπ‰πãÈó¥ÁöÑÊõºÂìàÈ°øË∑ùÁ¶ª„ÄÇÊúâ‰∫ÜËøô‰∏Ä‰∏™ÁªìËÆ∫ÔºåÊàë‰ª¨‰æøÊÉ≥Âà∞ÂèØ‰ª•Áî®ÊúÄÂ∞èÊõºÂìàÈ°øÁîüÊàêÊ†ëÊù•Â§ÑÁêÜËØ¢ÈóÆÁöÑÈ°∫Â∫è„ÄÇÁî±Ê≠§Ëé´ÈòüÁÆóÊ≥ï‰æøËØûÁîüÂï¶ÔºÅËé´ÈòüÁÆóÊ≥ïÂ∞±ÊòØÂÖàÂ∞ÜËØ¢ÈóÆÊäΩË±°ÊàêÂπ≥Èù¢‰∏äÁöÑÁÇπÔºåÁÑ∂ÂêéËøõË°å‰∏ÄËæπÊúÄÂ∞èÊõºÂìàÈ°øË∑ùÁ¶ªÁîüÊàêÊ†ëÔºåÁÑ∂ÂêéÊåâÁÖßÁîüÊàêÊ†ëÁöÑÈ°∫Â∫èÊù•Â§ÑÁêÜËØ¢ÈóÆÔºåËøôÊ†∑ÁöÑÁÆóÊ≥ïÂ§çÊùÇÂ∫¶Â§ßÁ∫¶ÊòØO(mSqrt(n))ÁöÑ„ÄÇÂ¶ÇÊ≠§ÔºåÈóÆÈ¢ò‰æøÁÆÄÂçï‰∫ÜËÆ∏Â§ö„ÄÇ ‰ΩÜÊòØÁî±‰∫éÊúÄÂ∞èÊõºÂìàÈ°øË∑ùÁ¶ªÁîüÊàêÊ†ë‰πü‰∏çÊòØÈÇ£‰πàÁöÑÂ•ΩÂÜôÔºåÊâÄ‰ª•Ëé´ÈòüÁÆóÊ≥ïËøòËÉΩÂÜçÁÆÄÂçï‰∏ÄÁÇπ‰πàÔºüÊàë‰ª¨ÊÄùËÄÉÊòØÂê¶ÂèØ‰ª•Áî®‰∏Ä‰∏™ÁÆÄÂçïËÄåÊö¥ÂäõÁöÑÁÆóÊ≥ï‰ª£ÊõøËé´ÈòüÁÆóÊ≥ïÂë¢„ÄÇÂæàÂø´‰æøËÉΩÊÉ≥Âà∞ÂàÜÂùóÁÆóÊ≥ï„ÄÇÊàë‰ª¨ÂèØ‰ª•‰ΩøÁî®ÂàÜÂùóÁÆóÊ≥ïÊù•Â§ÑÁêÜËØ¢ÈóÆ‰πãÈó¥ÁöÑÊ¨°Â∫èÈóÆÈ¢ò„ÄÇÂÜçÂéªÁúãÈÇ£‰∏™ËØ¢ÈóÆÂØπÂ∫îÁöÑÁÇπÊâÄÂú®ÁöÑÂπ≥Èù¢ÔºåÊàë‰ª¨ÊâæÂà∞ÂÆÉÁöÑXËΩ¥ÔºåÊàë‰ª¨ÊääXËΩ¥Âπ≥ÂùáÂàÜÂâ≤ÊàêrÂàÜÔºåÁÑ∂ÂêéÊàë‰ª¨ÊääÂú®‰∏Ä‰∏™ÂùóÂÜÖÁöÑËØ¢ÈóÆÁªü‰∏ÄÂÖàÂ§ÑÁêÜÔºå‰∏çÂú®‰∏Ä‰∏™ÂùóÂÜÖÁöÑËØ¢ÈóÆÊàë‰ª¨ÊåâÁÖßÂ∑¶Á´ØÁÇπÂçáÂ∫èÂè≥Á´ØÁÇπÂçáÂ∫èÊéíÂ∫è‰æùÊ¨°Â§ÑÁêÜ„ÄÇËøôÊ†∑ÂÅöÊúâ‰ªÄ‰πàÂ•ΩÂ§ÑÂë¢ÔºüÂØπ‰∫émÂπ≤‰∏™ËØ¢ÈóÆÔºåÂ¶ÇÊûúÂú®‰∏Ä‰∏™ÂùóÈáåÈù¢ÔºåÈÇ£‰πàÂ§ÑÁêÜËøô‰∫õËØ¢ÈóÆËä±Ë¥πÁöÑÂ§çÊùÇÂ∫¶ÊòØO(n/rnm)ÔºåÂ¶ÇÊûúÊúâ‰∏§‰∏™ËØ¢ÈóÆ‰∏çÂú®‰∏Ä‰∏™Âêå‰∏Ä‰∏™ÂùóÈáåÈù¢ÔºåÊåâÁÖßÊàë‰ª¨‰πãÂâçÁöÑÊéíÂ∫èËßÑÂàôÔºåÊàë‰ª¨ÊääÂ∑¶Âå∫Èó¥ÂíåÂè≥Âå∫Èó¥Âú®Âùó‰πãÈó¥ÁßªÂä®ÁöÑÊ¨°Êï∞ÊúÄÂ§ö‰∏∫r(n/r)rÊ¨°ÔºåÈÇ£‰πàÊàë‰ª¨ÁöÑÂ§çÊùÇÂ∫¶Â∞±ÊòØO(r(n/r)r)Ê¨°ÔºåÁªèËøáÁÆÄÂçïÁöÑÊï∞Â≠¶ÂàÜÊûêÔºåÊàë‰ª¨ÂèØ‰ª•ÂèëÁé∞r=Sqrt(n)ÊòØÊó∂Èó¥Â§çÊùÇÂ∫¶ÊúÄ‰Ωé‰∏∫O(nSqrt(n))Ê¨°ÔºåÊòØÂèØ‰ª•Êé•ÂèóÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶„ÄÇËøôÊ†∑Êàë‰ª¨ÁöÑËé´ÈòüÁÆóÊ≥ïÂ∞±ÂèàÁÆÄÂçïÊúâÂº∫Â§ß‰∫Ü„ÄÇ‰ΩÜÊòØÂú®Âè¶‰∏Ä‰∫õÊÉÖÂÜµ‰∏ãÔºåÈ¢òÁõÆ‰ºöÊó†ËÄªÁöÑÈôêÂÆöÊàë‰ª¨ÂèØ‰ª•‰ΩøÁî®ÁöÑÁ©∫Èó¥Ôºà‰∏ÄËà¨‰∏ç‰ºöÔºåÂõ†‰∏∫ËøôÊ†∑È´òÁ∫ßÊï∞ÊçÆÁªìÊûÑÁöÑÂ§çÂêà‰πüÈöæ‰ª•Ëß£ÂÜ≥ËøôÊ†∑ÁöÑÈóÆÈ¢ò‰∫ÜÔºâ„ÄÇÈÇ£‰πàÂ¶ÇÊûúÁ©∫Èó¥Ë¢´ÈôêÂÆö‰∫ÜÔºåÊàë‰ª¨Â∫îËØ•Â¶Ç‰ΩïËß£ÂÜ≥ÈóÆÈ¢òÂë¢ÔºüÂÖ∂ÂÆûÂæàÁÆÄÂçïÔºå ËøòËÆ∞ÂæóÊàë‰ª¨‰πãÂâçÁöÑr‰πàÔºüÊàë‰ª¨‰∏∫‰∫ÜÊ±ÇÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶ÊúÄÂ∞è‰ª§r=Sqrt(n),Â¶ÇÊûúÊàë‰ª¨‰ª§r=n ^ (2 / 3)ÔºåÈÇ£‰πà‰æøÊòØ‰∏Ä‰∏™Êó∂Èó¥Â§çÊùÇÂ∫¶ÂíåÁ©∫Èó¥Â§çÊùÇÂ∫¶ËæÉ‰∏∫Âπ≥Ë°°ÁöÑÊÉÖÂÜµÔºåËøôÊ†∑ÂèØ‰ª•ÂæàÂ•ΩÁöÑËß£ÂÜ≥ÈóÆÈ¢ò„ÄÇ ‰æãÈ¢ò ËæìÂÖ•Êï∞ÊçÆÈ¶ñÂÖàËæìÂÖ•‰∏§‰∏™Êï¥Êï∞N,QÔºåÂàÜÂà´‰ª£Ë°®Â∫èÂàóÁöÑÈïøÂ∫¶ÂíåËØ¢ÈóÆÁöÑ‰∏™Êï∞„ÄÇËøô‰∏§‰∏™Êï∞Â≠óÂ∞ÜÂçïÁã¨Âç†ÊçÆ‰∏ÄË°åÂπ∂Áî®‰∏Ä‰∏™Á©∫Ê†ºÂàÜÂºÄ„ÄÇËæìÂÖ•Êï∞ÊçÆÁöÑÁ¨¨‰∫åË°åÂåÖÂê´‰∫ÜN‰∏™Áî±‰∏Ä‰∏™Á©∫Ê†ºÂàÜÂºÄÁöÑÊ≠£Êï¥Êï∞Ôºå‰ª£Ë°®‰∫ÜÊï¥‰∏™Â∫èÂàóÔºå‰ªéÂ∑¶ÂêëÂè≥‰æùÊ¨°ÁºñÂè∑‰∏∫A1, A2‚Ä¶‚Ä¶An„ÄÇÊé•‰∏ãÊù•QË°åÔºåÊØèË°å‰∏§‰∏™Êï¥Êï∞i,jË°®Á§∫‰∫Ü‰∏Ä‰∏™ËØ¢ÈóÆÂå∫Èó¥„ÄÇËæìÂÖ•Êï∞ÊçÆ‰øùËØÅ1‚â§i &lt;j&lt;=N 2038: [2009ÂõΩÂÆ∂ÈõÜËÆ≠Èòü]Â∞èZÁöÑË¢úÂ≠ê(hose) Description ‰Ωú‰∏∫‰∏Ä‰∏™ÁîüÊ¥ªÊï£Êº´ÁöÑ‰∫∫ÔºåÂ∞èZÊØèÂ§©Êó©‰∏äÈÉΩË¶ÅËÄóË¥πÂæà‰πÖ‰ªé‰∏ÄÂ†Ü‰∫îÈ¢úÂÖ≠Ëâ≤ÁöÑË¢úÂ≠ê‰∏≠ÊâæÂá∫‰∏ÄÂèåÊù•Á©ø„ÄÇÁªà‰∫éÊúâ‰∏ÄÂ§©ÔºåÂ∞èZÂÜç‰πüÊó†Ê≥ïÂøçÂèóËøôÊÅº‰∫∫ÁöÑÊâæË¢úÂ≠êËøáÁ®ãÔºå‰∫éÊòØ‰ªñÂÜ≥ÂÆöÂê¨Â§©Áî±ÂëΩ‚Ä¶‚Ä¶ ÂÖ∑‰ΩìÊù•ËØ¥ÔºåÂ∞èZÊääËøôNÂè™Ë¢úÂ≠ê‰ªé1Âà∞NÁºñÂè∑ÔºåÁÑ∂Âêé‰ªéÁºñÂè∑LÂà∞R(L Â∞ΩÁÆ°Â∞èZÂπ∂‰∏çÂú®ÊÑè‰∏§Âè™Ë¢úÂ≠êÊòØ‰∏çÊòØÂÆåÊï¥ÁöÑ‰∏ÄÂèåÔºåÁîöËá≥‰∏çÂú®ÊÑè‰∏§Âè™Ë¢úÂ≠êÊòØÂê¶‰∏ÄÂ∑¶‰∏ÄÂè≥Ôºå‰ªñÂç¥ÂæàÂú®ÊÑèË¢úÂ≠êÁöÑÈ¢úËâ≤ÔºåÊØïÁ´üÁ©ø‰∏§Âè™‰∏çÂêåËâ≤ÁöÑË¢úÂ≠ê‰ºöÂæàÂ∞¥Â∞¨„ÄÇ ‰Ω†ÁöÑ‰ªªÂä°‰æøÊòØÂëäËØâÂ∞èZÔºå‰ªñÊúâÂ§öÂ§ßÁöÑÊ¶ÇÁéáÊäΩÂà∞‰∏§Âè™È¢úËâ≤Áõ∏ÂêåÁöÑË¢úÂ≠ê„ÄÇÂΩìÁÑ∂ÔºåÂ∞èZÂ∏åÊúõËøô‰∏™Ê¶ÇÁéáÂ∞ΩÈáèÈ´òÔºåÊâÄ‰ª•‰ªñÂèØËÉΩ‰ºöËØ¢ÈóÆÂ§ö‰∏™(L,R)‰ª•Êñπ‰æøËá™Â∑±ÈÄâÊã©„ÄÇ Input ËæìÂÖ•Êñá‰ª∂Á¨¨‰∏ÄË°åÂåÖÂê´‰∏§‰∏™Ê≠£Êï¥Êï∞NÂíåM„ÄÇN‰∏∫Ë¢úÂ≠êÁöÑÊï∞ÈáèÔºåM‰∏∫Â∞èZÊâÄÊèêÁöÑËØ¢ÈóÆÁöÑÊï∞Èáè„ÄÇÊé•‰∏ãÊù•‰∏ÄË°åÂåÖÂê´N‰∏™Ê≠£Êï¥Êï∞CiÔºåÂÖ∂‰∏≠CiË°®Á§∫Á¨¨iÂè™Ë¢úÂ≠êÁöÑÈ¢úËâ≤ÔºåÁõ∏ÂêåÁöÑÈ¢úËâ≤Áî®Áõ∏ÂêåÁöÑÊï∞Â≠óË°®Á§∫„ÄÇÂÜçÊé•‰∏ãÊù•MË°åÔºåÊØèË°å‰∏§‰∏™Ê≠£Êï¥Êï∞LÔºåRË°®Á§∫‰∏Ä‰∏™ËØ¢ÈóÆ„ÄÇ Output ÂåÖÂê´MË°åÔºåÂØπ‰∫éÊØè‰∏™ËØ¢ÈóÆÂú®‰∏ÄË°å‰∏≠ËæìÂá∫ÂàÜÊï∞A/BË°®Á§∫‰ªéËØ•ËØ¢ÈóÆÁöÑÂå∫Èó¥[L,R]‰∏≠ÈöèÊú∫ÊäΩÂá∫‰∏§Âè™Ë¢úÂ≠êÈ¢úËâ≤Áõ∏ÂêåÁöÑÊ¶ÇÁéá„ÄÇËã•ËØ•Ê¶ÇÁéá‰∏∫0ÂàôËæìÂá∫0/1ÔºåÂê¶ÂàôËæìÂá∫ÁöÑA/BÂøÖÈ°ª‰∏∫ÊúÄÁÆÄÂàÜÊï∞„ÄÇÔºàËØ¶ËßÅÊ†∑‰æãÔºâ Ê†∑‰æãËß£Èáä ËØ¢ÈóÆ1ÔºöÂÖ±C(5,2)=10ÁßçÂèØËÉΩÔºåÂÖ∂‰∏≠ÊäΩÂá∫‰∏§‰∏™2Êúâ1ÁßçÂèØËÉΩÔºåÊäΩÂá∫‰∏§‰∏™3Êúâ3ÁßçÂèØËÉΩÔºåÊ¶ÇÁéá‰∏∫(1+3)/10=4/10=2/5„ÄÇ ËØ¢ÈóÆ2ÔºöÂÖ±C(3,2)=3ÁßçÂèØËÉΩÔºåÊó†Ê≥ïÊäΩÂà∞È¢úËâ≤Áõ∏ÂêåÁöÑË¢úÂ≠êÔºåÊ¶ÇÁéá‰∏∫0/3=0/1„ÄÇ ËØ¢ÈóÆ3ÔºöÂÖ±C(3,2)=3ÁßçÂèØËÉΩÔºåÂùá‰∏∫ÊäΩÂá∫‰∏§‰∏™3ÔºåÊ¶ÇÁéá‰∏∫3/3=1/1„ÄÇ Ê≥®Ôºö‰∏äËø∞C(a, b)Ë°®Á§∫ÁªÑÂêàÊï∞ÔºåÁªÑÂêàÊï∞C(a, b)Á≠â‰ª∑‰∫éÂú®a‰∏™‰∏çÂêåÁöÑÁâ©ÂìÅ‰∏≠ÈÄâÂèñb‰∏™ÁöÑÈÄâÂèñÊñπÊ°àÊï∞„ÄÇ Êï∞ÊçÆËßÑÊ®°ÂíåÁ∫¶ÂÆö 30%ÁöÑÊï∞ÊçÆ‰∏≠ N,M ‚â§ 5000Ôºõ 60%ÁöÑÊï∞ÊçÆ‰∏≠ N,M ‚â§ 25000Ôºõ 100%ÁöÑÊï∞ÊçÆ‰∏≠ N,M ‚â§ 50000Ôºå1 ‚â§ L &lt; R ‚â§ NÔºåCi ‚â§ N„ÄÇ Âçï‰∏™ÊµãËØïÁÇπÊó∂Èôê2S ÂØπ‰∫é‰∏äËø∞ËøôÈÅìÈ¢òÔºå30%ÁöÑÊï∞ÊçÆÊàë‰ª¨ÂèØ‰ª•ÂØπ‰∫éÊØè‰∏™ËØ¢ÈóÆÈÉΩÊâ´ÊèèËØ¢ÈóÆÂå∫Èó¥‰∏≠ÊâÄÂ≠òÂú®ÁöÑÊï∞ÁÑ∂ÂêéËÆ°ÁÆóÔºåËøôÊ†∑ÂçïÊ¨°Â§çÊùÇÂ∫¶ÊòØO(N)ÁöÑÔºå‰ΩÜÊúâMÁöÑËØ¢ÈóÆÔºåÊÄªÂ§çÊùÇÂ∫¶ÊòØOÔºàMNÔºâ„ÄÇËøôÂ∞±ÊòæÂæóÊúâÁÇπ‰∏çÂ§™ËÉΩÊé•Âèó‰∫Ü„ÄÇ ‰ΩÜÊòØÂΩìÊàë‰ª¨Áü•ÈÅì‰∏Ä‰∏™ËØ¢ÈóÆ[l,r]ÁöÑÁ≠îÊ°àÂêéÔºå[l+1,r],[l-1,r],[l,r+1],[l,r-1]ËøôÂõõ‰∏™Âå∫Èó¥ÁöÑÁ≠îÊ°àÂèØ‰ª•ÈÄöËøáËÆ°ÁÆóÂÅöÂà∞O(1)ÁöÑÊó∂Èó¥ÂÜÖÂæóÂà∞ ÊâÄ‰ª•Êàë‰ª¨ÂèØ‰ª•ËÄÉËôëËé´ÈòüÁÆóÊ≥ïÔºåÂàÜ‰∏∫Â¶Ç‰∏ã‰∏âÊ≠•„ÄÇ 1„ÄÅÂàÜÂùó 2„ÄÅÊääÊâÄÊúâËØ¢ÈóÆÂ∑¶Á´ØÁÇπÊéíÂ∫è 3„ÄÅÂØπ‰∫éÂ∑¶Á´ØÁÇπÂú®Âêå‰∏ÄÂùóÂÜÖÁöÑËØ¢ÈóÆÊåâÂè≥Á´ØÁÇπÊéíÂ∫èÔºåÁÑ∂ÂêéÂàÜ‰∏âÁßçÊÉÖÂÜµÁªüËÆ°„ÄÇ ËÄåÂ§çÊùÇÂ∫¶Ê≠£Â¶ÇÁêÜËÆ∫ÈÉ®ÂàÜÊâÄËØ¥ÁöÑ‰∏ÄÊ†∑Ôºå ‰∏Ä„ÄÅi‰∏éi+1Âú®Âêå‰∏ÄÂùóÂÜÖÔºårÂçïË∞ÉÈÄíÂ¢ûÔºåÊâÄ‰ª•rÊòØO(N)ÁöÑ„ÄÇÁî±‰∫éÊúâsqrt(N)Âùó,ÊâÄ‰ª•Ëøô‰∏ÄÈÉ®ÂàÜÊó∂Èó¥Â§çÊùÇÂ∫¶ÊòØNsqrt(N)„ÄÇ ‰∫å„ÄÅi‰∏éi+1Ë∑®Ë∂ä‰∏ÄÂùóÔºårÊúÄÂ§öÂèòÂåñnÔºåÁî±‰∫éÊúâsqrt(N)ÂùóÔºåÊâÄ‰ª•Ëøô‰∏ÄÈÉ®ÂàÜÊó∂Èó¥Â§çÊùÇÂ∫¶ÊòØNsqrt(N) ‰∏â„ÄÅi‰∏éi+1Âú®Âêå‰∏ÄÂùóÂÜÖÊó∂ÂèòÂåñ‰∏çË∂ÖËøásqrt(N)ÔºåË∑®Ë∂ä‰∏ÄÂùó‰πü‰∏ç‰ºöË∂ÖËøá2* sqrt(N)Ôºå‰∏çÂ¶®Áúã‰ΩúÊòØsqrt(N)„ÄÇÁî±‰∫éÊúâN‰∏™Êï∞ÔºåÊâÄ‰ª•Êó∂Èó¥Â§çÊùÇÂ∫¶ÊòØO(Nsqrt(N)) ÂèØ‰ª•ËØÅÊòéÂ§çÊùÇÂ∫¶ÊòØO(Nsqrt(N))‰∫Ü ÁêÜËÆ∫2 ÂèØÁé∞Âú®ÊúâÂæàÂ§öÈóÆÈ¢òÈÉΩËÆæÁΩÆ‰∫Ü‰øÆÊîπÊìç‰ΩúÔºåÂØπ‰∫éËøôÁ±ªÊàë‰ª¨Êàë‰ª¨ÂèàËØ•Â¶Ç‰ΩïÂ§ÑÁêÜÂë¢Ôºü ‰æãÈ¢ò Êàë‰ª¨Áé∞Âú®Êúâ‰∏Ä‰∏™Èïø‰∏∫nÁöÑÔºåÂØπ‰∫éÂ∫èÂàóÔºåÊàë‰ª¨ÊúâmÊ¨°Êìç‰ΩúÔºåÊìç‰ΩúÂàÜ‰∏∫‰∏§Áßç 1„ÄÅËØ¢ÈóÆÂú®[l,r]‰∏≠ÊäΩÂà∞‰∏§‰∏™Êï∞Â≠óÁõ∏ÂêåÁöÑÊ¶ÇÁéá 2„ÄÅÊääÊüê‰∏™‰ΩçÁΩÆÁöÑÊï∞aiÊîπÊàêx 100%ÁöÑÊï∞ÊçÆ‰∏≠ N,M ‚â§100000Ôºå1 ‚â§ L &lt; R ‚â§ NÔºåCi ‚â§ N„ÄÇ Âçï‰∏™ÊµãËØïÁÇπÊó∂Èôê10S Êàë‰ª¨‰ºöÂèëÁé∞ÔºåÂä†‰∏ä‰∫Ü‰øÆÊîπÊìç‰ΩúÂêé„ÄÇÂ∞±Ê≤°ÂäûÊ≥ïÁõ¥Êé•ÊåâÁÖßÂàÜÂùóÊù•Â§ÑÁêÜËß£ÂÜ≥ËØ¢ÈóÆÁöÑÈ°∫Â∫è„ÄÇ ÂÆö‰πâB‰∏∫ÂàÜÂùóÁöÑÂ§ßÂ∞è„ÄÇ &gt; È¶ñÂÖàËÄÉËôëÊ≤°Êúâ‰øÆÊîπÊìç‰ΩúÔºåÈÇ£‰πàÂ∞±ÂíåÁêÜËÆ∫1‰∏≠Â∞èZÁöÑË¢úÂ≠ê‰∏ÄÊ†∑Ôºå‰ª§B = sqrt(n) „ÄÇÊääÊâÄÊúâËØ¢ÈóÆÂ∑¶Á´ØÁÇπÊéíÂ∫èÔºåÂØπ‰∫éÂ∑¶Á´ØÁÇπÂú®Âêå‰∏ÄÂùóÂÜÖÁöÑËØ¢ÈóÆÊåâÂè≥Á´ØÁÇπÊéíÂ∫è,ÁÑ∂ÂêéÂÜôËé´ÈòüÁÆóÊ≥ïÔºåÊåâÈ°∫Â∫èÊâ´ËØ¢ÈóÆÔºåËøôÊ†∑ÊòØO(n sqrt(n))„ÄÇÂ¶ÇÊûúÁé∞Âú®Âä†‰∏ä‰øÆÊîπÊìç‰ΩúËÄÉËôë‰∏Ä‰∏™ËØ¢ÈóÆ(l,r)ÔºåËøôÊ†∑ÊòØËÇØÂÆö‰∏çÂ§üÁöÑ„ÄÇ &gt; ‰∫éÊòØÂèòÊàêÔºö(l,r,ti)ÔºåtiÊòØËØ¢ÈóÆÊó∂ÁöÑÊó∂Èó¥ÔºåÂç≥ËøôÊ¨°ËØ¢ÈóÆÊòØÁ¨¨Âá†Ê¨°Êìç‰Ωú„ÄÇÊääÊâÄÊúâËØ¢ÈóÆÂ∑¶Á´ØÁÇπlÊéíÂ∫èÔºåÂØπ‰∫éÂ∑¶Á´ØÁÇπÂú®Âêå‰∏ÄÂùóÂÜÖÁöÑËØ¢ÈóÆÊåâÂè≥Á´ØÁÇπrÊâÄÂú®ÁöÑÂùóÊéíÂ∫èÔºåÂØπÂè≥Á´ØÁÇπrÊâÄÂú®ÂùóÁõ∏ÂêåÁöÑÊàë‰ª¨ÂÜçÊåâÁÖßÊó∂Èó¥tiÊéíÂ∫è„ÄÇ ÁÑ∂ÂêéÂÅöËé´ÈòüÁÆóÊ≥ïÔºåÊåâÈ°∫Â∫èÊâ´ËØ¢ÈóÆÔºåÊó∂Èó¥ÊúâÊó∂ÂêëÂâçÊúâÊó∂ÂÄíÊµÅ„ÄÇËøôÊ†∑‰ª§B = n ^ (2 / 3)ÔºåÂõ†‰∏∫Âú®ÊØè‰∏ÄÂùó‰∏≠Êó∂Èó¥ÊúÄÂ§ö‰ªé1Âà∞TÊîπÂèò‰∏ÄÊ¨°ÔºåËÆæËØ¢ÈóÆÊìç‰Ωúp1Ê¨°Ôºå‰øÆÊîπÊìç‰Ωúp2Ê¨°ÔºåÂàôÂú®ÊúÄÂ∑ÆÊÉÖÂÜµ‰∏ãÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶ÊòØO(p1 n^(2 / 3)+p2 n^(1 / 3) n^(1 / 3))=O(n^(5 / 3))„Äên‰∏émÁ≠â‰ª∑„ÄëÔºåËøôÂú®Êó∂Èôê‰∏ãÂü∫Êú¨ÊòØÂèØ‰ª•ÂæóÂà∞Á≠îÊ°àÁöÑ„ÄÇ &gt; ÈÇ£‰πàËøòÊúâ‰∏™ÈÅóÁïôÁöÑÈóÆÈ¢òÔºåÂ¶Ç‰ΩïÂ§ÑÁêÜÊó∂Èó¥„ÄÇÊàë‰ª¨Âè™ÈúÄË¶ÅËÆ∞ÂΩï‰øÆÊîπÂâçÂíå‰øÆÊîπÂêéËØ•ÁÇπÁöÑÂÄºÂ∞±ÂèØ‰ª•‰∫Ü„ÄÇ &gt; Ëá≥Ê≠§Ëøô‰∏™ÈóÆÈ¢òÂÆåÁæéËß£ÂÜ≥„ÄÇ ÊÄªÁªì ‰πüËÆ∏Ëé´ÈòüÊòØ‰∏ÄÁßçÁúãËµ∑Êù•Â§çÊùÇÂ∫¶ÈùûÂ∏∏È´òÁöÑÁÆóÊ≥ïÔºå‰ΩÜÂ¶ÇÊûúÂêàÁêÜÂú∞Â§ÑÁêÜÂ•ΩÂàÜÂùóÁöÑÂ§ßÂ∞èÂíåËØ¢ÈóÆÁöÑÈ°∫Â∫èÔºåÔºåÂÆÉ‰æøÂèØ‰ª•ÂèòÊàê‰∏Ä‰∏™ÊûÅÂÖ∂ÊúâÊïàÁöÑÂ∑•ÂÖ∑„ÄÇ ËæûË∞¢ Vfleaking„ÄÅËé´Ê∂õ ÂèÇËÄÉÊñáÁåÆ ÂõΩÂÆ∂ÈõÜËÆ≠ÈòüÂëΩÈ¢ò„ÄäÂ∞èzÁöÑË¢úÂ≠ê„Äã]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Êö¥Âäõ</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Ëé´Èòü</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 617E XOR and Favorite Number]]></title>
    <url>%2F2017%2F07%2F13%2FCodeForces-617E-XOR-and-Favorite-Number%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ Bob has a favorite number k and *a**i* of length n. Now he asks you to answer m queries. Each query is given by a pair *l**i* and *r**i* and asks you to count the number of pairs of integers i and j, such that l ‚â§ i ‚â§ j ‚â§ r and the xor of the numbers ai, ai + 1, ..., *a**j* is equal to k. Input The first line of the input contains integers n, m and k (1 ‚â§ n, m ‚â§ 100 000, 0 ‚â§ k ‚â§ 1 000 000) ‚Äî the length of the array, the number of queries and Bob's favorite number respectively. The second line contains n integers *a**i* (0 ‚â§ *a**i* ‚â§ 1 000 000) ‚Äî Bob's array. Then m lines follow. The i-th line contains integers *l**i* and *r**i* (1 ‚â§ li ‚â§ ri ‚â§ n) ‚Äî the parameters of the i-th query. Output Print m lines, answer the queries in the order they appear in the input. Examples input 6 2 3 1 2 1 1 0 3 1 6 3 5 output 7 0 input 5 3 1 1 1 1 1 1 1 5 2 4 1 3 output 9 4 4 Note In the first sample the suitable pairs of i and j for the first query are: (1, 2), (1, 4), (1, 5), (2, 3), (3, 6), (5, 6), (6, 6). Not a single of these pairs is suitable for the second query. In the second sample xor equals 1 for all subarrays of an odd length. ÂàÜÊûê Â§öÊ¨°ËØ¢ÈóÆÊ≤°Êúâ‰øÆÊîπÔºåÂÖ∏ÂûãÁöÑËé´ÈòüÈóÆÈ¢ò„ÄÇ ÂàöÂ≠¶Ëé´ÈòüÁöÑÁ¨¨‰∏ÄÈÅìÈ¢òÁõÆÊâÄ‰ª•ËÆ≤ÁÆÄÂçïÁöÑ‰ªãÁªç‰∏Ä‰∏ã ‰º†ÈÄÅÈó® cnt[]Ë°®Á§∫cnt[Âú®[l - 1, r]‰πãÈó¥Âá∫Áé∞ÁöÑÂâçÁºÄ]Âú®[l - 1, r]‰πãÈó¥Âá∫Áé∞ÁöÑÁöÑÊï∞Èáè È¶ñÂÖàÂ§ÑÁêÜÂ•ΩÂâçÁºÄÂºÇÊàñÂíåÔºåÊ≥®ÊÑèÂ§ÑÁêÜÁöÑÊï∞ÊçÆÊòØ[l - 1, r]Âõ†‰∏∫‰∫ãÂÆû‰∏äËøôÈáåÁöÑËé´ÈòüËá™Â∏¶Â∑¶ÂºÄÂè≥Èó≠Â±ûÊÄß(Áî±‰∫éÁî®ÂâçÁºÄÂíåÂ§ÑÁêÜ)ÔºåÂú®ËøôÈáåÂç°‰∫ÜÂæà‰πÖ„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** @Author: sun000* @Date: 2017-07-13 10:13:19* @Last Modified by: sun000* @Last Modified time: 2017-07-13 15:54:49*/#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e5 +10;int n, m, block = 1;int cnt[1048586];long long int num[MAXN];long long int k;struct SEC &#123; int l, r, id; long long int ans; SEC()&#123;&#125;&#125;sec[MAXN];bool cmp_block(SEC a, SEC b) &#123; if(a.l / block == b.l / block) return a.r &lt; b.r; return a.l &lt; b.l;&#125;bool cmp_id(SEC a, SEC b) &#123; return a.id &lt; b.id;&#125;long long int nans;void plus(int in) &#123; nans += cnt[num[in] ^ k]; cnt[num[in]]++;&#125;void dec(int in) &#123; cnt[num[in]]--; nans -= cnt[num[in] ^ k];&#125;int main(void) &#123; memset(cnt, 0, sizeof(cnt)); scanf("%d%d%lld", &amp;n, &amp;m, &amp;k); block = (int)sqrt(n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%lld", &amp;num[i]); num[i] ^= num[i - 1]; &#125; for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d", &amp;sec[i].l, &amp;sec[i].r); sec[i].id = i; sec[i].l--;//Êü•ËØ¢[l,r]ÊòØnum[r]ÂâçÁºÄ‰∏énum[l - 1]ÂâçÁºÄÂ§ÑÁêÜÁöÑÁªìÊûú sec[i].ans = 0; &#125; sort(sec, sec + m, cmp_block); int l = 0, r = 0; nans = 0, cnt[0] = 1; for(int i = 0; i &lt; m; i++) &#123; while(l &gt; sec[i].l) plus(--l); while(r &lt; sec[i].r) plus(++r); while(l &lt; sec[i].l) dec(l++); while(r &gt; sec[i].r) dec(r--); sec[i].ans = nans; &#125; sort(sec, sec + m, cmp_id); for(int i = 0; i &lt; m; i++) printf("%lld\n", sec[i].ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Êö¥Âäõ</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Ëé´Èòü</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces161D Distance in Tree]]></title>
    <url>%2F2017%2F07%2F09%2FCodeForces161D-Distance-in-Tree%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ A tree is a connected graph that doesn't contain any cycles. The distance between two vertices of a tree is the length (in edges) of the shortest path between these vertices. You are given a tree with n vertices and a positive number k. Find the number of distinct pairs of the vertices which have a distance of exactly k between them. Note that pairs (v, u) and (u, v) are considered to be the same pair. Input The first line contains two integers n and k (1 ‚â§ n ‚â§ 50000, 1 ‚â§ k ‚â§ 500) ‚Äî the number of vertices and the required distance between the vertices. Next n - 1 lines describe the edges as &quot;*a**i* bi&quot; (without the quotes) (1 ‚â§ ai, bi ‚â§ n, ai ‚â† bi), where ai and *b**i* are the vertices connected by the i-th edge. All given edges are different. Output Print a single integer ‚Äî the number of distinct pairs of the tree's vertices which have a distance of exactly k between them. Please do not use the %lld specifier to read or write 64-bit integers in –°++. It is preferred to use the cin, cout streams or the %I64dspecifier. Examples input 5 2 1 2 2 3 3 4 2 5 output 4 input 5 3 1 2 2 3 3 4 4 5 output 2 Note In the first sample the pairs of vertexes at distance 2 from each other are (1, 3), (1, 5), (3, 5) and (2, 4). ÂàÜÊûê ÂÆö‰πâ‰∏Ä‰∏™dp[i][j]Ë°®Á§∫iÁöÑÂ≠êÊ†ë‰∏≠Ë∑ùÁ¶ªiÁöÑË∑ùÁ¶ª‰∏∫jÁöÑÁÇπÁöÑ‰∏™Êï∞„ÄÇÁî®‰∏Ä‰∏™dfsÊ±ÇdpÁöÑÂÄºÔºåÁÑ∂ÂêéÊ±ÇÁ≠îÊ°àÔºåÂàôiÂ≠êÊ†ë‰∏≠ÂåÖÂê´ÁöÑans=sum{dp[son[i]][j - 1] * (dp[i][k - j] - dp[son[i]][k - j - 1])} Ê≥®ÊÑèÊï∞ÊçÆËåÉÂõ¥long long ans ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** @Author: sun000* @Date: 2017-07-09 11:05:44* @Last Modified by: sun000* @Last Modified time: 2017-07-09 12:58:06*/#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int dp[50010][505];vector&lt;int&gt; e[50010];int n, k;long long int ans;void addedge(int u, int v) &#123; e[u].push_back(v); e[v].push_back(u);&#125;void dfs(int s, int pre) &#123; int u, v; if(e[s].size() == 1 &amp;&amp; e[s][0] == pre) return; for(int i = 0; i &lt; e[s].size(); i++) &#123; v = e[s][i]; if(v != pre) &#123; dfs(v, s); for(int j = 1; j &lt;= k; j++) dp[s][j] += dp[v][j - 1]; &#125; &#125; long long int temp = 0; for(int i = 0; i &lt; e[s].size(); i++) &#123; u = e[s][i]; if (u != pre) &#123; temp += dp[u][k - 1] * 2; for(int l = 1; l &lt; k; l++) temp += dp[u][l - 1] * (dp[s][k - l] - dp[u][k - l - 1]); &#125; &#125; ans += temp / 2;&#125;void debug() &#123; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= k; j++) printf("dp[%d][%d] = %d\n", i, j, dp[i][j]);&#125;int main(void)&#123; int u, v; scanf("%d%d", &amp;n, &amp;k); for(int i = 0; i &lt; n - 1; i++) &#123; scanf("%d%d", &amp;u, &amp;v); addedge(u, v); &#125; if(k == 1) &#123; printf("%d\n", n - 1); return 0; &#125; memset(dp, 0, sizeof(dp)); for(int i = 1; i &lt;= n; i++) dp[i][0] = 1; ans = 0; dfs(1, 0); // debug(); printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>Ê†ëÂΩ¢DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces13E Holes]]></title>
    <url>%2F2017%2F07%2F09%2FCodeForces13E-Holes%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ Little Petya likes to play a lot. Most of all he likes to play a game ¬´Holes¬ª. This is a game for one person with following rules: There are N holes located in a single row and numbered from left to right with numbers from 1 to N. Each hole has it's own power (hole number i has the power a i). If you throw a ball into hole i it will immediately jump to hole i + a i, then it will jump out of it and so on. If there is no hole with such number, the ball will just jump out of the row. On each of the M moves the player can perform one of two actions: Set the power of the hole a to value b. Throw a ball into the hole a and count the number of jumps of a ball before it jump out of the row and also write down the number of the hole from which it jumped out just before leaving the row. Petya is not good at math, so, as you have already guessed, you are to perform all computations. Input The first line contains two integers N and M (1 ‚â§ N ‚â§ 105, 1 ‚â§ M ‚â§ 105) ‚Äî the number of holes in a row and the number of moves. The second line contains N positive integers not exceeding N ‚Äî initial values of holes power. The following M lines describe moves made by Petya. Each of these line can be one of the two types: 0 a b 1 a Type 0 means that it is required to set the power of hole a to b, and type 1 means that it is required to throw a ball into the a-th hole. Numbers a and b are positive integers do not exceeding N. Output For each move of the type 1 output two space-separated numbers on a separate line ‚Äî the number of the last hole the ball visited before leaving the row and the number of jumps it made. Examples input 8 5 1 1 1 1 1 2 8 2 1 1 0 1 3 1 1 0 3 4 1 2 output 8 7 8 5 7 3 ÂàÜÊûê ÂàÜÂùóÂ§ÑÁêÜÔºåÊääÊØè‰∏Ä‰∏™ÁªôÂÆöÁöÑÊï∞ÁªÑÂàÜÊàêkÂùóÔºåÂàôÂè™Ë¶ÅÊõ¥Êñ∞ÁöÑÊó∂ÂÄôÂè™Ë¶ÅÊõ¥Êñ∞ÂùóÂÜÖÂ∞±Â•Ω‰∫ÜÔºåÊü•ËØ¢ÁöÑÊó∂ÂÄôÊü•ËØ¢ÊâÄÊúâÂùóÔºåÊØè‰∏™ÂùóÂÜÖÊü•ËØ¢Êó∂Èó¥Â§çÊùÇÂ∫¶ÊòØo(1)ÔºåÂàôÊü•ËØ¢ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶ÊòØnÔºèk„ÄÇËøôÊ†∑ÁöÑËØùÔºåÊÄªÊó∂Èó¥Â§çÊùÇÂ∫¶ÊòØo(m*(k+n / k)), ÊòæÁÑ∂ÔºåÂΩìkÊòØ‚àönÁöÑÊó∂ÂÄôÊúÄ‰ºòÔºåÊ≠§Êó∂ÁöÑÊó∂Èó¥Â§çÊùÇÁöÑÊòØm‚àön ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** @Author: sun000* @Date: 2017-07-09 08:08:59* @Last Modified by: sun000* @Last Modified time: 2017-07-09 09:24:56*/#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e5 + 10;int n, m, block;int p[MAXN];int cnt[MAXN];//‰ªéiË∑≥Âá∫ÂΩìÂâçÂùóÁöÑÊ≠•Êï∞int la[MAXN];//‰ªéË∑≥Âá∫ÂΩìÂâç‰ΩçÁΩÆÂú®ËØ•Âùó‰∏≠ÁªèËøáÁöÑÊúÄÂêé‰∏Ä‰∏™‰ΩçÁΩÆvoid update_one(int a, int b) &#123;//Êõ¥Êñ∞‰∏Ä‰∏™‰∏ãÊ†á if(b &gt;= n) &#123;//Ë∑≥Âá∫ la[a] = a; cnt[a] = 1; &#125; else if(a / block == b / block) &#123;//Âêå‰∏Ä‰∏™Âùó‰∏≠ cnt[a] = cnt[b] + 1; la[a] = la[b]; &#125; else &#123;//Ë∑≥Âà∞ÂÖ∂‰ªñÂùó cnt[a] = 1; la[a] = a; &#125;&#125;void update(int a, int b) &#123;//Êõ¥Êñ∞ÊâÄÊúâÔºåÂç≥Êõ¥Êñ∞ÂΩìÂâçÊÆµ p[a] = b; int now = a / block * block; for(int i = a; i &gt;= now; i--) &#123; update_one(i, i + p[i]); &#125;&#125;void init() &#123; for(int i = n - 1; i &gt;= 0; i--) update_one(i, i + p[i]);&#125;int las;int query(int a) &#123; if(la[a] + p[la[a]] &gt;= n) &#123; las = la[a] + 1; return cnt[a]; &#125; else return cnt[a] + query(la[a] + p[la[a]]);&#125;void debug() &#123; for(int i = 0; i &lt; n; i++) printf("%d ", cnt[i]); printf("\n"); for(int i = 0; i &lt; n; i++) printf("%d ", la[i]); printf("\n");&#125;int main(void)&#123; scanf("%d%d", &amp;n, &amp;m); block = (int)sqrt(n); for(int i = 0; i &lt; n; i++) scanf("%d", &amp;p[i]); init(); // printf("block %d\n", block); // debug(); int op, a, b; for(int i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;op); if(!op) &#123; scanf("%d%d", &amp;a, &amp;b); update(a - 1, b); &#125; else &#123; scanf("%d", &amp;a); int ans = query(a - 1); printf("%d %d\n", las, ans); &#125; // debug(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>ÂàÜÂùó</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces546E Soldier and Traveling]]></title>
    <url>%2F2017%2F07%2F08%2FCodeForces546E-Soldier-and-Traveling%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ In the country there are n cities and m bidirectional roads between them. Each city has an army. Army of the i-th city consists of *a**i*soldiers. Now soldiers roam. After roaming each soldier has to either stay in his city or to go to the one of neighboring cities by at moving along at most one road. Check if is it possible that after roaming there will be exactly *b**i* soldiers in the i-th city. Input First line of input consists of two integers n and m (1 ‚â§ n ‚â§ 100, 0 ‚â§ m ‚â§ 200). Next line contains n integers a1, a2, ..., *a**n* (0 ‚â§ *a**i* ‚â§ 100). Next line contains n integers b1, b2, ..., *b**n* (0 ‚â§ *b**i* ‚â§ 100). Then m lines follow, each of them consists of two integers p and q (1 ‚â§ p, q ‚â§ n, p ‚â† q) denoting that there is an undirected road between cities p and q. It is guaranteed that there is at most one road between each pair of cities. Output If the conditions can not be met output single word &quot;NO&quot;. Otherwise output word &quot;YES&quot; and then n lines, each of them consisting of n integers. Number in the i-th line in the j-th column should denote how many soldiers should road from city i to city j (if i ‚â† j) or how many soldiers should stay in city i (if i = j). If there are several possible answers you may output any of them. Examples input 4 4 1 2 6 3 3 5 3 1 1 2 2 3 3 4 4 2 output YES 1 0 0 0 2 0 0 0 0 5 1 0 0 0 2 1 input 2 0 1 2 2 1 output NO ÂàÜÊûê ÂÉèËøôÁßçÁî±aÁä∂ÊÄÅËΩ¨ÁßªÂà∞Áä∂ÊÄÅÁöÑÈÉΩÂèØ‰ª•Áî®ÁΩëÁªúÊµÅÊù•ÂÜôÔºåÊ∫êÁÇπ0Âà∞[1,n]Ëøô‰∫õÁÇπÁöÑÊµÅÈáèÂàÜÂà´ÊòØa[i],[n + 1, 2n]Âà∞Ê±áÁÇπ2n + 1ÁöÑÊµÅÈáèÂàÜÂà´ÊòØb[i - n];(Â£´ÂÖµÂè™ËÉΩÊµÅÂä®‰∏ÄÊ¨°ÊâÄ‰ª•ÊãÜÁÇπ)„ÄÇÂú®ÁÇπiÂíåi+n‰πãÈó¥ËøûËæπÊµÅÈáèÊó†ÈôêÂ§ßÔºåÂç≥Â£´ÂÖµÂú®Ëá™Â∑±ÁöÑÂüéÂ∏Ç‰∏çÁßªÂä®ÔºåËã•ÂüéÂ∏ÇÈó¥ÊúâËæπ[i,j]ÂàôÂú®ÁΩëÁªúÊµÅÁöÑÂõæ‰∏≠ËøûËæπ[i, j + n]Âíå[j, i + n]ÔºåËæπÁöÑÊµÅÈáèÈÉΩÊòØÊó†ÈôêÂ§ß„ÄÇÊúÄÂêéÂè™Ë¶ÅÂà§Êñ≠ÊúÄÂ§ßÊµÅÊòØ‰∏çÊòØÁ≠â‰∫éÂºÄÂßãÁä∂ÊÄÅÁöÑÂ£´ÂÖµÂíåÂπ∂Á≠â‰∫éÁªìÊùüÁä∂ÊÄÅÁöÑÂ£´ÂÖµÂíåÔºåÂ¶ÇÊûúÁ≠îÊ°àÂèØË°åË¶ÅËæìÂá∫ÊµÅÁöÑÊñπÂºèÔºåÂàôÂè™Ë¶ÅËæìÂá∫ÊÆãÈáèÁΩëÁªú‰∏≠ÁöÑÂèçÂêëËæπÊµÅÈáèÂ∞±Â•Ω‰∫ÜÔºåË°®Á§∫Áî®ÊéâÁöÑÊµÅÈáè„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/** @Author: sun000* @Date: 2017-07-08 16:15:42* @Last Modified by: sun000* @Last Modified time: 2017-07-08 21:41:12*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int MAXN = 210;const int INF = 0x3f3f3f3f;struct node &#123; int u, v, next, flow;&#125;;node edge[MAXN * MAXN];int head[MAXN], dis[MAXN];int cnt;//ËæπÊï∞void init() &#123; memset(head, -1, sizeof(head)); memset(dis, -1, sizeof(dis)); cnt = 0;&#125;void addedge(int a, int b, int c) &#123; edge[cnt].u = a; edge[cnt].v = b; edge[cnt].flow = c; edge[cnt].next = head[a]; head[a] = cnt++;//ÂèçÂêëËæπ(ÂÅ∂Êï∞‰∏ãÊ†áÊ≠£ÂêëËæπÔºåÂ•áÊï∞‰∏ãÊ†áÂèçÂêëËæπ) edge[cnt].u = b; edge[cnt].v = a; edge[cnt].flow = 0; edge[cnt].next = head[b]; head[b] = cnt++;&#125;bool bfs(int sp, int tp) &#123;// ÁªôÂêÑÁÇπÂàÜÂ±ÇÔºåÁ¶ªÊ∫êÁÇπÁöÑËøúËøëÂàÜ memset(dis, -1, sizeof(dis)); queue&lt;int&gt; q; dis[sp] = 0; q.push(sp); int cur; while(!q.empty()) &#123; cur = q.front(); q.pop(); for(int i = head[cur]; i != -1; i = edge[i].next) &#123; if (dis[edge[i].v] == -1 &amp;&amp; edge[i].flow &gt; 0) &#123; dis[edge[i].v] = dis[cur] + 1; q.push(edge[i].v); &#125; &#125; &#125; if (dis[tp] &lt; 0) return false; return true;&#125;int Find(int x, int low, int tp) &#123; //ÊâæÂ¢ûÂπø int temp; if (x == tp) return low; for (int i = head[x]; i != -1; i = edge[i].next) &#123; int v = edge[i].v; if (dis[v] == dis[x] + 1 &amp;&amp; edge[i].flow &gt; 0 &amp;&amp; (temp = Find(v, min(low, edge[i].flow), tp))) &#123; edge[i].flow -= temp; edge[i ^ 1].flow += temp; return temp; &#125; &#125; return 0;&#125;int dinic(int sp, int tp) &#123; int ans = 0; while (bfs(sp, tp)) ans += Find(sp, INF, tp); return ans;&#125;int main(void) &#123; int n, m, temp, u, v; int sum1 = 0, sum2 = 0; scanf("%d%d", &amp;n, &amp;m); init(); int sp = 0;//Ê∫êÁÇπ int tp = 2 * n + 1;//Ê±áÁÇπ for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;temp); addedge(sp, i, temp); sum1 += temp; addedge(i, i + n, INF); &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;temp); sum2 += temp; addedge(i + n, tp, temp); &#125; for (int i = 0; i &lt; m; i++) &#123; scanf("%d%d", &amp;u, &amp;v); addedge(u, v + n, INF); addedge(v , u + n, INF); &#125; int ans = dinic(sp, tp); if (ans == sum1 &amp;&amp; ans == sum2) &#123; printf("YES\n"); int g[110][110], r; memset(g, 0, sizeof(g)); for(int i = 1; i &lt; cnt; i += 2) &#123; u = edge[i].u; v = edge[i].v; r = edge[i].flow; if(u &gt; n) u -= n; if(v &gt; n) v -= n; g[v][u] = r; &#125; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) printf("%d%c", g[i][j], j == n ? '\n' : ' '); &#125; else printf("NO\n"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>ÂõæËÆ∫</tag>
        <tag>Âª∫Âõæ</tag>
        <tag>ÁΩëÁªúÊµÅ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces754D Fedor and coupons]]></title>
    <url>%2F2017%2F07%2F08%2FCodeForces754DFedor-and-coupons%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ All our characters have hobbies. The same is true for Fedor. He enjoys shopping in the neighboring supermarket. The goods in the supermarket have unique integer ids. Also, for every integer there is a product with id equal to this integer. Fedor has ndiscount coupons, the i-th of them can be used with products with ids ranging from *l**i* to *r**i, inclusive. Today Fedor wants to take exactly k*coupons with him. Fedor wants to choose the k coupons in such a way that the number of such products x that all coupons can be used with this product xis as large as possible (for better understanding, see examples). Fedor wants to save his time as well, so he asks you to choose coupons for him. Help Fedor! Input The first line contains two integers n and k (1 ‚â§ k ‚â§ n ‚â§ 3¬∑105) ‚Äî the number of coupons Fedor has, and the number of coupons he wants to choose. Each of the next n lines contains two integers *l**i* and *r**i* ( - 109 ‚â§ li ‚â§ ri ‚â§ 109) ‚Äî the description of the i-th coupon. The coupons can be equal. Output In the first line print single integer ‚Äî the maximum number of products with which all the chosen coupons can be used. The products with which at least one coupon cannot be used shouldn't be counted. In the second line print k distinct integers p1, p2, ..., *p**k* (1 ‚â§ *p**i ‚â§ n*) ‚Äî the ids of the coupons which Fedor should choose. If there are multiple answers, print any of them. Examples input 4 2 1 100 40 70 120 130 125 180 output 31 1 2 input 3 2 1 12 15 20 25 30 output 0 1 2 input 5 2 1 10 5 15 14 50 30 70 99 100 output 21 3 4 Note In the first example if we take the first two coupons then all the products with ids in range [40, 70] can be bought with both coupons. There are 31 products in total. In the second example, no product can be bought with two coupons, that is why the answer is 0. Fedor can choose any two coupons in this example. ÂàÜÊûê Ë¥™ÂøÉÔºöËã•Â≠òÂú®Á≠îÊ°àÔºåÂàôÊòæÁÑ∂Ëøô‰∫õÂå∫Èó¥ÊòØÁõ∏ÈÇªÁöÑÔºåËøôÊòØÊúÄ‰ºòÁöÑ„ÄÇ Â∞ÜÂå∫Èó¥[l,r]ÊåâÁÖßl‰ªéÂ∞èÂà∞ËææÊéíÂ∫èÔºåÂ∞ÜÂå∫Èó¥ÊîæÂà∞‰∏Ä‰∏™ÂÖ≥‰∫érÁöÑÊúÄÂ∞èÂ†ÜÈáåÔºåÂàôÁª¥Êä§‰∏Ä‰∏™Â§ßÂ∞è‰∏∫kÁöÑÊúÄÂ∞èÂ†ÜÔºåÊúâ‰∏Ä‰∏™Âå∫Èó¥[l0,r0]ÔºåÂ∞ÜËøô‰∏™Âå∫Èó¥ÊîæÂÖ•Â†Ü‰∏≠ÂêéÔºåÂ∞ÜÂ†Ü‰∏≠ÊâÄÊúârÂ∞è‰∫él0ÁöÑÂå∫Èó¥popÔºåÂΩìÂ†ÜÁöÑÂ§ßÂ∞èÂ∞è‰∫ékÊó∂Ôºå‰∏çÊª°Ë∂≥Ë¶ÅÊ±ÇÔºõÂΩìÂ†ÜÁöÑÂ§ßÂ∞èÊòØkÊó∂ÔºåÊòæÁÑ∂Ëøô‰∫õÂå∫Èó¥ÊòØÊª°Ë∂≥Ë¶ÅÊ±ÇÁöÑÔºåÊ±ÇÂæó‰∏Ä‰∏™Á≠îÊ°à‰∫é‰∏éÂéüÁ≠îÊ°àÂèñMaxÔºõËã•Â†ÜÁöÑÂ§ßÂ∞èÂ§ß‰∫ékÊó∂ÔºåÂàôpop‰∏Ä‰∏™Âå∫Èó¥ÔºàËøô‰∏™Âå∫Èó¥ÊòØrÊúÄÂ∞èÁöÑÔºåÊòæÁÑ∂ËøôÊ†∑ÊòØÊúÄ‰ºòÁöÑÔºåËøô‰πüÊòØ‰∏Ä‰∏™Ë¥™ÂøÉÔºâ„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** @Author: sun000* @Date: 2017-07-08 14:31:47* @Last Modified by: sun000* @Last Modified time: 2017-07-08 15:14:45*/#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 3e5 + 10;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;struct SEC &#123; int l, r, in; SEC() &#123;&#125; SEC(int _l, int _r): l(_l), r(_r) &#123;&#125; bool operator &lt; (const SEC &amp;s) const &#123;//Áî®‰∫ésortÊéíÂ∫è return l &lt; s.l; &#125; bool operator &gt; (const SEC &amp;s) const &#123;//Áî®‰∫é‰ºòÂÖàÈòüÂàóÊéíÂ∫è return r &gt; s.r; &#125;&#125; sec[MAXN];int main(void)&#123; int n, k, ans = 0; scanf("%d%d", &amp;n, &amp;k); for (int i = 0; i &lt; n; i++) &#123; scanf("%d%d", &amp;sec[i].l, &amp;sec[i].r); sec[i].in = i + 1; &#125; sort(sec, sec + n); for (int i = 0; i &lt; n; i++) &#123; while (!q.empty() &amp;&amp; q.top() &lt; sec[i].l) q.pop(); q.push(sec[i].r); while (q.size() &gt; k) q.pop(); if (q.size() == k) ans = max(ans, q.top() - sec[i].l + 1); &#125; printf("%d\n", ans); if (!ans) for (int i = 0; i &lt; k; i++) printf("%d%c", i + 1, i == k - 1 ? '\n' : ' '); else &#123; int temp = 0; priority_queue&lt;SEC, vector&lt;SEC&gt;, greater&lt;SEC&gt;&gt; g; for (int i = 0; i &lt; n; i++) &#123; while (!g.empty() &amp;&amp; (g.top()).r &lt; sec[i].l) g.pop(); g.push(sec[i]); while (g.size() &gt; k) g.pop(); if (g.size() == k) &#123; temp = max(temp, (g.top()).r - sec[i].l + 1); if (temp == ans) &#123; for (int j = 0; j &lt; k; j++) &#123; printf("%d%c", (g.top()).in, j == k - 1 ? '\n' : ' '); g.pop(); &#125; break; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Ë¥™ÂøÉ</tag>
        <tag>‰ºòÂÖàÈòüÂàó</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces755F PolandBall and Gifts]]></title>
    <url>%2F2017%2F07%2F08%2FCodeForces755F-PolandBall-and-Gifts%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ It's Christmas time! PolandBall and his friends will be giving themselves gifts. There are n Balls overall. Each Ball has someone for whom he should bring a present according to some permutation p, *p**i ‚â† i* for all i. Unfortunately, Balls are quite clumsy. We know earlier that exactly k of them will forget to bring their gift. A Ball number i will get his present if the following two constraints will hold: Ball number i will bring the present he should give. Ball x such that *p**x = i* will bring his present. What is minimum and maximum possible number of kids who will not get their present if exactly k Balls will forget theirs? Input The first line of input contains two integers n and k (2 ‚â§ n ‚â§ 106, 0 ‚â§ k ‚â§ n), representing the number of Balls and the number of Balls who will forget to bring their presents. The second line contains the permutation p of integers from 1 to n, where *p**i* is the index of Ball who should get a gift from the i-th Ball. For all i, *p**i ‚â† i* holds. Output You should output two values ‚Äî minimum and maximum possible number of Balls who will not get their presents, in that order. Examples input 5 2 3 4 1 5 2 output 2 4 input 10 1 2 3 4 5 6 7 8 9 10 1 output 2 2 Note In the first sample, if the third and the first balls will forget to bring their presents, they will be th only balls not getting a present. Thus the minimum answer is 2. However, if the first ans the second balls will forget to bring their presents, then only the fifth ball will get a present. So, the maximum answer is 4. ÂàÜÊûê Âª∫ÂõæÔºöËÆæaË¶ÅÁªôbÂ∏¶Á§ºÁâ©ÔºåÂàôÂú®Âú®a-&gt;b‰πãÈó¥Ëøû‰∏ÄÊù°ÊúâÂêëËæπÔºå ÂàôÊúÄÂêéÁöÑÂõæÊòØËã•Âπ≤‰∏™ÁéØÔºåÂπ∂‰∏îÊØè‰∏Ä‰∏™ËäÇÁÇπÁöÑÂÖ•Â∫¶ÂíåÂá∫Â∫¶ÈÉΩÊòØ1ÔºåÂç≥ÊØè‰∏™ÁéØ‰πãÈó¥Ê≤°Êúâ‰∫§ÁÇπÔºåÂõ†‰∏∫ÊØè‰∏™Ê≤°ÊúâÂ∏¶Á§ºÁâ©ÁöÑ‰∫∫‰ºöÂØºËá¥Ë¶Å‰ªé‰ªñÁùÄËé∑ÂæóÁ§ºÁâ©ÁöÑ‰∫∫Âíå‰ªñËá™Â∑±ÈÉΩÊ≤°ÊúâÁ§ºÁâ©ÔºåÂàôÊúÄÂùèÊÉÖÂÜµÊòØ‰∏Ä‰∏™Ë¥™ÂøÉÔºöÂ∞ΩÈáè‰Ωø‰∏Ä‰∏™Ê≤°Â∏¶Á§ºÁâ©ÁöÑ‰∫∫ÂØºËá¥‰∏§‰∏™‰∫∫‰∏çËÉΩÊî∂Âà∞Á§ºÁâ©„ÄÇÊúÄÂ∞èÁöÑÊÉÖÂÜµÁöÑËØùÔºåÂ∞±ÊòØ‰ΩøË¶Å‰ªéÊ≤°Â∏¶Á§ºÁâ©ÁöÑ‰∫∫ÈÇ£ÈáåËé∑ÂæóÁ§ºÁâ©ÁöÑ‰∫∫Ëá™Â∑±‰πüÊ≤°ÊúâÂ∏¶Á§ºÁâ©ÔºåÂàôËøôÊ†∑ÁöÑËØùÂ∞±ÊòØÂ∞ΩÈáèÈÄâÊã©‰∏Ä‰∫õÂú®Âõæ‰∏≠ËøûÁª≠ÁöÑÁÇπ‰πàÔºåËøôÊ†∑ÁöÑËØùÊ≥®ÊÑèÂà∞Ëøô‰∏™Â∫èÂàóÁöÑÊúÄÂêé‰∏Ä‰∏™ÁÇπ‰ºöÂØºËá¥‰ªñÁöÑ‰∏ã‰∏Ä‰∏™ÁÇπ‰πüÊî∂‰∏çÂà∞Á§ºÁâ©ÔºåËøôÊ†∑ÁöÑËØùÂèØ‰ºöÂØºËá¥Â§ö‰∏Ä‰∏™‰∫∫Êî∂‰∏çÂà∞Á§ºÁâ©Ôºå‰ΩÜÊòØÂ¶ÇÊûúËøô‰∏™Â∫èÂàóÂàöÂ•ΩÊòØ‰∏Ä‰∏™ÁéØÁöÑËØùÔºåÂàôÊ≤°ÊúâËøôÁßçÊÉÖÂÜµÔºåÁªºÂêàËÄÉËôëÔºåËøô‰∏™Â∫èÂàóÂèØ‰ª•Â∞ΩÈáèÈÄâÊã©‰∏Ä‰∫õÁéØÔºåÂàôÂ¶ÇÊûúÊÅ∞Â•ΩÂ≠òÂú®‰∏Ä‰∫õÁéØÁöÑÁÇπÊï∞Âíå‰∏∫kÁöÑËØùÊúÄÂ∞èÁ≠îÊ°àÂ∞±ÊòØkÂê¶ÂàôÂ∞±ÊòØk+1ÔºåËøôÊ†∑ÁöÑËØùÈóÆÈ¢òÂ∞±ÂèòÊàêÈáåÊ±ÇÁªôÂÆöÁöÑ‰∏Ä‰∫õÁéØÊòØÂê¶ËÉΩÊÅ∞Â•ΩÊ±ÇÂíåÊàêkÔºåËøôÊòØ‰∏Ä‰∏™Â§öÈáçËÉåÂåÖÔºåËÄÉËôëÂà∞Êó∂Èó¥Â§çÊùÇÂ∫¶ÔºåÈúÄË¶ÅÁî®‰∫åËøõÂà∂‰ºòÂåñÂíåbitset‰ºòÂåñ„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** @Author: sun000* @Date: 2017-07-07 18:07:58* @Last Modified by: sun000* @Last Modified time: 2017-07-07 18:46:08*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;bitset&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int p[1000010];int num[1000010];int c[500010];bitset&lt;1000010&gt; dp;int cnt;void init(int s) &#123; for(int i = 0; i &lt;= s; i++) &#123; p[i] = i; num[i] = 1; &#125;&#125;int fin(int x) &#123; if(p[x] == x) return x; return p[x] = fin(p[x]);&#125;bool un(int x, int y) &#123; int a = fin(x); int b = fin(y); if(a == b) &#123; c[cnt++] = num[a]; return true; &#125; p[a] = b; num[b] += num[a]; return false;&#125;int main(void) &#123; cnt = 0; int n, k, temp; scanf("%d%d", &amp;n, &amp;k); init(n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;temp); un(i, temp); &#125; sort(c, c + cnt); int maxans; int co = 0, odd = 0; for(int i = 0; i &lt; cnt; i++) &#123; co += c[i] &gt;&gt; 1; if(c[i] &amp; 1) odd++; &#125; if(co &gt;= k) maxans = k * 2; else maxans = min(n, co * 2 + (k - co)); c[cnt++] = -1; int s = 0, pre = c[0], now = 1; for(int i = 1; i &lt; cnt; i++) &#123; if(pre == c[i]) now++; else &#123; int g = 1; while(now) &#123; now -= g; c[s++] = pre * g; g &lt;&lt;= 1; while(now - g &lt; 0) g &gt;&gt;= 1; &#125; now = 1; pre = c[i]; &#125; &#125; cnt = s; int minans = k + 1; dp.reset(); dp.set(0); for(int i = 0; i &lt; cnt; i++) dp |= (dp &lt;&lt; c[i]); if(dp[k]) minans--; printf("%d %d\n", minans, maxans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>ÂõæËÆ∫</tag>
        <tag>Ë¥™ÂøÉ</tag>
        <tag>BITSET</tag>
        <tag>ËÉåÂåÖ</tag>
        <tag>Âπ∂Êü•ÈõÜ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ITMOSummerCampDay1 GPick Your Team]]></title>
    <url>%2F2017%2F07%2F05%2FITMOSummerCampDay1GPick-Your-Team%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ This is it. The final battle between EPFL and Mars. The rules of the game are as follows. Neither side wants to sacrifice their own people, so we will be picking two teams of Unil students to fight each other instead. You have been chosen to pick the team that will fight for EPFL's honour! You are given a list containing the strength of each Unil student. You start by choosing one student to join your team, then the Martians will choose another student, and so on, until all n students are chosen. If you had no extra information, clearly you'd pick the strongest Unil student in each turn. However, we managed to figure out the preference of the Martians. More specifically, we have a permutation P of the first n numbers, representing the indices of the Unil students, which the Martians prefer to pick in order. Take a look at the example inputs to understand this further. You want to pick the team that maximises the difference between your team's strength and theirs. What's the maximum difference? Input The first line of the input has of an even integer n (2 ‚â§ n ‚â§ 100), the number of Unil students. The next line contains n space-separated integers si, the strength of each student (1 ‚â§ si ‚â§ 107). The last line contains n space-separated integers between 1 and n, representing the permutation P. Output Print the maximum difference in strength between your team and the Martians' team. Examples input 4 3 9 1 7 4 1 2 3 output 12 input 10 1 1 2 3 4 5 6 6 8 10 9 8 7 6 5 4 10 1 2 3 output 14 Note In the first example, there are four Unil students with strengths 3, 9, 1, 7. The Martians prefer to pick them in this order: 4, 1, 2, 3. This means that in their first turn, they'll pick student 4 (strength = 7) if that student hadn't been picked, otherwise they'll pick the next student on their list (student 1, strength = 3). If you had used the simple strategy of picking the strongest available student each turn, you'd have ended up with a total strength of 9 + 3 = 12, and the Martians with 7 + 1 = 8, giving you a difference of 4. Given this extra information, you can first pick student 4 (strength = 7), then student 2 (strength = 9) in your next turn. You'd have a difference of 9 + 7 - 3 - 1 = 12. In this case, this is the best strategy. ÂàÜÊûê: ÊåâÁÖßÁÅ´Êòü‰∫∫ÁöÑÈÄâÊã©È°∫Â∫èÊù•ÈÄâÔºåÂàôÂâç2k‰∏™ÁÅ´Êòü‰∫∫ÊúÄÂ∞ëÂè™ËÉΩÈÄâk‰∏™ÔºåÈÇ£‰πàÂÄíËøáÊù•ËÄÉËôëÔºåÂêé2k‰∏™Âú∞ÁêÉ‰∫∫Ëá≥Â∞ëËÉΩÈÄâk‰∏™ÔºåÂàôÁî®‰∏Ä‰∏™‰ºòÂÖàÈòüÂàóÔºå‰ªéÂêéÂæÄÂâçÔºåÂú∞ÁêÉ‰∫∫ÊØèÊ¨°ÂæóÂà∞‰∏§‰∏™Êñ∞ÁöÑÂèØÈÄâÊã©ÁöÑÔºå‰ªéÊÄªÂÖ±ÁöÑÂèØÈÄâÊã©ÁöÑÈáåÈù¢ÈÄâÂéª‰∏Ä‰∏™ÔºåËøôÁßçÈÄâÊã©ÂØπ‰∫éÂú∞ÁêÉ‰∫∫Êù•ËØ¥ÊòØÂèØ‰ª•ÂÅöÂà∞ÁöÑÔºåÁî®‰∏Ä‰∏™‰ºòÂÖàÈòüÂàóÊù•‰øùËØÅÂú∞ÁêÉ‰∫∫ÁöÑÈÄâÊã©ÊúÄ‰ºò„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738/** @Author: sun000* @Date: 2017-07-05 18:37:42* @Last Modified by: sun000* @Last Modified time: 2017-07-08 13:09:59*/#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q;int num[110], p[110];int main(void) &#123; int n, sum = 0; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;num[i]); sum += num[i]; &#125; for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;p[i]); int ans = 0; for(int i = n; i &gt; 0;) &#123; q.push(num[p[i--]]); q.push(num[p[i--]]); ans += q.top(); q.pop(); &#125; printf("%d\n", 2 * ans - sum); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Ë¥™ÂøÉ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces76E Points]]></title>
    <url>%2F2017%2F07%2F04%2FCodeForces76E-Points%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ You are given N points on a plane. Write a program which will find the sum of squares of distances between all pairs of points. Input The first line of input contains one integer number N (1 ‚â§ N ‚â§ 100 000) ‚Äî the number of points. Each of the following N lines contain two integer numbers X and Y ( - 10 000 ‚â§ X, Y ‚â§ 10 000) ‚Äî the coordinates of points. Two or more points may coincide. Output The only line of output should contain the required sum of squares of distances between all pairs of points. Examples input 4 1 1 -1 -1 1 -1 -1 1 output 32 ÂàÜÊûê Á≠îÊ°àÊòØ: \[ \sum_{i=1}^{n}{\sum_{j=i+1}^{n}{(x_i-x_j)^2+(y_i-y_j)^2}} \] ËøôÈáå‰ªÖËÆ°ÁÆóxÈÉ®ÂàÜÔºåyÈÉ®ÂàÜÁõ∏Âêå \[ \sum_{i=1}^n{\sum_{j=i+1}^n(x_i-x_j)^2} \] \[ =\sum_{i = 1}^n{\sum_{j = 1} ^n(x_i-x_j)^2}/2 \] \[ =\sum_{i = 1}^n{\sum_{j = 1} ^n(x_i^2-2x_ix_j+x_j^2)}/2 \] \[ =\sum_{i = 1}^n{\sum_{j = 1} ^n(x_i^2+x_j^2)}/2-\sum_{i = 1}^n{\sum_{j = 1} ^n(2x_ix_j)}/2 \] \[ =n\sum_{i = 1}^n{x_i^2}-\sum_{i = 1}^n{\sum_{j = 1} ^nx_ix_j} \] Áî±‰∫é \[ (\sum_{i=1}^n{x_i})^2=\sum_{i=1}^n{x_i}^2+2\sum_{i=1}^n{\sum_{j=i + 1}^n{x_ix_j}}=\sum_{i=1}^n{\sum_{j=1}^n{x_ix_j}} \] Âàô \[ \sum_{i = 1}^n{\sum_{j = i + 1} ^n(x_i-x_j)^2}=n\sum_{i = 1}^n{x_i^2}-(\sum_{i=1}^n{x_i})^2 \] ÂàôÊúÄÁªàÁöÑÁ≠îÊ°àÊòØ \[ \sum_{i=1}^n{\sum_{j = i + 1}^n}{(x_i-x_j)^2 + (y_i-y_j)^2}=nÔºà\sum_{i = 1}^n{x_i^2}+\sum_{i = 1}^n{y_i^2}Ôºâ-((\sum_{i=1}^n{x_i})^2+(\sum_{i=1}^n{y_i})^2) \] ËøôÊ†∑Â∞±ÂèØ‰ª•O(n)Â§çÊùÇÁöÑÂÜôÂá∫Êù•‰∫Ü ‰ª£Á†Å 1234567891011121314151617181920212223242526/** @Author: sun000* @Date: 2017-07-05 07:30:42* @Last Modified by: sun000* @Last Modified time: 2017-07-08 13:41:30*/#include &lt;cstdio&gt;long long int sumx, sumy, sumbx, sumby;int main(void) &#123; long long int n, x, y; sumx = sumy = sumbx = sumby = 0; scanf("%lld", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%lld%lld", &amp;x, &amp;y); sumx += x; sumbx += x * x; sumy += y; sumby += y * y; &#125; long long int ans = (n * (sumbx + sumby) - (sumx * sumx + sumy * sumy)); printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Êï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 768E:Game of Stones]]></title>
    <url>%2F2017%2F07%2F04%2FCodeForces-768E-Game-of-Stones%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ Sam has been teaching Jon the Game of Stones to sharpen his mind and help him devise a strategy to fight the white walkers. The rules of this game are quite simple: The game starts with n piles of stones indexed from 1 to n. The i-th pile contains *s**i* stones. The players make their moves alternatively. A move is considered as removal of some number of stones from a pile. Removal of 0stones does not count as a move. The player who is unable to make a move loses. Now Jon believes that he is ready for battle, but Sam does not think so. To prove his argument, Sam suggested that they play a modified version of the game. In this modified version, no move can be made more than once on a pile. For example, if 4 stones are removed from a pile, 4 stones cannot be removed from that pile again. Sam sets up the game and makes the first move. Jon believes that Sam is just trying to prevent him from going to battle. Jon wants to know if he can win if both play optimally. Input First line consists of a single integer n (1 ‚â§ n ‚â§ 106) ‚Äî the number of piles. Each of next n lines contains an integer *s**i* (1 ‚â§ *s**i ‚â§ 60) ‚Äî the number of stones in i*-th pile. Output Print a single line containing &quot;YES&quot; (without quotes) if Jon wins, otherwise print &quot;NO&quot; (without quotes) Examples input 1 5 output NO input 2 1 2 output YES Note In the first case, Sam removes all the stones and Jon loses. In second case, the following moves are possible by Sam: In each of these cases, last move can be made by Jon to win the game as follows: ÂàÜÊûê Ëß£Ê≥ï‰∏ÄÔºöÊö¥ÂäõsgÊâìË°®ÔºàÁï•Ôºâ Ëß£Ê≥ï‰∫åÔºöÂÅáËÆæ‰∏Ä‰∏™Â†ÜÊúânÈ¢óÁü≥Â≠êÔºåÈÇ£‰πàÂéªÂà∞ÂÆÉ‰∏çËÉΩÂÜçÂèñÔºåËá≥Â∞ëË¶ÅÂèñkÊ¨°ÔºåËøôÁßçÊÉÖÂÜµÂéªÁü≥Â≠êÁöÑÂ∫èÂàóÊòØ 1Ôºå2Ôºå3‚Ä¶‚Ä¶kÔºå ÂÖ∂‰∏≠0 &lt;= n-(1+2+3+‚Ä¶‚Ä¶+k) &lt;= k ÂàôËøô‰∏™Áî±‰∫éÂèØ‰ª•‰∏çÊåâÁÖßÂéªÊúÄÂ∞ëÊ¨°Êï∞ÁöÑÂèñÊ≥ïÂèñÔºåÂàô‰∏ÄÊ¨°ÂèØ‰ª•Âèñai+ajÈ¢óÁü≥Â≠êÔºå1&lt;=ai,aj&lt;=kÔºåÂàôËøô‰∏™Â†ÜÁü≥Â≠êÂèØ‰ª•ËΩ¨ÂåñÊàêÊúâkÈ¢óÁü≥Â≠êÔºåÊØèÊ¨°‰ªªÂèñÂá†È¢óÔºå‰∏çÂèØ‰∏çÂèñÔºåÈÇ£ËøôÊ†∑Â∞±Êàê‰∫ÜÊôÆÈÄöÁöÑNIMÊ∏∏Êàè‰∫ÜÔºåÂàôÂèØ‰ª•‰∏éÂ§ÑÁêÜÊâÄÊúâÁöÑÁü≥Â§¥Â†ÜÁü≥Â§¥‰∏™Êï∞ÔºåÁÑ∂ÂêéÁî®ÊôÆÈÄöÁöÑNIMÊ∏∏ÊàèÁöÑÂÅöÊ≥ïÔºåÂºÇÊàñ‰∏ÄÈÅçÂ∞±ÂèØ‰ª•‰∫Ü„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031/** @Author: sun000* @Date: 2017-07-04 22:31:00* @Last Modified by: sun000* @Last Modified time: 2017-07-04 22:37:24*/#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int getNimNum(int n) &#123; int k = (int)sqrt(2.0 * n); while(k * (k + 1) &lt;= 2 * n) k++; //printf("k = %d\n", k - 1); return k - 1;&#125;int main(void) &#123; int n, temp, ans = 0; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;temp); ans ^= getNimNum(temp); &#125; printf("%s\n", ans ? "NO" : "YES"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>ÂçöÂºà</tag>
        <tag>NIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ËÆ°Ëíú‰πãÈÅì2017Â§çËµõDÈ¢òÔºöÁôæÂ∫¶Âú∞ÂõæÂØºËà™]]></title>
    <url>%2F2017%2F06%2F11%2F%E8%AE%A1%E8%92%9C%E4%B9%8B%E9%81%932017%E5%A4%8D%E8%B5%9BD%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%AF%BC%E8%88%AA%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ ÁôæÂ∫¶Âú∞Âõæ‰∏äÊúâ n ‰∏™ÂüéÂ∏ÇÔºåÂüéÂ∏ÇÁºñÂè∑‰æùÊ¨°‰∏∫ 1 Âà∞ n„ÄÇÂú∞Âõæ‰∏≠ÊúâËã•Âπ≤‰∏™ÂüéÂ∏ÇÁæ§ÔºåÁºñÂè∑‰æùÊ¨°‰∏∫ 1 Âà∞ m„ÄÇÊØè‰∏™ÂüéÂ∏ÇÁæ§ÂåÖÂê´‰∏Ä‰∏™ÊàñÂ§ö‰∏™ÂüéÂ∏ÇÔºõÊØè‰∏™ÂüéÂ∏ÇÂèØËÉΩÂ±û‰∫éÂ§ö‰∏™ÂüéÂ∏ÇÁæ§Ôºå‰πüÂèØËÉΩ‰∏çÂ±û‰∫é‰ªª‰ΩïÂüéÂ∏ÇÁæ§„ÄÇ Âú∞Âõæ‰∏≠Êúâ‰∏§Á±ªÈÅìË∑Ø„ÄÇÁ¨¨‰∏ÄÁ±ªÈÅìË∑ØÊòØ ÂüéÂ∏Ç‰πãÈó¥ÁöÑÂø´ÈÄüË∑ØÔºå‰∏§‰∏™ÂüéÂ∏Ç u,v ‰πãÈó¥Â¢ûÂä†‰∏ÄÊù°Ë∑ùÁ¶ª‰∏∫ c ÁöÑËæπÔºõÁ¨¨‰∫åÁ±ªÈÅìË∑ØÊòØ ÂüéÂ∏ÇÁæ§‰πãÈó¥ÁöÑÈ´òÈÄüË∑ØÔºåËøûÊé•‰∏§‰∏™ÂüéÂ∏ÇÁæ§ a,bÔºåÈÄöËøáËøôÊù°È´òÈÄüË∑ØÔºåÂüéÂ∏ÇÁæ§ a ÈáåÁöÑÊØè‰∏™ÂüéÂ∏Ç‰∏éÂüéÂ∏ÇÁæ§ b ÈáåÁöÑÊØè‰∏™ÂüéÂ∏Ç‰πãÈó¥‰∏§‰∏§Â¢ûÂä†‰∏ÄÊù°Ë∑ùÁ¶ª‰∏∫ c ÁöÑËæπ„ÄÇÂõæ‰∏≠ÊâÄÊúâËæπÂùá‰∏∫Êó†ÂêëËæπ„ÄÇ ‰Ω†ÈúÄË¶ÅËÆ°ÁÆó‰ªéÂüéÂ∏Ç s Âà∞ÂüéÂ∏Ç t ÁöÑÊúÄÁü≠Ë∑Ø„ÄÇ ËæìÂÖ•Ê†ºÂºè Á¨¨‰∏ÄË°åËæìÂÖ•n(1‚â§n‚â§20000), m(0‚â§m‚â§20000)ÔºåÂàÜÂà´Ë°®Á§∫ÂüéÂ∏ÇÊÄªÊï∞ÂíåÂüéÂ∏ÇÁæ§ÊÄªÊï∞„ÄÇ Êé•‰∏ãÊù•‰∏ÄÂÖ±ËæìÂÖ• m Ë°å„ÄÇ Á¨¨ ii Ë°åÈ¶ñÂÖàËæìÂÖ•‰∏Ä‰∏™ki(1‚â§ki‚â§n)ÔºåË°®Á§∫Á¨¨ ii ‰∏™ÂüéÂ∏ÇÁæ§‰∏≠ÁöÑÂüéÂ∏ÇÊï∞‰∏∫ ki„ÄÇÊé•‰∏ãÊù•ËæìÂÖ• ki ‰∏™Êï∞ÔºåË°®Á§∫Á¨¨ i ‰∏™ÂüéÂ∏ÇÁæ§‰∏≠ÊØè‰∏™ÂüéÂ∏ÇÁöÑÁºñÂè∑,‰øùËØÅ‰∏Ä‰∏™ÂüéÂ∏ÇÁæ§ÂÜÖÁöÑÂüéÂ∏ÇÁºñÂè∑‰∏çÈáçÂ§ç‰∏îÂêàÊ≥ï \[ \sum_{i = 1}^m{k_i}‚â§20000 \] ‰∏ã‰∏ÄË°åËæìÂÖ•‰∏Ä‰∏™Êï¥Êï∞ m1(0‚â§m1‚â§20000)ÔºåË°®Á§∫Êúâ m1 Êù°Á¨¨‰∏ÄÁ±ªÈÅìË∑ØÔºåÂç≥ ÂüéÂ∏Ç‰πãÈó¥ÁöÑÂø´ÈÄüË∑Ø„ÄÇ Êé•‰∏ãÊù• m1 Ë°åÔºåÊØèË°åËæìÂÖ•‰∏â‰∏™Êï¥Êï∞ ui,vi(1‚â§ui,vi‚â§n),ci(1‚â§ci‚â§106)ÔºåÂàÜÂà´Ë°®Á§∫Âø´ÈÄüË∑ØËøûÊé•ÁöÑ‰∏§‰∏™ÂüéÂ∏ÇÁºñÂè∑ÂíåËæπÁöÑË∑ùÁ¶ª„ÄÇ ‰∏ã‰∏ÄË°åËæìÂÖ•‰∏Ä‰∏™Êï¥Êï∞ m2(0‚â§m2‚â§20000)ÔºåË°®Á§∫Êúâ m2 Êù°Á¨¨‰∫åÁ±ªÈÅìË∑ØÔºåÂç≥ ÂüéÂ∏ÇÁæ§‰πãÈó¥ÁöÑÈ´òÈÄüË∑Ø„ÄÇ Êé•‰∏ãÊù• m2 Ë°åÔºåÊØèË°åËæìÂÖ•‰∏â‰∏™Êï¥Êï∞ ai,bi(1‚â§ai,bi‚â§m),li(1‚â§li‚â§106)ÔºåÂàÜÂà´Ë°®Á§∫Âø´ÈÄüË∑ØËøûÊé•ÁöÑ‰∏§‰∏™ÂüéÂ∏ÇÁæ§ÁºñÂè∑ÂíåËæπÁöÑË∑ùÁ¶ª„ÄÇ ÊúÄÂêé‰∏ÄË°åËæìÂÖ•s,t(1‚â§s,t‚â§n)ÔºåË°®Á§∫Ëµ∑ÁÇπÂíåÁªàÁÇπÂüéÂ∏ÇÁºñÂè∑„ÄÇ ËæìÂá∫Ê†ºÂºè ËæìÂá∫‰∏Ä‰∏™Êï¥Êï∞ÔºåË°®Á§∫ÂüéÂ∏Ç s Âà∞ÂüéÂ∏Ç t Âà∞ÊúÄÁü≠Ë∑Ø„ÄÇÂ¶ÇÊûú‰∏çÂ≠òÂú®Ë∑ØÂæÑÔºåÂàôËæìÂá∫-1„ÄÇ Ê†∑‰æãËØ¥Êòé 1 -&gt; 2 - &gt; 5ÊàñËÄÖ1 -&gt; 4 -&gt; 5ÊòØÊúÄÁü≠ÁöÑË∑ØÂæÑÔºåÊÄªÈïøÂ∫¶‰∏∫ 12„ÄÇ Ê†∑‰æãËæìÂÖ• 5 4 2 5 1 2 2 4 1 3 2 3 4 2 1 2 9 1 5 18 2 1 2 6 1 3 10 1 5 Ê†∑‰æãËæìÂá∫ 12 ÂàÜÊûê ÊääÊØè‰∏Ä‰∏™ÂüéÂ∏ÇÁæ§ÁúãÊàê‰∏Ä‰∏™Êñ∞ÁöÑÁÇπÂä†Âà∞ÂõæÈáåÈù¢ÔºåÊñ∞Âä†ÁöÑ‚ÄúÂüéÂ∏ÇÁæ§ÁÇπ‚ÄùÂà∞ÂüéÂ∏ÇÁæ§ÂÜÖÁöÑÊâÄÊúâÁÇπÁöÑË∑ùÁ¶ªÈÉΩÊòØ0ÔºåÊ≥®ÊÑèËøôÈáåÁöÑ‚ÄúÂüéÂ∏ÇÁæ§ÁÇπ‚ÄùË¶ÅÊãÜÁÇπÔºåÊãÜÊàêÂÖ•ÁÇπÂíåÂá∫ÁÇπÔºåÂõ†‰∏∫‰∏çÊãÜÁÇπÁöÑËØù‰ºöÂØºËá¥Âêå‰∏Ä‰∏™‚ÄúÂüéÂ∏ÇÁæ§‚ÄùÂÜÖÈÉ®ÁöÑÁÇπ‰∏§‰∏§‰πãÈó¥ÁöÑË∑ùÁ¶ªÂÖ®ÈÉ®ÂèòÊàê0ÔºåËøôÊòæÁÑ∂ÊòØ‰∏çÂØπÁöÑ„ÄÇÔºàÊãÜÁÇπ‰πãÂêéÁÇπÁöÑÊï∞ÈáèÂèòÂ§öÔºåÂàöÂºÄÂßãÊï∞ÁªÑÂ§ßÂ∞èÊ≤°ÊúâÊîπÔºåÂØºËá¥‰∫ÜÊÆµÈîôËØØÔºâÔºåÂª∫ÂÆåÂõæË∑ë‰∏ÄËæπSPFAÂ∞±ÂèØ‰ª•‰∫Ü„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** @Author: sun000* @Date: 2017-06-11 11:57:57* @Last Modified by: sun000* @Last Modified time: 2017-06-11 15:48:54*/#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 60010;//ÁÇπÁöÑÊï∞ÈáèÊòØn + 2 * mstruct node &#123; int to; long long int len; node()&#123;&#125; node(int _to, long long int _len):to(_to),len(_len)&#123;&#125;&#125;;vector&lt;node&gt; G[MAXN];int n, m;void build_group(int k)&#123; int cnt, temp; scanf("%d", &amp;cnt); for(int i = 0; i &lt; cnt; i++) &#123; scanf("%d", &amp;temp); temp--; G[k + n + m].push_back(node(temp, 0)); G[temp].push_back(node(k + n, 0)); &#125;&#125;long long int solve(int s, int t) &#123; long long int dis[MAXN]; bool vis[MAXN]; queue&lt;int&gt; Q; memset(dis, 0x3f, sizeof(dis)); memset(vis, false, sizeof(vis)); dis[s] = 0; vis[s] = true; Q.push(s); while(!Q.empty()) &#123; int u = Q.front(); Q.pop(); vis[u] = false; for(int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i].to; long long int w = G[u][i].len; if(dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; if(!vis[v]) &#123; vis[v] = true; Q.push(v); &#125; &#125; &#125; &#125; return dis[t];&#125;int main(void)&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 0; i &lt; m; i++) build_group(i); int g, u, v; long long int len; scanf("%d", &amp;g); for(int i = 0; i &lt; g; i++) &#123; scanf("%d%d%lld", &amp;u, &amp;v, &amp;len); u--; v--; G[u].push_back(node(v, len)); G[v].push_back(node(u, len)); &#125; scanf("%d", &amp;g); for(int i = 0; i &lt; g; i++) &#123; scanf("%d%d%lld", &amp;u, &amp;v, &amp;len); u--; v--; G[v + n].push_back(node(u + n + m, len)); G[u + n].push_back(node(v + n + m, len)); &#125; int s, t; scanf("%d%d", &amp;s, &amp;t); long long int ans = solve(s - 1, t - 1); printf("%lld\n", ans &lt; 0x3f3f3f3f ? ans : -1); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>ÂõæËÆ∫</tag>
        <tag>Âª∫Âõæ</tag>
        <tag>ÊúÄÁü≠Ë∑Ø</tag>
        <tag>ÊãÜÁÇπ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ËÆ°Ëíú‰πãÈÅì2017Â§çËµõFÈ¢òÔºöËÖæËÆØÊ∂àÊ∂à‰πê]]></title>
    <url>%2F2017%2F06%2F10%2F%E8%AE%A1%E8%92%9C%E4%B9%8B%E9%81%932017F%E9%A2%98%E8%85%BE%E8%AE%AF%E6%B6%88%E6%B6%88%E4%B9%90%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òÁõÆ ËÖæËÆØÊé®Âá∫‰∫Ü‰∏ÄÊ¨æÁõäÊô∫Á±ªÊ∏∏Êàè‚Äî‚ÄîÊ∂àÊ∂à‰πê„ÄÇÊ∏∏Êàè‰∏ÄÂºÄÂßãÔºåÁªôÂÆö‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ n ÁöÑÂ∫èÂàóÔºåÂÖ∂‰∏≠Á¨¨ i ‰∏™Êï∞‰∏∫ Ai„ÄÇ Ê∏∏ÊàèÁöÑÁõÆÊ†áÊòØÊääËøô‰∫õÊï∞ÂÖ®ÈÉΩÂà†ÂéªÔºåÊØèÊ¨°Âà†Èô§ÁöÑÊìç‰Ωú‰∏∫ÔºöÈÄâÂèñ‰∏ÄÊÆµËøûÁª≠ÁöÑÂå∫Èó¥Ôºå‰∏çÂ¶®ËÆ∞‰∏∫ [L,R]ÔºåÂ¶ÇÊûúËøô‰∏ÄÊÆµÂå∫Èó¥ÂÜÖÊâÄÊúâÊï∞ÁöÑÊúÄÂ§ßÂÖ¨Á∫¶Êï∞ ‚â•kÔºàkÂÄºÂú®Ê∏∏ÊàèÁöÑ‰∏ÄÂºÄÂßã‰ºöÁªôÂÆöÔºâÔºåÈÇ£‰πàËøô‰∏ÄÊÆµÂå∫Èó¥Â∞±ËÉΩË¢´Áõ¥Êé•Âà†Âéª„ÄÇ Ê≥®ÊÑèÔºö‰∏ÄÊ¨°Âà†Èô§‰ª•ÂêéÔºåÂâ©‰∏ãÁöÑÊï∞‰ºöÂêàÂπ∂Êàê‰∏∫‰∏Ä‰∏™ËøûÁª≠Âå∫Èó¥„ÄÇ ÂÆö‰πâ f(i)‰∏∫ËøõË°å i Ê¨°Êìç‰ΩúÂ∞ÜÊï¥‰∏™Â∫èÂàóÂà†ÂÆåÁöÑÊñπÊ°àÊï∞„ÄÇ ‰Ω†ÈúÄË¶ÅÂÆûÁé∞‰∏Ä‰∏™Á®ãÂ∫èÔºåËÆ°ÁÆó \[ \sum_{i = 1}^n{(f(i) * i)} mod 1000000007 \] ËæìÂÖ•Ê†ºÂºè Á¨¨‰∏ÄË°åËæìÂÖ•‰∏§‰∏™Êï¥Êï∞ n,k(1‚â§n‚â§18) Á¨¨‰∫åË°åËæìÂÖ• n‰∏™Ê≠£Êï¥Êï∞ ai(1‚â§ai‚â§10^5)ÔºåË°®Á§∫ÂàùÂßãÂ∫èÂàó‰∏≠ÁöÑÊØè‰∏™Êï∞„ÄÇ ËæìÂÖ•Êï∞ÊçÆ‰øùËØÅ 1‚â§k‚â§min(a1,a2,‚Ä¶an) ËæìÂá∫Ê†ºÂºè ËæìÂá∫‰∏Ä‰∏™Êï¥Êï∞ÔºåË°®Á§∫ÁÆóÂá∫ÁöÑÁ≠îÊ°à„ÄÇ Ê†∑‰æãËØ¥Êòé ÂØπ‰∫éÊ†∑‰æã 1 ËÄåË®ÄÔºåf(1)=1Ôºåf(2)=9Ôºåf(3))=26Ôºåf(4)=24„ÄÇ ÂØπ‰∫éÊ†∑‰æã 2Ôºåf(1)=0Ôºåf(2)=2„ÄÇ Ê†∑‰æãËæìÂÖ•1 4 1 1 1 1 1 Ê†∑‰æãËæìÂá∫1 193 Ê†∑‰æãËæìÂÖ•2 2 2 2 3 Ê†∑‰æãËæìÂá∫2 4 Ê†∑‰æãËæìÂÖ•3 1 233 233 Ê†∑‰æãËæìÂá∫3 1 ÂàÜÊûê Êö¥ÂäõÁä∂ÊÄÅÂéãÁº©dp,dp[s][i] : sË°®Á§∫ÁöÑÁä∂ÊÄÅÁªèËøáiÊ¨°Ê∂àÂÆåÁöÑÊñπÊ°àÊï∞„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ÊòØÔºö \[ n^3*2^n \] ### ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** @Author: sun000* @Date: 2017-06-10 12:08:01* @Last Modified by: sun000* @Last Modified time: 2017-06-11 09:11:55*/#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MOD = 1000000007;const int MAXN = (1 &lt;&lt; 18) + 10;int n, k;int num[20];int dp[MAXN][20];//i, j,Áä∂ÊÄÅiÁî®jÊ¨°Ê∂àÂéªÁöÑÊñπÊ°àÊï∞int gcd(int a, int b) &#123; return b ? gcd(b, a % b) : a;&#125;void init() &#123; memset(dp, 0, sizeof(dp)); int temp; for(int s = 1; s &lt; (1 &lt;&lt; n); s++) &#123; temp = 0; for(int i = 0; i &lt; n; i++) if(s &amp; (1 &lt;&lt; i)) temp = gcd(temp, num[i]); if(temp &gt;= k) dp[s][1] = 1; &#125;&#125;int main(void)&#123; scanf("%d%d", &amp;n, &amp;k); for(int i = 0; i &lt; n; i++) scanf("%d", &amp;num[i]); init(); int temp, now; for(int s = 1; s &lt; (1 &lt;&lt; n); s++) //Êûö‰∏æÁä∂ÊÄÅ for(int i = 2; i &lt;= n; i++) //Êûö‰∏æÊ∂àÂéªÊ¨°Êï∞ //Êûö‰∏æÂå∫Èó¥ for(int l = 0; l &lt; n; l++) //Êûö‰∏æËµ∑ÁÇπ if(s &amp; (1 &lt;&lt; l)) //ÊúâÊïàËµ∑ÁÇπ &#123; temp = 0; now = 0; for(int r = l; r &lt; n; r++) //Êûö‰∏æÁªàÁÇπ if(s &amp; (1 &lt;&lt; r)) //ÊúâÊïàÁªàÁÇπ &#123; temp = gcd(temp, num[r]); now |= (1 &lt;&lt; r);//ÈÄâÊã©nowË°®Á§∫ÁöÑÁä∂ÊÄÅÔºåÊ∂àÂéª‰∏ÄÊ¨° if(temp &gt;= k) dp[s][i] = (dp[s][i] + dp[s ^ now][i - 1]) % MOD; else break; &#125; &#125; int ans = 0; for(int i = 1; i &lt;= n; i++) ans = (ans + (long long)dp[(1 &lt;&lt; n) - 1][i] * i % MOD) % MOD; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>Áä∂ÊÄÅÂéãÁº©</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5033 Building Êö¥Âäõ+ÂçïË∞ÉÊ†à‰ºòÂåñ]]></title>
    <url>%2F2017%2F06%2F08%2FHDU%205033%20Building%20%E6%9A%B4%E5%8A%9B%2B%E5%8D%95%E8%B0%83%E6%A0%88%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Building Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others) Total Submission(s): 2603 Accepted Submission(s): 739 Special Judge Problem Description Once upon a time Matt went to a small town. The town was so small and narrow that he can regard the town as a pivot. There were some skyscrapers in the town, each located at position xi with its height hi. All skyscrapers located in different place. The skyscrapers had no width, to make it simple. As the skyscrapers were so high, Matt could hardly see the sky.Given the position Matt was at, he wanted to know how large the angle range was where he could see the sky. Assume that Matt's height is 0. It's guaranteed that for each query, there is at least one building on both Matt's left and right, and no building locate at his position. Input The first line of the input contains an integer T, denoting the number of testcases. Then T test cases follow. Each test case begins with a number N(1&lt;=N&lt;=10^5), the number of buildings. In the following N lines, each line contains two numbers, xi(1&lt;=xi&lt;=10^7) and hi(1&lt;=hi&lt;=10^7). After that, there's a number Q(1&lt;=Q&lt;=10^5) for the number of queries. In the following Q lines, each line contains one number qi, which is the position Matt was at. Output For each test case, first output one line &quot;Case #x:&quot;, where x is the case number (starting from 1). Then for each query, you should output the angle range Matt could see the sky in degrees. The relative error of the answer should be no more than 10^(-4). Sample Input 3 3 1 2 2 1 5 1 1 4 3 1 3 2 2 5 1 1 4 3 1 4 2 3 5 1 1 4 Sample Output Case #1: 101.3099324740 Case #2: 90.0000000000 Case #3: 78.6900675260 È¢òÊÑèÔºö Âú®‰∏ÄÊù°Êï∞ËΩ¥‰∏äÊúân‰∏™Â§ßÊ•ºÔºåÁªôÂá∫n‰∏™Â§ßÊ•ºÁöÑÂùêÊ†áxÂíåÈ´òÂ∫¶hÊúân‰∏™ËØ¢ÈóÆÔºåÊØèÊ¨°ËØ¢ÈóÆÁªôÂá∫‰∏Ä‰∏™x0Ë°®Á§∫ËßÇÊµãÁÇπÁöÑÂùêÊ†áÔºåÊ±ÇËØ•ËßÇÊµãÁÇπËÉΩËßÇÊµãÂà∞ÁöÑÂ§©Á©∫ÁöÑËßíÂ∫¶„ÄÇ ÂàÜÊûêÔºö Áî®ÂçïË∞ÉÊ†àÊù•Áª¥Êä§‰∏Ä‰∏™Êö¥ÂäõÁöÑÈ°∫Â∫èÔºå‰ªéËßÇÊµãÁÇπÂêë‰∏§ËæπÁöÑÂª∫Á≠ëËøõË°åÊö¥ÂäõÊûö‰∏æÊØè‰∏Ä‰∏™Âª∫Á≠ëÁöÑÊúÄÂ§ßËßÜËßíÔºà‰∏çÊòØÊûö‰∏æÊâÄÊúâÁöÑÂª∫Á≠ëÔºåÊòØÊåâÁÖßÈ´òÂ∫¶ÈÄíÂ¢ûÁöÑÈ°∫Â∫èÊûö‰∏æÔºåÂõ†‰∏∫Ë∂äËøú‰ΩÜÈ´òÂ∫¶Âç¥‰∏çËÉΩÊõ¥È´òÁöÑËØùÔºåËßÇÊµãËßíÂ∫¶ËÇØÂÆöÊõ¥Â§ßÔºåÊàë‰ª¨Ë¶ÅÊ±ÇËßÇÊµãËßíÂ∫¶ÊúÄÂ∞èÔºâÔºåÁõ¥Âà∞Êûö‰∏æÂà∞‰∏§ËæπÊúÄÈ´òÁöÑÂª∫Á≠ë‰∏∫Ê≠¢„ÄÇ ‰ª£Á†ÅÔºö 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;cstdio&gt;#include &lt;stack&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const double PI = acos(-1);int n;struct node&#123; double x, h; node()&#123;&#125; node(double xx, double hh):x(xx),h(hh)&#123;&#125;&#125;s[100010];bool cmp(node a, node b)&#123; return a.x &lt; b.x;&#125;int bef[100010], nex[100010], lm[100010], rm[100010];stack&lt;int&gt; ss;void init()&#123; memset(bef, -1, sizeof(bef)); memset(nex, -1, sizeof(nex)); while(!ss.empty()) ss.pop(); for(int i = 0; i &lt; n; i++) &#123; if(ss.empty() || s[ss.top()].h &gt; s[i].h) ss.push(i); else &#123; while(!ss.empty() &amp;&amp; s[ss.top()].h &lt; s[i].h) &#123; nex[ss.top()] = i; ss.pop(); &#125; ss.push(i); &#125; &#125; while(!ss.empty()) ss.pop(); for(int i = n - 1; i &gt;= 0; i--) &#123; if(ss.empty() || s[ss.top()].h &gt; s[i].h) ss.push(i); else &#123; while(!ss.empty() &amp;&amp; s[ss.top()].h &lt; s[i].h) &#123; bef[ss.top()] = i; ss.pop(); &#125; ss.push(i); &#125; &#125; int mh = 0; for(int i = 0; i &lt; n; i++) &#123; if(s[mh].h &lt;= s[i].h) mh = i; lm[i] = mh; &#125; mh = n - 1; for(int i = n - 1; i &gt;= 0; i--) &#123; if(s[mh].h &lt;= s[i].h) mh = i; rm[i] = mh; &#125;&#125;void debug()&#123; for(int i = 0; i &lt; n; i++) &#123; printf("%d x = %f h = %f\n", i, s[i].x, s[i].h); printf("bef %d\nnex %d\nlm %d\nrm %d\n\n", bef[i], nex[i], lm[i], rm[i]); &#125;&#125;int main(void)&#123; int t, q; double x, h, g; scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; cas++) &#123; printf("Case #%d:\n", cas); scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%lf%lf", &amp;x, &amp;h); s[i] = node(x, h); &#125; sort(s, s + n, cmp); init(); //debug(); scanf("%d", &amp;q); while(q--) &#123; scanf("%lf", &amp;g); int r = lower_bound(s, s + n, node(g, 0), cmp) - s; int l = r - 1; double tl = 0, tr = 0; for(int i = l; i != -1 &amp;&amp; i &gt;= lm[l]; i = bef[i]) tl = max(s[i].h / (g - s[i].x), tl); for(int i = r; i != -1 &amp;&amp; i &lt;= rm[r]; i = nex[i]) tr = max(s[i].h / (s[i].x - g), tr); double ans = 180 - 180 * (atan(tl) + atan(tr)) / PI; printf("%.10f\n", ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Êö¥Âäõ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 2995 Robberies Ê¶ÇÁéáËÉåÂåÖ]]></title>
    <url>%2F2017%2F06%2F07%2FHDU-2995-Robberies-%E6%A6%82%E7%8E%87%E8%83%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[Robberies Time Limit: 2000/1000 MS ( Memory Limit: 32768/32768 K (: 21326 Accepted Submission(s): 7889 Problem Description The aspiring Roy the Robber has seen a lot of American movies, and knows that the bad guys usually gets caught in the end, often because they become too greedy. He has decided to work in the lucrative business of bank robbery only for a short while, before retiring to a comfortable job at a university. For a few months now, Roy has been assessing the security of various banks and the amount of cash they hold. He wants to make a calculated risk, and grab as much money as possible.His mother, Ola, has decided upon a tolerable probability of getting caught. She feels that he is safe enough if the banks he robs together give a probability less than this. Input The first line of input gives T, the number of cases. For each scenario, the first line of input gives a floating point number P, the probability Roy needs to be below, and an integer N, the number of banks he has plans for. Then follow N lines, where line j gives an integer Mj and a floating point number Pj . Bank j contains Mj millions, and the probability of getting caught from robbing it is Pj . Output For each test case, output a line with the maximum number of millions he can expect to get while the probability of getting caught is less than the limit set.Notes and Constraints0 &lt; T &lt;= 1000.0 &lt;= P &lt;= 1.00 &lt; N &lt;= 1000 &lt; Mj &lt;= 1000.0 &lt;= Pj &lt;= 1.0A bank goes bankrupt if it is robbed, and you may assume that all probabilities are independent as the police have very low funds. Sample Input 3 0.04 3 1 0.02 2 0.03 3 0.05 0.06 3 2 0.03 2 0.03 3 0.05 0.10 3 1 0.03 2 0.02 3 0.05 Sample Output 2 4 6 È¢òÊÑèÔºö ‰∏Ä‰∏™Â∞èÂÅ∑ÂéªÈì∂Ë°åÂÅ∑‰∏úË•øÔºåÁªôÂÆö‰∏Ä‰∏™pË¶ÅÊ±ÇË¢´Êäì‰ΩèÁöÑÊ¶ÇÁéáÂøÖÈ°ªÂ∞è‰∫ép,ÁÑ∂ÂêéÁªôÂÆön‰∏™Èì∂Ë°åÁöÑmjÂíåpj,ÂàÜÂà´Ë°®Á§∫Â∞èÂÅ∑Âú®ÊØè‰∏™Èì∂Ë°åËÉΩÂÅ∑Âà∞ÁöÑÈí±Âíå‰ºöË¢´Êäì‰ΩèÁöÑÊ¶ÇÁéá„ÄÇË¶ÅÊ±ÇÂ∞èÂÅ∑Âú®Ë¢´Êäì‰ΩèÁöÑÊ¶ÇÁéáÂ∞è‰∫épÁöÑÊÉÖÂÜµ‰∏ãÔºåÊúÄÂ§öËÉΩÂÅ∑Â§öÂ∞ëÈí±„ÄÇÔºàÁúãÊù•Â∞èÂÅ∑‰πüË¶Å‰ºöÁºñÁ®ãÔºå‰∏ç‰ºöÁºñÁ®ãÂÅ∑‰∏çÂà∞Èí±„ÄÇÊó†‰∏öÁ®ãÂ∫èÂëòÊúâÂá∫Ë∑Ø‰∫ÜÔºâ :) :) :) ÂàÜÊûêÔºö ÈîôËØØËß£Ê≥ïÔºöÊö¥ÂäõÁöÑÁõ¥Êé•Â•óÁî®01ËÉåÂåÖÁöÑÁä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ãÔºådp[i] = max{dp[i], dp[i - v[j].p] + v[j].w} ËøôÁúüÊòØÂ§™stupid‰∫ÜÔºåÊ¶ÇÁéá‰∏çÊòØÁî®Êù•Âä†ÁöÑÔºåÊ¶ÇÁéáÂíåÂú®ËøôÈáåÊ≤°Êúâ‰ªª‰ΩïÊÑè‰πâÔºàÂ•ΩÊ∞îÂëÄÔºåÊ†∑‰æãÁî®Ê¶ÇÁéáÂä†‰πüËÉΩËøáÔºåÊ≠£ÂºèÂ§™Èò¥Èô©‰∫ÜÔºâ Ê≠£Á°ÆËß£Ê≥ïÔºöÊ¶ÇÁéáÂ∫îËØ•ÊòØÁõ∏‰πòÁöÑÔºåÁÑ∂ËÄåÂú®ËøôÈáåÁõ¥Êé•ÁÆóË¢´Êäì‰ΩèÁöÑÊ¶ÇÁéáËøá‰∫éÈ∫ªÁÉ¶Ôºå‰∫éÊòØÂèçËøáÊù•ËÄÉËôëÔºåÁÆóËÉΩÊàêÂäüÈÄÉË∑ëÁöÑÊ¶ÇÁéáÁöÑÊúÄÂ§ßÊÉÖÂÜµ„ÄÇÈÇ£‰πàÁî®dp[i]Ë°®Á§∫ÂÅ∑iÁöÑÈí±ËÉΩÈÄÉË∑ëÁöÑÊúÄÂ§ßÊ¶ÇÁéá„ÄÇ ÂæóÂà∞Áä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ãÔºödp[i] =max{dp[i], dp[i - v[j].w] * (1 - v[j].p)} ÊúÄÂêéÊâæÂá∫ÈÄÉË∑ëÊ¶ÇÁéáÂ§ß‰∫éÁ≠â‰∫épÁöÑÊúÄÂ§ßÁöÑi ‰ª£Á†ÅÔºö 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//// main.cpp// HDU-Fighting//// Created by sun000 on 16/10/21.// Copyright ¬© 2016Âπ¥ sun000. All rights reserved.//#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;double dp[10010];//ÂÅ∑Èí±iÊó∂ËÉΩÈÄÉË∑ëÁöÑÊúÄÂ§ßÊ¶ÇÁéástruct node&#123; int w; double p;&#125;v[105];int main(void)&#123; int t, n, sum; double p; scanf("%d", &amp;t); while(t--) &#123; memset(dp, 0, sizeof(dp)); dp[0] = 1; sum = 0; scanf("%lf%d", &amp;p, &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d%lf", &amp;v[i].w, &amp;v[i].p); sum += v[i].w; &#125; for(int i = 1; i &lt;= n; i++)//01ËÉåÂåÖÂÖàÂæ™ÁéØÁâ©ÂìÅÔºåÂÜçÂæ™ÁéØÂÆπÈáè for(int j = sum; j &gt;= v[i].w; j--)//01ËÉåÂåÖÈÄÜÂ∫èÂæ™ÁéØÔºåÂÆåÂÖ®ËÉåÂåÖÊ≠£Â∫èÂæ™ÁéØ &#123; dp[j] = max(dp[j], dp[j - v[i].w] * (1 - v[i].p)); //printf("dp[%d] = %lf\n", j, dp[j]); &#125; for(int i = sum; i &gt;= 0; i--) if(dp[i] &gt;= 1 - p) &#123; printf("%d\n", i); break; &#125; &#125; return0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5531Ôºà2015ÈïøÊò• icpc E.RebuildÔºâ ËÆ°ÁÆóÂá†‰Ωï]]></title>
    <url>%2F2017%2F06%2F02%2FHDU-5531%EF%BC%882015%E9%95%BF%E6%98%A5-icpc-E-Rebuild%EF%BC%89-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%2F</url>
    <content type="text"><![CDATA[Rebuild Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others) Total Submission(s): 1881 Accepted Submission(s): 416 Problem Description Archaeologists find ruins of Ancient ACM Civilization, and they want to rebuild it. The ruins form a closed path on an x-y plane, which has n endpoints. The endpoints locate on (x1,y1), (x2,y2), ‚Ä¶,(xn,yn) respectively. Endpoint i and endpoint i‚àí1 are adjacent for 1 &lt; i ‚â§ n, also endpoint 1 and endpoint n are adjacent. Distances between any two adjacent endpoints are positive integers. To rebuild, they need to build one cylindrical pillar at each endpoint, the radius of the pillar of endpoint i is ri. All the pillars perpendicular to the x-y plane, and the corresponding endpoint is on the centerline of it. We call two pillars are adjacent if and only if two corresponding endpoints are adjacent. For any two adjacent pillars, one must be tangent externally to another, otherwise it will violate the aesthetics of Ancient ACM Civilization. If two pillars are not adjacent, then there are no constraints, even if they overlap each other. Note that ri must not be less than 0 since we cannot build a pillar with negative radius and pillars with zero radius are acceptable since those kind of pillars still exist in their neighbors. You are given the coordinates of n endpoints. Your task is to find r1,r2,‚Ä¶,rn which makes sum of base area of all pillars as minimum as possible. For example, if the endpoints are at (0,0), (11,0), (27,12), (5,12), we can choose (r1, r2, r3, r4)=(3.75, 7.25, 12.75, 9.25). The sum of base area equals to 3.752œÄ+7.252œÄ+12.752œÄ+9.252œÄ=988.816‚Ä¶. Note that we count the area of the overlapping parts multiple times. If there are several possible to produce the minimum sum of base area, you may output any of them. Input The first line contains an integer t indicating the total number of test cases. The following lines describe a test case. The first line of each case contains one positive integer n, the size of the closed path. Next n lines, each line consists of two integers (xi,yi) indicate the coordinate of the i-th endpoint. 1‚â§t‚â§100 3‚â§n‚â§104 |xi|,|yi|‚â§104 Distances between any two adjacent endpoints are positive integers. Output If such answer doesn't exist, then print on a single line &quot;IMPOSSIBLE&quot; (without the quotes). Otherwise, in the first line print the minimum sum of base area, and then print n lines, the i-th of them should contain a number ri, rounded to 2 digits after the decimal point. If there are several possible ways to produce the minimum sum of base area, you may output any of them. Sample Input 3 4 0 0 11 0 27 12 5 12 5 0 0 7 0 7 3 3 6 0 6 5 0 0 1 0 6 12 3 16 0 12 Sample Output 988.82 3.75 7.25 12.75 9.25 157.08 6.00 1.00 2.00 3.00 0.00 IMPOSSIBLE È¢òÊÑèÔºöËøôÈÅìÈ¢òÁõÆÊåâÈ°∫Â∫èÁªôÂá∫‰∏Ä‰∫õÁÇπÁöÑÂùêÊ†áÔºåÁÇπ‰æùÊ¨°Áõ∏ËøûÔºåÂπ∂‰∏îÊúÄÂêé‰∏Ä‰∏™ÁÇπÂíåÁ¨¨‰∏Ä‰∏™ÁÇπÁõ∏ËøûÂΩ¢Êàê‰∏Ä‰∏™ÁéØ„ÄÇÈóÆÂú®Êç¢‰∏ä‰ª•ÊØè‰∏™ÁÇπ‰∏∫ÂúÜÂøÉ‰Ωú‰∏ÄÁ≥ªÂàóÂúÜÔºåË¶ÅÊ±ÇÁõ∏ÈÇª‰∏§ÁÇπÁöÑÂúÜÁõ∏‰∫íÂ§ñÂàá„ÄÇÂ¶Ç‰∏çÂ≠òÂú®ËøôÊ†∑ÁöÑÁÇπÂàôËæìÂá∫‚ÄúIMPOSSIBLE‚ÄùÂê¶ÂàôËæìÂá∫Ëøô‰∫õÂúÜÊÄªÈù¢ÁßØÁöÑÊúÄÂ∞èÂÄºÔºåÂπ∂‰æùÊ¨°ËæìÂá∫Ê≠§Êó∂ÊâÄÊúâÂúÜÁöÑÂçäÂæÑÔºàÊâÄÊúâËæìÂá∫‰øùÁïô‰∏§‰ΩçÂ∞èÊï∞Ôºâ ÂàÜÊûêÔºöÊàë‰ª¨ÂèØ‰ª•ÂÅáËÆæÁ¨¨‰∏Ä‰∏™ÂúÜÁöÑÂçäÂæÑ‰∏∫xÈÇ£‰πàËÉΩÂ§ü‰∏ÄÊ¨°Ë°®Á§∫Âá∫ÊâÄÊúâÁöÑÂúÜÁöÑÂçäÂæÑÔºåÂπ∂‰∏îÂèØ‰ª•ÊääÊØè‰∏™ÂúÜÁöÑÂçäÂæÑ‰æùÊ¨°Ë°®Á§∫‰∏∫f[i] + x,ÊàñËÄÖf[i] - x;ÔºàÁ¨¨i‰∏™ÁÇπÔºâi‰∏∫Â•áÊï∞ÊòØÊòØ+ÔºåÂÅ∂Êï∞ÊòØ-ÔºõÂõ†‰∏∫Ë¶ÅÊ±ÇÊâÄÊúâÁöÑÂçäÂæÑÂ§ß‰∫éÁ≠â‰∫é0ÔºåÈÇ£‰πàÊàë‰ª¨Âú®ÂèØ‰ª•‰∏ÄÊ¨°Ê±ÇÂá∫ÊâÄÊúâÁöÑf[i]ÂÖàÔºåÂíåxÁöÑËåÉÂõ¥[minn, maxn]„ÄÇÊúÄÂêéÂèØ‰ª•Áî®xË°®Á§∫Âá∫ÊúÄÂêé‰∏Ä‰∏™ÂúÜÁöÑÂçäÂæÑ„ÄÇ Â¶ÇÊûúÊòØÂ•áÊï∞‰∏™ÁÇπÔºöÈÇ£‰πàxÊòØ‰∏Ä‰∏™ÂèØ‰ª•Ê±ÇÁöÑÂÆöÂÄºÔºåÂè™Ë¶ÅÂà§Êñ≠Âú®‰∏çÂú®[minn, maxn]ÈáåÂ∞±ÂèØ‰ª•ÔºåÂ¶ÇÊûúÂú®ÂàôÊúâËß£ÔºåÈÇ£‰πàÂèØ‰ª•ÈÄöËøáf[i]Ê±ÇÂá∫ÊâÄÊúâÂúÜÁöÑÂçäÂæÑÔºåÈù¢ÁßØ‰πüÂÆπÊòìÊ±Ç„ÄÇ Â¶ÇÊûúÊòØÂÅ∂Êï∞‰∏™ÁÇπÔºöÈÇ£‰πàÊúÄÂêéÁöÑÂçäÂæÑÂíåÁ¨¨‰∏Ä‰∏™ÂúÜÁöÑÂçäÂæÑÊòØÂêåÂè∑Á†ÅÁöÑÔºåÈÇ£‰πà‰∏çËÉΩÁõ¥Êé•Ê±ÇÂá∫xÔºåÊàë‰ª¨ÂèØ‰ª•Áî®xÊù•Ë°®Á§∫ÊØè‰∏Ä‰∏™ÂúÜÁöÑÂçäÂæÑÔºåÈÇ£‰πàÊÄªÈù¢ÁßØ‰∏ÄÂÆöËÉΩË°®Á§∫Áß∞‰∏Ä‰∏™xÁöÑ‰∫åÊ¨°ÂáΩÊï∞ÔºåÁÑ∂ÂêéÁªìÂêàxÂú®Âå∫Èó¥[minn, maxn]ÂÜÖÔºåÂèØ‰ª•Ê±ÇÂá∫ÊúÄÂ§ßÁöÑÊÄªÈù¢ÁßØÔºåÂπ∂Ê±ÇÂá∫Ê≠§Êó∂ÁöÑx„ÄÇÁÑ∂ÂêéÂèØ‰ª•Ê±ÇÂá∫ÊØè‰∏™ÂúÜÁöÑÂçäÂæÑ„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134//// main.cpp// HDU-Fighting//// Created by ÁªøËâ≤ÂÅ•Â∫∑ÊñáËâ∫Â∞èÊ∏ÖÊñ∞ on ...// Copyright 2016Âπ¥ ÁªøËâ≤ÂÅ•Â∫∑ÊñáËâ∫Â∞èÊ∏ÖÊñ∞. All rights reserved.//#include &lt;cstdio&gt;#include &lt;cmath&gt;const double PI = acos(-1);//‰πãÂâçÂêßpiÂÜôÊàê3.1415926ÁôΩwa‰∫Ü‰∏ÄÂèëÔºåpi‰ª•ÂêéÈÉΩÂÜôÊàêacos(-1)‰∏çË¶ÅÊó†ÊïÖÁöÑwaconst double eps = 1e-7;int n;double len[10005], f[10005], x;struct point&#123; double x, y;&#125; p[10005];double cal_len(point a, point b)&#123; return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;void cal_all_len()//‰∏ÄÊ¨°Ê±ÇÂá∫ÊâÄÊúâËæπÁöÑÈïø&#123; for(int i = 0; i &lt; n - 1; i++) len[i] = cal_len(p[i], p[i + 1]); len[n - 1] = cal_len(p[0], p[n - 1]);&#125;double abs(double x)&#123; if(x &gt; 0) return x; return -x;&#125;void print(double ans)&#123; printf("%.2f\n", ans * PI); for(int i = 0; i &lt; n; i++) &#123; if(i &amp; 1)//Êàë‰ªé‰∏ãÊ†á0ÂºÄÂßãÂ≠òÔºåÊâÄ‰ª•‰ª£Á†ÅÈáåÁöÑiÂíåÂàÜÊûêÈáåÁöÑÁ¨¨Âá†‰∏™Â•áÂÅ∂ÊÄßÊòØÁõ∏ÂèçÁöÑ printf("%.2f\n", f[i] - x); else printf("%.2f\n", f[i] + x); &#125;&#125;int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; double maxn = 0x3f3f3f, minn = 0; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) scanf("%lf%lf", &amp;p[i].x, &amp;p[i].y); cal_all_len(); f[0] = 0; for(int i = 1; i &lt; n; i++) &#123; f[i] = len[i - 1] - f[i - 1]; if((i &amp; 1) &amp;&amp; f[i] &lt; maxn) maxn = f[i]; if(!(i &amp; 1) &amp;&amp; (-f[i]) &gt; minn) minn = -f[i]; &#125; if(minn &gt;= maxn + eps) &#123; printf("IMPOSSIBLE\n"); continue; &#125; if(n &amp; 1) &#123; x = 1.0 * (len[n - 1] - f[n -1]) / 2; if(x &lt;= minn - eps || x &gt;= maxn + eps) &#123; printf("IMPOSSIBLE\n"); continue; &#125; double ans = 0.0; for(int i = 0; i &lt; n; i++) &#123; if(i &amp; 1) ans += (f[i] - x) * (f[i] - x); else ans += (f[i] + x) * (f[i] + x); &#125; print(ans); &#125; else &#123; if(abs(f[n - 1] - len[n - 1]) &gt; eps || (minn - maxn) &gt; eps) &#123; printf("IMPOSSIBLE\n"); continue; &#125; double A = 0, B = 0, C = 0; for(int i = 0; i &lt; n; i++) &#123; A = A + 1; C += f[i] * f[i]; if(i &amp; 1) B -= 2 * f[i]; else B += 2 * f[i]; &#125; double l = (-B / 2) / A; if(l &lt; minn + eps) x = minn; else if(maxn &lt; l + eps) x = maxn; else x = l; print(A * x * x + B * x + C); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Êï∞Â≠¶</tag>
        <tag>ËÆ°ÁÆóÂá†‰Ωï</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1830È´òÊñØÊ∂àÂÖÉ]]></title>
    <url>%2F2017%2F05%2F30%2FPOJ-1830%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%2F</url>
    <content type="text"><![CDATA[Êüê‰∫õÂºÄÂÖ≥ÁöÑÂä®‰ΩúÂèØËÉΩÂΩ±ÂìçÂè¶‰∏Ä‰∫õÂºÄÂÖ≥ÁöÑÁä∂ÊÄÅ,Âõ†Ê≠§‰ª•ÂºÄÂÖ≥‰∏∫ËäÇÁÇπÔºåÂ¶ÇÊûúÂ≠òÂú®ËøôÁßçÂÖ≥Á≥ªÂ∞±Âä†ÂÖ•‰∏ÄÊù°ÊúâÂêëËæπÔºàÂºÄÂßãÊàëÊÉ≥ÊàêÂØπÁß∞ÁöÑ‰∫ÜÔºåÊµ™Ë¥π‰∫ÜÂæàÂ§öÊó∂Èó¥- -ÔºâÔºåËøôÊ†∑Â∞±ÊûÑÊàê‰∫Ü‰∏Ä‰∏™ÂõæÔºåÂèØ‰ª•Áî®ÈÇªÊé•Áü©ÈòµË°®Á§∫Ôºà‰ΩÜÊòØË¶ÅËΩ¨ÁΩÆ‰∏Ä‰∏ãÔºåÂêéÈù¢ÁªÜËØ¥Ôºâ„ÄÇÂΩìÊüê‰∏™ÂºÄÂÖ≥Êåâ‰∏ãÊó∂ÔºåÂÖ∂Ëá™Ë∫´Áä∂ÊÄÅÊîπÂèòÔºåÂèóÂÖ∂ÂΩ±ÂìçÁöÑÂºÄÂÖ≥ÁöÑÁä∂ÊÄÅ‰πüÊîπÂèò„ÄÇ Áî®‰∏§‰∏™NÁª¥ÂêëÈáèË°®Á§∫ÂàùÂßãÁä∂ÊÄÅÂíåÁªìÊùüÁä∂ÊÄÅÔºå‰∏§ËÄÖÈÄê‰∏™ÂÖÉÁ¥†ÂºÇÊàñÔºåÂ∞±ÂæóÂà∞‰∫ÜÂºÄÂÖ≥Áä∂ÊÄÅÁöÑÂèòÂåñ„ÄÇ ‰ª•Á¨¨‰∏Ä‰∏™Ê†∑‰æãËæìÂÖ•‰∏∫‰æãÂàÜÊûêÔºå3‰∏™ÂºÄÂÖ≥Ôºå‰∏§‰∏§Áõ∏ËøûÔºåÂàùÂßãÁä∂ÊÄÅ000ÔºåÊúÄÁªàÁä∂ÊÄÅ111ÔºåÂ∞ÜÂØπËßíÁ∫øÁöÑ0ÂÖ®ÈÉ®Êç¢Êàê1ÔºåÂæóÁü©ÈòµA= ËøôÈáåÂÜôÂõæÁâáÊèèËø∞ Â∞ÜÁü©ÈòµÊØè‰∏ÄÂàóÊÉ≥Ë±°‰∏∫‰∏Ä‰∏™ÂºÄÂÖ≥Êåâ‰∏ãÂêé‰∫ßÁîüÁöÑÊïàÊûúÔºà1Ë°®Á§∫Áä∂ÊÄÅÁøªËΩ¨Ôºå0Ë°®Á§∫‰∏çÂèòÔºâÔºåÊØîÂ¶ÇÔºåÁ¨¨‰∫åÂàóÂ∞±Ë°®Á§∫Êåâ‰∏ãÁ¨¨‰∫å‰∏™ÂºÄÂÖ≥ÔºåÂàôÁ¨¨‰∫å‰∏™ÂºÄÂÖ≥ÁöÑÊú¨Ë∫´Áä∂ÊÄÅË¶ÅÊîπÂèòÔºàËøôÂ∞±ÊòØÊääÂØπËßíÁ∫ø0Êç¢Êàê1ÁöÑÂéüÂõ†ÔºâÔºåÂèóÁ¨¨‰∫å‰∏™ÂºÄÂÖ≥ÂΩ±ÂìçÁöÑÂºÄÂÖ≥jÁä∂ÊÄÅ‰πüË¶ÅÊîπÂèòÔºåÊÅ∞Â•ΩÂØπÂ∫îÈÇªÊé•Áü©Èòµ‰∏≠A[j, 2]=1 ÊääAÂÜôÊàêÂàÜÂùóÁü©ÈòµÁöÑÂΩ¢ÂºèÔºåÊØè‰∏ÄÂàó‰Ωú‰∏∫‰∏Ä‰∏™Â≠êÁü©ÈòµÔºåÂàôÊúâA=[a1, a2, a3],Ê≠§Â§ÑaiÂùá‰∏∫ÂàóÂêëÈáèÔºåËÆæÁ¨¨i‰∏™ÂºÄÂÖ≥Êåâ‰∏ãÊ¨°Êï∞‰∏∫xiÔºåxi=0Êàñ1ÔºàÂºÄÂÖ≥Êåâ‰∏§‰∏ãÂíåÊ≤°ÊåâÊòØÁ≠âÊïàÁöÑÔºå0/1Â∞±Â§ü‰∫ÜÔºâ ËÆ∞ÂàùÂßãÁä∂ÊÄÅb0=[0,0,0],ÊúÄÁªàÁä∂ÊÄÅb1=[1,1,1],ÂàôÁä∂ÊÄÅÂèòÂåñb=b0^b1=[1,1,1],ËøôÈáåb‰πüÊòØÂàóÂêëÈáè„ÄÇÁõÆÊ†áÂ∞±ÊòØÊ±Çx1a1 + x2a2 +x3a3 = bÁöÑËß£ÁöÑ‰∏™Êï∞ÔºàÊ≠§Â§ÑÁöÑÂä†ÊòØÊ®°2Âä†Ôºå‰πüÂ∞±ÊòØÂºÇÊàñÔºå‰∏ãÂêåÔºâ &gt; Ëøô‰∏™ÊñπÁ®ãÂèØ‰ª•ÂÜôÊàê &gt; &gt; ‰∏ãÈù¢Â∞±ÊòØËß£Ëøô‰∏™Á∫øÊÄßÊñπÁ®ãÁªÑ ÂØπÂ¢ûÂπøÁü©Èòµ[A b]ÂÅöÂàùÁ≠âË°åÂèòÊç¢ÔºåÂåñÊàêÈò∂Ê¢ØÂΩ¢ÔºàÈ´òÊñØÊ∂àÂÖÉÊ≥ïÔºâÔºåÂ¶ÇÊûúÂ≠òÂú®[0,0,‚Ä¶,0,1]ÁöÑË°åÔºåÂ∞±ÊòØÊó†Ëß£ÔºõÂ¶ÇÊûúÂ≠òÂú®rË°å[0,0,‚Ä¶,0,0]ÔºåÂ∞±ÊÑèÂë≥ÁùÄÊúâr‰∏™Ëá™Áî±ÂèòÈáèÔºåÂõ†‰∏∫ËøôÈáåÁöÑÂèòÈáèÂè™Âèñ0/1ÔºåÊâÄ‰ª•Êúâ2r‰∏™Ëß£ÔºõÂ¶ÇÊûú‰∏çÂ≠òÂú®[0,0,‚Ä¶,0,*]ÔºåÂç≥ÊääÊúÄÂêé‰∏ÄË°åÂéªÊéâÂêé‰∏çÂ≠òÂú®ÂÖ®0Ë°åÔºåÂàôA‰∏∫Êª°Áß©Áü©ÈòµÔºåÂàôÊñπÁ®ãÁªÑÊúâÂîØ‰∏ÄËß£„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//// main.cpp// HDU-Fighting//// Created by ÁªøËâ≤ÂÅ•Â∫∑ÊñáËâ∫Â∞èÊ∏ÖÊñ∞ on ...// Copyright 2016Âπ¥ ÁªøËâ≤ÂÅ•Â∫∑ÊñáËâ∫Â∞èÊ∏ÖÊñ∞. All rights reserved.//#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;const int mod = 2;int a[30][31];int gcd(int a, int b)&#123; int t; while(b)&#123; t = b; b = a % b; a = t; &#125; return a;&#125;int lcm(int a, int b)&#123; return a / gcd(a, b) * b;&#125;int Gauss(int equ, int var)&#123; int k, col; for (k = 0, col = 0; k &lt; equ &amp;&amp; col &lt; var; ++k, ++col)&#123; int max_r = k; for (int i = k + 1; i &lt; equ; ++i)&#123; if (abs(a[i][col]) &gt; abs(a[max_r][col])) max_r = i; &#125; if (max_r != k)&#123; for (int i = k; i &lt;= var; ++i) swap(a[k][i], a[max_r][i]); &#125; if (a[k][col] == 0)&#123; --k; continue; &#125; for (int i = k + 1; i &lt; equ; ++i)&#123; if (a[i][col] != 0) &#123; int LCM = lcm(abs(a[i][col]), abs(a[k][col])); int ta = LCM / abs(a[i][col]); int tb = LCM / abs(a[k][col]); if (a[i][col] * a[k][col] &lt; 0) tb = -tb; for (int j = col; j &lt;= var; ++j) &#123; a[i][j] = ((a[i][j] * ta - a[k][j] * tb) % mod + mod) % mod; &#125; &#125; &#125; &#125; for (int i = k; i &lt; equ; ++i)&#123; if (a[i][col] != 0) return -1; &#125; return var - k;&#125;int s[30], e[30];long long int b[30];void build(int n)&#123; int x, y; while(scanf("%d%d", &amp;x, &amp;y), x || y) a[y - 1][x - 1] = 1; for(int i = 0; i &lt; n; i++) a[i][n] = s[i] ^ e[i];&#125;void init()&#123; b[0] = 1; for(int i = 1; i &lt; 30; i++) b[i] = b[i - 1] * 2;&#125;int main(void)&#123; int t, n; scanf("%d", &amp;t); init(); while(t--) &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt;= n; j++) a[i][j] = 0; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;s[i]); a[i][i] = 1; &#125; for(int i = 0; i &lt; n; i++) scanf("%d", &amp;e[i]); build(n); int ans = Gauss(n, n); if(ans == -1) printf("Oh,it's impossible~!!\n"); else printf("%lld\n", b[ans]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Êï∞Â≠¶</tag>
        <tag>È´òÊñØÊ∂àÂÖÉ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ëé´ÊØî‰πåÊñØÂèçÊºîÂÖ•Èó®]]></title>
    <url>%2F2017%2F05%2F28%2F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Ëøô‰∏™ÊñáÁ´†‰∏ªË¶ÅËÆ≤‰∏Ä‰∏ãACM‰∏≠1‰∏™Â∏∏Áî®ÁöÑËé´ÊØî‰πåÊñØÂèçÊºîÂÖ¨ÂºèÔºåÁúãÂà∞ÂæàÂ§öÂçöÂÆ¢‰∏äÈù¢ÂÖ¨ÂºèÊòØÊúâÔºå‰ΩÜÊòØÈÉΩÊ≤°ËØÅÊòéÔºå„ÄäÁªÑÂêàÊï∞Â≠¶„Äã‰∏äÁöÑËØÅÊòéÂèàÊ≤°ÁúãÊáÇÔºå Â∞±Ëá™Â∑±ÊÉ≥‰∫ÜÁßçËØÅÊòéÊñπÊ≥ïÔºåËßâÂæóÊØî„ÄäÁªÑÂêàÊï∞Â≠¶„ÄãÁöÑËØÅÊòéÁÆÄÂçï‰∫õÔºåÂ∞±ÂÜô‰∏Ä‰∏ãÔºåÂ∏åÊúõÂØπÂàùÂ≠¶Ëé´ÊØî‰πåÊñØÂèçÊºîÁöÑÂêåÂ≠¶ÊúâÂ∏ÆÂä©„ÄÇ PSÔºö‰∏ãÈù¢ÂÖ¨ÂºèÂá∫Áé∞ÁöÑsigmaÊòØÁ¥ØÂä†ÔºåÂè¶Â§ñÂª∫ËÆÆÂ§ßÂÆ∂ÁúãÁöÑÊó∂ÂÄô ÊääÂÖ¨ÂºèÂú®Á∫∏‰∏äÂÜôÂá∫Êù•ÔºÅ ‰∏ÄÔºö‰ªÄ‰πàÊòØËé´ÊØî‰πåÊñØÂèçÊºî ÁÆÄÂçïÁÇπÁöÑËØ¥ÔºåÂ∞±ÊòØÂÖàÁªôÂá∫‰∏Ä‰∏™ÂáΩÊï∞ F(n) ,ÁÑ∂ÂêéÂÜçÁî± F(n)ÂÆö‰πâ‰∏Ä‰∏™Êñ∞ÂáΩÊï∞ G(n) ÂÖ∂‰∏≠ G(n) = sigma(F(d)) (ÂÖ∂‰∏≠dË¢´‚ÄúÂåÖÂê´‚Äù‰∫én) ÁÑ∂Âêé Áé∞Âú®Êàë‰ª¨‰∏çÁü•ÈÅì F(n)ÁöÑÂÄº Ôºå Âç¥Áü•ÈÅì G(n)Ôºå Êé•ÁùÄÊàë‰ª¨Â∞±ÂèØ‰ª•ÈÄöËøá ÂèçÊºîÁî±G(n)ÂèçÂêëÂæóÂà∞F(n) ‰ªÄ‰πàÂè´ (ÂÖ∂‰∏≠dË¢´‚ÄúÂåÖÂê´‚Äù‰∫én) Ôºü‰ª•ÂèäÊÄé‰πàÁêÜËß£ÂèçÊºîÔºü ÈÄöËøá‰∏ãÈù¢ÁöÑÂá†‰∏™‰æãÂ≠êËØ¥Êòé ‰æã1Ôºö Êàë‰ª¨Áõ¥Êé•ÂÆö‰πâ G(n)=sigma(F(i)) (1&lt;=i&lt;=n) {ËøôÈáåÁöÑÊØè‰∏™F(i)ÔºåÁõ∏ÂØπ‰∫éG(n)ÂÆûÈôÖ‰∏äÂ∞±ÊòØ‰∏ÄÁßçÂåÖÂê´ÂÖ≥Á≥ª‰∫ÜÔºÅÔºÅ} ÁÑ∂ÂêéÊàë‰ª¨Áé∞Âú®Â∑≤ÁªèÁü•ÈÅì G(n)=n*(n+1)/2; Êé•‰∏ãÊù• Êàë‰ª¨Ë¶ÅÈÄöËøá G(n)ÂèçÂêëÂæóÂà∞F(n) ÁöÑËøáÁ®ãÔºåÂ∞±ÊòØÂèçÊºî ÂΩìÁÑ∂ÔºåËøô‰∏™ÈóÆÈ¢òÂæàÁÆÄÂçïÔºåÂæàÂÆπÊòìÈÉΩÂèØ‰ª•ÁúãÂá∫Êù• F(n)=n ÔΩûÔΩû ‰æã2: Êàë‰ª¨ÂÖà‰ª§ S,X ÈÉΩË°®Á§∫ÈõÜÂêà ÊØîÂ¶Ç S={1,4,6} X={2} Á≠â Âπ∂‰ª§|S|Ë°®Á§∫ S‰∏≠ÂÖÉÁ¥†ÁöÑ‰∏™Êï∞ Êé•ÁùÄÂÆö‰πâ ÈõÜÂêà‰∏äÁöÑÂáΩÊï∞ F(S) /ÂÖ∑‰ΩìÊÄé‰πàÂÆö‰πâ‰∏çÁî®ÁÆ°ÔºåÊàë‰ª¨Âè™ÈúÄË¶ÅÁü•ÈÅìÊúâËøô‰πà‰∏Ä‰∏™ÂÖ≥‰∫éÈõÜÂêàÁöÑÂáΩÊï∞FÂ∞±Â•Ω‰∫Ü :) / ÁÑ∂ÂêéÂÜçÂÆö‰πâ G(S)=sigma(F(X)) (ÂÖ∂‰∏≠XÊòØSÁöÑÂ≠êÈõÜ) {ËøôÈáå‰πüÊòØ‰∏ÄÁßçÂåÖÂê´ÂÖ≥Á≥ªÔºåÈõÜÂêàÁöÑÂåÖÂê´ÔºÅÔºÅ} Êé•ÁùÄÊàë‰ª¨‰∏çÁü•ÈÅìF(S)ÔºåÊÉ≥ÈÄöËøáG(S) Êù•ÂæóÂà∞ F(S) Ëøô‰∏™ÈóÆÈ¢òÁõ∏ÂØπ‰∫é‰æã1Â∞±Â§çÊùÇÂ§ö‰∫ÜÔºå‰ΩÜÂÆûÈôÖ‰∏äÊàë‰ª¨Â∑≤ÁªèÊúâÁé∞ÊàêÁöÑÂÖ≥‰∫éÈõÜÂêàÂåÖÂê´ÁöÑËé´ÊØî‰πåÊñØÂèçÊºîÂÖ¨Âºè‰∫Ü :) F(S)=sigma((-1)^(|S|-|X|) * G(X)) (ÂÖ∂‰∏≠XÊòØSÁöÑÂ≠êÈõÜ) ÊòØ‰∏çÊòØÊÑüËßâÊúâÁÇπÁ•ûÂ•áÔºü Â§ßÂÆ∂ÂèØ‰ª•Ëá™Â∑±ÂÜô‰∏™Á®ãÂ∫èÊù•È™åËØÅ‰∏Ä‰∏ã„ÄÇ ‰∏ãÈù¢Â∞±ÊòØÊàëÁöÑÈ™åËØÅÁ®ãÂ∫èÔºö ÊàëÂÆö‰πâ F(S)=|S| Ôºå ÁÑ∂ÂêéÂÖà ËÆ°ÁÆóÂá∫ F(S) ,Êé•ÁùÄ ËÆ°ÁÆóÂá∫ G(S) , ÁÑ∂Âêé ÊØîËæÉÁî±G(S)ÂèçÊºîÂæóÂà∞ÁöÑ F(S)Âíå |S| ÁöÑÂ§ßÂ∞è ‰∏ãÈù¢ÊòØ ÊàëÁöÑÁ®ãÂ∫è 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;#define base 10#define REP(i,n) for(int i=0;i&lt;(n);i++)int F[1&lt;&lt;base],G[1&lt;&lt;base];// ÈõÜÂêàÁî®‰∫åËøõÂà∂Ë°®Á§∫ baseË°®Á§∫ÈõÜÂêàÊúÄÂ§ö10‰∏™ÂÖÉÁ¥†int Cal(int x)&#123; // ËÆ°ÁÆó |x| int sum=0; while(x) sum+=(x&amp;1),x/=2; return sum;&#125;int main()&#123; REP(S,1&lt;&lt;base) F[S]=Cal(S); // ËÆ°ÁÆóÂá∫ÊúÄÂºÄÂßãÁöÑF(S) REP(S,1&lt;&lt;base)&#123; // ËÆ°ÁÆóG(S) G[S]=0; for(int X=S;X;X=(X-1)&amp;S) G[S]+=F[X]; //Áî®XÈÅçÂéÜSÈõÜÂêà &#125; REP(S,1&lt;&lt;base)&#123; // ËÆ°ÁÆóÂèçÊºîÁöÑ F(S) F[S]=0; for(int X=S;X;X=(X-1)&amp;S) F[S]+=(int)pow(-1,Cal(S)-Cal(X))*G[X]; &#125; bool flag=1; // È™åËØÅ‰∏Ä‰∏ã REP(S,1&lt;&lt;base) if(F[S]!=Cal(S)) flag=0; if(flag) cout&lt;&lt;"YES"&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl;&#125; ÊúÄÂêéÂæóÂà∞ÁöÑÁªìÊûú ÂΩìÁÑ∂ÊòØ YES ÂíØÔºÅ:) ÂÖ≥‰∫éËøô‰∏™ ÂèçÊºîÂÖ¨Âºè ÁöÑËØÅÊòéÔºåÂÖà‰∏çË¶ÅÁùÄÊÄ•ÔºåÁúãÂÆåÊñáÁ´†ËøáÂêéÔºå‰Ω†Ëá™Â∑±ÈÉΩËÉΩÊë∏Á¥¢ÁùÄËØÅÊòé‰∫ÜÔºÅÔºÅ Áé∞Âú®ÂÖàÂ§ßÊ¶ÇÁêÜËß£ÂèçÊºîÊòØ‰∏™‰ªÄ‰πàÂ∞±Ë°å‰∫ÜÔºÅÔºÅ ‰æã3Ôºö ÂÖà‰ª§ d|n Ë°®Á§∫ dËÉΩÊï¥Èô§n ÊØîÂ¶Ç 2|4 (=.=) ÂÆö‰πâ ÂÖ≥‰∫é Êï¥Êï∞ ÁöÑÂáΩÊï∞ F(n) ÁÑ∂Âêé ÂÆö‰πâ G(n)=sigma(F(d)) (ÂÖ∂‰∏≠d|n) ‰∏äÈù¢ÁöÑËøôÁßçÂåÖÂê´ÂÖ≥Á≥ªÂ∞±Êõ¥Â§çÊùÇ‰∫ÜÔºåÂè™ÊúâÂΩìdÊòØnÁöÑÂõ†Â≠êÁöÑÊó∂ÂÄôÔºåF(d)Êâç‰ºöË¢´ÂåÖÂê´Âú®G(n)‰∏≠„ÄÇ ‰∏çËøáËøôÁßç ÂåÖÂê´ÂÖ≥Á≥ª Âú® ACM‰∏≠ÈÅáÂà∞ÁöÑÊúÄÂ§öÔºåÊâÄ‰ª•Êàë‰ºöËØ¶ÁªÜËÆ≤‰∏Ä‰∏ãËøôÁßçÁ±ªÂûãÁöÑ ÂèçÊºî„ÄÇ Áõ∏‰ø°ÊòéÁôΩ‰∫ÜËøô‰∏™ËøáÂêéÔºå‰æã2ÁöÑÂèçÊºî‰πüËÉΩÂ§üËá™Â∑±ËØÅÊòé‰∫Ü„ÄÇ ÂÖ∑‰ΩìÁöÑËÆ≤Ëß£ËßÅ‰∏ã‰∏ÄÁ´†ËäÇ :) ‰∫åÔºö‰∏ÄÁ±ªÂèçÊºî Ëøô‰∏™‰∏ÄÁ±ªÂèçÊºîÂ∞±ÊòØ‰æã3‰∏≠ÁöÑÈÇ£‰∏ÄÁ±ªÂíØ= = ÊàëÂÖàÁõ¥Êé•ÁªôÂá∫ÁªìËÆ∫Âêß ÂéüÂºè : G(n)=sigma(F(d)) (ÂÖ∂‰∏≠d|n) ÂèçÊºîÂÖ¨Âºè: F(n)=sigma(U(n/d)*G(d)) ËøôÈáåUÊòØ‰∏Ä‰∏™ÂáΩÊï∞Ôºå‰ªñÊòØÊØè‰∏ÄÈ°π G(d) ÁöÑÁ≥ªÊï∞Ôºå‰ªñÁöÑÂÆö‰πâËßÅ‰∏ãÈù¢ ÔºàÂº∫ÁÉàÂª∫ËÆÆÂÖ≥‰∫éUÁöÑÂÆö‰πâËøô‰∏ÄÊÆµÂèØ‰ª•ÂÖàË∑≥ËøáÔºåÂÖàËÆ§‰∏∫‰ªñÊòØGÁöÑÁ≥ªÊï∞Â∞±Ë°å‰∫ÜÔºåÂèØ‰ª•Ë∑≥Âà∞‰∏ãÈù¢Á∫¢Â≠ó‰ΩçÁΩÆÔºâ (1).UÊòØ‰∏Ä‰∏™ÂÖ≥‰∫éÊï¥Êï∞ÁöÑÂáΩÊï∞ (2).U[x] = 1 ÂΩì‰∏î‰ªÖÂΩì xËÉΩÂ§üÂàÜËß£ÊàêÂÅ∂Êï∞‰∏™‰∏çÂêåË¥®Êï∞ÁöÑ‰πòÁßØ ÔºàÂÖ∂‰∏≠1‰∏çËÉΩË¢´ÂàÜËß£ÔºåÊâÄ‰ª•1ÁöÑÂàÜËß£Âá∫ÁöÑË¥®Êï∞‰∏™Êï∞ÊòØ0ÔºåÊâÄ‰ª•U[1]=1Ôºâ (3).U[x] = -1 ÂΩì‰∏î‰ªÖÂΩì xËÉΩÂ§üÂàÜËß£ÊàêÂ•áÊï∞‰∏™‰∏çÂêåË¥®Êï∞ÁöÑ‰πòÁßØ (4).U[x] = 0 Èô§ÂºÄ(2),(3)ÁöÑÂÖ∂‰ªñÊÉÖÂÜµ Áúã‰∏äÈù¢ÂÖ≥‰∫éUÁöÑÂÆö‰πâÂèØËÉΩÊúâÁÇπÁúãÊôï‰∫ÜÔºåÈÄö‰øó‰∏ÄÁÇπÁöÑËØ¥ ÂØπ‰∫é‰∏Ä‰∏™ x , ÂàÜËß£Âõ†ÂºèËøáÂêé Êúâ x=(p1e1)(p2^e2)...(prer) Â¶ÇÊûú ei‰∏≠(1&lt;=i&lt;=r)Êúâ‰∏Ä‰∏™Êï∞eiÂ§ß‰∫é1 ÈÇ£‰πà U[x] = 0; ‰∏çÁÑ∂ÁöÑËØù U[x] = (-1)^r ‰æùÊóßÊù•‰∏§‰∏™‰æãÂ≠êÔºàÊàëÊúÄÂñúÊ¨¢‰∏æ‰æãÂ≠ê‰∫Ü = =Ôºâ U[1]=1;ÂÆö‰πâ‰∏≠ÁöÑËØ¥Êòé U[2]=-1; ÂàÜËß£Âºè 2=2; U[6]=1; ÂàÜËß£Âºè 6=2*3 U[9]=0; 9=3^2; Âá∫Áé∞‰∫Üe&gt;1 U[12]=0; 12=2^2*3; Ë∑≥Âà∞ËøôÈáå :) ‰∏äÈù¢Â∞±ÊòØÂÖ≥‰∫éËøôÁ±ªÂèçÊºîÂÖ¨ÂºèÁöÑÂÆö‰πâÔºå‰∏çË¶ÅÂ§¥Êôï= =ÔºåÁªßÁª≠ÂæÄ‰∏ãÁúãÂêß Âú®ËØÅÊòé‰πãÂâçÔºåÊàë‰ª¨ÂÖàÊÉ≥‰∏Ä‰∏ãÔºå‰∏∫‰ªÄ‰πàÂèçÊºîÂÖ¨Âºè‰ºöÊòØ F(n)=sigma(U(n/d)*G(d)) ËøôÊ†∑ÁöÑÂûãÂºèÔºü ‰æùÊóßÈÄöËøá‰æãÈ¢òÊù•ÊâæËßÑÂæã (^ ^) Êàë‰ª¨‰ª§ n=6; ÈÇ£‰πà Âú®ËÆ°ÁÆó F(6)ÁöÑÊó∂ÂÄôÔºåÊàë‰ª¨‰ºöÁî®Âà∞ G(1) G(2) G(3) G(6) Êàë‰ª¨ËÄÉÂØüËÄÖ4‰∏™G G(1) = F(1) G(2) = F(1)+F(2) G(3) = F(1)+F(3) G(6) = F(1)+F(2)+F(3)+F(6) ËßÇÂØü‰∏äÈù¢ÂèØ‰ª•ÂèëÁé∞ ÊØè‰∏™ G(n)ÈÉΩÊòØÁî±‰∏Ä‰∫õF(d)Á¥ØÂä†ÂæóÂà∞ÁöÑ ÂΩìÊàë‰ª¨ÈúÄË¶ÅÈÄÜÂêëÊúâGÂæóÂà∞F(n)Êó∂ÔºåÂè™ÈúÄË¶ÅÂ∞Ü‰∏Ä‰∫õ ‰∏é F(n) ÊúâÂÖ≥ÁöÑ GËøõË°åÂÆπÊñ•ÔºÅÔºÅÔºÅÔºÅÔºÅ ÊúÄÁªàÁªÑÂêàÂæóÂà∞F(n)ÔºÅÔºÅÔºÅ ÊØîÂ¶Ç F(6) = G(6)-G(2)-G(3)+G(1) ÔºÅÔºÅÔºÅÔºÅ Êúâ‰∫õÁ•ûÂ•áÔºÅÔºÅ ‰∏çËøáËøôÁ±ªËé´ÊØî‰πåÊñØÂèçÊºîÁöÑÂÆûË¥®‰πüÂ∞±ÊòØÂÆπÊñ•ÂéüÁêÜÁöÑÂ∫îÁî®ÔºÅÔºÅ ÈÇ£‰πàÊàë‰ª¨Áé∞Âú®Áü•ÈÅì‰∏∫‰ªÄ‰πà ËøôÁ±ªÂèçÊºîÂÖ¨Âºè‰ºöÊòØ Ëøô‰∏™ÂΩ¢Âºè‰∫ÜÔºåËÄå‰∏îÂØπÂÖ∂ÂéüÁêÜ‰πüÊúâ‰∫ÜÊõ¥Ê∑±ÁöÑÁêÜËß£ÔºåÁé∞Âú®ËØ•ÊÉ≥‰∏ÄÊÉ≥ÂÖ¨ÂºèÁöÑÁªÜËäÇ‰∫Ü„ÄÇ Êó¢ÁÑ∂Êàë‰ª¨Áü•ÈÅìË¶ÅÂæóÂà∞ F(n) ÔºåÂè™ÈúÄË¶ÅÂ∞Ü‰∏éÂÖ∂Áõ∏ÂÖ≥ÁöÑ GËøõË°åÂÆπÊñ•Â∞±ÂèØ‰ª•ÔºåÈÇ£‰πàÂâ©‰∏ãÁöÑÈóÆÈ¢òÂ∞±ÊòØÊØè‰∏™GÁöÑÁ≥ªÊï∞ÔºÅÔºÅÔºÅ Êàë‰ª¨‰ª• Ê±ÇËß£ F(6)‰∏∫‰æãÂ≠êÊù•ËØ¥Êòé ÔºåÂπ∂ÂÆö‰πâ‰∏Ä‰∏™Á≥ªÊï∞ÂáΩÊï∞ H(d,n). ÂÖ∂‰∏≠ H(d,n)Ë°®Á§∫ Ê±ÇËß£F(n)Êó∂ÔºåG(d)ÁöÑÁ≥ªÊï∞ ÔºàÂÖ∂‰∏≠d|nÔºâ ÊâÄ‰ª•ÂèØ‰ª•ÂæóÂà∞Ëøô‰∏™ÂºèÂ≠ê F(6) = H(6,6)G(6)+H(2,6)G(2)+H(3,6)G(3)+H(1,6)G(1) Êàë‰ª¨Áî® a,b,c,dÂàÜÂà´Êõø‰ª£ Âõõ‰∏™H(6,6),H(2,6),H(3,6),H(1,6)ÔºåÂπ∂‰∏îÊääÂØπÂ∫îÁöÑGÁî®FË°®Á§∫Âá∫Êù•ÔºåÂæóÂà∞ F(6)=a(F(6)+F(3)+F(2)+F(1))+b(F(2)+F(1))+c(F(3)+F(1))+dF(1),ÂÜçÂèòÂΩ¢‰∏Ä‰∏ãÔºåÂèàÊúâ F(6)(a-1)+F(3)(a+c)+F(2)(a+b)+F(1)(a+b+c+d)=0ÔºåÊääF(6),F(3),F(2),F(1)ÂΩì‰Ωú‰∏çÂêåÁöÑÂÖÉÔºåÂàôÂæóÂà∞‰∫Ü‰∏ãÈù¢ÁöÑÊñπÁ®ãÁªÑÔºÅÔºÅÔºÅ a-1==0 a+c==0 a+b==0 a+b+c+d==0 Áî±Ê≠§ÂèëÁé∞ÔºåÂõõ‰∏™Êú™Áü•Êï∞ÔºåÂõõ‰∏™ÊñπÁ®ãÔºåÂè™ÈúÄË¶ÅËß£Âá∫ÊñπÁ®ãÔºåÂ∞±ËÉΩÁü•ÈÅìÂØπ‰∫éGÁöÑÁ≥ªÊï∞„ÄÇ ÂÜçÊ∑±ÂÖ•ÁöÑÊÉ≥‰∏Ä‰∏ãÔºåÂØπ‰∫éÊØè‰∏™ F(n),ÂÅáËÆæ‰ªñÁöÑÂõ†Â≠êÊï∞‰∏∫,mÔºåÂàôÈÄöËøáËøôÁßçÊñπÂºèÔºåÊÄªËÉΩËÆæÂá∫m‰∏™Êú™Áü•Êï∞Ôºåm‰∏™ÊñπÁ®ãÔºå ËøôÊ†∑ÊÄªËÉΩÊâæÂà∞Ëß£ÔºåËÄåËøô‰πü‰∏∫Ëé´ÊØî‰πåÊñØÂèçÊºîÁöÑÂèØËÉΩÊÄß‰ΩúÂá∫‰∫ÜËß£ÈáäÔºÅÔºÅ Áé∞Âú®Êàë‰ª¨Ë¶ÅËØÅÊòé‰∏Ä‰∏™ÁªìËÆ∫ÔºåÂç≥‰ΩøH(a,b)==H(1,b/a)ÔºÅÔºÅËøô‰∏™ÁªìËÆ∫ÂæàÈáçË¶ÅÔºåÂÖ∑‰ΩìÂàÜÊûêËßÅ‰∏ã :) Êàë‰ª¨‰ª•Ê±ÇËß£ F(8)‰∏∫‰æãÂ≠êÔºå‰∏éF(8)Áõ∏ÂÖ≥ÁöÑ H Êúâ ÔºåH(8,8),H(4,8),H(2,8),H(1,8) F(8)=H(8,8)G(8)+H(4,8)G(4)+H(2,8)G(2)+H(1,8)G(1) È¶ñÂÖàÁúã H(8,8),ÂÖ∂ÂÄºÂèØ‰ª•Áõ¥Êé•Á°ÆÂÆöÔºåÂõ†‰∏∫ÊääF(8)ÂΩì‰ΩúÂÖÉÁöÑËØùÔºåÂ∑¶Ëæπ‰∏Ä‰∏™F(8),ËÄåÂú®Âè≥ËæπF(8)Âè™Âú®G(8)‰∏≠Âá∫Áé∞ÔºåÊâÄ‰ª•H(8,8)==1 ÂêåÁêÜ ÂØπ‰∫é F(n)ÔºåÂÖ∂G(n)ÁöÑÁ≥ªÊï∞H(n,n)==1ÔºåÊâÄ‰ª•H(8,8)==H(1,1) ÂÜçÊù•ÁúãH(4,8),ÔºåÈ¶ñÂÖàÊÉ≥ÔºåF(4)Âú®Âì™‰∫õÂú∞ÊñπÂá∫Áé∞ÔºåÂèëÁé∞ Âú®G(8)ÂíåG(4)Âá∫Áé∞ÔºåÂõ†‰∏∫Â∑¶Ëæπ‰∏çÂê´F(4)ÔºåËÄåÂâçÈù¢G(8)ÁöÑÁ≥ªÊï∞ÂèàÂ∑≤ÁªèÁ°ÆÂÆöÔºå ÊâÄ‰ª•ËøôÈáåH(4,8)*G(4)ÁöÑ‰ΩúÁî®Â∞±ÊòØ‰∏∫‰∫ÜÊäµÊ∂àÂâçÈù¢G(8)ÁöÑ‰ª£Êç¢‰∏≠ÔºåÂá∫Áé∞ÁöÑF(4)ÔºåÊâÄ‰ª• H(4,8)==-H(8,8)==-H(2,2)==H(1,2),{H(1,2)==-H(1,1)ËØ∑Â§ßÂÆ∂Ëá™Â∑±È™åËØÅ‰∏Ä‰∏ã} ÂêåÁêÜÂØπ‰∫éH(2,8)Ôºå‰ªñÊòØ‰∏∫‰∫ÜÊäµÊ∂àÂâçÈù¢Âú®G(8)ÂíåG(4)‰∏≠Âá∫Áé∞ÁöÑF(2)ÔºåÊâÄ‰ª•H(2,8)Áõ∏ÂΩì‰∫éÂèóÂà∞H(4,4)ÂíåH(2,4)ÁöÑÂΩ±Âìç(ÂÅáËÆæËøô‰∏™ÁªìËÆ∫ÂØπn==4‰πüÊàêÁ´ãÔºåH(2,4)==H(1,2))Ôºå ÊâÄ‰ª•H(2,8)==H(1,4) ÊâæÂà∞ËßÑÂæãËøáÂêéÔºåÊÄªÁªì‰∏Ä‰∏ãÔºåÂÅáËÆænÁöÑÂõ†Â≠êÊúâ d1,d2,d3...dm ÂÖ∂‰∏≠ d1&gt;d2&gt;d3...&gt;dm Êàë‰ª¨‰æùÊ¨°Á°ÆÂÆöH(di,n)ÁöÑÂÄºÔºåÂΩìÊàë‰ª¨Âú®Á°ÆÂÆöH(di,n)ÁöÑÂÄºÊó∂ÔºåÂâçÈù¢ÁöÑÂÄºÂ∑≤ÁªèÁ°ÆÂÆöÔºåÂç≥H(dj, n)(j &lt; i)ÁöÑÂÄºÂ∑≤ÁªèÁ°ÆÂÆöÔºå H(di,n)‰ºöÂèóÂà∞ÂâçÈù¢‰∏Ä‰∫õH(dj,n)ÁöÑÂΩ±ÂìçÔºåÂΩì‰∏î‰ªÖÂΩì dj&gt;di‰∏î di|dj „ÄÇ ÂÅáËÆæ H(a,b)==H(1,b/a)ÂØπÂâçÈù¢ÁöÑ H(dj,n)Âíå ÊâÄÊúâÁöÑH(k,m)ÂÖ∂‰∏≠m &lt; n Â∑≤ÁªèÊàêÁ´ã(È¶ñÂÖàÂØπ‰∫éH(n,n)Â∑≤ÁªèÊàêÁ´ã)ÔºåÈÇ£‰πàÊúâ H(dj,n)==H(1,n/dj)==H(dj/di,n/di) ËøôÊ†∑Â∞±ÊääÂâçÈù¢ÂØπH(di,n)ÈÄ†ÊàêÂΩ±ÂìçÁöÑHÁî± H(dj,n)ËΩ¨‰∏∫‰∫Ü H(dj/di,n/di) ,ÊâÄ‰ª•H(di,n) == H(1,n/di) Êó¢ÁÑ∂ H(a,b) ÈÉΩÂèØ‰ª• ÂÜôÊàê H(1,b/a) Ôºå ‰∫éÊòØÊàë‰ª¨ÊääHÁöÑÁ¨¨‰∏Ä‰∏™ÂÖÉÁ¥†Áï•ÂéªÔºåÁÆÄÂÜô‰∏∫ H(x) ËØ¥Âà∞ËøôÈáåÔºåÂ∞±ÂèØ‰ª•ÊääHÂíåUËÅîÁ≥ªËµ∑Êù•‰∫ÜÔºåÂÖ∂ÂÆû U(x) = H(x) = H(1,x) ÂÜçÊù•ÔºåÊàë‰ª¨Â∞±ÂèØ‰ª•ÁªôU(x)Ëµã‰∫à‰∏Ä‰∏™Êõ¥ÂÖ∑‰ΩìÁöÑÊÑè‰πâÔºå U(x)Ë°®Á§∫Âú®ËÆ°ÁÆó F(x)Êó∂ÔºåG(1)ÁöÑÁ≥ªÊï∞ÔºÅÔºÅ(Âõ†‰∏∫U(x)==H(1,x)) Êé•‰∏ãÊù•ÔºåÊàë‰ª¨Êù•Â∞ùËØï‰∏Ä‰∏ãÔºåÂ¶Ç‰ΩïÁî®‰∏äÈù¢ÈÇ£‰∏™U(x)ÁöÑÊñ∞ÊÑè‰πâÔºåÊù•ËÆ°ÁÆóU(x)ÁöÑÂÄºÔºÅÔºÅ È¶ñÂÖàÈúÄË¶ÅÊòéÁ°Æ2ÁÇπÔºÅ ‰∏ÄÊòØG(x)‰∏≠,‰∏ÄÂÆöÂåÖÂê´‰∏Ä‰∏™F(1)ÔºåÂõ†‰∏∫ 1|x ‰∫åÊòØÔºåF(1)==G(1) (0).Â¶ÇÊûú x==1 Âõ†‰∏∫ F(1)==G(1) ÊâÄ‰ª• U[1]=1; (1).ÂÅáËÆæ x ÊòØ‰∏Ä‰∏™ Ë¥®Êï∞ F(x) = U(1)G(x)+U(x)G(1) Â∏¶ÂÖ•U(1) == 1, Âõ†‰∏∫G(x)‰∏≠Âê´Êúâ‰∏Ä‰∏™F(1),ËÄåÂ∑¶Ëæπ‰∏çÂê´F(1)ÔºåÊâÄ‰ª•Êàë‰ª¨ÈúÄË¶ÅÂà©Áî®G(1)Êù•Ê∂àÂéªF(1) ÊâÄ‰ª•ÂæóÂà∞ U(x)=-1 (2).ÂÅáËÆæ x ÂèØ‰ª•ÂÜôÊàê2‰∏™‰∏çÂêåË¥®Êï∞ÁöÑ‰πòÁßØ x=p*q ÈÇ£‰πà F(x)=U(1)G(pq)+U(q)G(p)+U(p)G(q)+U(x)G(1) ËøôÈáå U(1)ÔºåU(p)ÔºåU(q) Â∞±ÊòØÂâçÈù¢2ÁßçÊÉÖÂÜµ Â∏¶ÂÖ•Á≥ªÊï∞ÔºåÂõ†‰∏∫Â∑¶ËæπÊ≤°Êúâ F(1)ÔºåÊâÄ‰ª•‰∏∫‰∫ÜÊäµÊ∂àÂè≥ËæπÁöÑF(1)ÔºåÊàë‰ª¨ÈúÄË¶Å‰ª§ U(x)=1; (3).ÂÅáËÆæ x ÂèØ‰ª•ÂÜôÊàê3‰∏™‰∏çÂêåË¥®Êï∞ÁöÑ‰πòÁßØ x=pp1p2 Êàë‰ª¨‰ª§ z = p1*p2 F(x) = U(1)G(pz)+U(z)G(p)+U(p)G(z)+U(x)G(1); ÂÖ∂‰∏≠ U(1),U(p),U(z) ÂàÜÂà´‰∏∫ÂâçÈù¢Âá†ÁßçÊÉÖÂÜµÔºåÂ∏¶ÂÖ•ËøáÂêé Ôºå‰∏∫ÊäµÊ∂àF(1) ÂæóÂà∞ U(x)=-1 Áî±Ê≠§ÂèØ‰ª•Áõ∏ÂêåÁöÑÊñπÂºèÂêë‰∏ãÈÄíÊé®ÔºåÂæóÂà∞Á¨¨‰∏ÄÊù°ÁªìËÆ∫ Â¶ÇÊûú x = p1p2...pr , ÂÖ∂‰∏≠piÊòØ‰∫íÂºÇÁöÑË¥®Êï∞ÔºåÈÇ£‰πà U[x] = (-1)^r ----------------------- 1ÔºÅÔºÅ (4).ÂÅáËÆæ x ÂèØ‰ª•ÂÜôÊàê‰∏Ä‰∏™Ë¥®Êï∞ÁöÑÂπ≥Êñπ x=p^2 F(x) = U(1)G(x)+U(p)G(p)+U(x)*G(1) Â∏¶ÂÖ•Á≥ªÊï∞ ÂæóÂà∞ U(x)=0; (5).ÂÅáËÆæ x ÂèØ‰ª•ÂÜôÊàê‰∏Ä‰∏™Ë¥®Êï∞ÁöÑ‰∏âÊ¨°Êñπ x=p^3 F(x) = U(1)G(x)+U(p)G(p2)+U(p2)G(p)+U(x)G(1) Â∏¶ÂÖ•Á≥ªÊï∞Âêé U(x)=0; Áî±Ê≠§ÂèØÁî®Áõ∏ÂêåÊñπÂºèÂêë‰∏ãÈÄíÊé®ÔºåÂæóÂà∞Á¨¨‰∫åÊù°ÁªìËÆ∫ Â¶ÇÊûú x = p^e (e&gt;1) U[x] = 0; -------------------------- 2ÔºÅÔºÅ (6).ÂÅáËÆæ x ÂèØÂÜôÊàê x = p^e*q ÂÖ∂‰∏≠p,q‰∏∫‰∏çÂêåË¥®Êï∞Ôºåe&gt;1 F(x) = U(1)G(x)+U(q)G(pe)+U(pe)G(q)+U(x)G(1) Â∏¶ÂÖ•Á≥ªÊï∞Âêé U(x) = 0; Áî±Ê≠§ÂèØÁªßÁª≠Âêë‰∏ãÈÄíÊé®ÔºåÂæóÂà∞Á¨¨‰∫åÊù°ÁªìËÆ∫ÁöÑÂä†Âº∫ÁâàÔºÅÔºÅ Â¶ÇÊûú x = p^e*z ÂÖ∂‰∏≠p‰∏∫Ë¥®Êï∞, z‰∏∫‰ªªÊÑèÊï∞,e&gt;1 ÈÇ£‰πà U[x] = 0 ----------------------2ÔºÅÔºÅ Áî±Ê≠§ÔºåÊàë‰ª¨ÂæóÂà∞‰∫Ü U[x] ÁöÑËÆ°ÁÆóÊñπÊ≥ïÔºÅÔºÅÂç≥ÊòØUÂÆö‰πâ‰∏≠ÁªôÂá∫ÁöÑÈÇ£Ê†∑ÔºÅÔºÅÔºàÊ≤°ÁúãÂÆö‰πâÁöÑÂêåÂ≠¶Ê≠§Êó∂ÂÜçË∑≥ÂõûÂéªÁúãÂêßÔºâ ‰∏âÔºöÂ∫îÁî® ÂæóÂà∞‰∫ÜÂÖ¨ÂºèÔºå‰πüÁü•ÈÅì‰∫Ü‰ªñÊòØÊÄé‰πàÊù•ÁöÑÔºåÁé∞Âú®Â∞±Áî®‰∏Ä‰∏™Â∫îÁî®Êù•Âä†Ê∑±ÁêÜËß£Âêß :) È¶ñÂÖàÊàë‰ª¨Ë¶ÅÁªôÂá∫ Á¨¨‰∫åÈÉ®ÂàÜ ‰∏≠ÈÇ£‰∏™ÂÖ¨ÂºèÁöÑÂè¶Â§ñ‰∏ÄÁßçÂΩ¢Âºè = = Êàë‰ª¨ÊääÂÆÉÁß∞‰∏∫ÂΩ¢Âºè‰∫åÂêßÔΩû ÂéüÂºè : G(n)=sigma(F(d)) (ÂÖ∂‰∏≠n|d,d&lt;=N) ÂèçÊºîÂÖ¨Âºè: F(n)=sigma(U(d/n)*G(d)) (ÂÖ∂‰∏≠n|d,d&lt;=N) ËøôÈáåU[x]ÁöÑËÆ°ÁÆóÊñπÂºèÂíå‰∏äÈù¢ÁöÑÁõ∏ÂêåÔºÅÔºÅ Ê≥®ÊÑè‰∏äÈù¢ÁöÑ n|d Âíå d/n Âíå‰∏äÈù¢ÊòØÁõ∏ÂèçÁöÑ ËØÅÊòéÊñπÊ≥ïÂíå‰∏äÈù¢Â∑Æ‰∏çÂ§öÔºåÂ§ßËá¥ËØ¥‰∏Ä‰∏ã ËøòÊòØÂÖàËÆæÁΩÆ‰∏Ä‰∏™Á≥ªÊï∞ÂáΩÊï∞ H(d,n) Ë°®Á§∫Ê±ÇËß£ F(n)Êó∂ G(d)Âá∫Áé∞ÁöÑÊ¨°Êï∞Ôºå Êé•ÁùÄ Áî®‰∏é‰∏äÈù¢Á±ª‰ººÁöÑÊñπÊ≥ïÂèòÂåñH(d,n) ‰∏∫ H (d/n,1) ---&gt; H(x,1) ÂàôËÅîÁ≥ª U(x) == H(x,1) Ë°®Á§∫ Âú®ËÆ°ÁÆó F(1)Êó∂ÔºåG(x)ÁöÑÁ≥ªÊï∞ ‰ª• x ‰∏∫Ë¥®Êï∞‰∏∫‰æãÂ≠êÔºåÁî±‰∫é G(1)=F(1)+F(2)....+F(N) F(1) = G(1)+U(2)G(2)...+U(x)G(x)...+U(N)G(N) Âõ†‰∏∫ x ‰∏∫Ë¥®Êï∞ ÊâÄ‰ª• F(x)Ëøô‰∏ÄÈ°π Âè™Âú®G(1)ÈáåÈù¢Âá∫Áé∞‰∫Ü‰∏ÄÊ¨°ÔºåËÄåÂÖ∂‰ªñÂú∞ÊñπÂè™‰ºöÂú® G(x)Âá∫Áé∞ ÊâÄ‰ª•Êàë‰ª¨ÈúÄË¶ÅËÆ© U(x)=-1 Êù•ÊäµÊ∂à F(x) Ââ©‰∏ãÁöÑÊ≠•È™§Â∞±Âíå‰∏äÈù¢Â∑Æ‰∏çÂ§ö‰∫ÜÔºåÂàÜÁ±ªËÆ®ËÆ∫‰∏Ä‰∏ãÔºåÂ∞±ÂèØ‰ª•Ê±ÇÂá∫ËøôÁßçÊÉÖÂÜµ‰∏ãÁöÑUÁöÑËÆ°ÁÆóÊñπÂºèÔºåÂíå‰∏äÈù¢Áõ∏ÂêåÔºÅÔºÅ Êé•‰∏ãÊù•Â∞±ÁúüÊ≠£ÁöÑÂºÄÂßãÊºîÁ§∫ÊÄé‰πàÁî® Ëé´ÊØî‰πåÊñØÂèçÊºî ÁÆÄÂåñËÆ°ÁÆó‰∫Ü ÔºÅÔºÅ Áúã‰∏ãÈù¢Ëøô‰∏™ÈóÆÈ¢òÔºÅ ÁªôÂá∫aÔºåb ÂÖ∂‰∏≠ (1&lt;=a,b&lt;=10^6) Ê±ÇÊª°Ë∂≥Êù°‰ª∂ÁöÑ x,y ÁöÑÂØπÊï∞Ôºå‰ΩøÂæó 1&lt;=x&lt;=a,1&lt;=y&lt;=b,‰∏îgcd(x,y) == 1„ÄÇ ÂÖ∂‰∏≠ (2,3) (3,2) ÁÆó‰∏§ÂØπÔºÅ Áõ¥Êé•Êö¥ÂäõÊòæÁÑ∂Â§çÊùÇÂ∫¶Â§™Â§ßÔºåÊàë‰ª¨Áî®Ëé´ÊØî‰πåÊñØÂèçÊºîÊù•Ëß£ÂÜ≥„ÄÇ ‰ª§N = max(a,b) ÁÑ∂ÂêéÂÆö‰πâ F(n) Ë°®Á§∫Êª°Ë∂≥Êù°‰ª∂ÁöÑ gcd(x,y)==nÁöÑ (x,y) ÂØπÊï∞ Âú®ÂÆö‰πâ G(n) Ë°®Á§∫Êª°Ë∂≥ n | gcd(x,y) ÁöÑ(x,y)ÂØπÊï∞ Âç≥ gcd(x,y)%n==0 ÁöÑx,yÂØπÊï∞ ÈÇ£‰πàÊ†πÊçÆÂÆö‰πâÔºåÊúâ G(n) = sigma(F(d)) (n|d,d&lt;=N) ‰∫éÊòØÊàë‰ª¨ÈúÄË¶ÅÊ±ÇÁöÑÂ∞±ÊòØ F(1) ÊÄé‰πàËß£ÂÜ≥Ôºü È¶ñÂÖàÊ†πÊçÆG(n)ÁöÑÂÆö‰πâÔºåÂèØ‰ª•ÂæàÂÆπÊòìÂèëÁé∞ G(n) = (a/n)*(b/n)ËøôÈáåÊòØÂêë‰∏ãÊï¥Èô§ ÔºàÊèêÁ§∫ÔºöÊäänÂΩìÊàêÊúÄÂ∞èÁöÑÂÖÉÔºâ ÁÑ∂Âêé Êàë‰ª¨Âè™Áõ¥Êé•ËÆ°ÁÆó F(1) Âç≥ÂèØ Â∏¶ÂÖ• G(n) ÁöÑÂÖ¨Âºè Êúâ F(1) = sigma(U[i](a/i)(b/i)) (1&lt;=i&lt;=N) Ëá≥‰∫éU[]ÁöÑÂÄºÔºåÂèØ‰ª•ÊèêÂâçÁî®Á≠õÊ≥ïÂú®O(n)ÁöÑÊó∂Èó¥ÂÜÖÂ§ÑÁêÜÂá∫Êù•ÔºåËøôÊ†∑ÊÄªÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶Â∞±ÊòØ O(n)ÔºåÈóÆÈ¢òÂæóÂà∞Ëß£ÂÜ≥ÔºÅÔºÅ ‰∏ãÈù¢ÈôÑ‰∏äÊàëËá™Â∑±Ê±ÇU[]ÁöÑ‰ª£Á†Å ÔºàÊïàÁéáÂπ∂‰∏çÊòØ‰∏•Ê†º‰∏äÁöÑO(n)Ôºå‰∏çËøá‰∏ÄËà¨ÊÉÖÂÜµ‰∏ãÂ∑≤ÁªèË∂≥Â§üÔºâ ÂõõÔºöËøõÈò∂ Âú®ACM‰∏≠ÔºåÂèØ‰ª•Âà©Áî® Ëé´ÊØî‰πåÊñØÂèçÊºî Êù•Ê±ÇËß£ÂæàÂ§öÂÖ≥‰∫é Gcd ÁöÑÈóÆÈ¢ò Êé®ËçêÂá†ÈÅìÂü∫Á°ÄÈ¢òÔºö SPOJ 7001 , ZOJ 3435, HDU 1695. ÊÉ≥ÂÅöÊõ¥Â§öÁöÑÈ¢òÁöÑËØùÔºåËá™Â∑±ÂéªHUST OJÊêúÁ¥¢Âêß :) ÊúÄÂêéÂÜçËØ¥‰∏Ä‰∏ã‰∏äÈù¢ÁöÑËØÅÊòéÊñπÊ≥ïÈÉΩÊòØ‰∏™‰∫∫YYÁöÑÔºåÊÑüËßâÊØî„ÄäÁªÑÂêàÊï∞Â≠¶„Äã‰∏äÁöÑËØÅÊòéÁÆÄÂçï‰∫õÔºàÊï∞Â≠¶Â§™Ê∏£orz...ÈÇ£‰∏™ËØÅÊòéÊàëÊòØÊ≤°ÁúãÂ§™ÊáÇÔºâÔºåÂÜô‰∏ãÊù• ÁªôÂàùÂ≠¶Ëé´ÊØî‰πåÊñØÂèçÊºîÁöÑÁ´•ÈûãÂΩì‰∏™ËµÑÊñôÔºà= =Ôºâ„ÄÇÂÖ≥‰∫é‰∏äÈù¢ÁöÑËØÅÊòéÊàëÊöÇÊó∂Ê≤°ÂèëÁé∞‰ªÄ‰πàÈîôËØØÔºåÂ¶ÇÊûúÂèëÁé∞ÈîôËØØÔºåËØ∑Âú®ÂõûÂ§çÈáåÈù¢ÊåáÂá∫ÔºÅÂè¶Â§ñ ÂΩ¢Âºè‰∫åÁöÑËØÅÊòéÂ∫îËØ•ÂèØ‰ª•Áî±ÂΩ¢Âºè‰∏ÄÁõ¥Êé•ÂæóÂà∞Ôºå‰∏çËøáÊàëÊ≤°ÊÉ≥Âá∫‰ªÄ‰πàÂ•ΩÂäûÊ≥ïÔºåÁü•ÈÅìÁöÑÁ•ûÁâõ‰πüËØ∑Âú®ËØÑËÆ∫‰∏≠ËØ¥‰∏Ä‰∏ãÔºÅ]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Êï∞Â≠¶</tag>
        <tag>Ëé´ÊØî‰πåÊñØÂèçÊºî</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ËÉåÂåÖ‰πùËÆ≤]]></title>
    <url>%2F2017%2F05%2F28%2F%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2%2F</url>
    <content type="text"><![CDATA[ËΩ¨ËΩΩÔºödd_engi ÁöÑËÉåÂåÖ‰πùËÆ≤ ËØ¶ÁªÜÂéüÂçöÂÆ¢ÔºàÈùûÊúÄÂàù‰ΩúËÄÖddÔºâ ÁõÆÂΩï Á¨¨‰∏ÄËÆ≤ 01ËÉåÂåÖÈóÆÈ¢ò Á¨¨‰∫åËÆ≤ ÂÆåÂÖ®ËÉåÂåÖÈóÆÈ¢ò Á¨¨‰∏âËÆ≤ Â§öÈáçËÉåÂåÖÈóÆÈ¢ò Á¨¨ÂõõËÆ≤ Ê∑∑Âêà‰∏âÁßçËÉåÂåÖÈóÆÈ¢ò Á¨¨‰∫îËÆ≤ ‰∫åÁª¥Ë¥πÁî®ÁöÑËÉåÂåÖÈóÆÈ¢ò Á¨¨ÂÖ≠ËÆ≤ ÂàÜÁªÑÁöÑËÉåÂåÖÈóÆÈ¢ò Á¨¨‰∏ÉËÆ≤ Êúâ‰æùËµñÁöÑËÉåÂåÖÈóÆÈ¢ò Á¨¨ÂÖ´ËÆ≤ Ê≥õÂåñÁâ©ÂìÅ Á¨¨‰πùËÆ≤ ËÉåÂåÖÈóÆÈ¢òÈóÆÊ≥ïÁöÑÂèòÂåñ ÈôÑÔºöUSACO‰∏≠ÁöÑËÉåÂåÖÈóÆÈ¢ò ÂâçË®Ä Êú¨ÁØáÊñáÁ´†ÊòØÊàë(dd_engi)Ê≠£Âú®ËøõË°å‰∏≠ÁöÑ‰∏Ä‰∏™ÈõÑÂøÉÂãÉÂãÉÁöÑÂÜô‰ΩúËÆ°ÂàíÁöÑ‰∏ÄÈÉ®ÂàÜÔºåËøô‰∏™ËÆ°ÂàíÁöÑÂÜÖÂÆπÊòØÂÜô‰Ωú‰∏Ä‰ªΩËæÉ‰∏∫ÂÆåÂñÑÁöÑNOIPÈöæÂ∫¶ÁöÑÂä®ÊÄÅËßÑÂàíÊÄªÁªìÔºåÂêç‰∏∫„ÄäËß£Âä®ÊÄÅËßÑÂàíÈ¢òÁöÑÂü∫Êú¨ÊÄùËÄÉÊñπÂºè„Äã„ÄÇÁé∞Âú®‰Ω†ÁúãÂà∞ÁöÑÊòØËøô‰∏™ÂÜô‰ΩúËÆ°ÂàíÊúÄÂÖàÂèëÂ∏ÉÁöÑ‰∏ÄÈÉ®ÂàÜ„ÄÇ ËÉåÂåÖÈóÆÈ¢òÊòØ‰∏Ä‰∏™ÁªèÂÖ∏ÁöÑÂä®ÊÄÅËßÑÂàíÊ®°Âûã„ÄÇÂÆÉÊó¢ÁÆÄÂçïÂΩ¢Ë±°ÂÆπÊòìÁêÜËß£ÔºåÂèàÂú®ÊüêÁßçÁ®ãÂ∫¶‰∏äËÉΩÂ§üÊè≠Á§∫Âä®ÊÄÅËßÑÂàíÁöÑÊú¨Ë¥®ÔºåÊïÖ‰∏çÂ∞ëÊïôÊùêÈÉΩÊääÂÆÉ‰Ωú‰∏∫Âä®ÊÄÅËßÑÂàíÈÉ®ÂàÜÁöÑÁ¨¨‰∏ÄÈÅì‰æãÈ¢òÔºåÊàë‰πüÂ∞ÜÂÆÉÊîæÂú®ÊàëÁöÑÂÜô‰ΩúËÆ°ÂàíÁöÑÁ¨¨‰∏ÄÈÉ®ÂàÜ„ÄÇ ËØªÊú¨ÊñáÊúÄÈáçË¶ÅÁöÑÊòØÊÄùËÄÉ„ÄÇÂõ†‰∏∫ÊàëÁöÑËØ≠Ë®ÄÂíåÂÜô‰ΩúÊñπÂºèÂêëÊù•‰∏ç‰ª•Êòì‰∫éÁêÜËß£‰∏∫ÈïøÔºåÊÄùË∑Ø‰πüÂÅ∂ÊúâË∑≥Ë∑ÉÁöÑÂú∞ÊñπÔºåÂêéÈù¢Êõ¥ÊúâÈúÄË¶ÅÂ§ßÈáèÊÄùËÄÉÊâçËÉΩÁêÜËß£ÁöÑÊØîËæÉÊäΩË±°ÁöÑÂÜÖÂÆπ„ÄÇÊõ¥ÈáçË¶ÅÁöÑÊòØÔºö‰∏çÂ§ßÈáèÊÄùËÄÉÔºåÁªùÂØπ‰∏çÂèØËÉΩÂ≠¶Â•ΩÂä®ÊÄÅËßÑÂàíËøô‰∏Ä‰ø°ÊÅØÂ≠¶Â••Ëµõ‰∏≠ÊúÄÁ≤æËá¥ÁöÑÈÉ®ÂàÜ„ÄÇ ‰Ω†Áé∞Âú®ÁúãÂà∞ÁöÑÊòØÊú¨ÊñáÁöÑ1.0Ê≠£ÂºèÁâà„ÄÇÊàë‰ºöÈïøÊúüÁª¥Êä§Ëøô‰ªΩÊñáÊú¨ÔºåÊääÂ§ßÂÆ∂ÁöÑÊÑèËßÅÂíåÂª∫ËÆÆËûçÂÖ•ÂÖ∂‰∏≠Ôºå‰πü‰ºö‰∏çÊñ≠Âä†ÂÖ•ÊàëÂú®OIÂ≠¶‰π†‰ª•ÂèäÂ∞ÜÊù•ÂèØËÉΩÁöÑACM-ICPCÁöÑÂæÅÁ®ã‰∏≠ÂæóÂà∞ÁöÑÊñ∞ÁöÑÂøÉÂæó„ÄÇ‰ΩÜÁõÆÂâçÊú¨ÊñáËøòÊ≤°Êúâ‰∏Ä‰∏™Âõ∫ÂÆöÁöÑÂèëÂ∏ÉÈ°µÈù¢ÔºåÊÉ≥‰∫ÜËß£Êú¨ÊñáÊòØÂê¶ÊúâÊõ¥Êñ∞ÁâàÊú¨ÂèëÂ∏ÉÔºåÂèØ‰ª•Âú®OIBHËÆ∫Âùõ‰∏≠‰ª•‚ÄúËÉåÂåÖÈóÆÈ¢ò‰πùËÆ≤‚Äù‰∏∫ÂÖ≥ÈîÆÂ≠óÊêúÁ¥¢Ë¥¥Â≠êÔºåÊØèÊ¨°ÊØîËæÉÈáçÂ§ßÁöÑÁâàÊú¨Êõ¥Êñ∞ÈÉΩ‰ºöÂú®ËøôÈáåÂèëË¥¥ÂÖ¨Â∏É„ÄÇ ÁõÆÂΩï Á¨¨‰∏ÄËÆ≤ 01ËÉåÂåÖÈóÆÈ¢ò ËøôÊòØÊúÄÂü∫Êú¨ÁöÑËÉåÂåÖÈóÆÈ¢òÔºåÊØè‰∏™Áâ©ÂìÅÊúÄÂ§öÂè™ËÉΩÊîæ‰∏ÄÊ¨°„ÄÇ Á¨¨‰∫åËÆ≤ ÂÆåÂÖ®ËÉåÂåÖÈóÆÈ¢ò Á¨¨‰∫å‰∏™Âü∫Êú¨ÁöÑËÉåÂåÖÈóÆÈ¢òÊ®°ÂûãÔºåÊØèÁßçÁâ©ÂìÅÂèØ‰ª•ÊîæÊó†ÈôêÂ§öÊ¨°„ÄÇ Á¨¨‰∏âËÆ≤ Â§öÈáçËÉåÂåÖÈóÆÈ¢ò ÊØèÁßçÁâ©ÂìÅÊúâ‰∏Ä‰∏™Âõ∫ÂÆöÁöÑÊ¨°Êï∞‰∏äÈôê„ÄÇ Á¨¨ÂõõËÆ≤ Ê∑∑Âêà‰∏âÁßçËÉåÂåÖÈóÆÈ¢ò Â∞ÜÂâçÈù¢‰∏âÁßçÁÆÄÂçïÁöÑÈóÆÈ¢òÂè†Âä†ÊàêËæÉÂ§çÊùÇÁöÑÈóÆÈ¢ò„ÄÇ Á¨¨‰∫îËÆ≤ ‰∫åÁª¥Ë¥πÁî®ÁöÑËÉåÂåÖÈóÆÈ¢ò ‰∏Ä‰∏™ÁÆÄÂçïÁöÑÂ∏∏ËßÅÊâ©Â±ï„ÄÇ Á¨¨ÂÖ≠ËÆ≤ ÂàÜÁªÑÁöÑËÉåÂåÖÈóÆÈ¢ò ‰∏ÄÁßçÈ¢òÁõÆÁ±ªÂûãÔºå‰πüÊòØ‰∏Ä‰∏™ÊúâÁî®ÁöÑÊ®°Âûã„ÄÇÂêé‰∏§ËäÇÁöÑÂü∫Á°Ä„ÄÇ Á¨¨‰∏ÉËÆ≤ Êúâ‰æùËµñÁöÑËÉåÂåÖÈóÆÈ¢ò Âè¶‰∏ÄÁßçÁªôÁâ©ÂìÅÁöÑÈÄâÂèñÂä†‰∏äÈôêÂà∂ÁöÑÊñπÊ≥ï„ÄÇ Á¨¨ÂÖ´ËÆ≤ Ê≥õÂåñÁâ©ÂìÅ ÊàëËá™Â∑±ÂÖ≥‰∫éËÉåÂåÖÈóÆÈ¢òÁöÑÊÄùËÄÉÊàêÊûúÔºåÊúâ‰∏ÄÁÇπÊäΩË±°„ÄÇ Á¨¨‰πùËÆ≤ ËÉåÂåÖÈóÆÈ¢òÈóÆÊ≥ïÁöÑÂèòÂåñ ËØïÂõæËß¶Á±ªÊóÅÈÄö„ÄÅ‰∏æ‰∏ÄÂèç‰∏â„ÄÇ ËÉåÂåÖÁöÑÊêúÁ¥¢ ÈôÑÔºöUSACO‰∏≠ÁöÑËÉåÂåÖÈóÆÈ¢ò ÁªôÂá∫ USACO Training ‰∏äÂèØ‰æõÁªÉ‰π†ÁöÑËÉåÂåÖÈóÆÈ¢òÂàóË°®ÔºåÂèäÁÆÄÂçïÁöÑËß£Á≠î„ÄÇ ËÅîÁ≥ªÊñπÂºè Â¶ÇÊûúÊúâ‰ªª‰ΩïÊÑèËßÅÂíåÂª∫ËÆÆÔºåÁâπÂà´ÊòØÊñáÁ´†ÁöÑÈîôËØØÂíå‰∏çË∂≥ÔºåÊàñËÄÖÂ∏åÊúõ‰∏∫ÊñáÁ´†Ê∑ªÂä†Êñ∞ÁöÑÊùêÊñôÔºåÂèØ‰ª•ÈÄöËøáhttp://kontactr.com/user/tianyi/Ëøô‰∏™ÁΩëÈ°µËÅîÁ≥ªÊàë„ÄÇ Ëá¥Ë∞¢ ÊÑüË∞¢‰ª•‰∏ãÂêçÂçïÔºö ÈòøÂù¶ jason911 donglixp ‰ªñ‰ª¨ÊØè‰∫∫ÈÉΩÊúÄÂÖàÊåáÂá∫‰∫ÜÊú¨ÊñáÁ¨¨‰∏Ä‰∏™betaÁâà‰∏≠ÁöÑÊüê‰∏™Âπ∂ÈùûÊó†ÂÖ≥Á¥ßË¶ÅÁöÑÈîôËØØ„ÄÇË∞¢Ë∞¢‰Ω†‰ª¨Â¶ÇÊ≠§‰ªîÁªÜÂú∞ÈòÖËØªÊãô‰ΩúÂπ∂Âº•Ë°•ÊàëÁöÑÁñèÊºè„ÄÇ ÊÑüË∞¢ XiaQÔºåÂÆÉÈíàÂØπÊú¨ÊñáÁöÑÁ¨¨‰∏Ä‰∏™betaÁâàÂèëË°®‰∫ÜÁî®ËØç‰∏•ÂéâÁöÑÂÖ≠Êù°Âª∫ËÆÆÔºåËôΩÁÑ∂ÊàëÂè™ËÆ§ÂêåÂπ∂ÈááÁ∫≥‰∫ÜÂÖ∂‰∏≠ÁöÑ‰∏§Êù°„ÄÇÂú®ÊâÄÊúâËØªËÄÖÂá†‰πé‰∏ÄËæπÂÄíÁöÑËµûÊâ¨Â∞ÜÊàëÂåÖÂõ¥ÁöÑÂΩìÊó∂Ôºå‰Ω†ÁöÑË¥¥Â≠êÊòØÊàëÁöÑ‰∏ÄÂâÇÊ∏ÖÈÜíÂâÇÔºåËÆ©ÊàëËÉΩÊ∏ÖÈÜíËµ∑Êù•Âπ∂Áî®Êõ¥‰∏•ÂéâÁöÑÁúºÂÖâÂÆ°ËßÜËá™Â∑±ÁöÑ‰ΩúÂìÅ„ÄÇ ÂΩìÁÑ∂ÔºåËøòÊúâÁî®ÂêÑÁßçÊñπÂºèÂØπÊàëË°®Á§∫ÈºìÂä±ÂíåÊîØÊåÅÁöÑÂá†‰πéÊó†Ê≥ïËÆ°Êï∞ÁöÑÂêåÂ≠¶„ÄÇ‰∏çÁÆ°ÊòØÂΩìÈù¢ËµûÊâ¨ÔºåÊàñÊòØÂú®ËÆ∫Âùõ‰∏äÂõûÂ§çÊàëÁöÑË¥¥Â≠êÔºå‰∏çÁÆ°ÊòØÂèëÊù•ÁÉ≠ÊÉÖÊ¥ãÊ∫¢ÁöÑÈÇÆ‰ª∂ÔºåÊàñÊòØÂú®Âç≥Êó∂ËÅäÂ§©ÁöÑÁ™óÂè£ÈáåÁ´ñËµ∑Â§ßÊãáÊåáÔºå‰Ω†‰ª¨ÁöÑÈºìÂä±ÂíåÊîØÊåÅÊòØÊîØÊíëÊàëÁöÑÂÜô‰ΩúËÆ°ÂàíÁöÑÂº∫Â§ßÂä®ÂäõÔºå‰πüÈû≠Á≠ñÁùÄÊàë‰∏çÊñ≠ÊèêÈ´òËá™Ë∫´Ê∞¥Âπ≥ÔºåË∞¢Ë∞¢‰Ω†‰ª¨ÔºÅ ÊúÄÂêéÔºåÊÑüË∞¢ Emacs Ëøô‰∏Ä‰∏ñÁïåÊúÄÂº∫Â§ßÁöÑÁºñËæëÂô®ÁöÑÊâÄÊúâË¥°ÁåÆËÄÖÔºåÊÑüË∞¢ÂÆÉÁöÑÊèí‰ª∂ EmacsMuse ÁöÑÂºÄÂèëËÄÖ‰ª¨ÔºåÊú¨ÊñáÁöÑÊâÄÊúâÁºñËæëÂ∑•‰ΩúÈÉΩÂÄüÂä©Ëøô‰∏§‰∏™ÂçìË∂äÁöÑËá™Áî±ËΩØ‰ª∂ÂÆåÊàê„ÄÇË∞¢Ë∞¢‰Ω†‰ª¨‚Äî‚ÄîËá™Áî±ËΩØ‰ª∂Á§æÁæ§‚Äî‚Äî‰∏∫Á§æ‰ºöÊèê‰æõ‰∫ÜÂ¶ÇÊ≠§ÊúâÁîü‰∫ßÂäõÁöÑÂ∑•ÂÖ∑„ÄÇÊàëÊ∑±Ê∑±Èí¶‰Ω©‰Ω†‰ª¨Ë∫´‰∏ä‰ΩìÁé∞Âá∫ÁöÑËá™Áî±ËΩØ‰ª∂ÁöÑÁ≤æÁ•ûÔºåÊ≤°Êúâ‰Ω†‰ª¨ÁöÑÊÑüÂè¨ÔºåÊàë‰∏çËÉΩÂÆåÊàêÊú¨Êñá„ÄÇÂú®‰Ω†‰ª¨ÁöÑÂΩ±Âìç‰∏ãÔºåÈááÁî®Ëá™Áî±ÊñáÊ°£ÁöÑÊñπÂºèÂèëÂ∏ÉÊú¨ÊñáÊ°£Ôºå‰πüÊòØÊàëÂØπËá™Áî±Á§æ‰ºö‰∫ã‰∏öÁöÑÂæÆËñÑÂä™Âäõ„ÄÇ P01: 01ËÉåÂåÖÈóÆÈ¢ò È¢òÁõÆ ÊúâN‰ª∂Áâ©ÂìÅÂíå‰∏Ä‰∏™ÂÆπÈáè‰∏∫VÁöÑËÉåÂåÖ„ÄÇÁ¨¨i‰ª∂Áâ©ÂìÅÁöÑË¥πÁî®ÊòØc[i]Ôºå‰ª∑ÂÄºÊòØw[i]„ÄÇÊ±ÇËß£Â∞ÜÂì™‰∫õÁâ©ÂìÅË£ÖÂÖ•ËÉåÂåÖÂèØ‰Ωø‰ª∑ÂÄºÊÄªÂíåÊúÄÂ§ß„ÄÇ Âü∫Êú¨ÊÄùË∑Ø ËøôÊòØÊúÄÂü∫Á°ÄÁöÑËÉåÂåÖÈóÆÈ¢òÔºåÁâπÁÇπÊòØÔºöÊØèÁßçÁâ©ÂìÅ‰ªÖÊúâ‰∏Ä‰ª∂ÔºåÂèØ‰ª•ÈÄâÊã©ÊîæÊàñ‰∏çÊîæ„ÄÇ Áî®Â≠êÈóÆÈ¢òÂÆö‰πâÁä∂ÊÄÅÔºöÂç≥f[i][v]Ë°®Á§∫Ââçi‰ª∂Áâ©ÂìÅÊÅ∞ÊîæÂÖ•‰∏Ä‰∏™ÂÆπÈáè‰∏∫vÁöÑËÉåÂåÖÂèØ‰ª•Ëé∑ÂæóÁöÑÊúÄÂ§ß‰ª∑ÂÄº„ÄÇÂàôÂÖ∂Áä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ã‰æøÊòØÔºö f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]} Ëøô‰∏™ÊñπÁ®ãÈùûÂ∏∏ÈáçË¶ÅÔºåÂü∫Êú¨‰∏äÊâÄÊúâË∑üËÉåÂåÖÁõ∏ÂÖ≥ÁöÑÈóÆÈ¢òÁöÑÊñπÁ®ãÈÉΩÊòØÁî±ÂÆÉË°çÁîüÂá∫Êù•ÁöÑ„ÄÇÊâÄ‰ª•ÊúâÂøÖË¶ÅÂ∞ÜÂÆÉËØ¶ÁªÜËß£Èáä‰∏Ä‰∏ãÔºö‚ÄúÂ∞ÜÂâçi‰ª∂Áâ©ÂìÅÊîæÂÖ•ÂÆπÈáè‰∏∫vÁöÑËÉåÂåÖ‰∏≠‚ÄùËøô‰∏™Â≠êÈóÆÈ¢òÔºåËã•Âè™ËÄÉËôëÁ¨¨i‰ª∂Áâ©ÂìÅÁöÑÁ≠ñÁï•ÔºàÊîæÊàñ‰∏çÊîæÔºâÔºåÈÇ£‰πàÂ∞±ÂèØ‰ª•ËΩ¨Âåñ‰∏∫‰∏Ä‰∏™Âè™ÁâµÊâØÂâçi-1‰ª∂Áâ©ÂìÅÁöÑÈóÆÈ¢ò„ÄÇÂ¶ÇÊûú‰∏çÊîæÁ¨¨i‰ª∂Áâ©ÂìÅÔºåÈÇ£‰πàÈóÆÈ¢òÂ∞±ËΩ¨Âåñ‰∏∫‚ÄúÂâçi-1‰ª∂Áâ©ÂìÅÊîæÂÖ•ÂÆπÈáè‰∏∫vÁöÑËÉåÂåÖ‰∏≠‚ÄùÔºå‰ª∑ÂÄº‰∏∫f[i-1][v]ÔºõÂ¶ÇÊûúÊîæÁ¨¨i‰ª∂Áâ©ÂìÅÔºåÈÇ£‰πàÈóÆÈ¢òÂ∞±ËΩ¨Âåñ‰∏∫‚ÄúÂâçi-1‰ª∂Áâ©ÂìÅÊîæÂÖ•Ââ©‰∏ãÁöÑÂÆπÈáè‰∏∫v-c[i]ÁöÑËÉåÂåÖ‰∏≠‚ÄùÔºåÊ≠§Êó∂ËÉΩËé∑ÂæóÁöÑÊúÄÂ§ß‰ª∑ÂÄºÂ∞±ÊòØf[i-1][v-c[i]]ÂÜçÂä†‰∏äÈÄöËøáÊîæÂÖ•Á¨¨i‰ª∂Áâ©ÂìÅËé∑ÂæóÁöÑ‰ª∑ÂÄºw[i]„ÄÇ ‰ºòÂåñÁ©∫Èó¥Â§çÊùÇÂ∫¶ ‰ª•‰∏äÊñπÊ≥ïÁöÑÊó∂Èó¥ÂíåÁ©∫Èó¥Â§çÊùÇÂ∫¶Âùá‰∏∫O(N*V)ÔºåÂÖ∂‰∏≠Êó∂Èó¥Â§çÊùÇÂ∫¶Âü∫Êú¨Â∑≤Áªè‰∏çËÉΩÂÜç‰ºòÂåñ‰∫ÜÔºå‰ΩÜÁ©∫Èó¥Â§çÊùÇÂ∫¶Âç¥ÂèØ‰ª•‰ºòÂåñÂà∞O(V)„ÄÇ ÂÖàËÄÉËôë‰∏äÈù¢ËÆ≤ÁöÑÂü∫Êú¨ÊÄùË∑ØÂ¶Ç‰ΩïÂÆûÁé∞ÔºåËÇØÂÆöÊòØÊúâ‰∏Ä‰∏™‰∏ªÂæ™ÁéØi=1..NÔºåÊØèÊ¨°ÁÆóÂá∫Êù•‰∫åÁª¥Êï∞ÁªÑf[i][0..V]ÁöÑÊâÄÊúâÂÄº„ÄÇÈÇ£‰πàÔºåÂ¶ÇÊûúÂè™Áî®‰∏Ä‰∏™Êï∞ÁªÑf[0..V]ÔºåËÉΩ‰∏çËÉΩ‰øùËØÅÁ¨¨iÊ¨°Âæ™ÁéØÁªìÊùüÂêéf[v]‰∏≠Ë°®Á§∫ÁöÑÂ∞±ÊòØÊàë‰ª¨ÂÆö‰πâÁöÑÁä∂ÊÄÅf[i][v]Âë¢Ôºüf[i][v]ÊòØÁî±f[i-1][v]Âíåf[i-1][v-c[i]]‰∏§‰∏™Â≠êÈóÆÈ¢òÈÄíÊé®ËÄåÊù•ÔºåËÉΩÂê¶‰øùËØÅÂú®Êé®f[i][v]Êó∂Ôºà‰πüÂç≥Âú®Á¨¨iÊ¨°‰∏ªÂæ™ÁéØ‰∏≠Êé®f[v]Êó∂ÔºâËÉΩÂ§üÂæóÂà∞f[i-1][v]Âíåf[i-1][v-c[i]]ÁöÑÂÄºÂë¢Ôºü‰∫ãÂÆû‰∏äÔºåËøôË¶ÅÊ±ÇÂú®ÊØèÊ¨°‰∏ªÂæ™ÁéØ‰∏≠Êàë‰ª¨‰ª•v=V..0ÁöÑÈ°∫Â∫èÊé®f[v]ÔºåËøôÊ†∑ÊâçËÉΩ‰øùËØÅÊé®f[v]Êó∂f[v-c[i]]‰øùÂ≠òÁöÑÊòØÁä∂ÊÄÅf[i-1][v-c[i]]ÁöÑÂÄº„ÄÇ‰º™‰ª£Á†ÅÂ¶Ç‰∏ãÔºö 123for i=1..N for v=V..0 f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; ÂÖ∂‰∏≠ÁöÑf[v]=max{f[v],f[v-c[i]]}‰∏ÄÂè•ÊÅ∞Â∞±Áõ∏ÂΩì‰∫éÊàë‰ª¨ÁöÑËΩ¨ÁßªÊñπÁ®ãf[i][v]=max{f[i-1][v],f[i-1][v-c[i]]}ÔºåÂõ†‰∏∫Áé∞Âú®ÁöÑf[v-c[i]]Â∞±Áõ∏ÂΩì‰∫éÂéüÊù•ÁöÑf[i-1][v-c[i]]„ÄÇÂ¶ÇÊûúÂ∞ÜvÁöÑÂæ™ÁéØÈ°∫Â∫è‰ªé‰∏äÈù¢ÁöÑÈÄÜÂ∫èÊîπÊàêÈ°∫Â∫èÁöÑËØùÔºåÈÇ£‰πàÂàôÊàê‰∫Üf[i][v]Áî±f[i][v-c[i]]Êé®Áü•Ôºå‰∏éÊú¨È¢òÊÑè‰∏çÁ¨¶Ôºå‰ΩÜÂÆÉÂç¥ÊòØÂè¶‰∏Ä‰∏™ÈáçË¶ÅÁöÑËÉåÂåÖÈóÆÈ¢òP02ÊúÄÁÆÄÊç∑ÁöÑËß£ÂÜ≥ÊñπÊ°àÔºåÊïÖÂ≠¶‰π†Âè™Áî®‰∏ÄÁª¥Êï∞ÁªÑËß£01ËÉåÂåÖÈóÆÈ¢òÊòØÂçÅÂàÜÂøÖË¶ÅÁöÑ„ÄÇ ‰∫ãÂÆû‰∏äÔºå‰ΩøÁî®‰∏ÄÁª¥Êï∞ÁªÑËß£01ËÉåÂåÖÁöÑÁ®ãÂ∫èÂú®ÂêéÈù¢‰ºöË¢´Â§öÊ¨°Áî®Âà∞ÔºåÊâÄ‰ª•ËøôÈáåÊäΩË±°Âá∫‰∏Ä‰∏™Â§ÑÁêÜ‰∏Ä‰ª∂01ËÉåÂåÖ‰∏≠ÁöÑÁâ©ÂìÅËøáÁ®ãÔºå‰ª•ÂêéÁöÑ‰ª£Á†Å‰∏≠Áõ¥Êé•Ë∞ÉÁî®‰∏çÂä†ËØ¥Êòé„ÄÇ{ÔºÅËÉåËøá} Êàë‰ª¨Áúã‰∏Ä‰∏ãÂéüÊù•ÁöÑÊñπÁ®ãf[i][v]=max{f[i-1][v], f[i-1][v-c[i]]+w[i]} ‰∏ç‰∏ÄÂÆö‰ªé1ÂºÄÂßãÔºåÈÇ£Ê†∑‰ºöÊµ™Ë¥π ‚Äã ËøáÁ®ãZeroOnePackÔºåË°®Á§∫Â§ÑÁêÜ‰∏Ä‰ª∂01ËÉåÂåÖ‰∏≠ÁöÑÁâ©ÂìÅÔºå‰∏§‰∏™ÂèÇÊï∞cost„ÄÅweightÂàÜÂà´Ë°®ÊòéËøô‰ª∂Áâ©ÂìÅÁöÑË¥πÁî®Âíå‰ª∑ÂÄº„ÄÇ 123procedure ZeroOnePack(cost,weight) for v=V..cost f[v]=max&#123;f[v],f[v-cost]+weight&#125; Ê≥®ÊÑèËøô‰∏™ËøáÁ®ãÈáåÁöÑÂ§ÑÁêÜ‰∏éÂâçÈù¢ÁªôÂá∫ÁöÑ‰º™‰ª£Á†ÅÊúâÊâÄ‰∏çÂêå„ÄÇÂâçÈù¢ÁöÑÁ§∫‰æãÁ®ãÂ∫èÂÜôÊàêv=V..0ÊòØ‰∏∫‰∫ÜÂú®Á®ãÂ∫è‰∏≠‰ΩìÁé∞ÊØè‰∏™Áä∂ÊÄÅÈÉΩÊåâÁÖßÊñπÁ®ãÊ±ÇËß£‰∫ÜÔºåÈÅøÂÖç‰∏çÂøÖË¶ÅÁöÑÊÄùÁª¥Â§çÊùÇÂ∫¶„ÄÇËÄåËøôÈáåÊó¢ÁÑ∂Â∑≤ÁªèÊäΩË±°ÊàêÁúã‰ΩúÈªëÁÆ±ÁöÑËøáÁ®ã‰∫ÜÔºåÂ∞±ÂèØ‰ª•Âä†ÂÖ•‰ºòÂåñ„ÄÇË¥πÁî®‰∏∫costÁöÑÁâ©ÂìÅ‰∏ç‰ºöÂΩ±ÂìçÁä∂ÊÄÅf[0..cost-1]ÔºåËøôÊòØÊòæÁÑ∂ÁöÑ„ÄÇ Êúâ‰∫ÜËøô‰∏™ËøáÁ®ã‰ª•ÂêéÔºå01ËÉåÂåÖÈóÆÈ¢òÁöÑ‰º™‰ª£Á†ÅÂ∞±ÂèØ‰ª•ËøôÊ†∑ÂÜôÔºö 12for i=1..N ZeroOnePack(c[i],w[i]); ÂàùÂßãÂåñÁöÑÁªÜËäÇÈóÆÈ¢ò Êàë‰ª¨ÁúãÂà∞ÁöÑÊ±ÇÊúÄ‰ºòËß£ÁöÑËÉåÂåÖÈóÆÈ¢òÈ¢òÁõÆ‰∏≠Ôºå‰∫ãÂÆû‰∏äÊúâ‰∏§Áßç‰∏çÂ§™Áõ∏ÂêåÁöÑÈóÆÊ≥ï„ÄÇÊúâÁöÑÈ¢òÁõÆË¶ÅÊ±Ç‚ÄúÊÅ∞Â•ΩË£ÖÊª°ËÉåÂåÖ‚ÄùÊó∂ÁöÑÊúÄ‰ºòËß£ÔºåÊúâÁöÑÈ¢òÁõÆÂàôÂπ∂Ê≤°ÊúâË¶ÅÊ±ÇÂøÖÈ°ªÊääËÉåÂåÖË£ÖÊª°„ÄÇ‰∏ÄÁßçÂå∫Âà´Ëøô‰∏§ÁßçÈóÆÊ≥ïÁöÑÂÆûÁé∞ÊñπÊ≥ïÊòØÂú®ÂàùÂßãÂåñÁöÑÊó∂ÂÄôÊúâÊâÄ‰∏çÂêå„ÄÇ Â¶ÇÊûúÊòØÁ¨¨‰∏ÄÁßçÈóÆÊ≥ïÔºåË¶ÅÊ±ÇÊÅ∞Â•ΩË£ÖÊª°ËÉåÂåÖÔºåÈÇ£‰πàÂú®ÂàùÂßãÂåñÊó∂Èô§‰∫Üf[0]‰∏∫0ÂÖ∂ÂÆÉf[1..V]ÂùáËÆæ‰∏∫-‚àûÔºåËøôÊ†∑Â∞±ÂèØ‰ª•‰øùËØÅÊúÄÁªàÂæóÂà∞ÁöÑf[N]ÊòØ‰∏ÄÁßçÊÅ∞Â•ΩË£ÖÊª°ËÉåÂåÖÁöÑÊúÄ‰ºòËß£„ÄÇ Â¶ÇÊûúÂπ∂Ê≤°ÊúâË¶ÅÊ±ÇÂøÖÈ°ªÊääËÉåÂåÖË£ÖÊª°ÔºåËÄåÊòØÂè™Â∏åÊúõ‰ª∑Ê†ºÂ∞ΩÈáèÂ§ßÔºåÂàùÂßãÂåñÊó∂Â∫îËØ•Â∞Üf[0..V]ÂÖ®ÈÉ®ËÆæ‰∏∫0„ÄÇ ‰∏∫‰ªÄ‰πàÂë¢ÔºüÂèØ‰ª•ËøôÊ†∑ÁêÜËß£ÔºöÂàùÂßãÂåñÁöÑfÊï∞ÁªÑ‰∫ãÂÆû‰∏äÂ∞±ÊòØÂú®Ê≤°Êúâ‰ªª‰ΩïÁâ©ÂìÅÂèØ‰ª•ÊîæÂÖ•ËÉåÂåÖÊó∂ÁöÑÂêàÊ≥ïÁä∂ÊÄÅ„ÄÇÂ¶ÇÊûúË¶ÅÊ±ÇËÉåÂåÖÊÅ∞Â•ΩË£ÖÊª°ÔºåÈÇ£‰πàÊ≠§Êó∂Âè™ÊúâÂÆπÈáè‰∏∫0ÁöÑËÉåÂåÖÂèØËÉΩË¢´‰ª∑ÂÄº‰∏∫0ÁöÑnothing‚ÄúÊÅ∞Â•ΩË£ÖÊª°‚ÄùÔºåÂÖ∂ÂÆÉÂÆπÈáèÁöÑËÉåÂåÖÂùáÊ≤°ÊúâÂêàÊ≥ïÁöÑËß£ÔºåÂ±û‰∫éÊú™ÂÆö‰πâÁöÑÁä∂ÊÄÅÔºåÂÆÉ‰ª¨ÁöÑÂÄºÂ∞±ÈÉΩÂ∫îËØ•ÊòØ-‚àû‰∫Ü„ÄÇÂ¶ÇÊûúËÉåÂåÖÂπ∂ÈùûÂøÖÈ°ªË¢´Ë£ÖÊª°ÔºåÈÇ£‰πà‰ªª‰ΩïÂÆπÈáèÁöÑËÉåÂåÖÈÉΩÊúâ‰∏Ä‰∏™ÂêàÊ≥ïËß£‚Äú‰ªÄ‰πàÈÉΩ‰∏çË£Ö‚ÄùÔºåËøô‰∏™Ëß£ÁöÑ‰ª∑ÂÄº‰∏∫0ÔºåÊâÄ‰ª•ÂàùÂßãÊó∂Áä∂ÊÄÅÁöÑÂÄº‰πüÂ∞±ÂÖ®ÈÉ®‰∏∫0‰∫Ü„ÄÇ Ëøô‰∏™Â∞èÊäÄÂ∑ßÂÆåÂÖ®ÂèØ‰ª•Êé®ÂπøÂà∞ÂÖ∂ÂÆÉÁ±ªÂûãÁöÑËÉåÂåÖÈóÆÈ¢òÔºåÂêéÈù¢‰πüÂ∞±‰∏çÂÜçÂØπËøõË°åÁä∂ÊÄÅËΩ¨Áßª‰πãÂâçÁöÑÂàùÂßãÂåñËøõË°åËÆ≤Ëß£„ÄÇ Â∞èÁªì 01ËÉåÂåÖÈóÆÈ¢òÊòØÊúÄÂü∫Êú¨ÁöÑËÉåÂåÖÈóÆÈ¢òÔºåÂÆÉÂåÖÂê´‰∫ÜËÉåÂåÖÈóÆÈ¢ò‰∏≠ËÆæËÆ°Áä∂ÊÄÅ„ÄÅÊñπÁ®ãÁöÑÊúÄÂü∫Êú¨ÊÄùÊÉ≥ÔºåÂè¶Â§ñÔºåÂà´ÁöÑÁ±ªÂûãÁöÑËÉåÂåÖÈóÆÈ¢òÂæÄÂæÄ‰πüÂèØ‰ª•ËΩ¨Êç¢Êàê01ËÉåÂåÖÈóÆÈ¢òÊ±ÇËß£„ÄÇÊïÖ‰∏ÄÂÆöË¶Å‰ªîÁªÜ‰Ωì‰ºö‰∏äÈù¢Âü∫Êú¨ÊÄùË∑ØÁöÑÂæóÂá∫ÊñπÊ≥ïÔºåÁä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ãÁöÑÊÑè‰πâÔºå‰ª•ÂèäÊúÄÂêéÊÄéÊ†∑‰ºòÂåñÁöÑÁ©∫Èó¥Â§çÊùÇÂ∫¶„ÄÇ È¶ñÈ°µ P02: ÂÆåÂÖ®ËÉåÂåÖÈóÆÈ¢ò È¢òÁõÆ ÊúâNÁßçÁâ©ÂìÅÂíå‰∏Ä‰∏™ÂÆπÈáè‰∏∫VÁöÑËÉåÂåÖÔºåÊØèÁßçÁâ©ÂìÅÈÉΩÊúâÊó†Èôê‰ª∂ÂèØÁî®„ÄÇÁ¨¨iÁßçÁâ©ÂìÅÁöÑË¥πÁî®ÊòØc[i]Ôºå‰ª∑ÂÄºÊòØw[i]„ÄÇÊ±ÇËß£Â∞ÜÂì™‰∫õÁâ©ÂìÅË£ÖÂÖ•ËÉåÂåÖÂèØ‰ΩøËøô‰∫õÁâ©ÂìÅÁöÑË¥πÁî®ÊÄªÂíå‰∏çË∂ÖËøáËÉåÂåÖÂÆπÈáèÔºå‰∏î‰ª∑ÂÄºÊÄªÂíåÊúÄÂ§ß„ÄÇ Âü∫Êú¨ÊÄùË∑Ø Ëøô‰∏™ÈóÆÈ¢òÈùûÂ∏∏Á±ª‰ºº‰∫é01ËÉåÂåÖÈóÆÈ¢ò ÔºåÊâÄ‰∏çÂêåÁöÑÊòØÊØèÁßçÁâ©ÂìÅÊúâÊó†Èôê‰ª∂„ÄÇ‰πüÂ∞±ÊòØ‰ªéÊØèÁßçÁâ©ÂìÅÁöÑËßíÂ∫¶ËÄÉËôëÔºå‰∏éÂÆÉÁõ∏ÂÖ≥ÁöÑÁ≠ñÁï•Â∑≤Âπ∂ÈùûÂèñÊàñ‰∏çÂèñ‰∏§ÁßçÔºåËÄåÊòØÊúâÂèñ0‰ª∂„ÄÅÂèñ1‰ª∂„ÄÅÂèñ2‰ª∂‚Ä¶‚Ä¶Á≠âÂæàÂ§öÁßç„ÄÇÂ¶ÇÊûú‰ªçÁÑ∂ÊåâÁÖßËß£01ËÉåÂåÖÊó∂ÁöÑÊÄùË∑ØÔºå‰ª§f[i][v]Ë°®Á§∫ÂâçiÁßçÁâ©ÂìÅÊÅ∞ÊîæÂÖ•‰∏Ä‰∏™ÂÆπÈáè‰∏∫vÁöÑËÉåÂåÖÁöÑÊúÄÂ§ßÊùÉÂÄº„ÄÇ‰ªçÁÑ∂ÂèØ‰ª•ÊåâÁÖßÊØèÁßçÁâ©ÂìÅ‰∏çÂêåÁöÑÁ≠ñÁï•ÂÜôÂá∫Áä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ãÔºåÂÉèËøôÊ†∑Ôºö f[i][v]=max{f[i-1][v-k*c[i]]+kw[i]|0&lt;=kc[i]&lt;=v} ËøôË∑ü01ËÉåÂåÖÈóÆÈ¢ò‰∏ÄÊ†∑ÊúâO(NV)‰∏™Áä∂ÊÄÅÈúÄË¶ÅÊ±ÇËß£Ôºå‰ΩÜÊ±ÇËß£ÊØè‰∏™Áä∂ÊÄÅÁöÑÊó∂Èó¥Â∑≤Áªè‰∏çÊòØÂ∏∏Êï∞‰∫ÜÔºåÊ±ÇËß£Áä∂ÊÄÅf[i][v]ÁöÑÊó∂Èó¥ÊòØO(v/c[i])ÔºåÊÄªÁöÑÂ§çÊùÇÂ∫¶ÊòØË∂ÖËøáO(VN)ÁöÑ„ÄÇ Â∞Ü01ËÉåÂåÖÈóÆÈ¢òÁöÑÂü∫Êú¨ÊÄùË∑ØÂä†‰ª•ÊîπËøõÔºåÂæóÂà∞‰∫ÜËøôÊ†∑‰∏Ä‰∏™Ê∏ÖÊô∞ÁöÑÊñπÊ≥ï„ÄÇËøôËØ¥Êòé01ËÉåÂåÖÈóÆÈ¢òÁöÑÊñπÁ®ãÁöÑÁ°ÆÊòØÂæàÈáçË¶ÅÔºåÂèØ‰ª•Êé®ÂèäÂÖ∂ÂÆÉÁ±ªÂûãÁöÑËÉåÂåÖÈóÆÈ¢ò„ÄÇ‰ΩÜÊàë‰ª¨ËøòÊòØËØïÂõæÊîπËøõËøô‰∏™Â§çÊùÇÂ∫¶„ÄÇ ‰∏Ä‰∏™ÁÆÄÂçïÊúâÊïàÁöÑ‰ºòÂåñ ÂÆåÂÖ®ËÉåÂåÖÈóÆÈ¢òÊúâ‰∏Ä‰∏™ÂæàÁÆÄÂçïÊúâÊïàÁöÑ‰ºòÂåñÔºåÊòØËøôÊ†∑ÁöÑÔºöËã•‰∏§‰ª∂Áâ©ÂìÅi„ÄÅjÊª°Ë∂≥c[i]&lt;=c[j]‰∏îw[i]&gt;=w[j]ÔºåÂàôÂ∞ÜÁâ©ÂìÅjÂéªÊéâÔºå‰∏çÁî®ËÄÉËôë„ÄÇËøô‰∏™‰ºòÂåñÁöÑÊ≠£Á°ÆÊÄßÊòæÁÑ∂Ôºö‰ªª‰ΩïÊÉÖÂÜµ‰∏ãÈÉΩÂèØÂ∞Ü‰ª∑ÂÄºÂ∞èË¥πÁî®È´òÂæójÊç¢ÊàêÁâ©Áæé‰ª∑ÂªâÁöÑiÔºåÂæóÂà∞Ëá≥Â∞ë‰∏ç‰ºöÊõ¥Â∑ÆÁöÑÊñπÊ°à„ÄÇÂØπ‰∫éÈöèÊú∫ÁîüÊàêÁöÑÊï∞ÊçÆÔºåËøô‰∏™ÊñπÊ≥ïÂæÄÂæÄ‰ºöÂ§ßÂ§ßÂáèÂ∞ëÁâ©ÂìÅÁöÑ‰ª∂Êï∞Ôºå‰ªéËÄåÂä†Âø´ÈÄüÂ∫¶„ÄÇÁÑ∂ËÄåËøô‰∏™Âπ∂‰∏çËÉΩÊîπÂñÑÊúÄÂùèÊÉÖÂÜµÁöÑÂ§çÊùÇÂ∫¶ÔºåÂõ†‰∏∫ÊúâÂèØËÉΩÁâπÂà´ËÆæËÆ°ÁöÑÊï∞ÊçÆÂèØ‰ª•‰∏Ä‰ª∂Áâ©ÂìÅ‰πüÂéª‰∏çÊéâ„ÄÇ Ëøô‰∏™‰ºòÂåñÂèØ‰ª•ÁÆÄÂçïÁöÑO(N^2)Âú∞ÂÆûÁé∞Ôºå‰∏ÄËà¨ÈÉΩÂèØ‰ª•ÊâøÂèó„ÄÇÂè¶Â§ñÔºåÈíàÂØπËÉåÂåÖÈóÆÈ¢òËÄåË®ÄÔºåÊØîËæÉ‰∏çÈîôÁöÑ‰∏ÄÁßçÊñπÊ≥ïÊòØÔºö[ÊòæÁÑ∂]È¶ñÂÖàÂ∞ÜË¥πÁî®Â§ß‰∫éVÁöÑÁâ©ÂìÅÂéªÊéâÔºåÁÑ∂Âêé‰ΩøÁî®Á±ª‰ººËÆ°Êï∞ÊéíÂ∫èÁöÑÂÅöÊ≥ïÔºåËÆ°ÁÆóÂá∫Ë¥πÁî®Áõ∏ÂêåÁöÑÁâ©ÂìÅ‰∏≠‰ª∑ÂÄºÊúÄÈ´òÁöÑÊòØÂì™‰∏™ÔºåÂèØ‰ª•O(V+N)Âú∞ÂÆåÊàêËøô‰∏™‰ºòÂåñ„ÄÇËøô‰∏™‰∏çÂ§™ÈáçË¶ÅÁöÑËøáÁ®ãÂ∞±‰∏çÁªôÂá∫‰º™‰ª£Á†Å‰∫ÜÔºåÂ∏åÊúõ‰Ω†ËÉΩÁã¨Á´ãÊÄùËÄÉÂÜôÂá∫‰º™‰ª£Á†ÅÊàñÁ®ãÂ∫è„ÄÇ ËΩ¨Âåñ‰∏∫01ËÉåÂåÖÈóÆÈ¢òÊ±ÇËß£ Êó¢ÁÑ∂01ËÉåÂåÖÈóÆÈ¢òÊòØÊúÄÂü∫Êú¨ÁöÑËÉåÂåÖÈóÆÈ¢òÔºåÈÇ£‰πàÊàë‰ª¨ÂèØ‰ª•ËÄÉËôëÊääÂÆåÂÖ®ËÉåÂåÖÈóÆÈ¢òËΩ¨Âåñ‰∏∫01ËÉåÂåÖÈóÆÈ¢òÊù•Ëß£„ÄÇÊúÄÁÆÄÂçïÁöÑÊÉ≥Ê≥ïÊòØÔºåËÄÉËôëÂà∞Á¨¨iÁßçÁâ©ÂìÅÊúÄÂ§öÈÄâV/c[i]‰ª∂Ôºå‰∫éÊòØÂèØ‰ª•ÊääÁ¨¨iÁßçÁâ©ÂìÅËΩ¨Âåñ‰∏∫V/c[i]‰ª∂Ë¥πÁî®Âèä‰ª∑ÂÄºÂùá‰∏çÂèòÁöÑÁâ©ÂìÅÔºåÁÑ∂ÂêéÊ±ÇËß£Ëøô‰∏™01ËÉåÂåÖÈóÆÈ¢ò„ÄÇËøôÊ†∑ÂÆåÂÖ®Ê≤°ÊúâÊîπËøõÂü∫Êú¨ÊÄùË∑ØÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶Ôºå‰ΩÜËøôÊØïÁ´üÁªô‰∫ÜÊàë‰ª¨Â∞ÜÂÆåÂÖ®ËÉåÂåÖÈóÆÈ¢òËΩ¨Âåñ‰∏∫01ËÉåÂåÖÈóÆÈ¢òÁöÑÊÄùË∑ØÔºöÂ∞Ü‰∏ÄÁßçÁâ©ÂìÅÊãÜÊàêÂ§ö‰ª∂Áâ©ÂìÅ„ÄÇ Êõ¥È´òÊïàÁöÑËΩ¨ÂåñÊñπÊ≥ïÊòØÔºöÊääÁ¨¨iÁßçÁâ©ÂìÅÊãÜÊàêË¥πÁî®‰∏∫c[i]2k„ÄÅ‰ª∑ÂÄº‰∏∫w[i]2^kÁöÑËã•Âπ≤‰ª∂Áâ©ÂìÅÔºåÂÖ∂‰∏≠kÊª°Ë∂≥c[i]2k&lt;=V„ÄÇËøôÊòØ‰∫åËøõÂà∂ÁöÑÊÄùÊÉ≥ÔºåÂõ†‰∏∫‰∏çÁÆ°ÊúÄ‰ºòÁ≠ñÁï•ÈÄâÂá†‰ª∂Á¨¨iÁßçÁâ©ÂìÅÔºåÊÄªÂèØ‰ª•Ë°®Á§∫ÊàêËã•Âπ≤‰∏™2^k‰ª∂Áâ©ÂìÅÁöÑÂíå„ÄÇËøôÊ†∑ÊØîÊääÊØèÁßçÁâ©ÂìÅÊãÜÊàêO(log(V/c[i]))‰ª∂Áâ©ÂìÅÔºåÊòØ‰∏Ä‰∏™ÂæàÂ§ßÁöÑÊîπËøõ„ÄÇ ‰ΩÜÊàë‰ª¨ÊúâÊõ¥‰ºòÁöÑO(VN)ÁöÑÁÆóÊ≥ï„ÄÇ O(VN)ÁöÑÁÆóÊ≥ï Ëøô‰∏™ÁÆóÊ≥ï‰ΩøÁî®‰∏ÄÁª¥Êï∞ÁªÑÔºåÂÖàÁúã‰º™‰ª£Á†ÅÔºö 123for i=1..N for v=0..V f[v]=max&#123;f[v],f[v-cost]+weight&#125; ‰Ω†‰ºöÂèëÁé∞ÔºåËøô‰∏™‰º™‰ª£Á†Å‰∏éP01ÁöÑ‰º™‰ª£Á†ÅÂè™ÊúâvÁöÑÂæ™ÁéØÊ¨°Â∫è‰∏çÂêåËÄåÂ∑≤„ÄÇ‰∏∫‰ªÄ‰πàËøôÊ†∑‰∏ÄÊîπÂ∞±ÂèØË°åÂë¢ÔºüÈ¶ñÂÖàÊÉ≥ÊÉ≥‰∏∫‰ªÄ‰πàP01‰∏≠Ë¶ÅÊåâÁÖßv=V..0ÁöÑÈÄÜÂ∫èÊù•Âæ™ÁéØ„ÄÇËøôÊòØÂõ†‰∏∫Ë¶Å‰øùËØÅÁ¨¨iÊ¨°Âæ™ÁéØ‰∏≠ÁöÑÁä∂ÊÄÅf[i][v]ÊòØÁî±Áä∂ÊÄÅf[i-1][v-c[i]]ÈÄíÊé®ËÄåÊù•„ÄÇÊç¢Âè•ËØùËØ¥ÔºåËøôÊ≠£ÊòØ‰∏∫‰∫Ü‰øùËØÅÊØè‰ª∂Áâ©ÂìÅÂè™ÈÄâ‰∏ÄÊ¨°Ôºå‰øùËØÅÂú®ËÄÉËôë‚ÄúÈÄâÂÖ•Á¨¨i‰ª∂Áâ©ÂìÅ‚ÄùËøô‰ª∂Á≠ñÁï•Êó∂Ôºå‰æùÊçÆÁöÑÊòØ‰∏Ä‰∏™ÁªùÊó†Â∑≤ÁªèÈÄâÂÖ•Á¨¨i‰ª∂Áâ©ÂìÅÁöÑÂ≠êÁªìÊûúf[i-1][v-c[i]]„ÄÇËÄåÁé∞Âú®ÂÆåÂÖ®ËÉåÂåÖÁöÑÁâπÁÇπÊÅ∞ÊòØÊØèÁßçÁâ©ÂìÅÂèØÈÄâÊó†Èôê‰ª∂ÔºåÊâÄ‰ª•Âú®ËÄÉËôë‚ÄúÂä†ÈÄâ‰∏Ä‰ª∂Á¨¨iÁßçÁâ©ÂìÅ‚ÄùËøôÁßçÁ≠ñÁï•Êó∂ÔºåÂç¥Ê≠£ÈúÄË¶Å‰∏Ä‰∏™ÂèØËÉΩÂ∑≤ÈÄâÂÖ•Á¨¨iÁßçÁâ©ÂìÅÁöÑÂ≠êÁªìÊûúf[i][v-c[i]]ÔºåÊâÄ‰ª•Â∞±ÂèØ‰ª•Âπ∂‰∏îÂøÖÈ°ªÈááÁî®v=0..VÁöÑÈ°∫Â∫èÂæ™ÁéØ„ÄÇËøôÂ∞±ÊòØËøô‰∏™ÁÆÄÂçïÁöÑÁ®ãÂ∫è‰∏∫‰ΩïÊàêÁ´ãÁöÑÈÅìÁêÜ„ÄÇ Ëøô‰∏™ÁÆóÊ≥ï‰πüÂèØ‰ª•‰ª•Âè¶Â§ñÁöÑÊÄùË∑ØÂæóÂá∫„ÄÇ‰æãÂ¶ÇÔºåÂü∫Êú¨ÊÄùË∑Ø‰∏≠ÁöÑÁä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ãÂèØ‰ª•Á≠â‰ª∑Âú∞ÂèòÂΩ¢ÊàêËøôÁßçÂΩ¢ÂºèÔºö f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]} Â∞ÜËøô‰∏™ÊñπÁ®ãÁî®‰∏ÄÁª¥Êï∞ÁªÑÂÆûÁé∞Ôºå‰æøÂæóÂà∞‰∫Ü‰∏äÈù¢ÁöÑ‰º™‰ª£Á†Å„ÄÇ ÊúÄÂêéÊäΩË±°Âá∫Â§ÑÁêÜ‰∏Ä‰ª∂ÂÆåÂÖ®ËÉåÂåÖÁ±ªÁâ©ÂìÅÁöÑËøáÁ®ã‰º™‰ª£Á†ÅÔºå‰ª•Âêé‰ºöÁî®Âà∞Ôºö 123procedure CompletePack(cost,weight) for v=cost..V f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125; ÊÄªÁªì ÂÆåÂÖ®ËÉåÂåÖÈóÆÈ¢ò‰πüÊòØ‰∏Ä‰∏™Áõ∏ÂΩìÂü∫Á°ÄÁöÑËÉåÂåÖÈóÆÈ¢òÔºåÂÆÉÊúâ‰∏§‰∏™Áä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ãÔºåÂàÜÂà´Âú®‚ÄúÂü∫Êú¨ÊÄùË∑Ø‚Äù‰ª•Âèä‚ÄúO(VN)ÁöÑÁÆóÊ≥ï‚ÄúÁöÑÂ∞èËäÇ‰∏≠ÁªôÂá∫„ÄÇÂ∏åÊúõ‰Ω†ËÉΩÂ§üÂØπËøô‰∏§‰∏™Áä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ãÈÉΩ‰ªîÁªÜÂú∞‰Ωì‰ºöÔºå‰∏ç‰ªÖËÆ∞‰ΩèÔºå‰πüË¶ÅÂºÑÊòéÁôΩÂÆÉ‰ª¨ÊòØÊÄé‰πàÂæóÂá∫Êù•ÁöÑÔºåÊúÄÂ•ΩËÉΩÂ§üËá™Â∑±ÊÉ≥‰∏ÄÁßçÂæóÂà∞Ëøô‰∫õÊñπÁ®ãÁöÑÊñπÊ≥ï„ÄÇ‰∫ãÂÆû‰∏äÔºåÂØπÊØè‰∏ÄÈÅìÂä®ÊÄÅËßÑÂàíÈ¢òÁõÆÈÉΩÊÄùËÄÉÂÖ∂ÊñπÁ®ãÁöÑÊÑè‰πâ‰ª•ÂèäÂ¶Ç‰ΩïÂæóÊù•ÔºåÊòØÂä†Ê∑±ÂØπÂä®ÊÄÅËßÑÂàíÁöÑÁêÜËß£„ÄÅÊèêÈ´òÂä®ÊÄÅËßÑÂàíÂäüÂäõÁöÑÂ•ΩÊñπÊ≥ï„ÄÇ È¶ñÈ°µ P03: Â§öÈáçËÉåÂåÖÈóÆÈ¢ò È¢òÁõÆ ÊúâNÁßçÁâ©ÂìÅÂíå‰∏Ä‰∏™ÂÆπÈáè‰∏∫VÁöÑËÉåÂåÖ„ÄÇÁ¨¨iÁßçÁâ©ÂìÅÊúÄÂ§öÊúân[i]‰ª∂ÂèØÁî®ÔºåÊØè‰ª∂Ë¥πÁî®ÊòØc[i]Ôºå‰ª∑ÂÄºÊòØw[i]„ÄÇÊ±ÇËß£Â∞ÜÂì™‰∫õÁâ©ÂìÅË£ÖÂÖ•ËÉåÂåÖÂèØ‰ΩøËøô‰∫õÁâ©ÂìÅÁöÑË¥πÁî®ÊÄªÂíå‰∏çË∂ÖËøáËÉåÂåÖÂÆπÈáèÔºå‰∏î‰ª∑ÂÄºÊÄªÂíåÊúÄÂ§ß„ÄÇ Âü∫Êú¨ÁÆóÊ≥ï ËøôÈ¢òÁõÆÂíåÂÆåÂÖ®ËÉåÂåÖÈóÆÈ¢òÂæàÁ±ª‰ºº„ÄÇÂü∫Êú¨ÁöÑÊñπÁ®ãÂè™ÈúÄÂ∞ÜÂÆåÂÖ®ËÉåÂåÖÈóÆÈ¢òÁöÑÊñπÁ®ãÁï•ÂæÆ‰∏ÄÊîπÂç≥ÂèØÔºåÂõ†‰∏∫ÂØπ‰∫éÁ¨¨iÁßçÁâ©ÂìÅÊúân[i]+1ÁßçÁ≠ñÁï•ÔºöÂèñ0‰ª∂ÔºåÂèñ1‰ª∂‚Ä¶‚Ä¶Âèñn[i]‰ª∂„ÄÇ‰ª§f[i][v]Ë°®Á§∫ÂâçiÁßçÁâ©ÂìÅÊÅ∞ÊîæÂÖ•‰∏Ä‰∏™ÂÆπÈáè‰∏∫vÁöÑËÉåÂåÖÁöÑÊúÄÂ§ßÊùÉÂÄºÔºåÂàôÊúâÁä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ãÔºö f[i][v]=max{f[i-1][v-k*c[i]]+kw[i]|0&lt;=k&lt;=n[i]} Â§çÊùÇÂ∫¶ÊòØO(VŒ£n[i])„ÄÇ ËΩ¨Âåñ‰∏∫01ËÉåÂåÖÈóÆÈ¢ò Âè¶‰∏ÄÁßçÂ•ΩÊÉ≥Â•ΩÂÜôÁöÑÂü∫Êú¨ÊñπÊ≥ïÊòØËΩ¨Âåñ‰∏∫01ËÉåÂåÖÊ±ÇËß£ÔºöÊääÁ¨¨iÁßçÁâ©ÂìÅÊç¢Êàên[i]‰ª∂01ËÉåÂåÖ‰∏≠ÁöÑÁâ©ÂìÅÔºåÂàôÂæóÂà∞‰∫ÜÁâ©ÂìÅÊï∞‰∏∫Œ£n[i]ÁöÑ01ËÉåÂåÖÈóÆÈ¢òÔºåÁõ¥Êé•Ê±ÇËß£ÔºåÂ§çÊùÇÂ∫¶‰ªçÁÑ∂ÊòØO(VŒ£n[i])„ÄÇ ‰ΩÜÊòØÊàë‰ª¨ÊúüÊúõÂ∞ÜÂÆÉËΩ¨Âåñ‰∏∫01ËÉåÂåÖÈóÆÈ¢ò‰πãÂêéËÉΩÂ§üÂÉèÂÆåÂÖ®ËÉåÂåÖ‰∏ÄÊ†∑Èôç‰ΩéÂ§çÊùÇÂ∫¶„ÄÇ‰ªçÁÑ∂ËÄÉËôë‰∫åËøõÂà∂ÁöÑÊÄùÊÉ≥ÔºåÊàë‰ª¨ËÄÉËôëÊääÁ¨¨iÁßçÁâ©ÂìÅÊç¢ÊàêËã•Âπ≤‰ª∂Áâ©ÂìÅÔºå‰ΩøÂæóÂéüÈóÆÈ¢ò‰∏≠Á¨¨iÁßçÁâ©ÂìÅÂèØÂèñÁöÑÊØèÁßçÁ≠ñÁï•‚Äî‚ÄîÂèñ0..n[i]‰ª∂‚Äî‚ÄîÂùáËÉΩÁ≠â‰ª∑‰∫éÂèñËã•Âπ≤‰ª∂‰ª£Êç¢‰ª•ÂêéÁöÑÁâ©ÂìÅ„ÄÇÂè¶Â§ñÔºåÂèñË∂ÖËøán[i]‰ª∂ÁöÑÁ≠ñÁï•ÂøÖ‰∏çËÉΩÂá∫Áé∞„ÄÇ ÊñπÊ≥ïÊòØÔºöÂ∞ÜÁ¨¨iÁßçÁâ©ÂìÅÂàÜÊàêËã•Âπ≤‰ª∂Áâ©ÂìÅÔºåÂÖ∂‰∏≠ÊØè‰ª∂Áâ©ÂìÅÊúâ‰∏Ä‰∏™Á≥ªÊï∞ÔºåËøô‰ª∂Áâ©ÂìÅÁöÑË¥πÁî®Âíå‰ª∑ÂÄºÂùáÊòØÂéüÊù•ÁöÑË¥πÁî®Âíå‰ª∑ÂÄº‰πò‰ª•Ëøô‰∏™Á≥ªÊï∞„ÄÇ‰ΩøËøô‰∫õÁ≥ªÊï∞ÂàÜÂà´‰∏∫1,2,4,...,2(k-1),n[i]-2k+1Ôºå‰∏îkÊòØÊª°Ë∂≥n[i]-2k+1&gt;0ÁöÑÊúÄÂ§ßÊï¥Êï∞„ÄÇ‰æãÂ¶ÇÔºåÂ¶ÇÊûún[i]‰∏∫13ÔºåÂ∞±Â∞ÜËøôÁßçÁâ©ÂìÅÂàÜÊàêÁ≥ªÊï∞ÂàÜÂà´‰∏∫1,2,4,6ÁöÑÂõõ‰ª∂Áâ©ÂìÅ„ÄÇ ÂàÜÊàêÁöÑËøôÂá†‰ª∂Áâ©ÂìÅÁöÑÁ≥ªÊï∞Âíå‰∏∫n[i]ÔºåË°®Êòé‰∏çÂèØËÉΩÂèñÂ§ö‰∫én[i]‰ª∂ÁöÑÁ¨¨iÁßçÁâ©ÂìÅ„ÄÇÂè¶Â§ñËøôÁßçÊñπÊ≥ï‰πüËÉΩ‰øùËØÅÂØπ‰∫é0..n[i]Èó¥ÁöÑÊØè‰∏Ä‰∏™Êï¥Êï∞ÔºåÂùáÂèØ‰ª•Áî®Ëã•Âπ≤‰∏™Á≥ªÊï∞ÁöÑÂíåË°®Á§∫ÔºåËøô‰∏™ËØÅÊòéÂèØ‰ª•ÂàÜ0..2k-1Âíå2^k..n[i]‰∏§ÊÆµÊù•ÂàÜÂà´ËÆ®ËÆ∫ÂæóÂá∫ÔºåÂπ∂‰∏çÈöæÔºåÂ∏åÊúõ‰Ω†Ëá™Â∑±ÊÄùËÄÉÂ∞ùËØï‰∏Ä‰∏ã„ÄÇ ËøôÊ†∑Â∞±Â∞ÜÁ¨¨iÁßçÁâ©ÂìÅÂàÜÊàê‰∫ÜO(log n[i])ÁßçÁâ©ÂìÅÔºåÂ∞ÜÂéüÈóÆÈ¢òËΩ¨Âåñ‰∏∫‰∫ÜÂ§çÊùÇÂ∫¶‰∏∫O(VŒ£log n[i])ÁöÑ01ËÉåÂåÖÈóÆÈ¢òÔºåÊòØÂæàÂ§ßÁöÑÊîπËøõ„ÄÇ ‰∏ãÈù¢ÁªôÂá∫O(log amount)Êó∂Èó¥Â§ÑÁêÜ‰∏Ä‰ª∂Â§öÈáçËÉåÂåÖ‰∏≠Áâ©ÂìÅÁöÑËøáÁ®ãÔºåÂÖ∂‰∏≠amountË°®Á§∫Áâ©ÂìÅÁöÑÊï∞ÈáèÔºö 12345678910procedure MultiplePack(cost,weight,amount) if cost*amount&gt;=V CompletePack(cost,weight) return integer k=1 while k&lt;num ZeroOnePack(k*cost,k*weight) amount=amount-k k=k*2 ZeroOnePack(amount*cost,amount*weight) Â∏åÊúõ‰Ω†‰ªîÁªÜ‰Ωì‰ºöËøô‰∏™‰º™‰ª£Á†ÅÔºåÂ¶ÇÊûú‰∏çÂ§™ÁêÜËß£ÁöÑËØùÔºå‰∏çÂ¶®ÁøªËØëÊàêÁ®ãÂ∫è‰ª£Á†Å‰ª•ÂêéÔºåÂçïÊ≠•ÊâßË°åÂá†Ê¨°ÔºåÊàñËÄÖÂ§¥ËÑëÂä†Á∫∏Á¨îÊ®°Êãü‰∏Ä‰∏ãÔºåÂ∞±‰ºöÊÖ¢ÊÖ¢ÁêÜËß£‰∫Ü„ÄÇ O(VN)ÁöÑÁÆóÊ≥ï Â§öÈáçËÉåÂåÖÈóÆÈ¢òÂêåÊ†∑ÊúâO(VN)ÁöÑÁÆóÊ≥ï„ÄÇËøô‰∏™ÁÆóÊ≥ïÂü∫‰∫éÂü∫Êú¨ÁÆóÊ≥ïÁöÑÁä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ãÔºå‰ΩÜÂ∫îÁî®ÂçïË∞ÉÈòüÂàóÁöÑÊñπÊ≥ï‰ΩøÊØè‰∏™Áä∂ÊÄÅÁöÑÂÄºÂèØ‰ª•‰ª•ÂùáÊëäO(1)ÁöÑÊó∂Èó¥Ê±ÇËß£„ÄÇÁî±‰∫éÁî®ÂçïË∞ÉÈòüÂàó‰ºòÂåñÁöÑDPÂ∑≤Ë∂ÖÂá∫‰∫ÜNOIPÁöÑËåÉÂõ¥ÔºåÊïÖÊú¨Êñá‰∏çÂÜçÂ±ïÂºÄËÆ≤Ëß£„ÄÇÊàëÊúÄÂàù‰∫ÜËß£Âà∞Ëøô‰∏™ÊñπÊ≥ïÊòØÂú®Ê•ºÂ§©ÊàêÁöÑ‚ÄúÁî∑‰∫∫ÂÖ´È¢ò‚ÄùÂπªÁÅØÁâá‰∏ä„ÄÇ Â∞èÁªì ËøôÈáåÊàë‰ª¨ÁúãÂà∞‰∫ÜÂ∞Ü‰∏Ä‰∏™ÁÆóÊ≥ïÁöÑÂ§çÊùÇÂ∫¶Áî±O(VŒ£n[i])ÊîπËøõÂà∞O(VŒ£log n[i])ÁöÑËøáÁ®ãÔºåËøòÁü•ÈÅì‰∫ÜÂ≠òÂú®Â∫îÁî®Ë∂ÖÂá∫NOIPËåÉÂõ¥ÁöÑÁü•ËØÜÁöÑO(VN)ÁÆóÊ≥ï„ÄÇÂ∏åÊúõ‰Ω†ÁâπÂà´Ê≥®ÊÑè‚ÄúÊãÜÂàÜÁâ©ÂìÅ‚ÄùÁöÑÊÄùÊÉ≥ÂíåÊñπÊ≥ïÔºåËá™Â∑±ËØÅÊòé‰∏Ä‰∏ãÂÆÉÁöÑÊ≠£Á°ÆÊÄßÔºåÂπ∂Â∞ÜÂÆåÊï¥ÁöÑÁ®ãÂ∫è‰ª£Á†ÅÂÜôÂá∫Êù•„ÄÇ È¶ñÈ°µ P04: Ê∑∑Âêà‰∏âÁßçËÉåÂåÖÈóÆÈ¢ò ÈóÆÈ¢ò Â¶ÇÊûúÂ∞ÜP01„ÄÅP02„ÄÅP03Ê∑∑ÂêàËµ∑Êù•„ÄÇ‰πüÂ∞±ÊòØËØ¥ÔºåÊúâÁöÑÁâ©ÂìÅÂè™ÂèØ‰ª•Âèñ‰∏ÄÊ¨°Ôºà01ËÉåÂåÖÔºâÔºåÊúâÁöÑÁâ©ÂìÅÂèØ‰ª•ÂèñÊó†ÈôêÊ¨°ÔºàÂÆåÂÖ®ËÉåÂåÖÔºâÔºåÊúâÁöÑÁâ©ÂìÅÂèØ‰ª•ÂèñÁöÑÊ¨°Êï∞Êúâ‰∏Ä‰∏™‰∏äÈôêÔºàÂ§öÈáçËÉåÂåÖÔºâ„ÄÇÂ∫îËØ•ÊÄé‰πàÊ±ÇËß£Âë¢Ôºü 01ËÉåÂåÖ‰∏éÂÆåÂÖ®ËÉåÂåÖÁöÑÊ∑∑Âêà ËÄÉËôëÂà∞Âú®P01ÂíåP02‰∏≠ÁªôÂá∫ÁöÑ‰º™‰ª£Á†ÅÂè™Êúâ‰∏ÄÂ§Ñ‰∏çÂêåÔºåÊïÖÂ¶ÇÊûúÂè™Êúâ‰∏§Á±ªÁâ©ÂìÅÔºö‰∏ÄÁ±ªÁâ©ÂìÅÂè™ËÉΩÂèñ‰∏ÄÊ¨°ÔºåÂè¶‰∏ÄÁ±ªÁâ©ÂìÅÂèØ‰ª•ÂèñÊó†ÈôêÊ¨°ÔºåÈÇ£‰πàÂè™ÈúÄÂú®ÂØπÊØè‰∏™Áâ©ÂìÅÂ∫îÁî®ËΩ¨ÁßªÊñπÁ®ãÊó∂ÔºåÊ†πÊçÆÁâ©ÂìÅÁöÑÁ±ªÂà´ÈÄâÁî®È°∫Â∫èÊàñÈÄÜÂ∫èÁöÑÂæ™ÁéØÂç≥ÂèØÔºåÂ§çÊùÇÂ∫¶ÊòØO(VN)„ÄÇ‰º™‰ª£Á†ÅÂ¶Ç‰∏ãÔºö 1234567for i=1..N if Á¨¨i‰ª∂Áâ©ÂìÅÊòØ01ËÉåÂåÖ for v=V..0 f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; else if Á¨¨i‰ª∂Áâ©ÂìÅÊòØÂÆåÂÖ®ËÉåÂåÖ for v=0..V f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; ÂÜçÂä†‰∏äÂ§öÈáçËÉåÂåÖ Â¶ÇÊûúÂÜçÂä†‰∏äÊúâÁöÑÁâ©ÂìÅÊúÄÂ§öÂèØ‰ª•ÂèñÊúâÈôêÊ¨°ÔºåÈÇ£‰πàÂéüÂàô‰∏ä‰πüÂèØ‰ª•ÁªôÂá∫O(VN)ÁöÑËß£Ê≥ïÔºöÈÅáÂà∞Â§öÈáçËÉåÂåÖÁ±ªÂûãÁöÑÁâ©ÂìÅÁî®ÂçïË∞ÉÈòüÂàóËß£Âç≥ÂèØ„ÄÇ‰ΩÜÂ¶ÇÊûú‰∏çËÄÉËôëË∂ÖËøáNOIPËåÉÂõ¥ÁöÑÁÆóÊ≥ïÁöÑËØùÔºåÁî®P03‰∏≠Â∞ÜÊØè‰∏™ËøôÁ±ªÁâ©ÂìÅÂàÜÊàêO(log n[i])‰∏™01ËÉåÂåÖÁöÑÁâ©ÂìÅÁöÑÊñπÊ≥ï‰πüÂ∑≤ÁªèÂæà‰ºò‰∫Ü„ÄÇ ÂΩìÁÑ∂ÔºåÊõ¥Ê∏ÖÊô∞ÁöÑÂÜôÊ≥ïÊòØË∞ÉÁî®Êàë‰ª¨ÂâçÈù¢ÁªôÂá∫ÁöÑ‰∏â‰∏™Áõ∏ÂÖ≥ËøáÁ®ã„ÄÇ Ê∑∑Ë°ÄÂÑøÁöÑ‰ºòÂäø 1234567for i=1..N if Á¨¨i‰ª∂Áâ©ÂìÅÊòØ01ËÉåÂåÖ ZeroOnePack(c[i],w[i]) else if Á¨¨i‰ª∂Áâ©ÂìÅÊòØÂÆåÂÖ®ËÉåÂåÖ CompletePack(c[i],w[i]) else if Á¨¨i‰ª∂Áâ©ÂìÅÊòØÂ§öÈáçËÉåÂåÖ MultiplePack(c[i],w[i],n[i]) Âú®ÊúÄÂàùÂÜôÂá∫Ëøô‰∏â‰∏™ËøáÁ®ãÁöÑÊó∂ÂÄôÔºåÂèØËÉΩÂÆåÂÖ®Ê≤°ÊúâÊÉ≥Âà∞ÂÆÉ‰ª¨‰ºöÂú®ËøôÈáåÊ∑∑ÂêàÂ∫îÁî®„ÄÇÊàëÊÉ≥Ëøô‰ΩìÁé∞‰∫ÜÁºñÁ®ã‰∏≠ÊäΩË±°ÁöÑÂ®ÅÂäõ„ÄÇÂ¶ÇÊûú‰Ω†‰∏ÄÁõ¥Â∞±ÊòØ‰ª•ËøôÁßç‚ÄúÊäΩË±°Âá∫ËøáÁ®ã‚ÄùÁöÑÊñπÂºèÂÜôÊØè‰∏ÄÁ±ªËÉåÂåÖÈóÆÈ¢òÁöÑÔºå‰πüÈùûÂ∏∏Ê∏ÖÊ•öÂÆÉ‰ª¨ÁöÑÂÆûÁé∞‰∏≠ÁªÜÂæÆÁöÑ‰∏çÂêåÔºåÈÇ£‰πàÂú®ÈÅáÂà∞Ê∑∑Âêà‰∏âÁßçËÉåÂåÖÈóÆÈ¢òÁöÑÈ¢òÁõÆÊó∂Ôºå‰∏ÄÂÆöËÉΩÂæàÂø´ÊÉ≥Âà∞‰∏äÈù¢ÁÆÄÊ¥ÅÁöÑËß£Ê≥ïÔºåÂØπÂêóÔºü Â∞èÁªì Êúâ‰∫∫ËØ¥ÔºåÂõ∞ÈöæÁöÑÈ¢òÁõÆÈÉΩÊòØÁî±ÁÆÄÂçïÁöÑÈ¢òÁõÆÂè†Âä†ËÄåÊù•ÁöÑ„ÄÇËøôÂè•ËØùÊòØÂê¶ÂÖ¨ÁêÜÊöÇ‰∏îÂ≠ò‰πã‰∏çËÆ∫Ôºå‰ΩÜÂÆÉÂú®Êú¨ËÆ≤‰∏≠Â∑≤ÁªèÂæóÂà∞‰∫ÜÂÖÖÂàÜÁöÑ‰ΩìÁé∞„ÄÇÊú¨Êù•01ËÉåÂåÖ„ÄÅÂÆåÂÖ®ËÉåÂåÖ„ÄÅÂ§öÈáçËÉåÂåÖÈÉΩ‰∏çÊòØ‰ªÄ‰πàÈöæÈ¢òÔºå‰ΩÜÂ∞ÜÂÆÉ‰ª¨ÁÆÄÂçïÂú∞ÁªÑÂêàËµ∑Êù•‰ª•ÂêéÂ∞±ÂæóÂà∞‰∫ÜËøôÊ†∑‰∏ÄÈÅì‰∏ÄÂÆöËÉΩÂêìÂÄí‰∏çÂ∞ë‰∫∫ÁöÑÈ¢òÁõÆ„ÄÇ‰ΩÜÂè™Ë¶ÅÂü∫Á°ÄÊâéÂÆûÔºåÈ¢Ü‰ºö‰∏âÁßçÂü∫Êú¨ËÉåÂåÖÈóÆÈ¢òÁöÑÊÄùÊÉ≥ÔºåÂ∞±ÂèØ‰ª•ÂÅöÂà∞ÊääÂõ∞ÈöæÁöÑÈ¢òÁõÆÊãÜÂàÜÊàêÁÆÄÂçïÁöÑÈ¢òÁõÆÊù•Ëß£ÂÜ≥„ÄÇ È¶ñÈ°µ ÁõÆÂΩï Á¨¨‰∫îËÆ≤ ‰∫åÁª¥Ë¥πÁî®ÁöÑËÉåÂåÖÈóÆÈ¢ò ‰∏Ä‰∏™ÁÆÄÂçïÁöÑÂ∏∏ËßÅÊâ©Â±ï„ÄÇ Á¨¨ÂÖ≠ËÆ≤ ÂàÜÁªÑÁöÑËÉåÂåÖÈóÆÈ¢ò ‰∏ÄÁßçÈ¢òÁõÆÁ±ªÂûãÔºå‰πüÊòØ‰∏Ä‰∏™ÊúâÁî®ÁöÑÊ®°Âûã„ÄÇÂêé‰∏§ËäÇÁöÑÂü∫Á°Ä„ÄÇ Á¨¨‰∏ÉËÆ≤ Êúâ‰æùËµñÁöÑËÉåÂåÖÈóÆÈ¢ò Âè¶‰∏ÄÁßçÁªôÁâ©ÂìÅÁöÑÈÄâÂèñÂä†‰∏äÈôêÂà∂ÁöÑÊñπÊ≥ï„ÄÇ Á¨¨ÂÖ´ËÆ≤ Ê≥õÂåñÁâ©ÂìÅ ÊàëËá™Â∑±ÂÖ≥‰∫éËÉåÂåÖÈóÆÈ¢òÁöÑÊÄùËÄÉÊàêÊûúÔºåÊúâ‰∏ÄÁÇπÊäΩË±°„ÄÇ Á¨¨‰πùËÆ≤ ËÉåÂåÖÈóÆÈ¢òÈóÆÊ≥ïÁöÑÂèòÂåñ ËØïÂõæËß¶Á±ªÊóÅÈÄö„ÄÅ‰∏æ‰∏ÄÂèç‰∏â„ÄÇ ËÉåÂåÖÁöÑÊêúÁ¥¢ ÈôÑÔºöUSACO‰∏≠ÁöÑËÉåÂåÖÈóÆÈ¢ò ÁªôÂá∫ USACO Training ‰∏äÂèØ‰æõÁªÉ‰π†ÁöÑËÉåÂåÖÈóÆÈ¢òÂàóË°®ÔºåÂèäÁÆÄÂçïÁöÑËß£Á≠î„ÄÇ P05: ‰∫åÁª¥Ë¥πÁî®ÁöÑËÉåÂåÖÈóÆÈ¢ò ÈóÆÈ¢ò ‰∫åÁª¥Ë¥πÁî®ÁöÑËÉåÂåÖÈóÆÈ¢òÊòØÊåáÔºöÂØπ‰∫éÊØè‰ª∂Áâ©ÂìÅÔºåÂÖ∑Êúâ‰∏§Áßç‰∏çÂêåÁöÑË¥πÁî®ÔºõÈÄâÊã©Ëøô‰ª∂Áâ©ÂìÅÂøÖÈ°ªÂêåÊó∂‰ªòÂá∫Ëøô‰∏§Áßç‰ª£‰ª∑ÔºõÂØπ‰∫éÊØèÁßç‰ª£‰ª∑ÈÉΩÊúâ‰∏Ä‰∏™ÂèØ‰ªòÂá∫ÁöÑÊúÄÂ§ßÂÄºÔºàËÉåÂåÖÂÆπÈáèÔºâ„ÄÇÈóÆÊÄéÊ†∑ÈÄâÊã©Áâ©ÂìÅÂèØ‰ª•ÂæóÂà∞ÊúÄÂ§ßÁöÑ‰ª∑ÂÄº„ÄÇËÆæËøô‰∏§Áßç‰ª£‰ª∑ÂàÜÂà´‰∏∫‰ª£‰ª∑1Âíå‰ª£‰ª∑2ÔºåÁ¨¨i‰ª∂Áâ©ÂìÅÊâÄÈúÄÁöÑ‰∏§Áßç‰ª£‰ª∑ÂàÜÂà´‰∏∫a[i]Âíåb[i]„ÄÇ‰∏§Áßç‰ª£‰ª∑ÂèØ‰ªòÂá∫ÁöÑÊúÄÂ§ßÂÄºÔºà‰∏§ÁßçËÉåÂåÖÂÆπÈáèÔºâÂàÜÂà´‰∏∫VÂíåU„ÄÇÁâ©ÂìÅÁöÑ‰ª∑ÂÄº‰∏∫w[i]„ÄÇ ÁÆóÊ≥ï Ë¥πÁî®Âä†‰∫Ü‰∏ÄÁª¥ÔºåÂè™ÈúÄÁä∂ÊÄÅ‰πüÂä†‰∏ÄÁª¥Âç≥ÂèØ„ÄÇËÆæf[i][v][u]Ë°®Á§∫Ââçi‰ª∂Áâ©ÂìÅ‰ªòÂá∫‰∏§Áßç‰ª£‰ª∑ÂàÜÂà´‰∏∫vÂíåuÊó∂ÂèØËé∑ÂæóÁöÑÊúÄÂ§ß‰ª∑ÂÄº„ÄÇÁä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ãÂ∞±ÊòØÔºö f[i][v][u]=max{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]} Â¶ÇÂâçËø∞ÊñπÊ≥ïÔºåÂèØ‰ª•Âè™‰ΩøÁî®‰∫åÁª¥ÁöÑÊï∞ÁªÑÔºöÂΩìÊØè‰ª∂Áâ©ÂìÅÂè™ÂèØ‰ª•Âèñ‰∏ÄÊ¨°Êó∂ÂèòÈáèvÂíåuÈááÁî®ÈÄÜÂ∫èÁöÑÂæ™ÁéØÔºåÂΩìÁâ©ÂìÅÊúâÂ¶ÇÂÆåÂÖ®ËÉåÂåÖÈóÆÈ¢òÊó∂ÈááÁî®È°∫Â∫èÁöÑÂæ™ÁéØ„ÄÇÂΩìÁâ©ÂìÅÊúâÂ¶ÇÂ§öÈáçËÉåÂåÖÈóÆÈ¢òÊó∂ÊãÜÂàÜÁâ©ÂìÅ„ÄÇËøôÈáåÂ∞±‰∏çÂÜçÁªôÂá∫‰º™‰ª£Á†Å‰∫ÜÔºåÁõ∏‰ø°Êúâ‰∫ÜÂâçÈù¢ÁöÑÂü∫Á°ÄÔºå‰Ω†ËÉΩÂ§üËá™Â∑±ÂÆûÁé∞Âá∫Ëøô‰∏™ÈóÆÈ¢òÁöÑÁ®ãÂ∫è„ÄÇ Áâ©ÂìÅÊÄª‰∏™Êï∞ÁöÑÈôêÂà∂ ÊúâÊó∂Ôºå‚Äú‰∫åÁª¥Ë¥πÁî®‚ÄùÁöÑÊù°‰ª∂ÊòØ‰ª•ËøôÊ†∑‰∏ÄÁßçÈöêÂê´ÁöÑÊñπÂºèÁªôÂá∫ÁöÑÔºöÊúÄÂ§öÂè™ËÉΩÂèñM‰ª∂Áâ©ÂìÅ„ÄÇËøô‰∫ãÂÆû‰∏äÁõ∏ÂΩì‰∫éÊØè‰ª∂Áâ©ÂìÅÂ§ö‰∫Ü‰∏ÄÁßç‚Äú‰ª∂Êï∞‚ÄùÁöÑË¥πÁî®ÔºåÊØè‰∏™Áâ©ÂìÅÁöÑ‰ª∂Êï∞Ë¥πÁî®Âùá‰∏∫1ÔºåÂèØ‰ª•‰ªòÂá∫ÁöÑÊúÄÂ§ß‰ª∂Êï∞Ë¥πÁî®‰∏∫M„ÄÇÊç¢Âè•ËØùËØ¥ÔºåËÆæf[v][m]Ë°®Á§∫‰ªòÂá∫Ë¥πÁî®v„ÄÅÊúÄÂ§öÈÄâm‰ª∂Êó∂ÂèØÂæóÂà∞ÁöÑÊúÄÂ§ß‰ª∑ÂÄºÔºåÂàôÊ†πÊçÆÁâ©ÂìÅÁöÑÁ±ªÂûãÔºà01„ÄÅÂÆåÂÖ®„ÄÅÂ§öÈáçÔºâÁî®‰∏çÂêåÁöÑÊñπÊ≥ïÂæ™ÁéØÊõ¥Êñ∞ÔºåÊúÄÂêéÂú®f[0..V][0..M]ËåÉÂõ¥ÂÜÖÂØªÊâæÁ≠îÊ°à„ÄÇ Â∞èÁªì ÊòØ‰∏çÊòØÂèØ‰ª•Áî®Êù•Ëß£ÂÜ≥Â§öÈáçËÉåÂåÖÁöÑÈóÆÈ¢òÔºüÔºüÔºüÂè™‰∏çËøáÊØîÂ§öÈáçËÉåÂåÖÂ§çÊùÇÂ∫¶È´ò ÂΩìÂèëÁé∞Áî±ÁÜüÊÇâÁöÑÂä®ÊÄÅËßÑÂàíÈ¢òÁõÆÂèòÂΩ¢ÂæóÊù•ÁöÑÈ¢òÁõÆÊó∂ÔºåÂú®ÂéüÊù•ÁöÑÁä∂ÊÄÅ‰∏≠Âä†‰∏ÄÁª¥‰ª•Êª°Ë∂≥Êñ∞ÁöÑÈôêÂà∂ÊòØ‰∏ÄÁßçÊØîËæÉÈÄöÁî®ÁöÑÊñπÊ≥ï„ÄÇÂ∏åÊúõ‰Ω†ËÉΩ‰ªéÊú¨ËÆ≤‰∏≠ÂàùÊ≠•‰Ωì‰ºöÂà∞ËøôÁßçÊñπÊ≥ï„ÄÇ È¶ñÈ°µ P06: ÂàÜÁªÑÁöÑËÉåÂåÖÈóÆÈ¢ò ÈóÆÈ¢ò ÊúâN‰ª∂Áâ©ÂìÅÂíå‰∏Ä‰∏™ÂÆπÈáè‰∏∫VÁöÑËÉåÂåÖ„ÄÇÁ¨¨i‰ª∂Áâ©ÂìÅÁöÑË¥πÁî®ÊòØc[i]Ôºå‰ª∑ÂÄºÊòØw[i]„ÄÇËøô‰∫õÁâ©ÂìÅË¢´ÂàíÂàÜ‰∏∫Ëã•Âπ≤ÁªÑÔºåÊØèÁªÑ‰∏≠ÁöÑÁâ©ÂìÅ‰∫íÁõ∏ÂÜ≤Á™ÅÔºåÊúÄÂ§öÈÄâ‰∏Ä‰ª∂„ÄÇÊ±ÇËß£Â∞ÜÂì™‰∫õÁâ©ÂìÅË£ÖÂÖ•ËÉåÂåÖÂèØ‰ΩøËøô‰∫õÁâ©ÂìÅÁöÑË¥πÁî®ÊÄªÂíå‰∏çË∂ÖËøáËÉåÂåÖÂÆπÈáèÔºå‰∏î‰ª∑ÂÄºÊÄªÂíåÊúÄÂ§ß„ÄÇ ÁÆóÊ≥ï Ëøô‰∏™ÈóÆÈ¢òÂèòÊàê‰∫ÜÊØèÁªÑÁâ©ÂìÅÊúâËã•Âπ≤ÁßçÁ≠ñÁï•ÔºöÊòØÈÄâÊã©Êú¨ÁªÑÁöÑÊüê‰∏Ä‰ª∂ÔºåËøòÊòØ‰∏Ä‰ª∂ÈÉΩ‰∏çÈÄâ„ÄÇ‰πüÂ∞±ÊòØËØ¥ËÆæf[k][v]Ë°®Á§∫ÂâçkÁªÑÁâ©ÂìÅËä±Ë¥πË¥πÁî®vËÉΩÂèñÂæóÁöÑÊúÄÂ§ßÊùÉÂÄºÔºåÂàôÊúâÔºö f[k][v]=max{f[k-1][v],f[k-1][v-c[i]]+w[i]|Áâ©ÂìÅiÂ±û‰∫éÁ¨¨kÁªÑ} ‰ΩøÁî®‰∏ÄÁª¥Êï∞ÁªÑÁöÑ‰º™‰ª£Á†ÅÂ¶Ç‰∏ãÔºö 1234for ÊâÄÊúâÁöÑÁªÑk for v=V..0 for ÊâÄÊúâÁöÑiÂ±û‰∫éÁªÑk f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125; Ê≥®ÊÑèËøôÈáåÁöÑ‰∏âÂ±ÇÂæ™ÁéØÁöÑÈ°∫Â∫èÔºåÁîöËá≥Âú®Êú¨ÊñáÁöÑbetaÁâà‰∏≠ÊàëËá™Â∑±ÈÉΩÂÜôÈîô‰∫Ü„ÄÇ‚Äúfor v=V..0‚ÄùËøô‰∏ÄÂ±ÇÂæ™ÁéØÂøÖÈ°ªÂú®‚Äúfor ÊâÄÊúâÁöÑiÂ±û‰∫éÁªÑk‚Äù‰πãÂ§ñ„ÄÇËøôÊ†∑ÊâçËÉΩ‰øùËØÅÊØè‰∏ÄÁªÑÂÜÖÁöÑÁâ©ÂìÅÊúÄÂ§öÂè™Êúâ‰∏Ä‰∏™‰ºöË¢´Ê∑ªÂä†Âà∞ËÉåÂåÖ‰∏≠„ÄÇ Âè¶Â§ñÔºåÊòæÁÑ∂ÂèØ‰ª•ÂØπÊØèÁªÑÂÜÖÁöÑÁâ©ÂìÅÂ∫îÁî®P02‰∏≠‚Äú‰∏Ä‰∏™ÁÆÄÂçïÊúâÊïàÁöÑ‰ºòÂåñ‚Äù„ÄÇ Â∞èÁªì ÂàÜÁªÑÁöÑËÉåÂåÖÈóÆÈ¢òÂ∞ÜÂΩºÊ≠§‰∫íÊñ•ÁöÑËã•Âπ≤Áâ©ÂìÅÁß∞‰∏∫‰∏Ä‰∏™ÁªÑÔºåËøôÂª∫Á´ã‰∫Ü‰∏Ä‰∏™ÂæàÂ•ΩÁöÑÊ®°Âûã„ÄÇ‰∏çÂ∞ëËÉåÂåÖÈóÆÈ¢òÁöÑÂèòÂΩ¢ÈÉΩÂèØ‰ª•ËΩ¨Âåñ‰∏∫ÂàÜÁªÑÁöÑËÉåÂåÖÈóÆÈ¢òÔºà‰æãÂ¶ÇP07ÔºâÔºåÁî±ÂàÜÁªÑÁöÑËÉåÂåÖÈóÆÈ¢òËøõ‰∏ÄÊ≠•ÂèØÂÆö‰πâ‚ÄúÊ≥õÂåñÁâ©ÂìÅ‚ÄùÁöÑÊ¶ÇÂøµÔºåÂçÅÂàÜÊúâÂà©‰∫éËß£È¢ò„ÄÇ È¶ñÈ°µ P07: Êúâ‰æùËµñÁöÑËÉåÂåÖÈóÆÈ¢ò ÁÆÄÂåñÁöÑÈóÆÈ¢ò ËøôÁßçËÉåÂåÖÈóÆÈ¢òÁöÑÁâ©ÂìÅÈó¥Â≠òÂú®ÊüêÁßç‚Äú‰æùËµñ‚ÄùÁöÑÂÖ≥Á≥ª„ÄÇ‰πüÂ∞±ÊòØËØ¥Ôºåi‰æùËµñ‰∫éjÔºåË°®Á§∫Ëã•ÈÄâÁâ©ÂìÅiÔºåÂàôÂøÖÈ°ªÈÄâÁâ©ÂìÅj„ÄÇ‰∏∫‰∫ÜÁÆÄÂåñËµ∑ËßÅÔºåÊàë‰ª¨ÂÖàËÆæÊ≤°ÊúâÊüê‰∏™Áâ©ÂìÅÊó¢‰æùËµñ‰∫éÂà´ÁöÑÁâ©ÂìÅÔºåÂèàË¢´Âà´ÁöÑÁâ©ÂìÅÊâÄ‰æùËµñÔºõÂè¶Â§ñÔºåÊ≤°ÊúâÊüê‰ª∂Áâ©ÂìÅÂêåÊó∂‰æùËµñÂ§ö‰ª∂Áâ©ÂìÅ„ÄÇ ÁÆóÊ≥ï Ëøô‰∏™ÈóÆÈ¢òÁî±NOIP2006ÈáëÊòéÁöÑÈ¢ÑÁÆóÊñπÊ°à‰∏ÄÈ¢òÊâ©Â±ïËÄåÊù•„ÄÇÈÅµ‰ªéËØ•È¢òÁöÑÊèêÊ≥ïÔºåÂ∞Ü‰∏ç‰æùËµñ‰∫éÂà´ÁöÑÁâ©ÂìÅÁöÑÁâ©ÂìÅÁß∞‰∏∫‚Äú‰∏ª‰ª∂‚ÄùÔºå‰æùËµñ‰∫éÊüê‰∏ª‰ª∂ÁöÑÁâ©ÂìÅÁß∞‰∏∫‚ÄúÈôÑ‰ª∂‚Äù„ÄÇÁî±Ëøô‰∏™ÈóÆÈ¢òÁöÑÁÆÄÂåñÊù°‰ª∂ÂèØÁü•ÊâÄÊúâÁöÑÁâ©ÂìÅÁî±Ëã•Âπ≤‰∏ª‰ª∂Âíå‰æùËµñ‰∫éÊØè‰∏™‰∏ª‰ª∂ÁöÑ‰∏Ä‰∏™ÈôÑ‰ª∂ÈõÜÂêàÁªÑÊàê„ÄÇ ÊåâÁÖßËÉåÂåÖÈóÆÈ¢òÁöÑ‰∏ÄËà¨ÊÄùË∑ØÔºå‰ªÖËÄÉËôë‰∏Ä‰∏™‰∏ª‰ª∂ÂíåÂÆÉÁöÑÈôÑ‰ª∂ÈõÜÂêà„ÄÇÂèØÊòØÔºåÂèØÁî®ÁöÑÁ≠ñÁï•ÈùûÂ∏∏Â§öÔºåÂåÖÊã¨Ôºö‰∏Ä‰∏™‰πü‰∏çÈÄâÔºå‰ªÖÈÄâÊã©‰∏ª‰ª∂ÔºåÈÄâÊã©‰∏ª‰ª∂ÂêéÂÜçÈÄâÊã©‰∏Ä‰∏™ÈôÑ‰ª∂ÔºåÈÄâÊã©‰∏ª‰ª∂ÂêéÂÜçÈÄâÊã©‰∏§‰∏™ÈôÑ‰ª∂‚Ä¶‚Ä¶Êó†Ê≥ïÁî®Áä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ãÊù•Ë°®Á§∫Â¶ÇÊ≠§Â§öÁöÑÁ≠ñÁï•„ÄÇÔºà‰∫ãÂÆû‰∏äÔºåËÆæÊúân‰∏™ÈôÑ‰ª∂ÔºåÂàôÁ≠ñÁï•Êúâ2^n+1‰∏™Ôºå‰∏∫ÊåáÊï∞Á∫ß„ÄÇÔºâ ËÄÉËôëÂà∞ÊâÄÊúâËøô‰∫õÁ≠ñÁï•ÈÉΩÊòØ‰∫íÊñ•ÁöÑÔºà‰πüÂ∞±ÊòØËØ¥Ôºå‰Ω†Âè™ËÉΩÈÄâÊã©‰∏ÄÁßçÁ≠ñÁï•ÔºâÔºåÊâÄ‰ª•‰∏Ä‰∏™‰∏ª‰ª∂ÂíåÂÆÉÁöÑÈôÑ‰ª∂ÈõÜÂêàÂÆûÈôÖ‰∏äÂØπÂ∫î‰∫éP06‰∏≠ÁöÑ‰∏Ä‰∏™Áâ©ÂìÅÁªÑÔºåÊØè‰∏™ÈÄâÊã©‰∫Ü‰∏ª‰ª∂ÂèàÈÄâÊã©‰∫ÜËã•Âπ≤‰∏™ÈôÑ‰ª∂ÁöÑÁ≠ñÁï•ÂØπÂ∫î‰∫éËøô‰∏™Áâ©ÂìÅÁªÑ‰∏≠ÁöÑ‰∏Ä‰∏™Áâ©ÂìÅÔºåÂÖ∂Ë¥πÁî®Âíå‰ª∑ÂÄºÈÉΩÊòØËøô‰∏™Á≠ñÁï•‰∏≠ÁöÑÁâ©ÂìÅÁöÑÂÄºÁöÑÂíå„ÄÇ‰ΩÜ‰ªÖ‰ªÖÊòØËøô‰∏ÄÊ≠•ËΩ¨ÂåñÂπ∂‰∏çËÉΩÁªôÂá∫‰∏Ä‰∏™Â•ΩÁöÑÁÆóÊ≥ïÔºåÂõ†‰∏∫Áâ©ÂìÅÁªÑ‰∏≠ÁöÑÁâ©ÂìÅËøòÊòØÂÉèÂéüÈóÆÈ¢òÁöÑÁ≠ñÁï•‰∏ÄÊ†∑Â§ö„ÄÇ ÂÜçËÄÉËôëP06‰∏≠ÁöÑ‰∏ÄÂè•ËØùÔºö ÂèØ‰ª•ÂØπÊØèÁªÑ‰∏≠ÁöÑÁâ©ÂìÅÂ∫îÁî®P02‰∏≠‚Äú‰∏Ä‰∏™ÁÆÄÂçïÊúâÊïàÁöÑ‰ºòÂåñ‚Äù„ÄÇ ËøôÊèêÁ§∫Êàë‰ª¨ÔºåÂØπ‰∫é‰∏Ä‰∏™Áâ©ÂìÅÁªÑ‰∏≠ÁöÑÁâ©ÂìÅÔºåÊâÄÊúâË¥πÁî®Áõ∏ÂêåÁöÑÁâ©ÂìÅÂè™Áïô‰∏Ä‰∏™‰ª∑ÂÄºÊúÄÂ§ßÁöÑÔºå‰∏çÂΩ±ÂìçÁªìÊûú„ÄÇÊâÄ‰ª•ÔºåÊàë‰ª¨ÂèØ‰ª•ÂØπ‰∏ª‰ª∂iÁöÑ‚ÄúÈôÑ‰ª∂ÈõÜÂêà‚ÄùÂÖàËøõË°å‰∏ÄÊ¨°01ËÉåÂåÖÔºåÂæóÂà∞Ë¥πÁî®‰æùÊ¨°‰∏∫0..V-c[i]ÊâÄÊúâËøô‰∫õÂÄºÊó∂Áõ∏Â∫îÁöÑÊúÄÂ§ß‰ª∑ÂÄºf'[0..V-c[i]]„ÄÇÈÇ£‰πàËøô‰∏™‰∏ª‰ª∂ÂèäÂÆÉÁöÑÈôÑ‰ª∂ÈõÜÂêàÁõ∏ÂΩì‰∫éV-c[i]+1‰∏™Áâ©ÂìÅÁöÑÁâ©ÂìÅÁªÑÔºåÂÖ∂‰∏≠Ë¥πÁî®‰∏∫c[i]+kÁöÑÁâ©ÂìÅÁöÑ‰ª∑ÂÄº‰∏∫f'[k]+w[i]„ÄÇ‰πüÂ∞±ÊòØËØ¥ÂéüÊù•ÊåáÊï∞Á∫ßÁöÑÁ≠ñÁï•‰∏≠ÊúâÂæàÂ§öÁ≠ñÁï•ÈÉΩÊòØÂÜó‰ΩôÁöÑÔºåÈÄöËøá‰∏ÄÊ¨°01ËÉåÂåÖÂêéÔºåÂ∞Ü‰∏ª‰ª∂iËΩ¨Âåñ‰∏∫V-c[i]+1‰∏™Áâ©ÂìÅÁöÑÁâ©ÂìÅÁªÑÔºåÂ∞±ÂèØ‰ª•Áõ¥Êé•Â∫îÁî®P06ÁöÑÁÆóÊ≥ïËß£ÂÜ≥ÈóÆÈ¢ò‰∫Ü„ÄÇ ËæÉ‰∏ÄËà¨ÁöÑÈóÆÈ¢ò Êõ¥‰∏ÄËà¨ÁöÑÈóÆÈ¢òÊòØÔºö‰æùËµñÂÖ≥Á≥ª‰ª•ÂõæËÆ∫‰∏≠‚ÄúÊ£ÆÊûó‚ÄùÁöÑÂΩ¢ÂºèÁªôÂá∫ÔºàÊ£ÆÊûóÂç≥Â§öÂèâÊ†ëÁöÑÈõÜÂêàÔºâÔºå‰πüÂ∞±ÊòØËØ¥Ôºå‰∏ª‰ª∂ÁöÑÈôÑ‰ª∂‰ªçÁÑ∂ÂèØ‰ª•ÂÖ∑ÊúâËá™Â∑±ÁöÑÈôÑ‰ª∂ÈõÜÂêàÔºåÈôêÂà∂Âè™ÊòØÊØè‰∏™Áâ©ÂìÅÊúÄÂ§öÂè™‰æùËµñ‰∫é‰∏Ä‰∏™Áâ©ÂìÅÔºàÂè™Êúâ‰∏Ä‰∏™‰∏ª‰ª∂Ôºâ‰∏î‰∏çÂá∫Áé∞Âæ™ÁéØ‰æùËµñ„ÄÇ Ëß£ÂÜ≥Ëøô‰∏™ÈóÆÈ¢ò‰ªçÁÑ∂ÂèØ‰ª•Áî®Â∞ÜÊØè‰∏™‰∏ª‰ª∂ÂèäÂÖ∂ÈôÑ‰ª∂ÈõÜÂêàËΩ¨Âåñ‰∏∫Áâ©ÂìÅÁªÑÁöÑÊñπÂºè„ÄÇÂîØ‰∏Ä‰∏çÂêåÁöÑÊòØÔºåÁî±‰∫éÈôÑ‰ª∂ÂèØËÉΩËøòÊúâÈôÑ‰ª∂ÔºåÂ∞±‰∏çËÉΩÂ∞ÜÊØè‰∏™ÈôÑ‰ª∂ÈÉΩÁúã‰Ωú‰∏Ä‰∏™‰∏ÄËà¨ÁöÑ01ËÉåÂåÖ‰∏≠ÁöÑÁâ©ÂìÅ‰∫Ü„ÄÇËã•Ëøô‰∏™ÈôÑ‰ª∂‰πüÊúâÈôÑ‰ª∂ÈõÜÂêàÔºåÂàôÂÆÉÂøÖÂÆöË¶ÅË¢´ÂÖàËΩ¨Âåñ‰∏∫Áâ©ÂìÅÁªÑÔºåÁÑ∂ÂêéÁî®ÂàÜÁªÑÁöÑËÉåÂåÖÈóÆÈ¢òËß£Âá∫‰∏ª‰ª∂ÂèäÂÖ∂ÈôÑ‰ª∂ÈõÜÂêàÊâÄÂØπÂ∫îÁöÑÈôÑ‰ª∂ÁªÑ‰∏≠ÂêÑ‰∏™Ë¥πÁî®ÁöÑÈôÑ‰ª∂ÊâÄÂØπÂ∫îÁöÑ‰ª∑ÂÄº„ÄÇ ‰∫ãÂÆû‰∏äÔºåËøôÊòØ‰∏ÄÁßçÊ†ëÂΩ¢DPÔºåÂÖ∂ÁâπÁÇπÊòØÔºöÊØè‰∏™Áà∂ËäÇÁÇπÈÉΩÈúÄË¶ÅÂØπÂÆÉÁöÑÂêÑ‰∏™ÂÑøÂ≠êÁöÑÂ±ûÊÄßËøõË°å‰∏ÄÊ¨°DP‰ª•Ê±ÇÂæóËá™Â∑±ÁöÑÁõ∏ÂÖ≥Â±ûÊÄß„ÄÇËøôÂ∑≤ÁªèËß¶ÂèäÂà∞‰∫Ü‚ÄúÊ≥õÂåñÁâ©ÂìÅ‚ÄùÁöÑÊÄùÊÉ≥„ÄÇÁúãÂÆåP08ÂêéÔºå‰Ω†‰ºöÂèëÁé∞Ëøô‰∏™‚Äú‰æùËµñÂÖ≥Á≥ªÊ†ë‚ÄùÊØè‰∏Ä‰∏™Â≠êÊ†ëÈÉΩÁ≠â‰ª∑‰∫é‰∏Ä‰ª∂Ê≥õÂåñÁâ©ÂìÅÔºåÊ±ÇÊüêËäÇÁÇπ‰∏∫Ê†πÁöÑÂ≠êÊ†ëÂØπÂ∫îÁöÑÊ≥õÂåñÁâ©ÂìÅÁõ∏ÂΩì‰∫éÊ±ÇÂÖ∂ÊâÄÊúâÂÑøÂ≠êÁöÑÂØπÂ∫îÁöÑÊ≥õÂåñÁâ©ÂìÅ‰πãÂíå„ÄÇ Â∞èÁªì NOIP2006ÁöÑÈÇ£ÈÅìËÉåÂåÖÈóÆÈ¢òÊàëÂÅöÂæóÂæàÂ§±Ë¥•ÔºåÂÜô‰∫Ü‰∏äÁôæË°åÁöÑ‰ª£Á†ÅÔºåÂç¥‰∏ÄÂàÜÊú™Âæó„ÄÇÂêéÊù•ÊàëÈÄöËøáÊÄùËÄÉÂèëÁé∞ÈÄöËøáÂºïÂÖ•‚ÄúÁâ©ÂìÅÁªÑ‚ÄùÂíå‚Äú‰æùËµñ‚ÄùÁöÑÊ¶ÇÂøµÂèØ‰ª•Âä†Ê∑±ÂØπËøôÈ¢òÁöÑÁêÜËß£ÔºåËøòÂèØ‰ª•Ëß£ÂÜ≥ÂÆÉÁöÑÊé®ÂπøÈóÆÈ¢ò„ÄÇÁî®Áâ©ÂìÅÁªÑÁöÑÊÄùÊÉ≥ËÄÉËôëÈÇ£È¢ò‰∏≠ÊûÅÂÖ∂ÁâπÊÆäÁöÑ‰æùËµñÂÖ≥Á≥ªÔºöÁâ©ÂìÅ‰∏çËÉΩÊó¢‰Ωú‰∏ª‰ª∂Âèà‰ΩúÈôÑ‰ª∂ÔºåÊØè‰∏™‰∏ª‰ª∂ÊúÄÂ§öÊúâ‰∏§‰∏™ÈôÑ‰ª∂ÔºåÂèØ‰ª•ÂèëÁé∞‰∏Ä‰∏™‰∏ª‰ª∂ÂíåÂÆÉÁöÑ‰∏§‰∏™ÈôÑ‰ª∂Á≠â‰ª∑‰∫é‰∏Ä‰∏™Áî±Âõõ‰∏™Áâ©ÂìÅÁªÑÊàêÁöÑÁâ©ÂìÅÁªÑÔºåËøô‰æøÊè≠Á§∫‰∫ÜÈóÆÈ¢òÁöÑÊüêÁßçÊú¨Ë¥®„ÄÇ ÊàëÊÉ≥ËØ¥ÔºöÂ§±Ë¥•‰∏çÊòØ‰ªÄ‰πà‰∏¢‰∫∫ÁöÑ‰∫ãÊÉÖÔºå‰ªéÂ§±Ë¥•‰∏≠ÂÖ®Êó†Êî∂Ëé∑ÊâçÊòØ„ÄÇ È¶ñÈ°µ P08: Ê≥õÂåñÁâ©ÂìÅ ÂÆö‰πâ ËÄÉËôëËøôÊ†∑‰∏ÄÁßçÁâ©ÂìÅÔºåÂÆÉÂπ∂Ê≤°ÊúâÂõ∫ÂÆöÁöÑË¥πÁî®Âíå‰ª∑ÂÄºÔºåËÄåÊòØÂÆÉÁöÑ‰ª∑ÂÄºÈöèÁùÄ‰Ω†ÂàÜÈÖçÁªôÂÆÉÁöÑË¥πÁî®ËÄåÂèòÂåñ„ÄÇËøôÂ∞±ÊòØÊ≥õÂåñÁâ©ÂìÅÁöÑÊ¶ÇÂøµ„ÄÇ Êõ¥‰∏•Ê†ºÁöÑÂÆö‰πâ‰πã„ÄÇÂú®ËÉåÂåÖÂÆπÈáè‰∏∫VÁöÑËÉåÂåÖÈóÆÈ¢ò‰∏≠ÔºåÊ≥õÂåñÁâ©ÂìÅÊòØ‰∏Ä‰∏™ÂÆö‰πâÂüü‰∏∫0..V‰∏≠ÁöÑÊï¥Êï∞ÁöÑÂáΩÊï∞hÔºåÂΩìÂàÜÈÖçÁªôÂÆÉÁöÑË¥πÁî®‰∏∫vÊó∂ÔºåËÉΩÂæóÂà∞ÁöÑ‰ª∑ÂÄºÂ∞±ÊòØh(v)„ÄÇ Ëøô‰∏™ÂÆö‰πâÊúâ‰∏ÄÁÇπÁÇπÊäΩË±°ÔºåÂè¶‰∏ÄÁßçÁêÜËß£ÊòØ‰∏Ä‰∏™Ê≥õÂåñÁâ©ÂìÅÂ∞±ÊòØ‰∏Ä‰∏™Êï∞ÁªÑh[0..V]ÔºåÁªôÂÆÉË¥πÁî®vÔºåÂèØÂæóÂà∞‰ª∑ÂÄºh[V]„ÄÇ{fuck!Ëøô‰∏ç‰∏ÄÊ†∑ÂïäÔºÅ} [Â∞ÜÊâÄÊúâÁöÑËÉåÂåÖÊôÆÈÅçÂåñ]Ôºö1.‰∏Ä‰∏™Ë¥πÁî®‰∏∫c‰ª∑ÂÄº‰∏∫wÁöÑÁâ©ÂìÅÔºåÂ¶ÇÊûúÂÆÉÊòØ01ËÉåÂåÖ‰∏≠ÁöÑÁâ©ÂìÅÔºåÈÇ£‰πàÊääÂÆÉÁúãÊàêÊ≥õÂåñÁâ©ÂìÅÔºåÂÆÉÂ∞±ÊòØÈô§‰∫Üh(c)=wÂÖ∂ÂÆÉÂáΩÊï∞ÂÄºÈÉΩ‰∏∫0ÁöÑ‰∏Ä‰∏™ÂáΩÊï∞„ÄÇ2.Â¶ÇÊûúÂÆÉÊòØÂÆåÂÖ®ËÉåÂåÖ‰∏≠ÁöÑÁâ©ÂìÅÔºåÈÇ£‰πàÂÆÉÂèØ‰ª•ÁúãÊàêËøôÊ†∑‰∏Ä‰∏™ÂáΩÊï∞Ôºå‰ªÖÂΩìvË¢´cÊï¥Èô§Êó∂Êúâh(v)=v/cwÔºåÂÖ∂ÂÆÉÂáΩÊï∞ÂÄºÂùá‰∏∫0„ÄÇ3.Â¶ÇÊûúÂÆÉÊòØÂ§öÈáçËÉåÂåÖ‰∏≠ÈáçÂ§çÊ¨°Êï∞ÊúÄÂ§ö‰∏∫nÁöÑÁâ©ÂìÅÔºåÈÇ£‰πàÂÆÉÂØπÂ∫îÁöÑÊ≥õÂåñÁâ©ÂìÅÁöÑÂáΩÊï∞Êúâh(v)=v/cw‰ªÖÂΩìvË¢´cÊï¥Èô§‰∏îv/c&lt;=nÔºåÂÖ∂ÂÆÉÊÉÖÂÜµÂáΩÊï∞ÂÄºÂùá‰∏∫0„ÄÇ ‰∏Ä‰∏™Áâ©ÂìÅÁªÑÂèØ‰ª•Áúã‰Ωú‰∏Ä‰∏™Ê≥õÂåñÁâ©ÂìÅh„ÄÇÂØπ‰∫é‰∏Ä‰∏™0..V‰∏≠ÁöÑvÔºåËã•Áâ©ÂìÅÁªÑ‰∏≠‰∏çÂ≠òÂú®Ë¥πÁî®‰∏∫vÁöÑÁöÑÁâ©ÂìÅÔºåÂàôh(v)=0ÔºåÂê¶Âàôh(v)‰∏∫ÊâÄÊúâË¥πÁî®‰∏∫vÁöÑÁâ©ÂìÅÁöÑÊúÄÂ§ß‰ª∑ÂÄº„ÄÇP07‰∏≠ÊØè‰∏™‰∏ª‰ª∂ÂèäÂÖ∂ÈôÑ‰ª∂ÈõÜÂêàÁ≠â‰ª∑‰∫é‰∏Ä‰∏™Áâ©ÂìÅÁªÑÔºåËá™ÁÑ∂‰πüÂèØÁúã‰Ωú‰∏Ä‰∏™Ê≥õÂåñÁâ©ÂìÅ„ÄÇ Ê≥õÂåñÁâ©ÂìÅÁöÑÂíå Â¶ÇÊûúÈù¢ÂØπ‰∏§‰∏™Ê≥õÂåñÁâ©ÂìÅhÂíålÔºåË¶ÅÁî®ÁªôÂÆöÁöÑË¥πÁî®‰ªéËøô‰∏§‰∏™Ê≥õÂåñÁâ©ÂìÅ‰∏≠ÂæóÂà∞ÊúÄÂ§ßÁöÑ‰ª∑ÂÄºÔºåÊÄé‰πàÊ±ÇÂë¢Ôºü‰∫ãÂÆû‰∏äÔºåÂØπ‰∫é‰∏Ä‰∏™ÁªôÂÆöÁöÑË¥πÁî®vÔºåÂè™ÈúÄÊûö‰∏æÂ∞ÜËøô‰∏™Ë¥πÁî®Â¶Ç‰ΩïÂàÜÈÖçÁªô‰∏§‰∏™Ê≥õÂåñÁâ©ÂìÅÂ∞±ÂèØ‰ª•‰∫Ü„ÄÇÂêåÊ†∑ÁöÑÔºåÂØπ‰∫é0..VÁöÑÊØè‰∏Ä‰∏™Êï¥Êï∞vÔºåÂèØ‰ª•Ê±ÇÂæóË¥πÁî®vÂàÜÈÖçÂà∞hÂíål‰∏≠ÁöÑÊúÄÂ§ß‰ª∑ÂÄºf(v)„ÄÇ‰πüÂç≥f(v)=max{h(k)+l(v-k)|0&lt;=k&lt;=v}„ÄÇÂèØ‰ª•ÁúãÂà∞Ôºåf‰πüÊòØ‰∏Ä‰∏™Áî±Ê≥õÂåñÁâ©ÂìÅhÂíålÂÜ≥ÂÆöÁöÑÂÆö‰πâÂüü‰∏∫0..VÁöÑÂáΩÊï∞Ôºå‰πüÂ∞±ÊòØËØ¥ÔºåfÊòØ‰∏Ä‰∏™Áî±Ê≥õÂåñÁâ©ÂìÅhÂíålÂÜ≥ÂÆöÁöÑÊ≥õÂåñÁâ©ÂìÅ„ÄÇ Áî±Ê≠§ÂèØ‰ª•ÂÆö‰πâÊ≥õÂåñÁâ©ÂìÅÁöÑÂíåÔºöh„ÄÅlÈÉΩÊòØÊ≥õÂåñÁâ©ÂìÅÔºåËã•Ê≥õÂåñÁâ©ÂìÅfÊª°Ë∂≥f(v)=max{h(k)+l(v-k)|0&lt;=k&lt;=v}ÔºåÂàôÁß∞fÊòØh‰∏élÁöÑÂíåÔºåÂç≥f=h+l„ÄÇËøô‰∏™ËøêÁÆóÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶ÂèñÂÜ≥‰∫éËÉåÂåÖÁöÑÂÆπÈáèÔºåÊòØO(V^2)„ÄÇ Ê≥õÂåñÁâ©ÂìÅÁöÑÂÆö‰πâË°®ÊòéÔºöÂú®‰∏Ä‰∏™ËÉåÂåÖÈóÆÈ¢ò‰∏≠ÔºåËã•Â∞Ü‰∏§‰∏™Ê≥õÂåñÁâ©ÂìÅ‰ª£‰ª•ÂÆÉ‰ª¨ÁöÑÂíåÔºå‰∏çÂΩ±ÂìçÈóÆÈ¢òÁöÑÁ≠îÊ°à„ÄÇ‰∫ãÂÆû‰∏äÔºåÂØπ‰∫éÂÖ∂‰∏≠ÁöÑÁâ©ÂìÅÈÉΩÊòØÊ≥õÂåñÁâ©ÂìÅÁöÑËÉåÂåÖÈóÆÈ¢òÔºåÊ±ÇÂÆÉÁöÑÁ≠îÊ°àÁöÑËøáÁ®ã‰πüÂ∞±ÊòØÊ±ÇÊâÄÊúâËøô‰∫õÊ≥õÂåñÁâ©ÂìÅ‰πãÂíåÁöÑËøáÁ®ã„ÄÇËÆæÊ≠§Âíå‰∏∫sÔºåÂàôÁ≠îÊ°àÂ∞±ÊòØs[0..V]‰∏≠ÁöÑÊúÄÂ§ßÂÄº„ÄÇ ËÉåÂåÖÈóÆÈ¢òÁöÑÊ≥õÂåñÁâ©ÂìÅ ‰∏Ä‰∏™ËÉåÂåÖÈóÆÈ¢ò‰∏≠ÔºåÂèØËÉΩ‰ºöÁªôÂá∫ÂæàÂ§öÊù°‰ª∂ÔºåÂåÖÊã¨ÊØèÁßçÁâ©ÂìÅÁöÑË¥πÁî®„ÄÅ‰ª∑ÂÄºÁ≠âÂ±ûÊÄßÔºåÁâ©ÂìÅ‰πãÈó¥ÁöÑÂàÜÁªÑ„ÄÅ‰æùËµñÁ≠âÂÖ≥Á≥ªÁ≠â„ÄÇ‰ΩÜËÇØÂÆöËÉΩÂ∞ÜÈóÆÈ¢òÂØπÂ∫î‰∫éÊüê‰∏™Ê≥õÂåñÁâ©ÂìÅ„ÄÇ‰πüÂ∞±ÊòØËØ¥ÔºåÁªôÂÆö‰∫ÜÊâÄÊúâÊù°‰ª∂‰ª•ÂêéÔºåÂ∞±ÂèØ‰ª•ÂØπÊØè‰∏™ÈùûË¥üÊï¥Êï∞vÊ±ÇÂæóÔºöËã•ËÉåÂåÖÂÆπÈáè‰∏∫vÔºåÂ∞ÜÁâ©ÂìÅË£ÖÂÖ•ËÉåÂåÖÂèØÂæóÂà∞ÁöÑÊúÄÂ§ß‰ª∑ÂÄºÊòØÂ§öÂ∞ëÔºåËøôÂèØ‰ª•ËÆ§‰∏∫ÊòØÂÆö‰πâÂú®ÈùûË¥üÊï¥Êï∞ÈõÜ‰∏äÁöÑ‰∏Ä‰ª∂Ê≥õÂåñÁâ©ÂìÅ„ÄÇËøô‰∏™Ê≥õÂåñÁâ©ÂìÅ‚Äî‚ÄîÊàñËÄÖËØ¥ÈóÆÈ¢òÊâÄÂØπÂ∫îÁöÑ‰∏Ä‰∏™ÂÆö‰πâÂüü‰∏∫ÈùûË¥üÊï¥Êï∞ÁöÑÂáΩÊï∞‚Äî‚ÄîÂåÖÂê´‰∫ÜÂÖ≥‰∫éÈóÆÈ¢òÊú¨Ë∫´ÁöÑÈ´òÂ∫¶ÊµìÁº©ÁöÑ‰ø°ÊÅØ„ÄÇ‰∏ÄËà¨ËÄåË®ÄÔºåÊ±ÇÂæóËøô‰∏™Ê≥õÂåñÁâ©ÂìÅÁöÑ‰∏Ä‰∏™Â≠êÂüüÔºà‰æãÂ¶Ç0..VÔºâÁöÑÂÄº‰πãÂêéÔºåÂ∞±ÂèØ‰ª•Ê†πÊçÆËøô‰∏™ÂáΩÊï∞ÁöÑÂèñÂÄºÂæóÂà∞ËÉåÂåÖÈóÆÈ¢òÁöÑÊúÄÁªàÁ≠îÊ°à„ÄÇ Áªº‰∏äÊâÄËø∞Ôºå‰∏ÄËà¨ËÄåË®ÄÔºåÊ±ÇËß£ËÉåÂåÖÈóÆÈ¢òÔºåÂç≥Ê±ÇËß£Ëøô‰∏™ÈóÆÈ¢òÊâÄÂØπÂ∫îÁöÑ‰∏Ä‰∏™ÂáΩÊï∞ÔºåÂç≥ËØ•ÈóÆÈ¢òÁöÑÊ≥õÂåñÁâ©ÂìÅ„ÄÇËÄåÊ±ÇËß£Êüê‰∏™Ê≥õÂåñÁâ©ÂìÅÁöÑ‰∏ÄÁßçÊñπÊ≥ïÂ∞±ÊòØÂ∞ÜÂÆÉË°®Á§∫‰∏∫Ëã•Âπ≤Ê≥õÂåñÁâ©ÂìÅÁöÑÂíåÁÑ∂ÂêéÊ±Ç‰πã„ÄÇ Â∞èÁªì Êú¨ËÆ≤ÂèØ‰ª•ËØ¥ÈÉΩÊòØÊàëËá™Â∑±ÁöÑÂéüÂàõÊÄùÊÉ≥„ÄÇÂÖ∑‰ΩìÊù•ËØ¥ÔºåÊòØÊàëÂú®Â≠¶‰π†ÂáΩÊï∞ÂºèÁºñÁ®ãÁöÑ Scheme ËØ≠Ë®ÄÊó∂ÔºåÁî®ÂáΩÊï∞ÁºñÁ®ãÁöÑÁúºÂÖâÂÆ°ËßÜÂêÑÁ±ªËÉåÂåÖÈóÆÈ¢òÂæóÂá∫ÁöÑÁêÜËÆ∫„ÄÇËøô‰∏ÄËÆ≤ÁúüÁöÑÂæàÊäΩË±°Ôºå‰πüËÆ∏Âú®‚ÄúÊ®°ÂûãÁöÑÊäΩË±°Á®ãÂ∫¶‚ÄùËøô‰∏ÄÊñπÈù¢Â∑≤ÁªèË∂ÖÂá∫‰∫ÜNOIPÁöÑË¶ÅÊ±ÇÔºåÊâÄ‰ª•ÊöÇ‰∏îÁúã‰∏çÊáÇ‰πüÊ≤°ÂÖ≥Á≥ª„ÄÇÁõ∏‰ø°ÈöèÁùÄ‰Ω†ÁöÑOI‰πãË∑ØÈÄêÊ∏êÂª∂‰º∏ÔºåÊúâ‰∏ÄÂ§©‰Ω†‰ºöÁêÜËß£ÁöÑ„ÄÇ ÊàëÊÉ≥ËØ¥Ôºö‚ÄúÊÄùËÄÉ‚ÄùÊòØ‰∏Ä‰∏™OIerÊúÄÈáçË¶ÅÁöÑÂìÅË¥®„ÄÇÁÆÄÂçïÁöÑÈóÆÈ¢òÔºåÊ∑±ÂÖ•ÊÄùËÄÉ‰ª•ÂêéÔºå‰πüËÉΩÂèëÁé∞Êõ¥Â§ö„ÄÇ È¶ñÈ°µ P09: ËÉåÂåÖÈóÆÈ¢òÈóÆÊ≥ïÁöÑÂèòÂåñ ‰ª•‰∏äÊ∂âÂèäÁöÑÂêÑÁßçËÉåÂåÖÈóÆÈ¢òÈÉΩÊòØË¶ÅÊ±ÇÂú®ËÉåÂåÖÂÆπÈáèÔºàË¥πÁî®ÔºâÁöÑÈôêÂà∂‰∏ãÊ±ÇÂèØ‰ª•ÂèñÂà∞ÁöÑÊúÄÂ§ß‰ª∑ÂÄºÔºå‰ΩÜËÉåÂåÖÈóÆÈ¢òËøòÊúâÂæàÂ§öÁßçÁÅµÊ¥ªÁöÑÈóÆÊ≥ïÔºåÂú®ËøôÈáåÂÄºÂæóÊèê‰∏Ä‰∏ã„ÄÇ‰ΩÜÊòØÊàëËÆ§‰∏∫ÔºåÂè™Ë¶ÅÊ∑±ÂÖ•ÁêÜËß£‰∫ÜÊ±ÇËÉåÂåÖÈóÆÈ¢òÊúÄÂ§ß‰ª∑ÂÄºÁöÑÊñπÊ≥ïÔºåÂç≥‰ΩøÈóÆÊ≥ïÂèòÂåñ‰∫ÜÔºå‰πüÊòØ‰∏çÈöæÊÉ≥Âá∫ÁÆóÊ≥ïÁöÑ„ÄÇ ‰æãÂ¶ÇÔºåÊ±ÇËß£ÊúÄÂ§öÂèØ‰ª•ÊîæÂ§öÂ∞ë‰ª∂Áâ©ÂìÅÊàñËÄÖÊúÄÂ§öÂèØ‰ª•Ë£ÖÊª°Â§öÂ∞ëËÉåÂåÖÁöÑÁ©∫Èó¥„ÄÇËøôÈÉΩÂèØ‰ª•Ê†πÊçÆÂÖ∑‰ΩìÈóÆÈ¢òÂà©Áî®ÂâçÈù¢ÁöÑÊñπÁ®ãÊ±ÇÂá∫ÊâÄÊúâÁä∂ÊÄÅÁöÑÂÄºÔºàfÊï∞ÁªÑÔºâ‰πãÂêéÂæóÂà∞„ÄÇ ÂæàÂ§öÈÉΩÊòØËøôÊ†∑ÁöÑ ËøòÊúâÔºåÂ¶ÇÊûúË¶ÅÊ±ÇÁöÑÊòØ‚ÄúÊÄª‰ª∑ÂÄºÊúÄÂ∞è‚Äù‚ÄúÊÄª‰ª∂Êï∞ÊúÄÂ∞è‚ÄùÔºåÂè™ÈúÄÁÆÄÂçïÁöÑÂ∞Ü‰∏äÈù¢ÁöÑÁä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ã‰∏≠ÁöÑmaxÊîπÊàêminÂç≥ÂèØ„ÄÇ ‰∏ãÈù¢ËØ¥‰∏Ä‰∫õÂèòÂåñÊõ¥Â§ßÁöÑÈóÆÊ≥ï„ÄÇ ËæìÂá∫ÊñπÊ°à ‰∏ÄËà¨ËÄåË®ÄÔºåËÉåÂåÖÈóÆÈ¢òÊòØË¶ÅÊ±Ç‰∏Ä‰∏™ÊúÄ‰ºòÂÄºÔºåÂ¶ÇÊûúË¶ÅÊ±ÇËæìÂá∫Ëøô‰∏™ÊúÄ‰ºòÂÄºÁöÑÊñπÊ°àÔºåÂèØ‰ª•ÂèÇÁÖß‰∏ÄËà¨Âä®ÊÄÅËßÑÂàíÈóÆÈ¢òËæìÂá∫ÊñπÊ°àÁöÑÊñπÊ≥ïÔºöËÆ∞ÂΩï‰∏ãÊØè‰∏™Áä∂ÊÄÅÁöÑÊúÄ‰ºòÂÄºÊòØÁî±Áä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ãÁöÑÂì™‰∏ÄÈ°πÊé®Âá∫Êù•ÁöÑÔºåÊç¢Âè•ËØùËØ¥ÔºåËÆ∞ÂΩï‰∏ãÂÆÉÊòØÁî±Âì™‰∏Ä‰∏™Á≠ñÁï•Êé®Âá∫Êù•ÁöÑ„ÄÇ‰æøÂèØÊ†πÊçÆËøôÊù°Á≠ñÁï•ÊâæÂà∞‰∏ä‰∏Ä‰∏™Áä∂ÊÄÅÔºå‰ªé‰∏ä‰∏Ä‰∏™Áä∂ÊÄÅÊé•ÁùÄÂêëÂâçÊé®Âç≥ÂèØ„ÄÇ ËøòÊòØ‰ª•01ËÉåÂåÖ‰∏∫‰æãÔºåÊñπÁ®ã‰∏∫f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}„ÄÇÂÜçÁî®‰∏Ä‰∏™Êï∞ÁªÑg[i][v]ÔºåËÆæg[i][v]=0Ë°®Á§∫Êé®Âá∫f[i][v]ÁöÑÂÄºÊó∂ÊòØÈááÁî®‰∫ÜÊñπÁ®ãÁöÑÂâç‰∏ÄÈ°πÔºà‰πüÂç≥f[i][v]=f[i-1][v]ÔºâÔºåg[i][v]Ë°®Á§∫ÈááÁî®‰∫ÜÊñπÁ®ãÁöÑÂêé‰∏ÄÈ°π„ÄÇÊ≥®ÊÑèËøô‰∏§È°πÂàÜÂà´Ë°®Á§∫‰∫Ü‰∏§ÁßçÁ≠ñÁï•ÔºöÊú™ÈÄâÁ¨¨i‰∏™Áâ©ÂìÅÂèäÈÄâ‰∫ÜÁ¨¨i‰∏™Áâ©ÂìÅ„ÄÇÈÇ£‰πàËæìÂá∫ÊñπÊ°àÁöÑ‰º™‰ª£Á†ÅÂèØ‰ª•ËøôÊ†∑ÂÜôÔºàËÆæÊúÄÁªàÁä∂ÊÄÅ‰∏∫f[N][V]ÔºâÔºö 12345678i=Nv=Vwhile(i&gt;0) if(g[i][v]==0) print "Êú™ÈÄâÁ¨¨iÈ°πÁâ©ÂìÅ" else if(g[i][v]==1) print "ÈÄâ‰∫ÜÁ¨¨iÈ°πÁâ©ÂìÅ" v=v-c[i] Âè¶Â§ñÔºåÈááÁî®ÊñπÁ®ãÁöÑÂâç‰∏ÄÈ°πÊàñÂêé‰∏ÄÈ°π‰πüÂèØ‰ª•Âú®ËæìÂá∫ÊñπÊ°àÁöÑËøáÁ®ã‰∏≠Ê†πÊçÆf[i][v]ÁöÑÂÄºÂÆûÊó∂Âú∞Ê±ÇÂá∫Êù•Ôºå‰πüÂç≥‰∏çÈ°ªÁ∫™ÂΩïgÊï∞ÁªÑÔºåÂ∞Ü‰∏äËø∞‰ª£Á†Å‰∏≠ÁöÑ\(g[i][v]==0\)ÊîπÊàê\(f[i][v]==f[i-1][v]\)Ôºå\(g[i][v]==1\)ÊîπÊàê\(f[i][v]==f[i-1][v-c[i]]+w[i]\)‰πüÂèØ„ÄÇ ËæìÂá∫Â≠óÂÖ∏Â∫èÊúÄÂ∞èÁöÑÊúÄ‰ºòÊñπÊ°à ËøôÈáå‚ÄúÂ≠óÂÖ∏Â∫èÊúÄÂ∞è‚ÄùÁöÑÊÑèÊÄùÊòØ1..NÂè∑Áâ©ÂìÅÁöÑÈÄâÊã©ÊñπÊ°àÊéíÂàóÂá∫Êù•‰ª•ÂêéÂ≠óÂÖ∏Â∫èÊúÄÂ∞è„ÄÇ‰ª•ËæìÂá∫01ËÉåÂåÖÊúÄÂ∞èÂ≠óÂÖ∏Â∫èÁöÑÊñπÊ°à‰∏∫‰æã„ÄÇ ‰∏ÄËà¨ËÄåË®ÄÔºåÊ±Ç‰∏Ä‰∏™Â≠óÂÖ∏Â∫èÊúÄÂ∞èÁöÑÊúÄ‰ºòÊñπÊ°àÔºåÂè™ÈúÄË¶ÅÂú®ËΩ¨ÁßªÊó∂Ê≥®ÊÑèÁ≠ñÁï•„ÄÇÈ¶ñÂÖàÔºåÂ≠êÈóÆÈ¢òÁöÑÂÆö‰πâË¶ÅÁï•Êîπ‰∏Ä‰∫õ„ÄÇÊàë‰ª¨Ê≥®ÊÑèÂà∞ÔºåÂ¶ÇÊûúÂ≠òÂú®‰∏Ä‰∏™ÈÄâ‰∫ÜÁâ©ÂìÅ1ÁöÑÊúÄ‰ºòÊñπÊ°àÔºåÈÇ£‰πàÁ≠îÊ°à‰∏ÄÂÆöÂåÖÂê´Áâ©ÂìÅ1ÔºåÂéüÈóÆÈ¢òËΩ¨Âåñ‰∏∫‰∏Ä‰∏™ËÉåÂåÖÂÆπÈáè‰∏∫v-c[1]ÔºåÁâ©ÂìÅ‰∏∫2..NÁöÑÂ≠êÈóÆÈ¢ò„ÄÇÂèç‰πãÔºåÂ¶ÇÊûúÁ≠îÊ°à‰∏çÂåÖÂê´Áâ©ÂìÅ1ÔºåÂàôËΩ¨ÂåñÊàêËÉåÂåÖÂÆπÈáè‰ªç‰∏∫VÔºåÁâ©ÂìÅ‰∏∫2..NÁöÑÂ≠êÈóÆÈ¢ò„ÄÇ‰∏çÁÆ°Á≠îÊ°àÊÄéÊ†∑ÔºåÂ≠êÈóÆÈ¢òÁöÑÁâ©ÂìÅÈÉΩÊòØ‰ª•i..NËÄåÈùûÂâçÊâÄËø∞ÁöÑ1..iÁöÑÂΩ¢ÂºèÊù•ÂÆö‰πâÁöÑÔºåÊâÄ‰ª•Áä∂ÊÄÅÁöÑÂÆö‰πâÂíåËΩ¨ÁßªÊñπÁ®ãÈÉΩÈúÄË¶ÅÊîπ‰∏Ä‰∏ã„ÄÇ‰ΩÜ‰πüËÆ∏Êõ¥ÁÆÄÊòìÁöÑÊñπÊ≥ïÊòØÂÖàÊääÁâ©ÂìÅÈÄÜÂ∫èÊéíÂàó‰∏Ä‰∏ãÔºå‰ª•‰∏ãÊåâÁâ©ÂìÅÂ∑≤Ë¢´ÈÄÜÂ∫èÊéíÂàóÊù•ÂèôËø∞„ÄÇ Âú®ËøôÁßçÊÉÖÂÜµ‰∏ãÔºåÂèØ‰ª•ÊåâÁÖßÂâçÈù¢ÁªèÂÖ∏ÁöÑÁä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ãÊù•Ê±ÇÂÄºÔºåÂè™ÊòØËæìÂá∫ÊñπÊ°àÁöÑÊó∂ÂÄôË¶ÅÊ≥®ÊÑèÔºö‰ªéNÂà∞1ËæìÂÖ•Êó∂ÔºåÂ¶ÇÊûú\(f[i][v]==f[i-v]\)Âèä\(f[i][v]==f[i-1][f-c[i]]+w[i]\) ÂêåÊó∂ÊàêÁ´ãÔºåÂ∫îËØ•ÊåâÁÖßÂêéËÄÖÔºàÂç≥ÈÄâÊã©‰∫ÜÁâ©ÂìÅiÔºâÊù•ËæìÂá∫ÊñπÊ°à„ÄÇ{ÂèñI‰∏é‰∏çÂèñIÁõ∏ÊØîÔºåÂèñÁöÑËØù‰∏ÄÂÆöÂú®Â≠óÂÖ∏Ââç} Ê±ÇÊñπÊ°àÊÄªÊï∞ ÂØπ‰∫é‰∏Ä‰∏™ÁªôÂÆö‰∫ÜËÉåÂåÖÂÆπÈáè„ÄÅÁâ©ÂìÅË¥πÁî®„ÄÅÁâ©ÂìÅÈó¥Áõ∏‰∫íÂÖ≥Á≥ªÔºàÂàÜÁªÑ„ÄÅ‰æùËµñÁ≠âÔºâÁöÑËÉåÂåÖÈóÆÈ¢òÔºåÈô§‰∫ÜÂÜçÁªôÂÆöÊØè‰∏™Áâ©ÂìÅÁöÑ‰ª∑ÂÄºÂêéÊ±ÇÂèØÂæóÂà∞ÁöÑÊúÄÂ§ß‰ª∑ÂÄºÂ§ñÔºåËøòÂèØ‰ª•ÂæóÂà∞Ë£ÖÊª°ËÉåÂåÖÊàñÂ∞ÜËÉåÂåÖË£ÖËá≥Êüê‰∏ÄÊåáÂÆöÂÆπÈáèÁöÑÊñπÊ°àÊÄªÊï∞„ÄÇ ÂØπ‰∫éËøôÁ±ªÊîπÂèòÈóÆÊ≥ïÁöÑÈóÆÈ¢òÔºå‰∏ÄËà¨Âè™ÈúÄÂ∞ÜÁä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ã‰∏≠ÁöÑmaxÊîπÊàêsumÂç≥ÂèØ„ÄÇ‰æãÂ¶ÇËã•ÊØè‰ª∂Áâ©ÂìÅÂùáÊòØÂÆåÂÖ®ËÉåÂåÖ‰∏≠ÁöÑÁâ©ÂìÅÔºåËΩ¨ÁßªÊñπÁ®ãÂç≥‰∏∫ \(f[i][v]=\sum{f[i-1][v],f[i][v-c[i]]}\) ÂàùÂßãÊù°‰ª∂\(f[0][0]=1\)„ÄÇ ‰∫ãÂÆû‰∏äÔºåËøôÊ†∑ÂÅöÂèØË°åÁöÑÂéüÂõ†Âú®‰∫éÁä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ãÂ∑≤ÁªèËÄÉÂØü‰∫ÜÊâÄÊúâÂèØËÉΩÁöÑËÉåÂåÖÁªÑÊàêÊñπÊ°à„ÄÇ ÊúÄ‰ºòÊñπÊ°àÁöÑÊÄªÊï∞ ËøôÈáåÁöÑÊúÄ‰ºòÊñπÊ°àÊòØÊåáÁâ©ÂìÅÊÄª‰ª∑ÂÄºÊúÄÂ§ßÁöÑÊñπÊ°à„ÄÇ‰ª•01ËÉåÂåÖ‰∏∫‰æã„ÄÇ ÁªìÂêàÊ±ÇÊúÄÂ§ßÊÄª‰ª∑ÂÄºÂíåÊñπÊ°àÊÄªÊï∞‰∏§‰∏™ÈóÆÈ¢òÁöÑÊÄùË∑ØÔºåÊúÄ‰ºòÊñπÊ°àÁöÑÊÄªÊï∞ÂèØ‰ª•ËøôÊ†∑Ê±ÇÔºöf[i][v]ÊÑè‰πâÂêåÂâçËø∞Ôºåg[i][v]Ë°®Á§∫Ëøô‰∏™Â≠êÈóÆÈ¢òÁöÑÊúÄ‰ºòÊñπÊ°àÁöÑÊÄªÊï∞ÔºåÂàôÂú®Ê±Çf[i][v]ÁöÑÂêåÊó∂Ê±Çg[i][v]ÁöÑ‰º™‰ª£Á†ÅÂ¶Ç‰∏ãÔºö 12345678for i=1..N for v=0..V f[i][v]=max&#123;f[i-1][v],f[i-1][v-c[i]]+w[i]&#125; g[i][v]=0 if(f[i][v]==f[i-1][v]) inc(g[i][v],g[i-1][v]) if(f[i][v]==f[i-1][v-c[i]]+w[i]) inc(g[i][v],g[i-1][v-c[i]]) Â¶ÇÊûú‰Ω†ÊòØÁ¨¨‰∏ÄÊ¨°ÁúãÂà∞ËøôÊ†∑ÁöÑÈóÆÈ¢òÔºåËØ∑‰ªîÁªÜ‰Ωì‰ºö‰∏äÈù¢ÁöÑ‰º™‰ª£Á†Å„ÄÇ Ê±ÇÊ¨°‰ºòËß£„ÄÅÁ¨¨K‰ºòËß£ ÂØπ‰∫éÊ±ÇÊ¨°‰ºòËß£„ÄÅÁ¨¨K‰ºòËß£Á±ªÁöÑÈóÆÈ¢òÔºåÂ¶ÇÊûúÁõ∏Â∫îÁöÑÊúÄ‰ºòËß£ÈóÆÈ¢òËÉΩÂÜôÂá∫Áä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ã„ÄÅÁî®Âä®ÊÄÅËßÑÂàíËß£ÂÜ≥ÔºåÈÇ£‰πàÊ±ÇÊ¨°‰ºòËß£ÂæÄÂæÄÂèØ‰ª•Áõ∏ÂêåÁöÑÂ§çÊùÇÂ∫¶Ëß£ÂÜ≥ÔºåÁ¨¨K‰ºòËß£ÂàôÊØîÊ±ÇÊúÄ‰ºòËß£ÁöÑÂ§çÊùÇÂ∫¶‰∏äÂ§ö‰∏Ä‰∏™Á≥ªÊï∞K„ÄÇ ÂÖ∂Âü∫Êú¨ÊÄùÊÉ≥ÊòØÂ∞ÜÊØè‰∏™Áä∂ÊÄÅÈÉΩË°®Á§∫ÊàêÊúâÂ∫èÈòüÂàóÔºåÂ∞ÜÁä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ã‰∏≠ÁöÑmax/minËΩ¨ÂåñÊàêÊúâÂ∫èÈòüÂàóÁöÑÂêàÂπ∂„ÄÇËøôÈáå‰ªçÁÑ∂‰ª•01ËÉåÂåÖ‰∏∫‰æãËÆ≤Ëß£‰∏Ä‰∏ã„ÄÇ È¶ñÂÖàÁúã01ËÉåÂåÖÊ±ÇÊúÄ‰ºòËß£ÁöÑÁä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ãÔºöf[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}„ÄÇÂ¶ÇÊûúË¶ÅÊ±ÇÁ¨¨K‰ºòËß£ÔºåÈÇ£‰πàÁä∂ÊÄÅf[i][v]Â∞±Â∫îËØ•ÊòØ‰∏Ä‰∏™Â§ßÂ∞è‰∏∫KÁöÑÊï∞ÁªÑf[i][v][1..K]„ÄÇÂÖ∂‰∏≠f[i][v][k]Ë°®Á§∫Ââçi‰∏™Áâ©ÂìÅ„ÄÅËÉåÂåÖÂ§ßÂ∞è‰∏∫vÊó∂ÔºåÁ¨¨k‰ºòËß£ÁöÑÂÄº„ÄÇ‚Äúf[i][v]ÊòØ‰∏Ä‰∏™Â§ßÂ∞è‰∏∫KÁöÑÊï∞ÁªÑ‚ÄùËøô‰∏ÄÂè•ÔºåÁÜüÊÇâCËØ≠Ë®ÄÁöÑÂêåÂ≠¶ÂèØËÉΩÊØîËæÉÂ•ΩÁêÜËß£ÔºåÊàñËÄÖ‰πüÂèØ‰ª•ÁÆÄÂçïÂú∞ÁêÜËß£‰∏∫Âú®ÂéüÊù•ÁöÑÊñπÁ®ã‰∏≠Âä†‰∫Ü‰∏ÄÁª¥„ÄÇÊòæÁÑ∂f[i][v][1..K]ËøôK‰∏™Êï∞ÊòØÁî±Â§ßÂà∞Â∞èÊéíÂàóÁöÑÔºåÊâÄ‰ª•Êàë‰ª¨ÊääÂÆÉËÆ§‰∏∫ÊòØ‰∏Ä‰∏™ÊúâÂ∫èÈòüÂàó„ÄÇ ÁÑ∂ÂêéÂéüÊñπÁ®ãÂ∞±ÂèØ‰ª•Ëß£Èáä‰∏∫Ôºöf[i][v]Ëøô‰∏™ÊúâÂ∫èÈòüÂàóÊòØÁî±f[i-1][v]Âíåf[i-1][v-c[i]]+w[i]Ëøô‰∏§‰∏™ÊúâÂ∫èÈòüÂàóÂêàÂπ∂ÂæóÂà∞ÁöÑ„ÄÇÊúâÂ∫èÈòüÂàóf[i-1][v]Âç≥f[i-1][v][1..K]Ôºåf[i-1][v-c[i]]+w[i]ÂàôÁêÜËß£‰∏∫Âú®f[i-1][v-c[i]][1..K]ÁöÑÊØè‰∏™Êï∞‰∏äÂä†‰∏äw[i]ÂêéÂæóÂà∞ÁöÑÊúâÂ∫èÈòüÂàó„ÄÇÂêàÂπ∂Ëøô‰∏§‰∏™ÊúâÂ∫èÈòüÂàóÂπ∂Â∞ÜÁªìÊûúÔºàÁöÑÂâçKÈ°πÔºâÂÇ®Â≠òÂà∞f[i][v][1..K]‰∏≠ÁöÑÂ§çÊùÇÂ∫¶ÊòØO(K)„ÄÇÊúÄÂêéÁöÑÁ≠îÊ°àÊòØf[N][V][K]„ÄÇÊÄªÁöÑÂ§çÊùÇÂ∫¶ÊòØO(NVK)„ÄÇ ‰∏∫‰ªÄ‰πàËøô‰∏™ÊñπÊ≥ïÊ≠£Á°ÆÂë¢ÔºüÂÆûÈôÖ‰∏äÔºå‰∏Ä‰∏™Ê≠£Á°ÆÁöÑÁä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ãÁöÑÊ±ÇËß£ËøáÁ®ãÈÅçÂéÜ‰∫ÜÊâÄÊúâÂèØÁî®ÁöÑÁ≠ñÁï•Ôºå‰πüÂ∞±Ë¶ÜÁõñ‰∫ÜÈóÆÈ¢òÁöÑÊâÄÊúâÊñπÊ°à„ÄÇÂè™‰∏çËøáÁî±‰∫éÊòØÊ±ÇÊúÄ‰ºòËß£ÔºåÊâÄ‰ª•ÂÖ∂ÂÆÉÂú®‰ªª‰Ωï‰∏Ä‰∏™Á≠ñÁï•‰∏äËææ‰∏çÂà∞ÊúÄ‰ºòÁöÑÊñπÊ°àÈÉΩË¢´ÂøΩÁï•‰∫Ü„ÄÇÂ¶ÇÊûúÊääÊØè‰∏™Áä∂ÊÄÅË°®Á§∫Êàê‰∏Ä‰∏™Â§ßÂ∞è‰∏∫KÁöÑÊï∞ÁªÑÔºåÂπ∂Âú®Ëøô‰∏™Êï∞ÁªÑ‰∏≠ÊúâÂ∫èÁöÑ‰øùÂ≠òËØ•Áä∂ÊÄÅÂèØÂèñÂà∞ÁöÑÂâçK‰∏™ÊúÄ‰ºòÂÄº„ÄÇÈÇ£‰πàÔºåÂØπ‰∫é‰ªª‰∏§‰∏™Áä∂ÊÄÅÁöÑmaxËøêÁÆóÁ≠â‰ª∑‰∫é‰∏§‰∏™Áî±Â§ßÂà∞Â∞èÁöÑÊúâÂ∫èÈòüÂàóÁöÑÂêàÂπ∂„ÄÇ Âè¶Â§ñËøòË¶ÅÊ≥®ÊÑèÈ¢òÁõÆÂØπ‰∫é‚ÄúÁ¨¨K‰ºòËß£‚ÄùÁöÑÂÆö‰πâÔºåÂ∞ÜÁ≠ñÁï•‰∏çÂêå‰ΩÜÊùÉÂÄºÁõ∏ÂêåÁöÑ‰∏§‰∏™ÊñπÊ°àÊòØÁúã‰ΩúÂêå‰∏Ä‰∏™Ëß£ËøòÊòØ‰∏çÂêåÁöÑËß£„ÄÇÂ¶ÇÊûúÊòØÂâçËÄÖÔºåÂàôÁª¥Êä§ÊúâÂ∫èÈòüÂàóÊó∂Ë¶Å‰øùËØÅÈòüÂàóÈáåÁöÑÊï∞Ê≤°ÊúâÈáçÂ§çÁöÑ„ÄÇ Â∞èÁªì Êòæ ÁÑ∂ÔºåËøôÈáå‰∏çÂèØËÉΩÁ©∑Â∞ΩËÉåÂåÖÁ±ªÂä®ÊÄÅËßÑÂàíÈóÆÈ¢òÊâÄÊúâÁöÑÈóÆÊ≥ï„ÄÇÁîöËá≥ËøòÂ≠òÂú®‰∏ÄÁ±ªÂ∞ÜËÉåÂåÖÁ±ªÂä®ÊÄÅËßÑÂàíÈóÆÈ¢ò‰∏éÂÖ∂ÂÆÉÈ¢ÜÂüüÔºà‰æãÂ¶ÇÊï∞ËÆ∫„ÄÅÂõæËÆ∫ÔºâÁªìÂêàËµ∑Êù•ÁöÑÈóÆÈ¢òÔºåÂú®ËøôÁØáËÆ∫ËÉåÂåÖÈóÆÈ¢òÁöÑ ‰∏ìÊñá‰∏≠‰πü‰∏ç‰ºöËÆ∫Âèä„ÄÇ‰ΩÜÂè™Ë¶ÅÊ∑±ÂàªÈ¢Ü‰ºöÂâçËø∞ÊâÄÊúâÁ±ªÂà´ÁöÑËÉåÂåÖÈóÆÈ¢òÁöÑÊÄùË∑ØÂíåÁä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ãÔºåÈÅáÂà∞ÂÖ∂ÂÆÉÁöÑÂèòÂΩ¢ÈóÆÊ≥ïÔºåÂè™Ë¶ÅÈ¢òÁõÆÈöæÂ∫¶ËøòÂ±û‰∫éNOIPÔºåÂ∫îËØ•‰πü‰∏çÈöæÊÉ≥Âá∫ÁÆóÊ≥ï„ÄÇËß¶Á±ªÊóÅÈÄö„ÄÅ‰∏æ‰∏ÄÂèç‰∏âÔºåÂ∫îËØ•‰πüÊòØ‰∏Ä‰∏™OIerÂ∫îÊúâÁöÑÂìÅË¥®Âêß„ÄÇ È¶ñÈ°µ P11: ËÉåÂåÖÈóÆÈ¢òÁöÑÊêúÁ¥¢Ëß£Ê≥ï „ÄäËÉåÂåÖÈóÆÈ¢ò‰πùËÆ≤„ÄãÁöÑÊú¨ÊÑèÊòØÂ∞ÜËÉåÂåÖÈóÆÈ¢ò‰Ωú‰∏∫Âä®ÊÄÅËßÑÂàíÈóÆÈ¢ò‰∏≠ÁöÑ‰∏ÄÁ±ªËøõË°åËÆ≤Ëß£„ÄÇ‰ΩÜÈâ¥‰∫éÁöÑÁ°ÆÊúâ‰∏Ä‰∫õËÉåÂåÖÈóÆÈ¢òÂè™ËÉΩÁî®ÊêúÁ¥¢Êù•Ëß£ÔºåÊâÄ‰ª•ËøôÈáå‰πüÂØπÁî®ÊêúÁ¥¢Ëß£ËÉåÂåÖÈóÆÈ¢òÂÅöÁÆÄÂçï‰ªãÁªç„ÄÇÂ§ßÈÉ®ÂàÜ‰ª•01ËÉåÂåÖ‰∏∫‰æãÔºåÂÖ∂ÂÆÉÁöÑÂ∫îËØ•ÂèØ‰ª•Ëß¶Á±ªÊóÅÈÄö„ÄÇ ÁÆÄÂçïÁöÑÊ∑±Êêú ÂØπ‰∫é01ËÉåÂåÖÈóÆÈ¢òÔºåÁÆÄÂçïÁöÑÊ∑±ÊêúÁöÑÂ§çÊùÇÂ∫¶ÊòØO(2N)„ÄÇÂ∞±ÊòØÊûö‰∏æÂá∫ÊâÄÊúâ2NÁßçÂ∞ÜÁâ©ÂìÅÊîæÂÖ•ËÉåÂåÖÁöÑÊñπÊ°àÔºåÁÑ∂ÂêéÊâæÊúÄ‰ºòËß£„ÄÇÂü∫Êú¨Ê°ÜÊû∂Â¶Ç‰∏ãÔºö 12345678procedure SearchPack(i,cur_v,cur_w) if(i&gt;N) if(cur_w&gt;best) best=cur_w return if(cur_v+v[i]&lt;=V) SearchPack(i+1,cur_v+v[i],cur_w+w[i]) SearchPack(i+1,cur_v,cur_w) ÂÖ∂‰∏≠cur_vÂíåcur_wË°®Á§∫ÂΩìÂâçËß£ÁöÑË¥πÁî®ÂíåÊùÉÂÄº„ÄÇ‰∏ªÁ®ãÂ∫è‰∏≠Ë∞ÉÁî®SearchPack(1,0,0)Âç≥ÂèØ„ÄÇ ÊêúÁ¥¢ÁöÑÂâ™Êûù Âü∫Êú¨ÁöÑÂâ™ÊûùÊñπÊ≥ï‰∏çÂ§ñ‰πéÂèØË°åÊÄßÂâ™ÊûùÊàñÊúÄ‰ºòÊÄßÂâ™Êûù„ÄÇ ÂèØË°åÊÄßÂâ™ÊûùÂç≥Âà§Êñ≠ÊåâÁÖßÂΩìÂâçÁöÑÊêúÁ¥¢Ë∑ØÂæÑÊêú‰∏ãÂéªËÉΩÂê¶ÊâæÂà∞‰∏Ä‰∏™ÂèØË°åËß£Ôºå‰æãÂ¶ÇÔºöËã•Â∞ÜÂâ©‰∏ãÊâÄÊúâÁâ©ÂìÅÈÉΩÊîæÂÖ•ËÉåÂåÖ‰ªçÁÑ∂Êó†Ê≥ïÂ∞ÜËÉåÂåÖÂÖÖÊª°ÔºàËÆæÈ¢òÁõÆË¶ÅÊ±ÇÂøÖÈ°ªÂ∞ÜËÉåÂåÖÂÖÖÊª°ÔºâÔºåÂàôÂâ™Êûù„ÄÇ ÊúÄ‰ºòÊÄßÂâ™ÊûùÂç≥Âà§Êñ≠ÊåâÁÖßÂΩìÂâçÁöÑÊêúÁ¥¢Ë∑ØÂæÑÊêú‰∏ãÂéªËÉΩÂê¶ÊâæÂà∞‰∏Ä‰∏™ÊúÄ‰ºòËß£Ôºå‰æãÂ¶ÇÔºöËã•Âä†‰∏äÂâ©‰∏ãÊâÄÊúâÁâ©ÂìÅÁöÑÊùÉÂÄº‰πüÊó†Ê≥ïÂæóÂà∞ÊØîÂΩìÂâçÂæóÂà∞ÁöÑÊúÄ‰ºòËß£Êõ¥‰ºòÁöÑËß£ÔºåÂàôÂâ™Êûù„ÄÇ ÊêúÁ¥¢ÁöÑÈ°∫Â∫è Âú®ÊêúÁ¥¢‰∏≠ÔºåÂèØ‰ª•ËÆ§‰∏∫È°∫Â∫èÈù†ÂâçÁöÑÁâ©ÂìÅ‰ºöË¢´‰ºòÂÖàËÄÉËôë„ÄÇÊâÄ‰ª•Âà©Áî®Ë¥™ÂøÉÁöÑÊÄùÊÉ≥ÔºåÂ∞ÜÊõ¥ÊúâÂèØËÉΩÂá∫Áé∞Âú®ÁªìÊûú‰∏≠ÁöÑÁâ©ÂìÅÁöÑÈ°∫Â∫èÊèêÂâçÔºåÂèØ‰ª•ËæÉÂø´Âú∞ÂæóÂá∫Ë¥™ÂøÉÂú∞ËæÉ‰ºòËß£ÔºåÊõ¥ÊúâÂà©‰∫éÊúÄ‰ºòÊÄßÂâ™Êûù„ÄÇÊâÄ‰ª•ÔºåÂèØ‰ª•ËÄÉËôëÂ∞ÜÊåâÁÖß‚ÄúÊÄß‰ª∑ÊØî‚ÄùÔºàÊùÉÂÄº/Ë¥πÁî®ÔºâÊù•ÊéíÂàóÊêúÁ¥¢È°∫Â∫è„ÄÇ Âè¶‰∏ÄÊñπÈù¢ÔºåËã•Â∞ÜË¥πÁî®ËæÉÂ§ßÁöÑÁâ©ÂìÅÊéíÂàóÂú®ÂâçÈù¢ÔºåÂèØ‰ª•ËæÉÂø´Âú∞Â°´Êª°ËÉåÂåÖÔºåÊúâÂà©‰∫éÂèØË°åÊÄßÂâ™Êûù„ÄÇ ÊúÄÂêé‰∏ÄÁßçÂèØ‰ª•ËÄÉËôëÁöÑÊñπÊ°àÊòØÔºöÂú®ÂºÄÂßãÊêúÁ¥¢ÂâçÂ∞ÜËæìÂÖ•Êñá‰ª∂‰∏≠ÁªôÂÆöÁöÑÁâ©ÂìÅÁöÑÈ°∫Â∫èÈöèÊú∫Êâì‰π±„ÄÇËøôÊ†∑ÂèØ‰ª•ÈÅøÂÖçÂëΩÈ¢ò‰∫∫ÊïÖÊÑèËÆæÁΩÆÁöÑÈô∑Èò±„ÄÇ ‰ª•‰∏ä‰∏âÁßçÂÜ≥ÂÆöÊêúÁ¥¢È°∫Â∫èÁöÑÊñπÊ≥ïÂæàÈöæËØ¥Âì™ÁßçÊõ¥Â•ΩÔºå‰∫ãÂÆû‰∏äÊØèÁßçÊñπÊ≥ïÈÉΩÊúâÈÄÇÁî®ÁöÑÈ¢òÁõÆÂíåÊï∞ÊçÆÔºå‰πüÊúâÂèØËÉΩÂ∞ÜÂÆÉ‰ª¨Âú®ÊüêÁßçÁ®ãÂ∫¶‰∏äÊ∑∑Âêà‰ΩøÁî®„ÄÇ Â≠êÈõÜÂíåÈóÆÈ¢ò Â≠êÈõÜÂíåÈóÆÈ¢òÊòØ‰∏Ä‰∏™NP-CompleteÈóÆÈ¢òÔºå‰∏éÂâçËø∞ÁöÑÔºàÂä†ÊùÉÁöÑÔºâ01ËÉåÂåÖÈóÆÈ¢òÂπ∂‰∏çÁõ∏Âêå„ÄÇÁªôÂÆö‰∏Ä‰∏™Êï¥Êï∞ÁöÑÈõÜÂêàSÂíå‰∏Ä‰∏™Êï¥Êï∞XÔºåÈóÆÊòØÂê¶Â≠òÂú®SÁöÑ‰∏Ä‰∏™Â≠êÈõÜÊª°Ë∂≥ÂÖ∂‰∏≠ÊâÄÊúâÂÖÉÁ¥†ÁöÑÂíå‰∏∫X„ÄÇ Ëøô‰∏™ÈóÆÈ¢òÊúâ‰∏Ä‰∏™Êó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫O(2(N/2))ÁöÑËæÉÈ´òÊïàÁöÑÊêúÁ¥¢ÁÆóÊ≥ïÔºåÂÖ∂‰∏≠NÊòØÈõÜÂêàSÁöÑÂ§ßÂ∞è„ÄÇ Á¨¨‰∏ÄÊ≠•ÊÄùÊÉ≥ÊòØ‰∫åÂàÜ„ÄÇÂ∞ÜÈõÜÂêàSÂàíÂàÜÊàê‰∏§‰∏™Â≠êÈõÜS1ÂíåS2ÔºåÂÆÉ‰ª¨ÁöÑÂ§ßÂ∞èÈÉΩÊòØN/2„ÄÇÂØπ‰∫éS1ÂíåS2ÔºåÂàÜÂà´Êûö‰∏æÂá∫ÂÆÉ‰ª¨ÊâÄÊúâÁöÑ2(N/2)‰∏™Â≠êÈõÜÂíåÔºå‰øùÂ≠òÂà∞ÊüêÁßçÊîØÊåÅÊü•ÊâæÁöÑÊï∞ÊçÆÁªìÊûÑ‰∏≠Ôºå‰æãÂ¶Çhash set„ÄÇ ÁÑ∂ÂêéÂ∞±Ë¶ÅÂ∞Ü‰∏§ÈÉ®ÂàÜÁªìÊûúÂêàÂπ∂ÔºåÂØªÊâæÊòØÂê¶ÊúâÂíå‰∏∫XÁöÑSÁöÑÂ≠êÈõÜ„ÄÇ‰∫ãÂÆû‰∏äÔºåÂØπ‰∫éS1ÁöÑÊüê‰∏™Âíå‰∏∫X1ÁöÑÂ≠êÈõÜÔºåÂè™ÈúÄÂØªÊâæS2ÊòØÂê¶ÊúâÂíå‰∏∫X-X1ÁöÑÂ≠êÈõÜ„ÄÇ ÂÅáËÆæÈááÁî®ÁöÑhash setÊòØÁêÜÊÉ≥ÁöÑÔºåÊØèÊ¨°Êü•ÊâæÂíåÊèíÂÖ•ÈÉΩ‰ªÖËä±Ë¥πO(1)ÁöÑÊó∂Èó¥„ÄÇ‰∏§Ê≠•ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶ÊòæÁÑ∂ÈÉΩÊòØO(2^(N/2))„ÄÇ ÂÆûË∑µ‰∏≠ÔºåÂæÄÂæÄÂèØ‰ª•ÂÖàÂ∞ÜÁ¨¨‰∏ÄÊ≠•ÂæóÂà∞ÁöÑ‰∏§ÁªÑÂ≠êÈõÜÂíåÂàÜÂà´ÊéíÂ∫èÔºåÁÑ∂ÂêéÂÜçÁî®‰∏§‰∏™ÊåáÈíàÊâ´ÊèèÁöÑÊñπÊ≥ïÊü•ÊâæÊòØÂê¶ÊúâÊª°Ë∂≥Ë¶ÅÊ±ÇÁöÑÂ≠êÈõÜÂíå„ÄÇËøôÊ†∑ÁöÑÂÆûÁé∞ÔºåÂú®ÂèØÊé•ÂèóÁöÑÊó∂Èó¥ÂÜÖÂèØ‰ª•Ëß£ÂÜ≥ÁöÑÊúÄÂ§ßËßÑÊ®°Á∫¶‰∏∫N=42„ÄÇ ÊêúÁ¥¢ËøòÊòØDP? Âú®ÁúãÂà∞‰∏ÄÈÅìËÉåÂåÖÈóÆÈ¢òÊó∂ÔºåÂ∫îËØ•Áî®ÊêúÁ¥¢ËøòÊòØÂä®ÊÄÅËßÑÂàíÂë¢Ôºü È¶ñÂÖàÔºåÂèØ‰ª•‰ªéÊï∞ÊçÆËåÉÂõ¥‰∏≠ÂæóÂà∞ÂëΩÈ¢ò‰∫∫ÊÑèÂõæÁöÑÁ∫øÁ¥¢„ÄÇÂ¶ÇÊûú‰∏Ä‰∏™ËÉåÂåÖÈóÆÈ¢òÂèØ‰ª•Áî®DPËß£ÔºåV‰∏ÄÂÆö‰∏çËÉΩÂæàÂ§ßÔºåÂê¶ÂàôO(VN)ÁöÑÁÆóÊ≥ïÊó†Ê≥ïÊâøÂèóÔºåËÄå‰∏ÄËà¨ÁöÑÊêúÁ¥¢Ëß£Ê≥ïÈÉΩ ÊòØ‰ªÖ‰∏éNÊúâÂÖ≥Ôºå‰∏éVÊó†ÂÖ≥ÁöÑ„ÄÇÊâÄ‰ª•ÔºåVÂæàÂ§ßÊó∂Ôºà‰æãÂ¶Ç‰∏äÁôæ‰∏áÔºâÔºåÂëΩÈ¢ò‰∫∫ÁöÑÊÑèÂõæÂ∞±Â∫îËØ•ÊòØËÄÉÂØüÊêúÁ¥¢„ÄÇÂè¶‰∏ÄÊñπÈù¢ÔºåNËæÉÂ§ßÊó∂Ôºà‰æãÂ¶Ç‰∏äÁôæÔºâÔºåÂëΩÈ¢ò‰∫∫ÁöÑÊÑèÂõæÂ∞±ÂæàÊúâÂèØËÉΩÊòØËÄÉ ÂØüÂä®ÊÄÅËßÑÂàí‰∫Ü„ÄÇ Âè¶Â§ñÔºåÂΩìÊÉ≥‰∏çÂá∫ÂêàÈÄÇÁöÑÂä®ÊÄÅËßÑÂàíÁÆóÊ≥ïÊó∂ÔºåÂ∞±Âè™ËÉΩÁî®ÊêúÁ¥¢‰∫Ü„ÄÇ‰æãÂ¶ÇÁúãÂà∞‰∏Ä‰∏™‰ªéÊú™ËßÅËøáÁöÑËÉåÂåÖ‰∏≠Áâ©ÂìÅÁöÑÈôêÂà∂Êù°‰ª∂ÔºåÊó†Ê≥ïÊÉ≥Âá∫DPÁöÑÊñπÁ®ãÔºåÂè™Â•ΩÂÜôÊêúÁ¥¢‰ª•Ë∞ãÊ±Ç‰∏ÄÂÆöÁöÑÂàÜÊï∞‰∫Ü„ÄÇ ÈôÑÔºöUSACO‰∏≠ÁöÑËÉåÂåÖÈóÆÈ¢ò USACOÊòØUSA Computing OlympiadÁöÑÁÆÄÁß∞ÔºåÂÆÉÁªÑÁªá‰∫ÜÂæàÂ§öÈù¢ÂêëÂÖ®ÁêÉÁöÑËÆ°ÁÆóÊú∫Á´ûËµõÊ¥ªÂä®„ÄÇ USACO TrainngÊòØ‰∏Ä‰∏™ÂæàÈÄÇÂêàÂàùÂ≠¶ËÄÖÁöÑÈ¢òÂ∫ìÔºåÊàëËÆ§‰∏∫ÂÆÉÁöÑÁâπËâ≤ÊòØÈ¢òÁõÆË¥®ÈáèÈ´òÔºåÂæ™Â∫èÊ∏êËøõÔºåËøòÈÖçÊúâ‰∏çÈîôÁöÑËØæÊñáÂíåÈ¢òÁõÆÂàÜÊûê„ÄÇÂÖ∂‰∏≠ÂÖ≥‰∫éËÉåÂåÖÈóÆÈ¢òÁöÑÈÇ£ÁØáËØæÊñá (TEXT Knapsack Problems) ‰πüÂÄºÂæó‰∏ÄÁúã„ÄÇ Âè¶Â§ñÔºåUSACO ContestÊòØUSACOÂ∏∏Âπ¥ÁªÑÁªáÁöÑÈù¢ÂêëÂÖ®ÁêÉÁöÑÁ´ûËµõÁ≥ªÂàóÔºåÂú®Ê≠§‰πüÊé®ËçêNOIPÈÄâÊâãÂèÇÂä†„ÄÇ ÊàëÊï¥ÁêÜ‰∫ÜUSACO Training‰∏≠Ê∂âÂèäËÉåÂåÖÈóÆÈ¢òÁöÑÈ¢òÁõÆÔºåÂ∫îËØ•ÂèØ‰ª•‰Ωú‰∏∫‰∏çÈîôÁöÑ‰π†È¢ò„ÄÇÂÖ∂‰∏≠Ê†áÂä†Âè∑ÁöÑÊòØÊàëÊØîËæÉÊé®ËçêÁöÑÔºåÊ†áÂèπÂè∑ÁöÑÊòØÊàëËÆ§‰∏∫ÂØπNOIPÈÄâÊâãÊØîËæÉÊúâÊåëÊàòÊÄßÁöÑ„ÄÇ È¢òÁõÆÂàóË°® Inflate (+) ÔºàÂü∫Êú¨01ËÉåÂåÖÔºâ Stamps (+)(!) ÔºàÂØπÂàùÂ≠¶ËÄÖÊúâ‰∏ÄÂÆöÊåëÊàòÊÄßÔºâ Money Nuggets Subsets Rockers (+) ÔºàÂè¶‰∏ÄÁ±ªÊúâË∂£ÁöÑ‚Äú‰∫åÁª¥‚ÄùËÉåÂåÖÈóÆÈ¢òÔºâ Milk4 (!) ÔºàÂæàÊÄ™ÁöÑËÉåÂåÖÈóÆÈ¢òÈóÆÊ≥ïÔºåËæÉÈöæÁî®Á∫ØDPÊ±ÇËß£Ôºâ È¢òÁõÆÁÆÄËß£ ‰ª•‰∏ãÊñáÂ≠óÊù•Ëá™ÊàëÊâÄÊí∞ÁöÑ„ÄäUSACOÂøÉÂæó„Äã‰∏ÄÊñáÔºåËØ•ÊñáÁöÑÂÆåÊï¥ÁâàÊú¨ÔºåÂåÖÊã¨ÊàëÁöÑÁ®ãÂ∫èÔºåÂèØÂú®DDÁöÑUSACOÂæÅÁ®ã‰∏≠ÊâæÂà∞„ÄÇ Inflate ÊòØÂä†ÊùÉ01 ËÉåÂåÖÈóÆÈ¢òÔºå‰πüÂ∞±ÊòØËØ¥ÔºöÊØèÁßçÁâ©ÂìÅÂè™Êúâ‰∏Ä‰ª∂ÔºåÂè™ÂèØ‰ª•ÈÄâÊã©ÊîæÊàñËÄÖ‰∏çÊîæÔºõËÄå‰∏îÊØèÁßçÁâ©ÂìÅÊúâÂØπÂ∫îÁöÑÊùÉÂÄºÔºåÁõÆÊ†áÊòØ‰ΩøÊÄªÊùÉÂÄºÊúÄÂ§ßÊàñÊúÄÂ∞è„ÄÇÂÆÉÊúÄÊú¥Á¥†ÁöÑÁä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ãÊòØÔºöf[k][i] = max{f[k-1][i] , f[k-1][i-v[k]]+w[k]}„ÄÇf[k][i]Ë°®Á§∫Ââçk ‰ª∂Áâ©ÂìÅËä±Ë¥π‰ª£‰ª∑i ÂèØ‰ª•ÂæóÂà∞ÁöÑÊúÄÂ§ßÊùÉÂÄº„ÄÇv[k]Âíåw[k]ÂàÜÂà´ÊòØÁ¨¨k ‰ª∂Áâ©ÂìÅÁöÑËä±Ë¥πÂíåÊùÉÂÄº„ÄÇÂèØ‰ª•ÁúãÂà∞Ôºåf[k]ÁöÑÊ±ÇËß£ËøáÁ®ãÂ∞±ÊòØ‰ΩøÁî®Á¨¨k ‰ª∂Áâ©ÂìÅÂØπf[k-1]ËøõË°åÊõ¥Êñ∞ÁöÑËøáÁ®ã„ÄÇÈÇ£‰πà‰∫ãÂÆû‰∏äÂ∞±‰∏çÁî®‰ΩøÁî®‰∫åÁª¥Êï∞ÁªÑÔºåÂè™ÈúÄË¶ÅÂÆö‰πâf[i]ÔºåÁÑ∂ÂêéÂØπ‰∫éÊØè‰ª∂Áâ©ÂìÅkÔºåÈ°∫Â∫èÂú∞Ê£ÄÊü•f[i]‰∏éf[i-v[k]]+w[k]ÁöÑÂ§ßÂ∞èÔºåÂ¶ÇÊûúÂêéËÄÖÊõ¥Â§ßÔºåÂ∞±ÂØπÂâçËÄÖËøõË°åÊõ¥Êñ∞„ÄÇËøôÊòØËÉåÂåÖÈóÆÈ¢ò‰∏≠ÂÖ∏ÂûãÁöÑ‰ºòÂåñÊñπÊ≥ï„ÄÇ È¢òÁõÆstamps ‰∏≠ÔºåÊØèÁßçÁâ©ÂìÅÁöÑ‰ΩøÁî®ÈáèÊ≤°ÊúâÁõ¥Êé•ÈôêÂà∂Ôºå‰ΩÜ‰ΩøÁî®Áâ©ÂìÅÁöÑÊÄªÈáèÊúâÈôêÂà∂„ÄÇÊ±ÇÁ¨¨‰∏Ä‰∏™‰∏çËÉΩÁî®ËøôÊúâÈôê‰∏™Áâ©ÂìÅÁªÑÊàêÁöÑËÉåÂåÖÁöÑÂ§ßÂ∞è„ÄÇÔºàÂèØ‰ª•ËøôÊ†∑Á≠â‰ª∑Âú∞ËÆ§‰∏∫ÔºâËÆæf[k][i] Ë°®Á§∫Ââçk ‰ª∂Áâ©ÂìÅÁªÑÊàêÂ§ßÂ∞è‰∏∫i ÁöÑËÉåÂåÖÔºå ÊúÄÂ∞ëÈúÄË¶ÅÁâ©ÂìÅÁöÑÊï∞Èáè„ÄÇÂàôf[k][i]= min{f[k-1][i],f[k-1][i-j*s[k]]+j}ÔºåÂÖ∂‰∏≠j ÊòØÈÄâÊã©‰ΩøÁî®Á¨¨k ‰ª∂Áâ©ÂìÅÁöÑÊï∞ÁõÆÔºåËøô‰∏™ÊñπÁ®ãËøêÁî®Êó∂ÂèØ‰ª•Áî®Âíå‰∏äÈù¢‰∏ÄÊ†∑ÁöÑÊñπÊ≥ïÂ§ÑÁêÜÊàê‰∏ÄÁª¥ÁöÑ„ÄÇÊ±ÇËß£Êó∂ÂÖàËÆæÁΩÆ‰∏Ä‰∏™Á≤óÁ≥ôÁöÑÂæ™ÁéØ‰∏äÈôêÔºåÂç≥ÊúÄÂ§ßÁöÑÁâ©ÂìÅ‰πòÊúÄÂ§öÁâ©ÂìÅÊï∞„ÄÇ Money ÊòØÂ§öÈáçËÉåÂåÖÈóÆÈ¢ò„ÄÇ‰πüÂ∞±ÊòØÊØè‰∏™Áâ©ÂìÅÂèØ‰ª•‰ΩøÁî®Êó†ÈôêÂ§öÊ¨°„ÄÇË¶ÅÊ±ÇËß£ÁöÑÊòØÊûÑÊàê‰∏ÄÁßçËÉåÂåÖÁöÑ‰∏çÂêåÊñπÊ°àÊÄªÊï∞„ÄÇÂü∫Êú¨‰∏äÂ∞±ÊòØÊää‰∏ÄËà¨ÁöÑÂ§öÈáçËÉåÂåÖÁöÑÊñπÁ®ã‰∏≠ÁöÑmin ÊîπÊàêsum Â∞±Ë°å‰∫Ü„ÄÇ Nuggets ÁöÑÊ®°Âûã‰πüÊòØÂ§öÈáçËÉåÂåÖ„ÄÇË¶ÅÊ±ÇÊ±ÇËß£ÊâÄÁªôÁöÑÁâ©ÂìÅ‰∏çËÉΩÊÅ∞Â•ΩÊîæÂÖ•ÁöÑËÉåÂåÖÂ§ßÂ∞èÁöÑÊúÄÂ§ßÂÄºÔºàÂèØËÉΩ‰∏çÂ≠òÂú®Ôºâ„ÄÇÂè™ÈúÄË¶ÅÊ†πÊçÆ‚ÄúËã•i„ÄÅj ‰∫íË¥®ÔºåÂàôÂÖ≥‰∫éx„ÄÅy ÁöÑ‰∏çÂÆöÊñπÁ®ãix+yj=n ÂøÖÊúâÊ≠£Êï¥Êï∞Ëß£ÔºåÂÖ∂‰∏≠n&gt;ij‚ÄùËøô‰∏ÄÂÆöÁêÜÂæóÂá∫‰∏Ä‰∏™Âæ™ÁéØÁöÑ‰∏äÈôê„ÄÇSubsets Â≠êÈõÜÂíåÈóÆÈ¢òÁõ∏ÂΩì‰∫éÁâ©ÂìÅÂ§ßÂ∞èÊòØÂâçN ‰∏™Ëá™ÁÑ∂Êï∞Êó∂Ê±ÇÂ§ßÂ∞è‰∏∫N(N+1)/4 ÁöÑ 01 ËÉåÂåÖÁöÑÊñπÊ°àÊï∞„ÄÇ Rockers ÂèØ‰ª•Âà©Áî®Ê±ÇËß£ËÉåÂåÖÈóÆÈ¢òÁöÑÊÄùÊÉ≥ËÆæËÆ°Ëß£Ê≥ï„ÄÇÊàëÁöÑÁä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ãÂ¶Ç‰∏ãÔºö f[i][j][t]=max{f[i][j][t-1] , f[i-1][j][t] , f[i-1][j][t-time[i]]+1 , f[i-1][j-1][T]+(t&gt;=time[i])}„ÄÇÂÖ∂‰∏≠ f[i][j][t]Ë°®Á§∫Ââçi È¶ñÊ≠åÁî®j Âº†ÂÆåÊï¥ÁöÑÁõòÂíå‰∏ÄÂº†ÂΩï‰∫Üt ÂàÜÈíüÁöÑÁõòÂèØ‰ª•ÊîæÂÖ•ÁöÑÊúÄÂ§öÊ≠åÊï∞ÔºåT ÊòØ‰∏ÄÂº†ÂÖâÁõòÁöÑÊúÄÂ§ßÂÆπÈáèÔºåt&gt;=time[i]ÊòØ‰∏Ä‰∏™bool ÂÄºËΩ¨Êç¢Êàêint ÂèñÂÄº‰∏∫0 Êàñ1„ÄÇ‰ΩÜÊàëÂêéÊù•ÂèëÁé∞ÊàëÂΩìÊó∂ËÆæËÆ°ÁöÑÁä∂ÊÄÅÂíåÊñπÁ®ãÊïàÁéáÊúâÁÇπ‰ΩéÔºåÂ¶ÇÊûúÊç¢ÊàêËøôÊ†∑Ôºöf[i][j]=(a,b)Ë°®Á§∫Ââçi È¶ñÊ≠å‰∏≠ÈÄâ‰∫Üj È¶ñÈúÄË¶ÅÁî®Âà∞a Âº†ÂÆåÊï¥ÁöÑÂÖâÁõò‰ª•Âèä‰∏ÄÂº†ÂΩï‰∫Üb ÂàÜÈíüÁöÑÂÖâÁõòÔºå‰ºöÂ∞ÜÊó∂Á©∫Â§çÊùÇÂ∫¶ÈÉΩÂ§ßÂ§ßÈôç‰Ωé„ÄÇËøôÁßçÂ∞ÜÁä∂ÊÄÅÁöÑÂÄºËÆæ‰∏∫‰∫åÁª¥ÁöÑÊñπÊ≥ïÂÄºÂæóÊ≥®ÊÑè„ÄÇ Milk4 ÊòØËøô‰∫õÁ±ªËÉåÂåÖÈóÆÈ¢ò‰∏≠ÈöæÂ∫¶ÊúÄÂ§ßÁöÑ‰∏ÄÈÅì‰∫Ü„ÄÇÂæàÂ§ö‰∫∫Êó†Ê≥ïÂÅöÂà∞Â∞ÜÂÆÉÁî®Á∫ØDP ÊñπÊ≥ïÊ±ÇËß£ÔºåËÄåÊòØÁî®Ëø≠‰ª£Âä†Ê∑±ÊêúÁ¥¢Êûö‰∏æ‰ΩøÁî®ÁöÑÊ°∂ÔºåÂ∞ÜÂÖ∂ËΩ¨Êç¢ÊàêÂ§öÈáçËÉåÂåÖÈóÆÈ¢òÂÜçDP„ÄÇÁî±‰∫é USACO ÁöÑÊï∞ÊçÆÂº±ÔºåËø≠‰ª£Âä†Ê∑±ÁöÑÊ∑±Â∫¶ÂæàÂ∞èÔºåËøôÊ†∑‰πüÂèØ‰ª•ACÔºå‰ΩÜÊàë‰ª¨ËøòÊòØÂèØ‰ª•Áî®Á∫ØDP ÊñπÊ≥ïÂ∞ÜÂÆÉÂÆåÁæéËß£ÂÜ≥ÁöÑ„ÄÇËÆæf[k]‰∏∫Áß∞ÈáèÂá∫k Âçï‰ΩçÁâõÂ•∂ÈúÄË¶ÅÁöÑÊúÄÂ∞ëÁöÑÊ°∂Êï∞„ÄÇÈÇ£‰πàÂèØ‰ª•Áî®Á±ª‰ººÂ§öÈáçËÉåÂåÖÁöÑÊñπÊ≥ïÂØπf Êï∞ÁªÑÂèçÂ§çÊõ¥Êñ∞‰ª•Ê±ÇÂæóÊúÄÂ∞èÂÄº„ÄÇÁÑ∂ËÄåÂõ∞ÈöæÂú®‰∫éÂ¶Ç‰ΩïËæìÂá∫Â≠óÂÖ∏Â∫èÊúÄÂ∞èÁöÑÊñπÊ°à„ÄÇÊàë‰ª¨ÂèØ‰ª•ÂØπÊØè‰∏™iËÆ∞ÂΩïpre_f[i]Âíåpre_v[i]„ÄÇË°®Á§∫ÂæóÂà∞i Âçï‰ΩçÁâõÂ•∂ÁöÑËøáÁ®ãÊòØÁî®pre_f[i]Âçï‰ΩçÁâõÂ•∂Âä†‰∏äËã•Âπ≤‰∏™ÁºñÂè∑‰∏∫pre_v[i]ÁöÑÊ°∂ÁöÑÁâõÂ•∂„ÄÇËøôÊ†∑Â∞±ÂèØ‰ª•‰∏ÄÊ≠•Ê≠•Ê±ÇÂæóÂæóÂà∞i Âçï‰ΩçÁâõÂ•∂ÁöÑÂÆåÊï¥ÊñπÊ°à„ÄÇ‰∏∫‰∫Ü‰ΩøÊñπÊ°àÁöÑÂ≠óÂÖ∏Â∫èÊúÄÂ∞èÔºåÊàë‰ª¨Âú®ÊØèÊ¨°ÊâæÂà∞‰∏Ä‰∏™ËÄóË¥πÊ°∂Êï∞Áõ∏ÂêåÁöÑÊñπÊ°àÊó∂ÂØπÂ∑≤ÂÇ®Â≠òÁöÑÊñπÊ°àÂíåÊñ∞ÊñπÊ°àËøõË°åÊØîËæÉÂÜçÂÜ≥ÂÆöÊòØÂê¶Êõ¥Êñ∞ÊñπÊ°à„ÄÇ‰∏∫‰∫Ü‰ΩøËøôÁßçÊØîËæÉÂø´Êç∑ÔºåÂú®‰ΩøÁî®ÂêÑÁßçÂ§ßÂ∞èÁöÑÊ°∂ÂØπf Êï∞ÁªÑËøõË°åÊõ¥Êñ∞Êó∂ÂÖàÂ§ßÂêéÂ∞èÂú∞ËøõË°å„ÄÇUSACO ÁöÑÂÆòÊñπÈ¢òËß£Ê≠£ÊòØËøô‰∏ÄÊÄùË∑Ø„ÄÇÂ¶ÇÊûúËÆ§‰∏∫‰ª•‰∏äÊñáÂ≠óÊØîËæÉÈöæÁêÜËß£ÂèØ‰ª•ÈòÖËØªÂÆòÊñπÁ®ãÂ∫èÊàñÊàëÁöÑÁ®ãÂ∫è„ÄÇ 26 ËÉåÂåÖÈóÆÈ¢òÂ∫îÁî® Category: Êï∞ÊçÆÁªìÊûÑ‰∏éÁÆóÊ≥ï View: 6,055 ÈòÖ Author: Dong ‰ΩúËÄÖ:Dong | ÂèØ‰ª•ËΩ¨ËΩΩ, ‰ΩÜÂøÖÈ°ª‰ª•Ë∂ÖÈìæÊé•ÂΩ¢ÂºèÊ†áÊòéÊñáÁ´†ÂéüÂßãÂá∫Â§ÑÂíå‰ΩúËÄÖ‰ø°ÊÅØÂèäÁâàÊùÉÂ£∞Êòé ÁΩëÂùÄ:http://dongxicheng.org/structure/knapsack-problems/ ËÉåÂåÖÈóÆÈ¢ò‰ªãÁªç ËÉåÂåÖÈóÆÈ¢ò‰∏çÂçïÂçïÊòØ‰∏Ä‰∏™ÁÆÄÂçïÁöÑÁÆóÊ≥ïÈóÆÈ¢òÔºåÂÆÉÊú¨Ë¥®‰∏ä‰ª£Ë°®‰∫Ü‰∏ÄÂ§ßÁ±ªÈóÆÈ¢òÔºåËøôÁ±ªÈóÆÈ¢òÂÆûÈôÖ‰∏äÊòØ01Á∫øÊÄßËßÑÂàíÈóÆÈ¢òÔºåÂÖ∂Á∫¶ÊùüÊù°‰ª∂ÂíåÁõÆÊ†áÂáΩÊï∞Â¶Ç‰∏ãÔºö Ëá™‰ªédd_engiÂú®2007Âπ¥Êé®Âá∫„ÄäËÉåÂåÖÈóÆÈ¢ò‰πùËÆ≤„Äã‰πãÂêéÔºåËÉåÂåÖÈóÆÈ¢òÁöÑ‰∏ªË¶ÅÁ≤æÈ´ìÂü∫Êú¨Â∑≤ÈÅìÂ∞Ω„ÄÇÊú¨ÊñáÊ≤°ÊúâÂ∞ùËØïÂØπËÉåÂåÖÈóÆÈ¢òÁöÑÊú¨Ë¥®ËøõË°åÊâ©Â±ïÊàñÊ∑±ÂÖ•ÊåñÊéòÔºåËÄåÂè™ÊòØ‰ªéÊúâÈôêÁöÑÁêÜËß£ÔºàËøôÈáåÊåáÂØπ„ÄäËÉåÂåÖÈóÆÈ¢ò‰πùËÆ≤„ÄãÁöÑÁêÜËß£ÔºâÂá∫ÂèëÔºåÂ∏ÆÂä©ËØªËÄÖÊõ¥Âø´Âú∞Â≠¶‰π†„ÄäËÉåÂåÖÈóÆÈ¢ò‰πùËÆ≤„Äã‰∏≠ÁöÑÊèêÂà∞ÁöÑÂêÑÁßçËÉåÂåÖÈóÆÈ¢òÁöÑ‰∏ªË¶ÅÁÆóÊ≥ïÊÄùÊÉ≥ÔºåÂπ∂ÈÄöËøáÂÆû‰æãËß£Èáä‰∫ÜÁõ∏Â∫îÁöÑÁÆóÊ≥ïÔºåÂêåÊó∂ÁªôÂá∫‰∫ÜÂá†‰∏™ËÉåÂåÖÈóÆÈ¢òÁöÑÁªèÂÖ∏Â∫îÁî®„ÄÇ ËÉåÂåÖÈóÆÈ¢òÂèäÂ∫îÁî® dd_engiÂú®„ÄäËÉåÂåÖÈóÆÈ¢ò‰πùËÆ≤„Äã‰∏≠‰∏ªË¶ÅÊèêÂà∞ÂõõÁßçËÉåÂåÖÈóÆÈ¢òÔºåÂàÜÂà´‰∏∫Ôºö01ËÉåÂåÖÈóÆÈ¢òÔºåÂÆåÂÖ®ËÉåÂåÖÈóÆÈ¢òÔºåÂ§öÈáçËÉåÂåÖÈóÆÈ¢òÔºå‰∫åÁª¥Ë¥πÁî®ËÉåÂåÖÈóÆÈ¢ò„ÄÇÊú¨ËäÇÊÄªÁªì‰∫ÜËøôÂá†ÁßçËÉåÂåÖÈóÆÈ¢òÔºåÂπ∂ÁªôÂá∫‰∫ÜÂÖ∂ÂÖ∏ÂûãÁöÑÂ∫îÁî®‰ª•Â∏ÆÂä©ËØªËÄÖÁêÜËß£ËøôÂá†ÁßçÈóÆÈ¢òÁöÑÊú¨Ë¥®„ÄÇ 2.1 01ËÉåÂåÖÈóÆÈ¢ò Ôºà1ÔºâÈóÆÈ¢òÊèèËø∞ ÊúâN‰ª∂Áâ©ÂìÅÂíå‰∏Ä‰∏™ÂÆπÈáè‰∏∫VÁöÑËÉåÂåÖ„ÄÇÁ¨¨i‰ª∂Áâ©ÂìÅÁöÑË¥πÁî®ÊòØc[i]Ôºå‰ª∑ÂÄºÊòØw[i]„ÄÇÊ±ÇËß£Â∞ÜÂì™‰∫õÁâ©ÂìÅË£ÖÂÖ•ËÉåÂåÖÂèØ‰Ωø‰ª∑ÂÄºÊÄªÂíåÊúÄÂ§ß„ÄÇ Ôºà2ÔºâÁä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ã ÂÖ∂‰∏≠Ôºåf(i,v) Ë°®Á§∫‰ªéÂâçi‰ª∂Áâ©ÂìÅÈÄâÊã©Ëã•Âπ≤Áâ©ÂìÅË£ÖÂà∞ÂÆπÈáè‰∏∫vÁöÑËÉåÂåÖ‰∏≠‰∫ßÁîüÁöÑÊúÄÂ§ß‰ª∑ÂÄº„ÄÇÂΩìv=0Êó∂Ôºåf(i,v)ÂàùÂßãÂåñ‰∏∫0ÔºåË°®Á§∫È¢òÁõÆ‰∏çË¶ÅÊ±ÇËÉåÂåÖ‰∏ÄÂÆöÂàöÂ•ΩË£ÖÊª°ÔºåËÄåf(i,v)=inf/-infÔºàÊ≠£Êó†Á©∑ÊàñË¥üÊó†Á©∑ÔºâË°®Á§∫È¢òÁõÆË¶ÅÊ±ÇËÉåÂåÖ‰∏ÄÂÆöË¶ÅÂàöÂ•ΩË£ÖÊª°„ÄÇ‰∏ãÈù¢Âá†ÁßçËÉåÂåÖÁ±ª‰ººÔºå‰ª•Âêé‰∏çÂÜçËµòËø∞„ÄÇ Ôºà3Ôºâ ‰º™‰ª£Á†Å ‰ªéËΩ¨ÁßªÊñπÁ®ã‰∏äÂèØ‰ª•ÁúãÂá∫ÔºåÂâçi‰∏™Áâ©ÂìÅÁöÑÊúÄ‰ºòËß£Âè™‰æùËµñ‰∫éÂâçi-1‰∏™Áâ©ÂìÅÊúÄ‰ºòËß£ÔºåËÄå‰∏éÂâçi-2Ôºåi-3,‚Ä¶ÂêÑÁâ©ÂìÅÊúÄ‰ºòÊó†Áõ¥Êé•ÂÖ≥Á≥ªÔºåÂèØ‰ª•Âà©Áî®Ëøô‰∏™ÁâπÁÇπ‰ºòÂåñÂ≠òÂÇ®Á©∫Èó¥ÔºåÂç≥Âè™Áî≥ËØ∑‰∏Ä‰∏™‰∏ÄÁª¥Êï∞ÁªÑÂç≥ÂèØÔºåÁÆóÊ≥ïÊó∂Èó¥Â§çÊùÇÂ∫¶ÔºàO(VN)Ôºâ‰∏∫: 123for i=1..N for v=V..0 f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; Ê≥®ÊÑèvÁöÑÈÅçÂéÜÈ°∫Â∫èÔºÅÔºÅÔºÅ ‰∏ãÈù¢Âá†ÁßçËÉåÂåÖÁî®Âà∞Á±ª‰ºº‰ºòÂåñÔºå‰ª•Âêé‰∏çÂÜçËµòËø∞„ÄÇ Ôºà4Ôºâ ‰∏æ‰æã V=10ÔºåN=3Ôºåc[]={3,4,5}, w={4,5,6} Ôºà1ÔºâËÉåÂåÖ‰∏ç‰∏ÄÂÆöË£ÖÊª° ËÆ°ÁÆóÈ°∫Â∫èÊòØÔºö‰ªéÂè≥ÂæÄÂ∑¶ÔºåËá™‰∏äËÄå‰∏ãÔºö Ôºà2ÔºâËÉåÂåÖÂàöÂ•ΩË£ÖÊª° ËÆ°ÁÆóÈ°∫Â∫èÊòØÔºö‰ªéÂè≥ÂæÄÂ∑¶ÔºåËá™‰∏äËÄå‰∏ã„ÄÇÊ≥®ÊÑèÂàùÂßãÂÄºÔºåÂÖ∂‰∏≠-infË°®Á§∫Ë¥üÊó†Á©∑ Ôºà5Ôºâ ÁªèÂÖ∏È¢òÂûã [1] ‰Ω†Êúâ‰∏ÄÂ†ÜÁü≥Â§¥Ë¥®ÈáèÂàÜÂà´‰∏∫W1,W2,W3‚Ä¶WN.(WÔºúÔºù100000,N &lt;30)Áé∞Âú®ÈúÄË¶Å‰Ω†Â∞ÜÁü≥Â§¥ÂêàÂπ∂‰∏∫‰∏§Â†ÜÔºå‰Ωø‰∏§Â†ÜË¥®ÈáèÁöÑÂ∑Æ‰∏∫ÊúÄÂ∞è„ÄÇ [2] Áªô‰∏Ä‰∏™Êï¥Êï∞ÁöÑÈõÜÂêàÔºåË¶ÅÊääÂÆÉÂàÜÊàê‰∏§‰∏™ÈõÜÂêàÔºåË¶Å‰∏§‰∏™ÈõÜÂêàÁöÑÊï∞ÁöÑÂíåÊúÄÊé•Ëøë [3] Êúâ‰∏Ä‰∏™ÁÆ±Â≠êÂÆπÈáè‰∏∫VÔºàÊ≠£Êï¥Êï∞Ôºå0‚â§V‚â§20000ÔºâÔºåÂêåÊó∂Êúân‰∏™Áâ©ÂìÅÔºà0Â∞è‰∫én‚â§30ÔºâÔºåÊØè‰∏™Áâ©ÂìÅÊúâ‰∏Ä‰∏™‰ΩìÁßØÔºàÊ≠£Êï¥Êï∞Ôºâ„ÄÇË¶ÅÊ±Ç‰ªén‰∏™Áâ©ÂìÅ‰∏≠Ôºå‰ªªÂèñËã•Âπ≤‰∏™Ë£ÖÂÖ•ÁÆ±ÂÜÖÔºå‰ΩøÁÆ±Â≠êÁöÑÂâ©‰ΩôÁ©∫Èó¥‰∏∫ÊúÄÂ∞è„ÄÇ 2.2 ÂÆåÂÖ®ËÉåÂåÖÈóÆÈ¢ò Ôºà1ÔºâÈóÆÈ¢òÊèèËø∞ ÊúâNÁßçÁâ©ÂìÅÂíå‰∏Ä‰∏™ÂÆπÈáè‰∏∫VÁöÑËÉåÂåÖÔºåÊØèÁßçÁâ©ÂìÅÈÉΩÊúâÊó†Èôê‰ª∂ÂèØÁî®„ÄÇÁ¨¨iÁßçÁâ©ÂìÅÁöÑË¥πÁî®ÊòØc[i]Ôºå‰ª∑ÂÄºÊòØw[i]„ÄÇÊ±ÇËß£Â∞ÜÂì™‰∫õÁâ©ÂìÅË£ÖÂÖ•ËÉåÂåÖÂèØ‰ΩøËøô‰∫õÁâ©ÂìÅÁöÑË¥πÁî®ÊÄªÂíå‰∏çË∂ÖËøáËÉåÂåÖÂÆπÈáèÔºå‰∏î‰ª∑ÂÄºÊÄªÂíåÊúÄÂ§ß„ÄÇ Ôºà2ÔºâÁä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ã ÊàñËÄÖÔºö Ôºà3Ôºâ ‰º™‰ª£Á†Å 123for i=1..N for v=0..V f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; Ê≥®ÊÑèvÁöÑÈÅçÂéÜÈ°∫Â∫èÔºÅÔºÅÔºÅ Ê≥®ÊÑèÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶‰ªç‰∏∫ÔºöO(VN). Ôºà4Ôºâ ‰∏æ‰æã V=10ÔºåN=3Ôºåc[]={3,4,5}, w={4,5,6} Ôºà1ÔºâËÉåÂåÖ‰∏ç‰∏ÄÂÆöË£ÖÊª° ËÆ°ÁÆóÈ°∫Â∫èÊòØÔºö‰ªéÂ∑¶ÂæÄÂè≥ÔºåËá™‰∏äËÄå‰∏ãÔºö Ôºà2ÔºâËÉåÂåÖÂàöÂ•ΩË£ÖÊª° ËÆ°ÁÆóÈ°∫Â∫èÊòØÔºö‰ªéÂ∑¶ÂæÄÂè≥ÔºåËá™‰∏äËÄå‰∏ã„ÄÇÊ≥®ÊÑèÂàùÂßãÂÄºÔºåÂÖ∂‰∏≠-infË°®Á§∫Ë¥üÊó†Á©∑ Ôºà5Ôºâ ÁªèÂÖ∏È¢òÂûã [1] ÊâæÈõ∂Èí±ÈóÆÈ¢òÔºöÊúânÁßçÈù¢È¢ùÁöÑÁ°¨Â∏ÅÔºåÊØèÁßçÁ°¨Â∏ÅÊó†ÈôêÂ§öÔºåËá≥Â∞ëÁî®Â§öÂ∞ëÊûöÁ°¨Â∏ÅË°®Á§∫ÁªôÂÆöÁöÑÈù¢ÂÄºMÔºü 2.3 Â§öÈáçËÉåÂåÖÈóÆÈ¢ò Ôºà1ÔºâÈóÆÈ¢òÊèèËø∞ ÊúâNÁßçÁâ©ÂìÅÂíå‰∏Ä‰∏™ÂÆπÈáè‰∏∫VÁöÑËÉåÂåÖ„ÄÇÁ¨¨iÁßçÁâ©ÂìÅÊúÄÂ§öÊúân[i]‰ª∂ÂèØÁî®ÔºåÊØè‰ª∂Ë¥πÁî®ÊòØc[i]Ôºå‰ª∑ÂÄºÊòØw[i]„ÄÇÊ±ÇËß£Â∞ÜÂì™‰∫õÁâ©ÂìÅË£ÖÂÖ•ËÉåÂåÖÂèØ‰ΩøËøô‰∫õÁâ©ÂìÅÁöÑË¥πÁî®ÊÄªÂíå‰∏çË∂ÖËøáËÉåÂåÖÂÆπÈáèÔºå‰∏î‰ª∑ÂÄºÊÄªÂíåÊúÄÂ§ß„ÄÇ Ôºà2ÔºâÁä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ã Ôºà3Ôºâ Ëß£È¢òÊÄùÊÉ≥ Áî®‰ª•‰∏ãÊñπÊ≥ïËΩ¨Âåñ‰∏∫ÊôÆÈÄö01ËÉåÂåÖÈóÆÈ¢òÔºöÂ∞ÜÁ¨¨iÁßçÁâ©ÂìÅÂàÜÊàêËã•Âπ≤‰ª∂Áâ©ÂìÅÔºåÂÖ∂‰∏≠ÊØè‰ª∂Áâ©ÂìÅÊúâ‰∏Ä‰∏™Á≥ªÊï∞ÔºåËøô‰ª∂Áâ©ÂìÅÁöÑË¥πÁî®Âíå‰ª∑ÂÄºÂùáÊòØÂéüÊù•ÁöÑË¥πÁî®Âíå‰ª∑ÂÄº‰πò‰ª•Ëøô‰∏™Á≥ªÊï∞„ÄÇ‰ΩøËøô‰∫õÁ≥ªÊï∞ÂàÜÂà´‰∏∫ 1,2,4,‚Ä¶,2(k-1),n[i]-2k+1Ôºå‰∏îkÊòØÊª°Ë∂≥n[i]-2^k+1&gt;0ÁöÑÊúÄÂ§ßÊï¥Êï∞„ÄÇ‰æãÂ¶ÇÔºåÂ¶ÇÊûún[i]‰∏∫13ÔºåÂ∞±Â∞ÜËøôÁßç Áâ©ÂìÅÂàÜÊàêÁ≥ªÊï∞ÂàÜÂà´‰∏∫1,2,4,6ÁöÑÂõõ‰ª∂Áâ©ÂìÅ„ÄÇËøôÁßçÊñπÊ≥ïËÉΩ‰øùËØÅÂØπ‰∫é0..n[i]Èó¥ÁöÑÊØè‰∏Ä‰∏™Êï¥Êï∞ÔºåÂùáÂèØ‰ª•Áî®Ëã•Âπ≤‰∏™Á≥ªÊï∞ÁöÑÂíåË°®Á§∫„ÄÇËøô‰∏™ÂæàÂÆπÊòìËØÅÊòéÔºåËØÅÊòéËøáÁ®ã‰∏≠Áî®Âà∞‰ª•‰∏ãÂÆöÁêÜÔºö‰ªª‰Ωï‰∏Ä‰∏™Êï¥Êï∞nÂùáÂèØ‰ª•Ë°®Á§∫ÊàêÔºön=a020+a121+‚Ä¶+ak2k,ÂÖ∂‰∏≠ak=0ÊàñËÄÖ1(ÂÆûÈôÖ‰∏äÂ∞±ÊòØnÁöÑ‰∫åËøõÂà∂ÂàÜËß£)Ôºå ÂÆöÁêÜÔºö‰∏Ä‰∏™Ê≠£Êï¥Êï∞nÂèØ‰ª•Ë¢´ÂàÜËß£Êàê1,2,4,‚Ä¶,2(k-1),n-2k+1ÔºàkÊòØÊª°Ë∂≥n-2k+1&gt;0ÁöÑÊúÄÂ§ßÊï¥Êï∞ÔºâÁöÑÂΩ¢ÂºèÔºå‰∏î1ÔΩûn‰πãÂÜÖÁöÑÊâÄÊúâÊï¥Êï∞ÂùáÂèØ‰ª•ÂîØ‰∏ÄË°®Á§∫Êàê1,2,4,‚Ä¶,2(k-1),n-2k+1‰∏≠ÊüêÂá†‰∏™Êï∞ÁöÑÂíåÁöÑÂΩ¢Âºè„ÄÇ ËØ•ÂÆöÁêÜÁöÑËØÅÊòéÂ¶Ç‰∏ãÔºö Ôºà1Ôºâ Êï∞Âàó1,2,4,‚Ä¶,2(k-1),n-2k+1‰∏≠ÊâÄÊúâÂÖÉÁ¥†ÁöÑÂíå‰∏∫nÔºåÊâÄ‰ª•Ëã•Âπ≤ÂÖÉÁ¥†ÁöÑÂíåÁöÑËåÉÂõ¥‰∏∫Ôºö[1, n]Ôºõ Ôºà2ÔºâÂ¶ÇÊûúÊ≠£Êï¥Êï∞t&lt;= 2^k ‚Äì 1,Âàôt‰∏ÄÂÆöËÉΩÁî®1,2,4,‚Ä¶,2^(k-1)‰∏≠ÊüêÂá†‰∏™Êï∞ÁöÑÂíåË°®Á§∫ÔºåËøô‰∏™ÂæàÂÆπÊòìËØÅÊòéÔºöÊàë‰ª¨ÊäätÁöÑ‰∫åËøõÂà∂Ë°®Á§∫ÂÜôÂá∫Êù•ÔºåÂæàÊòéÊòæÔºåtÂèØ‰ª•Ë°®Á§∫Êàên=a020+a121+‚Ä¶+ak2Ôºàk-1ÔºâÔºåÂÖ∂‰∏≠ak=0ÊàñËÄÖ1ÔºåË°®Á§∫tÁöÑÁ¨¨ak‰Ωç‰∫åËøõÂà∂Êï∞‰∏∫0ÊàñËÄÖ1. Ôºà3ÔºâÂ¶ÇÊûút&gt;=2k,ËÆæs=n-2k+1ÔºåÂàôt-s&lt;=2k-1ÔºåÂõ†ËÄåt-sÂèØ‰ª•Ë°®Á§∫Êàê1,2,4,‚Ä¶,2(k-1)‰∏≠ÊüêÂá†‰∏™Êï∞ÁöÑÂíåÁöÑÂΩ¢ÂºèÔºåËøõËÄåtÂèØ‰ª•Ë°®Á§∫Êàê1,2,4,‚Ä¶,2(k-1)Ôºås‰∏≠ÊüêÂá†‰∏™Êï∞ÁöÑÂíåÔºàÂä†Êï∞‰∏≠‰∏ÄÂÆöÂê´ÊúâsÔºâÁöÑÂΩ¢Âºè„ÄÇ ÔºàËØÅÊØïÔºÅÔºâ ËØ•ÁÆóÊ≥ïÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ÔºöO(V*sum(logn[i])). Ôºà4Ôºâ ÁªèÂÖ∏È¢òÂûã [1] ÊâæÈõ∂Èí±ÈóÆÈ¢òÔºöÊúânÁßçÈù¢È¢ùÁöÑÁ°¨Â∏ÅÔºåÂàÜÂà´‰∏∫a[0], a[1],‚Ä¶, a[n-1]ÔºåÊØèÁßçÁ°¨Â∏ÅÁöÑ‰∏™Êï∞‰∏∫b[0], b[1],‚Ä¶, b[n-1]ÔºåËá≥Â∞ëÁî®Â§öÂ∞ëÊûöÁ°¨Â∏ÅË°®Á§∫ÁªôÂÆöÁöÑÈù¢ÂÄºMÔºü 2.4 ‰∫åÁª¥Ë¥πÁî®ËÉåÂåÖ Ôºà1Ôºâ ÈóÆÈ¢òÊèèËø∞ ‰∫åÁª¥Ë¥πÁî®ÁöÑËÉåÂåÖÈóÆÈ¢òÊòØÊåáÔºöÂØπ‰∫éÊØè‰ª∂Áâ©ÂìÅÔºåÂÖ∑Êúâ‰∏§Áßç‰∏çÂêåÁöÑË¥πÁî®ÔºõÈÄâÊã©Ëøô‰ª∂Áâ©ÂìÅÂøÖÈ°ªÂêåÊó∂‰ªòÂá∫Ëøô‰∏§Áßç‰ª£‰ª∑ÔºõÂØπ‰∫éÊØèÁßç‰ª£‰ª∑ÈÉΩÊúâ‰∏Ä‰∏™ÂèØ‰ªòÂá∫ÁöÑÊúÄÂ§ßÂÄºÔºàËÉåÂåÖÂÆπÈáèÔºâ„ÄÇÈóÆ ÊÄéÊ†∑ÈÄâÊã©Áâ©ÂìÅÂèØ‰ª•ÂæóÂà∞ÊúÄÂ§ßÁöÑ‰ª∑ÂÄº„ÄÇËÆæËøô‰∏§Áßç‰ª£‰ª∑ÂàÜÂà´‰∏∫‰ª£‰ª∑1Âíå‰ª£‰ª∑2ÔºåÁ¨¨i‰ª∂Áâ©ÂìÅÊâÄÈúÄÁöÑ‰∏§Áßç‰ª£‰ª∑ÂàÜÂà´‰∏∫a[i]Âíåb[i]„ÄÇ‰∏§Áßç‰ª£‰ª∑ÂèØ‰ªòÂá∫ÁöÑÊúÄÂ§ßÂÄºÔºà‰∏§Áßç ËÉåÂåÖÂÆπÈáèÔºâÂàÜÂà´‰∏∫VÂíåU„ÄÇÁâ©ÂìÅÁöÑ‰ª∑ÂÄº‰∏∫w[i]„ÄÇ Ôºà2Ôºâ Áä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ã Ôºà3Ôºâ ÁÆóÊ≥ïÊÄùÊÉ≥ ÈááÁî®Âêå‰∏ÄÁª¥ÊÉÖÂÜµÁ±ª‰ººÁöÑÊñπÊ≥ïÊ±ÇËß£ Ôºà4Ôºâ ÁªèÂÖ∏È¢òÂûã Êúâ2n‰∏™Êï¥Êï∞ÔºåÂπ≥ÂùáÂàÜÊàê‰∏§ÁªÑÔºåÊØèÁªÑn‰∏™Êï∞Ôºå‰ΩøËøô‰∏§ÁªÑÊï∞ÁöÑÂíåÊúÄÊé•Ëøë„ÄÇ 3. ËÉåÂåÖÊÄªÁªì ËÉåÂåÖÈóÆÈ¢òÂÆûÈôÖ‰∏ä‰ª£Ë°®ÁöÑÊòØÁ∫øÊÄßËßÑÂàíÈóÆÈ¢òÔºå‰∏ÄËà¨Ë¶ÅËÄÉËôë‰ª•‰∏ãÂá†‰∏™Âõ†Á¥†Â∑≤ÂÜ≥ÂÆöÈÄâÂèñ‰ªÄ‰πàÊ†∑ÁöÑÁÆóÊ≥ïÔºö Ôºà1Ôºâ Á∫¶ÊùüÊù°‰ª∂ÔºåÊúâ‰∏Ä‰∏™ËøòÊòØ‰∏§‰∏™ÊàñËÄÖÊõ¥Â§ö‰∏™ÔºåÂ¶ÇÊûúÊòØ‰∏Ä‰∏™ÔºåÂèØËÉΩÊòØ01ËÉåÂåÖÔºåÂÆåÂÖ®ËÉåÂåÖÊàñËÄÖÂ§öÈáçËÉåÂåÖÈóÆÈ¢òÔºåÂ¶ÇÊûúÊúâ‰∏§‰∏™Á∫¶ÊùüÊù°‰ª∂ÔºåÂàôÂèØËÉΩÊòØ‰∫åÁª¥ËÉåÂåÖÈóÆÈ¢ò„ÄÇ Ôºà2Ôºâ ‰ºòÂåñÁõÆÊ†áÔºåÊ±ÇÊúÄÂ§ßÂÄºÔºåËøòÊòØÊúÄÂ∞èÂÄºÔºåËøòÊòØÊÄªÊï∞(Âè™ÈúÄÂ∞ÜmaxÊç¢Êàêsum) Ôºà3Ôºâ ÊØèÁßçÁâ©ÂìÅÁöÑ‰∏™Êï∞ÈôêÂà∂ÔºåÂ¶ÇÊûúÊØèÁßçÁâ©ÂìÅÂè™Êúâ‰∏Ä‰∏™ÔºåÂè™ÊòØÁÆÄÂçïÁöÑ01ËÉåÂåÖÈóÆÈ¢òÔºåÂ¶ÇÊûú‰∏™Êï∞Êó†ÈôêÂà∂ÔºåÂàôÊòØÂÆåÂÖ®ËÉåÂåÖÈóÆÈ¢òÔºåÂ¶ÇÊûúÊØèÁßçÁâ©ÂìÅÁöÑ‰∏™Êï∞ÊúâÈôêÂà∂ÔºåÂàôÊòØÂ§öÈáçËÉåÂåÖÈóÆÈ¢ò„ÄÇ Ôºà4Ôºâ ËÉåÂåÖÊòØÂê¶Ë¶ÅÊ±ÇÂàöÂ•ΩÂ°ûÊª°ÔºåÊ≥®ÊÑè‰∏çÂ°ûÊª°ÂíåÂ°ûÊª°‰∏§ÁßçÊÉÖÂÜµ‰∏ãÂàùÂßãÂÄº‰∏çÂêå„ÄÇ 4. ÂèÇËÄÉËµÑÊñô dd_engiÔºö„ÄäËÉåÂåÖÈóÆÈ¢ò‰πùËÆ≤„Äã]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>ËÉåÂåÖ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂçöÂºàÂü∫Á°ÄÊ±áÊÄª]]></title>
    <url>%2F2017%2F05%2F28%2F%E5%8D%9A%E5%BC%88%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[Êúâ‰∏ÄÁßçÂæàÊúâÊÑèÊÄùÁöÑÊ∏∏ÊàèÔºåÂ∞±ÊòØÊúâÁâ©‰ΩìËã•Âπ≤Â†ÜÔºåÂèØ‰ª•ÊòØÁÅ´Êü¥Ê£çÊàñÊòØÂõ¥Ê£ãÂ≠êÁ≠âÁ≠âÂùáÂèØ„ÄÇ‰∏§‰∏™‰∫∫ËΩÆÊµÅ‰ªéÂ†Ü‰∏≠ÂèñÁâ©‰ΩìËã•Âπ≤ÔºåËßÑÂÆöÊúÄÂêéÂèñÂÖâÁâ©‰ΩìËÄÖÂèñËÉú„ÄÇËøôÊòØÊàëÂõΩÊ∞ëÈó¥ÂæàÂè§ËÄÅÁöÑ‰∏Ä‰∏™Ê∏∏ÊàèÔºåÂà´ÁúãËøôÊ∏∏ÊàèÊûÅÂÖ∂ÁÆÄÂçïÔºåÂç¥Ëï¥Âê´ÁùÄÊ∑±ÂàªÁöÑÊï∞Â≠¶ÂéüÁêÜ„ÄÇ‰∏ãÈù¢Êàë‰ª¨Êù•ÂàÜÊûê‰∏Ä‰∏ãË¶ÅÂ¶Ç‰ΩïÊâçËÉΩÂ§üÂèñËÉú„ÄÇ Ôºà‰∏ÄÔºâÂ∑¥‰ªÄÂçöÂ•ïÔºàBash GameÔºâÔºö Âè™Êúâ‰∏ÄÂ†Ün‰∏™Áâ©ÂìÅÔºå‰∏§‰∏™‰∫∫ËΩÆÊµÅ‰ªéËøôÂ†ÜÁâ©ÂìÅ‰∏≠ÂèñÁâ©ÔºåËßÑÂÆöÊØèÊ¨°Ëá≥Â∞ëÂèñ‰∏Ä‰∏™ÔºåÊúÄÂ§öÂèñm‰∏™„ÄÇÊúÄÂêéÂèñÂÖâËÄÖÂæóËÉú„ÄÇ ÊòæÁÑ∂ÔºåÂ¶ÇÊûún=m+1ÔºåÈÇ£‰πàÁî±‰∫é‰∏ÄÊ¨°ÊúÄÂ§öÂè™ËÉΩÂèñm‰∏™ÔºåÊâÄ‰ª•ÔºåÊó†ËÆ∫ÂÖàÂèñËÄÖÊãøËµ∞Â§öÂ∞ë‰∏™ÔºåÂêéÂèñËÄÖÈÉΩËÉΩÂ§ü‰∏ÄÊ¨°ÊãøËµ∞Ââ©‰ΩôÁöÑÁâ©ÂìÅÔºåÂêéËÄÖÂèñËÉú„ÄÇÂõ†Ê≠§Êàë‰ª¨ÂèëÁé∞‰∫ÜÂ¶Ç‰ΩïÂèñËÉúÁöÑÊ≥ïÂàôÔºöÂ¶ÇÊûún=Ôºàm+1Ôºâr+sÔºåÔºàr‰∏∫‰ªªÊÑèËá™ÁÑ∂Êï∞Ôºås‚â§m),ÈÇ£‰πàÂÖàÂèñËÄÖË¶ÅÊãøËµ∞s‰∏™Áâ©ÂìÅÔºåÂ¶ÇÊûúÂêéÂèñËÄÖÊãøËµ∞kÔºà‚â§m)‰∏™ÔºåÈÇ£‰πàÂÖàÂèñËÄÖÂÜçÊãøËµ∞m+1-k‰∏™ÔºåÁªìÊûúÂâ©‰∏ãÔºàm+1ÔºâÔºàr-1Ôºâ‰∏™Ôºå‰ª•Âêé‰øùÊåÅËøôÊ†∑ÁöÑÂèñÊ≥ïÔºåÈÇ£‰πàÂÖàÂèñËÄÖËÇØÂÆöËé∑ËÉú„ÄÇÊÄª‰πãÔºåË¶Å‰øùÊåÅÁªôÂØπÊâãÁïô‰∏ãÔºàm+1ÔºâÁöÑÂÄçÊï∞ÔºåÂ∞±ËÉΩÊúÄÂêéËé∑ËÉú„ÄÇËøô‰∏™Ê∏∏ÊàèËøòÂèØ‰ª•Êúâ‰∏ÄÁßçÂèòÁõ∏ÁöÑÁé©Ê≥ïÔºö‰∏§‰∏™‰∫∫ËΩÆÊµÅÊä•Êï∞ÔºåÊØèÊ¨°Ëá≥Â∞ëÊä•‰∏Ä‰∏™ÔºåÊúÄÂ§öÊä•ÂçÅ‰∏™ÔºåË∞ÅËÉΩÊä•Âà∞100ËÄÖËÉú„ÄÇ Ôºà‰∫åÔºâÂ®Å‰ΩêÂ§´ÂçöÂ•ïÔºàWythoff GameÔºâÔºö Êúâ‰∏§Â†ÜÂêÑËã•Âπ≤‰∏™Áâ©ÂìÅÔºå‰∏§‰∏™‰∫∫ËΩÆÊµÅ‰ªéÊüê‰∏ÄÂ†ÜÊàñÂêåÊó∂‰ªé‰∏§Â†Ü‰∏≠ÂèñÂêåÊ†∑Â§öÁöÑÁâ©ÂìÅÔºåËßÑÂÆöÊØèÊ¨°Ëá≥Â∞ëÂèñ‰∏Ä‰∏™ÔºåÂ§öËÄÖ‰∏çÈôêÔºåÊúÄÂêéÂèñÂÖâËÄÖÂæóËÉú„ÄÇ ËøôÁßçÊÉÖÂÜµ‰∏ãÊòØÈ¢á‰∏∫Â§çÊùÇÁöÑ„ÄÇÊàë‰ª¨Áî®ÔºàakÔºåbkÔºâÔºàak ‚â§ bk ,k=0Ôºå1Ôºå2Ôºå‚Ä¶,n)Ë°®Á§∫‰∏§Â†ÜÁâ©ÂìÅÁöÑÊï∞ÈáèÂπ∂Áß∞ÂÖ∂‰∏∫Â±ÄÂäøÔºåÂ¶ÇÊûúÁî≤Èù¢ÂØπÔºà0Ôºå0ÔºâÔºåÈÇ£‰πàÁî≤Â∑≤ÁªèËæì‰∫ÜÔºåËøôÁßçÂ±ÄÂäøÊàë‰ª¨Áß∞‰∏∫Â•áÂºÇÂ±ÄÂäø„ÄÇÂâçÂá†‰∏™Â•áÂºÇÂ±ÄÂäøÊòØÔºöÔºà0Ôºå0Ôºâ„ÄÅÔºà1Ôºå2Ôºâ„ÄÅÔºà3Ôºå5Ôºâ„ÄÅÔºà4Ôºå7Ôºâ„ÄÅÔºà6Ôºå10Ôºâ„ÄÅÔºà8Ôºå13Ôºâ„ÄÅÔºà9Ôºå15Ôºâ„ÄÅÔºà11Ôºå18Ôºâ„ÄÅÔºà12Ôºå20Ôºâ„ÄÇ ÂèØ‰ª•ÁúãÂá∫,a0=b0=0,akÊòØÊú™Âú®ÂâçÈù¢Âá∫Áé∞ËøáÁöÑÊúÄÂ∞èËá™ÁÑ∂Êï∞,ËÄå bk= ak + kÔºåÂ•áÂºÇÂ±ÄÂäøÊúâÂ¶Ç‰∏ã‰∏âÊù°ÊÄßË¥®Ôºö 1„ÄÇ‰ªª‰ΩïËá™ÁÑ∂Êï∞ÈÉΩÂåÖÂê´Âú®‰∏Ä‰∏™‰∏î‰ªÖÊúâ‰∏Ä‰∏™Â•áÂºÇÂ±ÄÂäø‰∏≠„ÄÇ Áî±‰∫éakÊòØÊú™Âú®ÂâçÈù¢Âá∫Áé∞ËøáÁöÑÊúÄÂ∞èËá™ÁÑ∂Êï∞ÔºåÊâÄ‰ª•Êúâak &gt; ak-1 ÔºåËÄå bk= ak + k &gt; ak -1 + k-1 = bk-1 &gt; ak-1 „ÄÇÊâÄ‰ª•ÊÄßË¥®1„ÄÇÊàêÁ´ã„ÄÇ &gt; 2„ÄÇ‰ªªÊÑèÊìç‰ΩúÈÉΩÂèØÂ∞ÜÂ•áÂºÇÂ±ÄÂäøÂèò‰∏∫ÈùûÂ•áÂºÇÂ±ÄÂäø„ÄÇ &gt; ‰∫ãÂÆû‰∏äÔºåËã•Âè™ÊîπÂèòÂ•áÂºÇÂ±ÄÂäøÔºàakÔºåbkÔºâÁöÑÊüê‰∏Ä‰∏™ÂàÜÈáèÔºåÈÇ£‰πàÂè¶‰∏Ä‰∏™ÂàÜÈáè‰∏çÂèØËÉΩÂú®ÂÖ∂‰ªñÂ•áÂºÇÂ±ÄÂäø‰∏≠ÔºåÊâÄ‰ª•ÂøÖÁÑ∂ÊòØÈùûÂ•áÂºÇÂ±ÄÂäø„ÄÇÂ¶ÇÊûú‰ΩøÔºàakÔºåbkÔºâÁöÑ‰∏§‰∏™ÂàÜÈáèÂêåÊó∂ÂáèÂ∞ëÔºåÂàôÁî±‰∫éÂÖ∂Â∑Æ‰∏çÂèòÔºå‰∏î‰∏çÂèØËÉΩÊòØÂÖ∂‰ªñÂ•áÂºÇÂ±ÄÂäøÁöÑÂ∑ÆÔºåÂõ†Ê≠§‰πüÊòØÈùûÂ•áÂºÇÂ±ÄÂäø„ÄÇ &gt; 3„ÄÇÈááÁî®ÈÄÇÂΩìÁöÑÊñπÊ≥ïÔºåÂèØ‰ª•Â∞ÜÈùûÂ•áÂºÇÂ±ÄÂäøÂèò‰∏∫Â•áÂºÇÂ±ÄÂäø„ÄÇ &gt; ÂÅáËÆæÈù¢ÂØπÁöÑÂ±ÄÂäøÊòØÔºàa,bÔºâÔºåËã• b = aÔºåÂàôÂêåÊó∂‰ªé‰∏§Â†Ü‰∏≠ÂèñËµ∞ a ‰∏™Áâ©‰ΩìÔºåÂ∞±Âèò‰∏∫‰∫ÜÂ•áÂºÇÂ±ÄÂäøÔºà0Ôºå0ÔºâÔºõÂ¶ÇÊûúa = ak Ôºåb &gt; bkÔºåÈÇ£‰πàÔºåÂèñËµ∞b ‚Äì bk‰∏™Áâ©‰ΩìÔºåÂç≥Âèò‰∏∫Â•áÂºÇÂ±ÄÂäøÔºõÂ¶ÇÊûú a = ak Ôºå b &lt; bk ,ÂàôÂêåÊó∂‰ªé‰∏§Â†Ü‰∏≠ÊãøËµ∞ ak ‚Äì ab + ak‰∏™Áâ©‰Ωì,Âèò‰∏∫Â•áÂºÇÂ±ÄÂäøÔºà ab ‚Äì ak , ab ‚Äì ak+ b ‚Äì akÔºâÔºõÂ¶ÇÊûúa &gt; ak Ôºåb= ak + k,Âàô‰ªéÁ¨¨‰∏ÄÂ†Ü‰∏≠ÊãøËµ∞Â§ö‰ΩôÁöÑÊï∞Èáèa ‚Äì ak Âç≥ÂèØÔºõÂ¶ÇÊûúa &lt; ak Ôºåb= ak + k,ÂàÜ‰∏§ÁßçÊÉÖÂÜµÔºåÁ¨¨‰∏ÄÁßçÔºåa=aj Ôºàj &lt; kÔºâ,‰ªéÁ¨¨‰∫åÂ†ÜÈáåÈù¢ÊãøËµ∞ b ‚Äì bj Âç≥ÂèØÔºõÁ¨¨‰∫åÁßçÔºåa=bj Ôºàj &lt; kÔºâ,‰ªéÁ¨¨‰∫åÂ†ÜÈáåÈù¢ÊãøËµ∞ b ‚Äì aj Âç≥ÂèØ„ÄÇ &gt; ‰ªéÂ¶Ç‰∏äÊÄßË¥®ÂèØÁü•Ôºå‰∏§‰∏™‰∫∫Â¶ÇÊûúÈÉΩÈááÁî®Ê≠£Á°ÆÊìç‰ΩúÔºåÈÇ£‰πàÈù¢ÂØπÈùûÂ•áÂºÇÂ±ÄÂäøÔºåÂÖàÊãøËÄÖÂøÖËÉúÔºõÂèç‰πãÔºåÂàôÂêéÊãøËÄÖÂèñËÉú„ÄÇ &gt; ÈÇ£‰πà‰ªªÁªô‰∏Ä‰∏™Â±ÄÂäøÔºàaÔºåbÔºâÔºåÊÄéÊ†∑Âà§Êñ≠ÂÆÉÊòØ‰∏çÊòØÂ•áÂºÇÂ±ÄÂäøÂë¢ÔºüÊàë‰ª¨ÊúâÂ¶Ç‰∏ãÂÖ¨ÂºèÔºö &gt; ak =[kÔºà1+‚àö5Ôºâ/2]Ôºåbk= ak + k Ôºàk=0Ôºå1Ôºå2Ôºå‚Ä¶,n ÊñπÊã¨Âè∑Ë°®Á§∫ÂèñÊï¥ÂáΩÊï∞) Â•áÂ¶ôÁöÑÊòØÂÖ∂‰∏≠Âá∫Áé∞‰∫ÜÈªÑÈáëÂàÜÂâ≤Êï∞Ôºà1+‚àö5Ôºâ/2 = 1„ÄÇ618‚Ä¶,Âõ†Ê≠§,Áî±akÔºåbkÁªÑÊàêÁöÑÁü©ÂΩ¢Ëøë‰ºº‰∏∫ÈªÑÈáëÁü©ÂΩ¢ÔºåÁî±‰∫é2/Ôºà1+‚àö5Ôºâ=Ôºà‚àö5-1Ôºâ/2ÔºåÂèØ‰ª•ÂÖàÊ±ÇÂá∫j=[aÔºà‚àö5-1Ôºâ/2]ÔºåËã•a=[jÔºà1+‚àö5Ôºâ/2]ÔºåÈÇ£‰πàa = ajÔºåbj = aj + jÔºåËã•‰∏çÁ≠â‰∫éÔºåÈÇ£‰πàa = aj+1Ôºåbj+1 = aj+1+ j + 1ÔºåËã•ÈÉΩ‰∏çÊòØÔºåÈÇ£‰πàÂ∞±‰∏çÊòØÂ•áÂºÇÂ±ÄÂäø„ÄÇÁÑ∂ÂêéÂÜçÊåâÁÖß‰∏äËø∞Ê≥ïÂàôËøõË°åÔºå‰∏ÄÂÆö‰ºöÈÅáÂà∞Â•áÂºÇÂ±ÄÂäø„ÄÇ Ôºà‰∏âÔºâÂ∞ºÂßÜÂçöÂ•ïÔºàNimm GameÔºâÔºö Êúâ‰∏âÂ†ÜÂêÑËã•Âπ≤‰∏™Áâ©ÂìÅÔºå‰∏§‰∏™‰∫∫ËΩÆÊµÅ‰ªéÊüê‰∏ÄÂ†ÜÂèñ‰ªªÊÑèÂ§öÁöÑÁâ©ÂìÅÔºåËßÑÂÆöÊØèÊ¨°Ëá≥Â∞ëÂèñ‰∏Ä‰∏™ÔºåÂ§öËÄÖ‰∏çÈôêÔºåÊúÄÂêéÂèñÂÖâËÄÖÂæóËÉú„ÄÇ ËøôÁßçÊÉÖÂÜµÊúÄÊúâÊÑèÊÄùÔºåÂÆÉ‰∏é‰∫åËøõÂà∂ÊúâÂØÜÂàáÂÖ≥Á≥ªÔºåÊàë‰ª¨Áî®ÔºàaÔºåbÔºåcÔºâË°®Á§∫ÊüêÁßçÂ±ÄÂäøÔºåÈ¶ñÂÖàÔºà0Ôºå0Ôºå0ÔºâÊòæÁÑ∂ÊòØÂ•áÂºÇÂ±ÄÂäøÔºåÊó†ËÆ∫Ë∞ÅÈù¢ÂØπÂ•áÂºÇÂ±ÄÂäøÔºåÈÉΩÂøÖÁÑ∂Â§±Ë¥•„ÄÇÁ¨¨‰∫åÁßçÂ•áÂºÇÂ±ÄÂäøÊòØÔºà0ÔºånÔºånÔºâÔºåÂè™Ë¶Å‰∏éÂØπÊâãÊãøËµ∞‰∏ÄÊ†∑Â§öÁöÑÁâ©ÂìÅÔºåÊúÄÂêéÈÉΩÂ∞ÜÂØºËá¥Ôºà0Ôºå0Ôºå0Ôºâ„ÄÇ‰ªîÁªÜÂàÜÊûê‰∏Ä‰∏ãÔºåÔºà1Ôºå2Ôºå3Ôºâ‰πüÊòØÂ•áÂºÇÂ±ÄÂäøÔºåÊó†ËÆ∫ÂØπÊâãÂ¶Ç‰ΩïÊãøÔºåÊé•‰∏ãÊù•ÈÉΩÂèØ‰ª•Âèò‰∏∫Ôºà0ÔºånÔºånÔºâÁöÑÊÉÖÂΩ¢„ÄÇ ËÆ°ÁÆóÊú∫ÁÆóÊ≥ïÈáåÈù¢Êúâ‰∏ÄÁßçÂè´ÂÅöÊåâ‰ΩçÊ®°2Âä†Ôºå‰πüÂè´ÂÅöÂºÇÊàñÁöÑËøêÁÆóÔºåÊàë‰ª¨Áî®Á¨¶Âè∑Ôºà+ÔºâË°®Á§∫ËøôÁßçËøêÁÆó„ÄÇËøôÁßçËøêÁÆóÂíå‰∏ÄËà¨Âä†Ê≥ï‰∏çÂêåÁöÑ‰∏ÄÁÇπÊòØ1+1=0„ÄÇÂÖàÁúãÔºà1Ôºå2Ôºå3ÔºâÁöÑÊåâ‰ΩçÊ®°2Âä†ÁöÑÁªìÊûúÔºö 1 =‰∫åËøõÂà∂01 2 =‰∫åËøõÂà∂10 3 =‰∫åËøõÂà∂11 Ôºà+Ôºâ ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî 0 =‰∫åËøõÂà∂00 ÔºàÊ≥®ÊÑè‰∏çËøõ‰ΩçÔºâ ÂØπ‰∫éÂ•áÂºÇÂ±ÄÂäøÔºà0ÔºånÔºånÔºâ‰πü‰∏ÄÊ†∑ÔºåÁªìÊûú‰πüÊòØ0„ÄÇ ‰ªª‰ΩïÂ•áÂºÇÂ±ÄÂäøÔºàaÔºåbÔºåcÔºâÈÉΩÊúâaÔºà+ÔºâbÔºà+Ôºâc =0„ÄÇ Â¶ÇÊûúÊàë‰ª¨Èù¢ÂØπÁöÑÊòØ‰∏Ä‰∏™ÈùûÂ•áÂºÇÂ±ÄÂäøÔºàaÔºåbÔºåcÔºâÔºåË¶ÅÂ¶Ç‰ΩïÂèò‰∏∫Â•áÂºÇÂ±ÄÂäøÂë¢ÔºüÂÅáËÆæ a &lt; b&lt; c,Êàë‰ª¨Âè™Ë¶ÅÂ∞Ü c Âèò‰∏∫ aÔºà+Ôºâb,Âç≥ÂèØ,Âõ†‰∏∫ÊúâÂ¶Ç‰∏ãÁöÑËøêÁÆóÁªìÊûú: aÔºà+ÔºâbÔºà+Ôºâ(aÔºà+Ôºâb)=(aÔºà+Ôºâa)Ôºà+Ôºâ(bÔºà+Ôºâb)=0Ôºà+Ôºâ0=0„ÄÇË¶ÅÂ∞Üc Âèò‰∏∫aÔºà+ÔºâbÔºåÂè™Ë¶Å‰ªé c‰∏≠ÂáèÂéª c-Ôºà aÔºà+ÔºâbÔºâÂç≥ÂèØ„ÄÇ ‰æã1„ÄÇÔºà14Ôºå21Ôºå39ÔºâÔºå14Ôºà+Ôºâ21=27Ôºå39-27=12ÔºåÊâÄ‰ª•‰ªé39‰∏≠ÊãøËµ∞12‰∏™Áâ©‰ΩìÂç≥ÂèØËææÂà∞Â•áÂºÇÂ±ÄÂäøÔºà14Ôºå21Ôºå27Ôºâ„ÄÇ ‰æã2„ÄÇÔºà55Ôºå81Ôºå121ÔºâÔºå55Ôºà+Ôºâ81=102Ôºå121-102=19ÔºåÊâÄ‰ª•‰ªé121‰∏≠ÊãøËµ∞19‰∏™Áâ©ÂìÅÂ∞±ÂΩ¢Êàê‰∫ÜÂ•áÂºÇÂ±ÄÂäøÔºà55Ôºå81Ôºå102Ôºâ„ÄÇ ‰æã3„ÄÇÔºà29Ôºå45Ôºå58ÔºâÔºå29Ôºà+Ôºâ45=48Ôºå58-48=10Ôºå‰ªé58‰∏≠ÊãøËµ∞10‰∏™ÔºåÂèò‰∏∫Ôºà29Ôºå45Ôºå48Ôºâ„ÄÇ ‰æã4„ÄÇÊàë‰ª¨Êù•ÂÆûÈôÖËøõË°å‰∏ÄÁõòÊØîËµõÁúãÁúãÔºö Áî≤:(7,8,9)-&gt;(1,8,9)Â•áÂºÇÂ±ÄÂäø ‰πô:(1,8,9)-&gt;(1,8,4) Áî≤:(1,8,4)-&gt;(1,5,4)Â•áÂºÇÂ±ÄÂäø ‰πô:(1,5,4)-&gt;(1,4,4) Áî≤:(1,4,4)-&gt;(0,4,4)Â•áÂºÇÂ±ÄÂäø ‰πô:(0,4,4)-&gt;(0,4,2) Áî≤:(0.4,2)-&gt;(0,2,2)Â•áÂºÇÂ±ÄÂäø ‰πô:(0,2,2)-&gt;(0,2,1) Áî≤:(0,2,1)-&gt;(0,1,1)Â•áÂºÇÂ±ÄÂäø ‰πô:(0,1,1)-&gt;(0,1,0) Áî≤:(0,1,0)-&gt;(0,0,0)Â•áÂºÇÂ±ÄÂäø Áî≤ËÉú„ÄÇ ÂèñÁÅ´Êü¥ÁöÑÊ∏∏Êàè È¢òÁõÆ1Ôºö ‰ªäÊúâËã•Âπ≤Â†ÜÁÅ´Êü¥Ôºå‰∏§‰∫∫‰æùÊ¨°‰ªé‰∏≠ÊãøÂèñÔºåËßÑÂÆöÊØèÊ¨°Âè™ËÉΩ‰ªé‰∏ÄÂ†Ü‰∏≠ÂèñËã•Âπ≤Ê†πÔºå ÂèØÂ∞Ü‰∏ÄÂ†ÜÂÖ®ÂèñËµ∞Ôºå‰ΩÜ‰∏çÂèØ‰∏çÂèñÔºåÊúÄÂêéÂèñÂÆåËÄÖ‰∏∫ËÉúÔºåÊ±ÇÂøÖËÉúÁöÑÊñπÊ≥ï„ÄÇ È¢òÁõÆ2Ôºö ‰ªäÊúâËã•Âπ≤Â†ÜÁÅ´Êü¥Ôºå‰∏§‰∫∫‰æùÊ¨°‰ªé‰∏≠ÊãøÂèñÔºåËßÑÂÆöÊØèÊ¨°Âè™ËÉΩ‰ªé‰∏ÄÂ†Ü‰∏≠ÂèñËã•Âπ≤Ê†πÔºå ÂèØÂ∞Ü‰∏ÄÂ†ÜÂÖ®ÂèñËµ∞Ôºå‰ΩÜ‰∏çÂèØ‰∏çÂèñÔºåÊúÄÂêéÂèñÂÆåËÄÖ‰∏∫Ë¥üÔºåÊ±ÇÂøÖËÉúÁöÑÊñπÊ≥ï„ÄÇ ÂòøÂòøÔºåËøô‰∏™Ê∏∏ÊàèÊàëÊó©Â∞±ËßÅËØÜËøá‰∫Ü„ÄÇÂ∞èÊó∂ÂÄôÁî®Áè†ÁÆóÁé©Ëøô‰∏™Ê∏∏ÊàèÔºöÁ¨¨‰∏ÄÊ°£Êã®‰∏Ä‰∏™ÔºåÁ¨¨‰∫åÊ°£Êã®‰∏§‰∏™Ôºå‰æùÊ¨°Áõ¥Âà∞Á¨¨‰∫îÊ°£Êã®‰∫î‰∏™„ÄÇÁÑ∂Âêé‰∏§‰∏™‰∫∫Â∞±ËΩÆÊµÅÂÜçÊääÊ£ãÂ≠êÊã®‰∏ãÊù•ÔºåË∞ÅË¶ÅÊòØÊúÄÂêé‰∏Ä‰∏™Êã®Ë∞ÅÂ∞±Ëµ¢„ÄÇÊúâ‰∏ÄÊ¨°ÊöëÂÅáÁúãËßÅ‰∏§‰∏™Â∞èÂ≠©Â≠êÂú®Áé©Ëøô‰∏™Ê∏∏ÊàèÔºåÊàëÂ∞±Âú®ÊÉ≥ÊúâÊ≤°Êúâ‰∏Ä‰∏™ÂÆöËÆ∫Âë¢„ÄÇ‰∏ãÈù¢Â∞±Êù•ËØïÁùÄËØÅÊòé‰∏Ä‰∏ãÂêß ÂÖàËß£ÂÜ≥Á¨¨‰∏Ä‰∏™ÈóÆÈ¢òÂêß„ÄÇ ÂÆö‰πâÔºöËã•ÊâÄÊúâÁÅ´Êü¥Êï∞ÂºÇÊàñ‰∏∫0ÔºåÂàôËØ•Áä∂ÊÄÅË¢´Áß∞‰∏∫Âà©‰ªñÊÄÅÔºåÁî®Â≠óÊØçTË°®Á§∫ÔºõÂê¶ÂàôÔºå ‰∏∫Âà©Â∑±ÊÄÅÔºåÁî®SË°®Á§∫„ÄÇ [ÂÆöÁêÜ1]ÔºöÂØπ‰∫é‰ªª‰Ωï‰∏Ä‰∏™SÊÄÅÔºåÊÄªËÉΩ‰ªé‰∏ÄÂ†ÜÁÅ´Êü¥‰∏≠ÂèñÂá∫Ëã•Âπ≤‰∏™‰Ωø‰πãÊàê‰∏∫TÊÄÅ„ÄÇ ËØÅÊòéÔºö Ëã•ÊúânÂ†ÜÁÅ´Êü¥ÔºåÊØèÂ†ÜÁÅ´Êü¥ÊúâA(i)Ê†πÁÅ´Êü¥Êï∞ÔºåÈÇ£‰πàÊó¢ÁÑ∂Áé∞Âú®Â§Ñ‰∫éSÊÄÅÔºå c = A(1) xor A(2) xor ‚Ä¶ xor A(n) &gt; 0; ÊääcË°®Á§∫Êàê‰∫åËøõÂà∂ÔºåËÆ∞ÂÆÉÁöÑ‰∫åËøõÂà∂Êï∞ÁöÑÊúÄÈ´ò‰Ωç‰∏∫Á¨¨p‰ΩçÔºåÂàôÂøÖÁÑ∂Â≠òÂú®‰∏Ä‰∏™A(t),ÂÆÉ‰∫åËøõÂà∂ÁöÑÁ¨¨p‰Ωç‰πüÊòØ1„ÄÇÔºàÂê¶ÂàôÔºåËã•ÊâÄÊúâÁöÑA(i)ÁöÑÁ¨¨p‰ΩçÈÉΩÊòØ0ÔºåËøô‰∏écÁöÑÁ¨¨p‰ΩçÂ∞±‰πü‰∏∫0ÁüõÁõæÔºâ„ÄÇ ÈÇ£‰πàÊàë‰ª¨Êääx = A(t) xor c,ÂàôÂæóÂà∞x &lt; A(t).ËøôÊòØÂõ†‰∏∫Êó¢ÁÑ∂A(t)ÁöÑÁ¨¨p‰Ωç‰∏écÁöÑÁ¨¨p‰ΩçÂêå‰∏∫1,ÈÇ£‰πàxÁöÑÁ¨¨p‰ΩçÂèò‰∏∫0,ËÄåÈ´ò‰∫épÁöÑ‰ΩçÂπ∂Ê≤°ÊúâÊîπÂèò„ÄÇÊâÄ‰ª•x &lt; A(t).ËÄå A(1) xor A(2) xor ‚Ä¶ xor x xor ‚Ä¶ xor A(n) = A(1) xor A(2) xor ‚Ä¶ xor A(t) xor c xor ‚Ä¶ xor A(n) = A(1) xor A(2) xor‚Ä¶ xor A(n) xor A(1) xor A(2) xor ‚Ä¶ xor A(n) = 0 ËøôÂ∞±ÊòØËØ¥‰ªéA(t)Â†Ü‰∏≠ÂèñÂá∫ A(t) ‚Äì x Ê†πÁÅ´Êü¥ÂêéÁä∂ÊÄÅÂ∞±‰ºö‰ªéSÊÄÅÂèò‰∏∫TÊÄÅ„ÄÇËØÅÊØï [ÂÆöÁêÜ2]ÔºöTÊÄÅÔºåÂèñ‰ªª‰Ωï‰∏ÄÂ†ÜÁöÑËã•Âπ≤Ê†πÔºåÈÉΩÂ∞ÜÊàê‰∏∫SÊÄÅ„ÄÇ ËØÅÊòéÔºöÁî®ÂèçËØÅÊ≥ïËØïËØï„ÄÇ Ëã• c = A(1) xor A(2) xor ‚Ä¶ xor A(i) xor ‚Ä¶ xor A(n) = 0Ôºõ c‚Äô = A(1) xor A(2) xor ‚Ä¶ xor A(i‚Äô) xor c xor ‚Ä¶ xor A(n) = 0; ÂàôÊúâ c xor c‚Äô = A(1) xor A(2) xor ‚Ä¶ xor A(i) xor ‚Ä¶ xor A(n) xor A(1) xor A(2) xor ‚Ä¶ xor A(i‚Äô) xor c xor ‚Ä¶ xor A(n) = A(i) xor A(i‚Äô) =0 ËøõËÄåÊé®Âá∫A(i) = A(i‚Äô)ÔºåËøô‰∏éÂ∑≤Áü•ÁüõÁõæ„ÄÇÊâÄ‰ª•ÂëΩÈ¢òÂæóËØÅ„ÄÇ [ÂÆöÁêÜ 3]ÔºöSÊÄÅÔºåÂè™Ë¶ÅÊñπÊ≥ïÊ≠£Á°ÆÔºåÂøÖËµ¢„ÄÇ ÊúÄÁªàËÉúÂà©Âç≥Áî±SÊÄÅËΩ¨Âèò‰∏∫TÊÄÅÔºå‰ªª‰Ωï‰∏Ä‰∏™SÊÄÅÔºåÂè™Ë¶ÅÊääÂÆÉÂèò‰∏∫TÊÄÅÔºåÔºàÁî±ÂÆöÁêÜ1ÔºåÂèØ‰ª•ÊääÂÆÉÂèòÊàêTÊÄÅ„ÄÇÔºâÂØπÊñπÂè™ËÉΩÊääTÊÄÅËΩ¨Âèò‰∏∫SÊÄÅ(ÂÆöÁêÜ2)„ÄÇËøôÊ†∑ÔºåÊâÄÊúâSÊÄÅÂêëTÊÄÅÁöÑËΩ¨ÂèòÈÉΩÂèØ‰ª•ÊúâÂ∑±ÊñπÊéßÂà∂ÔºåÂØπÊñπÂè™ËÉΩË¢´Âä®Âú∞ÂÆûÁé∞Áî±TÊÄÅËΩ¨Âèò‰∏∫SÊÄÅ„ÄÇÊïÖSÊÄÅÂøÖËµ¢„ÄÇ [ÂÆöÁêÜ4]ÔºöTÊÄÅÔºåÂè™Ë¶ÅÂØπÊñπÊ≥ïÊ≠£Á°ÆÔºåÂøÖË¥•„ÄÇ Áî±ÂÆöÁêÜ3ÊòìÂæó„ÄÇ Êé•ÁùÄÊù•Ëß£ÂÜ≥Á¨¨‰∫å‰∏™ÈóÆÈ¢ò„ÄÇ ÂÆö‰πâÔºöËã•‰∏ÄÂ†Ü‰∏≠‰ªÖÊúâ1Ê†πÁÅ´Êü¥ÔºåÂàôË¢´Áß∞‰∏∫Â≠§ÂçïÂ†Ü„ÄÇËã•Â§ß‰∫é1Ê†πÔºåÂàôÁß∞‰∏∫ÂÖÖË£ïÂ†Ü„ÄÇ ÂÆö‰πâÔºöTÊÄÅ‰∏≠ÔºåËã•ÂÖÖË£ïÂ†ÜÁöÑÂ†ÜÊï∞Â§ß‰∫éÁ≠â‰∫é2ÔºåÂàôÁß∞‰∏∫ÂÆåÂÖ®Âà©‰ªñÊÄÅÔºåÁî®T2Ë°®Á§∫ÔºõËã•ÂÖÖË£ïÂ†ÜÁöÑÂ†ÜÊï∞Á≠â‰∫é0ÔºåÂàôÁß∞‰∏∫ÈÉ®ÂàÜÂà©‰ªñÊÄÅÔºåÁî®T0Ë°®Á§∫„ÄÇ Â≠§ÂçïÂ†ÜÁöÑÊ†πÊï∞ÂºÇÊàñÂè™‰ºöÂΩ±Âìç‰∫åËøõÂà∂ÁöÑÊúÄÂêé‰∏Ä‰ΩçÔºå‰ΩÜÂÖÖË£ïÂ†Ü‰ºöÂΩ±ÂìçÈ´ò‰ΩçÔºàÈùûÊúÄÂêé‰∏Ä‰ΩçÔºâ„ÄÇ‰∏Ä‰∏™ÂÖÖË£ïÂ†ÜÔºåÈ´ò‰ΩçÂøÖÊúâ‰∏Ä‰Ωç‰∏ç‰∏∫0ÔºåÂàôÊâÄÊúâÊ†πÊï∞ÂºÇÊàñ‰∏ç‰∏∫0„ÄÇÊïÖ‰∏ç‰ºöÊòØTÊÄÅ„ÄÇ [ÂÆöÁêÜ5]ÔºöS0ÊÄÅÔºåÂç≥‰ªÖÊúâÂ•áÊï∞‰∏™Â≠§ÂçïÂ†ÜÔºåÂøÖË¥•„ÄÇT0ÊÄÅÂøÖËÉú„ÄÇ ËØÅÊòéÔºö S0ÊÄÅÔºåÂÖ∂ÂÆûÂ∞±ÊòØÊØèÊ¨°Âè™ËÉΩÂèñ‰∏ÄÊ†π„ÄÇÊØèÊ¨°Á¨¨Â•áÊï∞Ê†πÈÉΩÁî±Â∑±ÂèñÔºåÁ¨¨ÂÅ∂Êï∞Ê†πÈÉΩÁî±ÂØπ ÊñπÂèñÔºåÊâÄ‰ª•ÊúÄÂêé‰∏ÄÊ†πÂøÖÂ∑±Âèñ„ÄÇË¥•„ÄÇÂêåÁêÜ, T0ÊÄÅÂøÖËÉú# [ÂÆöÁêÜ6]ÔºöS1ÊÄÅÔºåÂè™Ë¶ÅÊñπÊ≥ïÊ≠£Á°ÆÔºåÂøÖËÉú„ÄÇ ËØÅÊòéÔºö Ëã•Ê≠§Êó∂Â≠§ÂçïÂ†ÜÂ†ÜÊï∞‰∏∫Â•áÊï∞ÔºåÊääÂÖÖË£ïÂ†ÜÂèñÂÆåÔºõÂê¶ÂàôÔºåÂèñÊàê‰∏ÄÊ†π„ÄÇËøôÊ†∑ÔºåÂ∞±ÂèòÊàêÂ•áÊï∞‰∏™Â≠§ÂçïÂ†ÜÔºåÁî±ÂØπÊñπÂèñ„ÄÇÁî±ÂÆöÁêÜ5ÔºåÂØπÊñπÂøÖËæì„ÄÇÂ∑±ÂøÖËÉú„ÄÇ # [ÂÆöÁêÜ7]ÔºöS2ÊÄÅ‰∏çÂèØËΩ¨‰∏ÄÊ¨°Âèò‰∏∫T0ÊÄÅ„ÄÇ ËØÅÊòéÔºö ÂÖÖË£ïÂ†ÜÊï∞‰∏çÂèØËÉΩ‰∏ÄÊ¨°Áî±2Âèò‰∏∫0„ÄÇÂæóËØÅ„ÄÇ # [ÂÆöÁêÜ8]ÔºöS2ÊÄÅÂèØ‰∏ÄÊ¨°ËΩ¨Âèò‰∏∫T2ÊÄÅ„ÄÇ ËØÅÊòéÔºö Áî±ÂÆöÁêÜ1ÔºåSÊÄÅÂèØËΩ¨Âèò‰∏∫TÊÄÅÔºåÊÄÅÂèØ‰∏ÄÊ¨°ËΩ¨Âèò‰∏∫TÊÄÅÔºåÂèàÁî±ÂÆöÁêÜ6ÔºåS2ÊÄÅ‰∏çÂèØËΩ¨‰∏ÄÊ¨°Âèò‰∏∫T0ÊÄÅÔºåÊâÄ‰ª•ËΩ¨ÂèòÁöÑTÊÄÅ‰∏∫T2ÊÄÅ„ÄÇ # [ÂÆöÁêÜ9]ÔºöT2ÊÄÅÔºåÂè™ËÉΩËΩ¨Âèò‰∏∫S2ÊÄÅÊàñS1ÊÄÅ„ÄÇ ËØÅÊòéÔºö Áî±ÂÆöÁêÜ2ÔºåTÊÄÅÂøÖÁÑ∂Âèò‰∏∫SÊÄÅ„ÄÇÁî±‰∫éÂÖÖË£ïÂ†ÜÊï∞‰∏çÂèØËÉΩ‰∏ÄÊ¨°Áî±2Âèò‰∏∫0ÔºåÊâÄ‰ª•Ê≠§Êó∂ÁöÑSÊÄÅ‰∏çÂèØËÉΩ‰∏∫S0ÊÄÅ„ÄÇÂëΩÈ¢òÂæóËØÅ„ÄÇ [ÂÆöÁêÜ10]ÔºöS2ÊÄÅÔºåÂè™Ë¶ÅÊñπÊ≥ïÊ≠£Á°ÆÔºåÂøÖËÉú. ËØÅÊòéÔºö ÊñπÊ≥ïÂ¶Ç‰∏ãÔºö 1Ôºâ S2ÊÄÅÔºåÂ∞±ÊääÂÆÉÂèò‰∏∫T2ÊÄÅ„ÄÇÔºàÁî±ÂÆöÁêÜ8Ôºâ 2Ôºâ ÂØπÊñπÂè™ËÉΩT2ËΩ¨ÂèòÊàêS2ÊÄÅÊàñS1ÊÄÅÔºàÂÆöÁêÜ9Ôºâ Ëã•ËΩ¨Âèò‰∏∫S2, ËΩ¨Âêë1Ôºâ Ëã•ËΩ¨Âèò‰∏∫S1, ËøôÂ∑±ÂøÖËÉú„ÄÇÔºàÂÆöÁêÜ5Ôºâ [ÂÆöÁêÜ11]ÔºöT2ÊÄÅÂøÖËæì„ÄÇ ËØÅÊòéÔºöÂêå10„ÄÇ Áªº‰∏äÊâÄËø∞ÔºåÂøÖËæìÊÄÅÊúâÔºö T2,S0 ÂøÖËÉúÊÄÅÔºö S2,S1,T0. ‰∏§È¢òÊØîËæÉÔºö Á¨¨‰∏ÄÈ¢òÁöÑÂÖ®ËøáÁ®ãÂÖ∂ÂÆûÂ¶Ç‰∏ãÔºö S2-&gt;T2-&gt;S2-&gt;T2-&gt; ‚Ä¶‚Ä¶ -&gt;T2-&gt;S1-&gt;T0-&gt;S0-&gt;T0-&gt;‚Ä¶‚Ä¶-&gt;S0-&gt;T0(ÂÖ®0) Á¨¨‰∫åÈ¢òÁöÑÂÖ®ËøáÁ®ãÂÖ∂ÂÆûÂ¶Ç‰∏ãÔºö S2-&gt;T2-&gt;S2-&gt;T2-&gt; ‚Ä¶‚Ä¶ -&gt;T2-&gt;S1-&gt;S0-&gt;T0-&gt;S0-&gt;‚Ä¶‚Ä¶-&gt;S0-&gt;T0(ÂÖ®0) ‰∏ãÂàíÁ∫øË°®Á§∫ËÉúÂà©‰∏ÄÊñπÁöÑÂèñÊ≥ï„ÄÇ ÊòØÂê¶ÂèëÁé∞‰∫Ü‰ªñ‰ª¨ÁöÑÊÉä‰∫∫Áõ∏‰ºº‰πãÂ§Ñ„ÄÇ Êàë‰ª¨‰∏çÈöæÂèëÁé∞(ËßÅÂä†ÈªëÈÉ®ÂàÜ)ÔºåS1ÊÄÅÂèØ‰ª•ËΩ¨Âèò‰∏∫S0ÊÄÅÔºàÁ¨¨‰∫åÈ¢òÂÅöÊ≥ïÔºâÔºå‰πüÂèØ‰ª•ËΩ¨Âèò‰∏∫ T0ÔºàÁ¨¨‰∏ÄÈ¢òÂÅöÊ≥ïÔºâ„ÄÇÂì™‰∏ÄÊñπÊéßÂà∂‰∫ÜS1ÊÄÅÔºå‰ªñÂç≥ÂèØ‰ª•ÊúâÂäûÊ≥ï‰ΩøËá™Â∑±ÂæóÂà∞ÊúÄÂêé‰∏ÄÊ†πÔºàËΩ¨Âèò‰∏∫ T0Ôºâ,‰πüÂèØ‰ª•‰ΩøÂØπÊñπÂæóÂà∞ÊúÄÂêé‰∏ÄÊ†πÔºàËΩ¨Âèò‰∏∫S0Ôºâ„ÄÇ ÊâÄ‰ª•ÔºåÊä¢Â§∫S1ÊòØÂà∂ËÉúÁöÑÂÖ≥ÈîÆÔºÅ ‰∏∫Ê≠§ÔºåÂßãÁªàÊääT2ÊÄÅËÆ©ÁªôÂØπÊñπÔºåÂ∞Ü‰ΩøÂØπÊñπÂ§Ñ‰∫éË¢´Âä®Áä∂ÊÄÅÔºå‰ªñÊó©ÊôöÂ∞ÜÊääÁä∂ÊÄÅÂèò‰∏∫S1. Êé®ËçêHDOJÈ¢òÁõÆ http://acm.hdu.edu.cn/showproblem.php?pid=1907 http://acm.hdu.edu.cn/showproblem.php?pid=2509 ÁúãÂÆå‰∏äÈù¢ÁöÑÁªìËÆ∫ÔºåÂ∞±ËÉΩÈ°∫Âà©Ëß£ÂÜ≥‰∏äÈù¢2ÈÅì‰∫Ü S-Nim http://acm.hdu.edu.cn/showproblem.php?pid=1536 http://acm.hdu.edu.cn/showproblem.php?pid=1944 ÂçöÂºàÁÆóÊ≥ïÂÖ•Èó®Â∞èËäÇ 1536 1517 1907 Â∞èÂ≠êÊúÄËøëËø∑ÈÄî‰∫éÂçöÂºà‰πã‰∏≠„ÄÇ„ÄÇ„ÄÇÊÑüËß¶È¢áÊ∑±„ÄÇ ‰∏∫‰∫ÜËÆ©Â§ßÂÆ∂ËÉΩÂ§üÂú®Â≠¶‰π†ÂçöÂºàÁöÑÊó∂ÂÄôÂ∞ëËµ∞ÂºØË∑ØÔºåÊúÄÈáçË¶ÅÁöÑ‰πüÊòØ‰∏∫‰∫ÜÂä†Ê∑±Ëá™Â∑±ÁöÑÂΩ±ÂìçÔºåÊ∏©ÊïÖËÄåÁü•Êñ∞ÔºåÁâπÂèëÊ≠§Ë¥¥‰∏éÂ§ßÂÆ∂ÂÖ±Âãâ„ÄÇ Â≠¶ÂçöÂºàÂÖà‰ªéÊ¶ÇÂøµÂºÄÂßãÔºö ÁâπÂà´Êé®ËçêLCYËÄÅÂ∏àÁöÑËØæ‰ª∂ÔºöÂçöÂºàÂÖ•Èó®„ÄÇ ‰∏ãËΩΩÂú∞ÂùÄÔºöhttp://acm.hdu.edu.cn/forum/read.php?tid=6875 Ëøô‰∏™ËØæ‰ª∂‰∏™‰∫∫ËÆ§‰∏∫‰ªéÂçöÂºàÁöÑÂü∫Êú¨ÊÄùÊÉ≥Ôºå‰∏ÄÁõ¥Âà∞Ëß£ÂçöÂºàÁöÑ‰∏≠ÂøÉÁÆóÊ≥ïÂÅö‰∫ÜÂæàÂ•ΩÁöÑËØ†Èáä„ÄÇ‰ΩÜÊòØÁâπÂà´Ë¶ÅÊ≥®ÊÑèÁöÑÊòØ„ÄÇËØæ‰ª∂ÂêéÈù¢‰∏ÄÈÉ®ÂàÜËã±ËØ≠ÂÜôÁöÑËÆ≤‰πâÊòØÈáç‰∏≠‰πãÈáç„ÄÇÂ∞èÂ≠êËã±ËØ≠ÂæàÂº±ÔºåÂú®ËøôÂõ∞Êâ∞Âæà‰πÖ„ÄÇÁé∞Âú®‰∏∫Â§ßÂÆ∂Â§ßÊ¶Ç‰ªãÁªç‰∏Ä‰∏ã„ÄÇ ‰∏ªË¶ÅÊòØÂêéÁªßÁÇπÂíåSGÂÄºÁöÑÈóÆÈ¢ò: SGÂÄºÔºö‰∏Ä‰∏™ÁÇπÁöÑSGÂÄºÂ∞±ÊòØ‰∏Ä‰∏™‰∏çÁ≠â‰∫éÂÆÉÁöÑÂêéÁªßÁÇπÁöÑSGÁöÑ‰∏îÂ§ß‰∫éÁ≠â‰∫éÈõ∂ÁöÑÊúÄÂ∞èÊï¥Êï∞„ÄÇ ÂêéÁªßÁÇπÔºö‰πüÂ∞±ÊòØÊåâÁÖßÈ¢òÁõÆË¶ÅÊ±ÇÁöÑËµ∞Ê≥ïÔºàÊØîÂ¶ÇÂèñÁü≥Â≠êÂèØ‰ª•ÂèñÁöÑÊï∞ÈáèÔºåÊñπÊ≥ïÔºâËÉΩÂ§üËµ∞‰∏ÄÊ≠•ËææÂà∞ÁöÑÈÇ£‰∏™ÁÇπ„ÄÇ ÂÖ∑‰ΩìÁöÑÊúâÂÖ≥SGÂÄºÊòØÊÄé‰πàËøêÁî®ÁöÑÂ∏åÊúõÂ§ßÂÆ∂Ëá™Â∑±Â§öÊÉ≥ÊÉ≥„ÄÇ ËØæ‰ª∂ÂêéÈù¢Êúâ‰∏Ä‰∏™1536ÁöÑ‰ª£Á†Å„ÄÇÂèØ‰ª•ÊîæÂú®ÂêéÈù¢ÂÅöÂÅö ÁúãÂà∞ËøôÈáåÊé®ËçêÂ§ßÂÆ∂ÂÅöÂá†ÈÅìÈ¢òÔºö1846ÔºàÊúÄÁÆÄÂçïÁöÑÂçöÂºàÊ∞¥È¢òÔºâ 1847ÔºàÊ±ÇSGÂÄºÔºâ Êúâ‰∫Ü‰∏äÈù¢ÁöÑÁü•ËØÜÊé•‰∏ãÊù•Êàë‰ª¨Êù•ÁúãÁúãÁªÑÂêàÂçöÂºàÔºànÂ†ÜÁü≥Â≠êÔºâ Êé®ËçêÂ§ßÂÆ∂Áúã‰∏™ËµÑÊñôÔºö ÂçöÂºà-ÂèñÁü≥Â≠êÊ∏∏Êàè(Êé®ËçêÁ≠âÁ∫ß‰∫îÊòüÁ∫ß) ËøôÈáåÊèêÂá∫‰∫Ü‰∏Ä‰∏™Â•áÂºÇÁä∂ÊÄÅÁöÑÈóÆÈ¢ò„ÄÇÁúã‰∫ÜËøôÁØáÊñáÁ´†‰Ω†‰ºöÂèëÁé∞ÂºÇÊàñËøêÁÆóÂú®ÂçöÂºà‰∏≠‰ΩøÁî®ÁöÑÂ¶ôÂ§Ñ„ÄÇÂΩìÁÑ∂ËøôÈáåÊåáÂá∫ÁöÑÂè™ÊòØÁªÑÂêàÂçöÂºà‰∏≠‰∏ÄÁßçÁâπÊÆäÊÉÖÂÜµ„ÄÇ ÁéãÈÅìËøòÊòØÂØπSGÂÄºÁöÑÊ±ÇËß£Ôºå‰ΩÜÊòØÁü•ÈÅìËøô‰πà‰∏ÄÁßçÊÄùË∑ØÊó†ÁñëÂØπÊÄùÁª¥ÁöÑÂπøÂ∫¶ÂíåÊ∑±Â∫¶Êâ©Â±ïÊòØÂæàÊúâÂ∏ÆÂä©ÁöÑ„ÄÇ ZZÂçöÂºà ËøôÈáå‰ªãÁªç‰∫ÜÁªÑÂíåÂçöÂºàÁöÑ‰∏§ÁßçÂ§ßÁöÑÁ±ªÂûãÔºå‰∏ÄÁßçÊòØÊúÄÂêéÂèñÁöÑÊòØNÁä∂ÊÄÅ‰∏ÄÁßçÊòØÊúÄÂêéÂèñÁöÑÊòØPÁä∂ÊÄÅÔºå‰∏§‰∏™Áä∂ÊÄÅÁöÑËß£È¢òÊñπÊ≥ïËÉΩÁúãÊáÇÂæàÊúâÂ∏ÆÂä©„ÄÇÂΩìÁÑ∂ÔºåËÉΩÂ§üÊääÊé®ÂØºËøáÁ®ãÁêÜËß£ÔºåÂêÉÈÄèÊó†ÁñëÊòØÂ§ßÁâõÁ∫ßÁöÑÂÅöÊ≥ïÂ∞èÂ≠ê‰πü‰Ω©ÊúçÁöÑÁ¥ß 1536È¢òÊé®ËçêÂÅöÂÅöËøôÈ¢òÔºåËøôÈ¢òÂâçÈù¢ÊèêÈÜíÂ§ßÂÆ∂ÊòØ‰∏Ä‰∏™Ê±ÇSGÂÄºÁöÑÈ¢òÁõÆÔºåÈ¢òÁõÆÂâçÈù¢ÊòØÂØπÂºÇÊàñËøêÁÆóËøêÁî®Âú®ÁªÑÂêàÂçöÂºàÈóÆÈ¢ò‰∏≠ÁöÑÂæàÂ•ΩÁöÑËß£Èáä„ÄÇÂΩìÁÑ∂È¢òÁõÆÊú¨Ë∫´ÊòØÊúâÊâÄ‰∏çÂêåÁöÑ„ÄÇÂõ†‰∏∫Âú®ËøôÈáåÈù¢ÂØπÂèñÊ≥ïÊúâÊâÄË¶ÅÊ±Ç„ÄÇÈÇ£‰πàËøôÊ†∑Â∞±ÂõûÂΩíÂà∞‰∫ÜËß£ÂÜ≥ÂçöÂºàÈóÆÈ¢òÁöÑÁéãÈÅìÁÆóÊ≥ï‚Äî‚ÄîÊ±ÇSGÂÄº‰∏ä„ÄÇ ÊúâÂÖ≥ËøêÁî®Ê±ÇSGÂÄºÁöÑÂçöÂºàÈ¢òÁõÆÊúâÔºö 1850Ôºà‰πüÂèØÂü∫‰∫éÂ•áÂºÇÁä∂ÊÄÅÂºÇÊàñÔºâ 1848Ôºà‰∏≠ÂíåÁöÑÂ§ßÊñêÊ≥¢ÈÇ£Â•ëÊï∞ÂàóÁöÑÂÖ∏ÂûãÊ±ÇSGÂÄºÈ¢òÔºâ 1517Ôºà‰∏™‰∫∫ËÆ§‰∏∫ÊúâÁÇπÁå•ÁêêÁöÑÈ¢òÁõÆ„ÄÇ„ÄÇ„ÄÇ„ÄÇÂú®Ê≠§È¢ò‰∏äÂõ∞Êâ∞Âæà‰πÖ„ÄÇÂΩìÁÑ∂ÊêûÂá∫Êù•ÂæàÂºÄÂøÉ„ÄÇÂ∞èÂ≠êÊòØÁî®ÊØîËæÉËßÑÁü©ÁöÑÊ±ÇSGÂÄºÁöÑÊñπÊ≥ïÊ±ÇÂá∫Êù•ÁöÑÔºå‰ΩÜÊòØËÆ∫ÂùõÊúâ‰∫∫ÂØπÂÖ∂Êé®Âá∫Êù•‰∫ÜËßÑÂæãÔºåËøôÈáå‰Ω©Êúç‰∏Ä‰∏ãÔºåÂ§ßÂÆ∂ÂèØ‰ª•Â≠¶‰π†‰∏Ä‰∏ãÔºâ 1079ÔºàÊõ¥Áå•ÁêêÁöÑÈ¢òÁõÆÔºåÂØπÊñ∞ÊâãË¶ÅÊ±ÇËæÉÈ´òÔºåÂõ†‰∏∫Êåâ‰º†ÁªüÊñπÊ≥ïÈúÄË¶ÅÊØîËæÉÁªÜËá¥ÁöÑÊ®°ÊãüÂä†ÂØπËæπËßíÁä∂ÊÄÅÁöÑËÄÉËôëÔºåÂêåÊ†∑Êúâ‰∫∫Êé®Âá∫Êù•‰∫ÜÂÖ¨ÂºèÔºâ ÂΩì‰Ω†ÂÖ®ÈÉ®ÁúãÂÆå‰ª•‰∏äÁöÑ‰∏úË•ø„ÄÇÂÅöÂÆå‰ª•‰∏äÁöÑÈ¢òÁõÆÁöÑËØù„ÄÇ„ÄÇ„ÄÇÂ∞èÂ≠êÊÅ≠Âñú‰Ω†‰Ω†ÂçöÂºàÂÖ•Èó®‰∫Ü~ ËøôÈáåÂ∞èÂ≠êÂëäËØâÂ§ßÂÆ∂„ÄÇÂçöÂºàÂæàÂº∫Â§ß„ÄÇÂ≠¶‰π†Ë¶ÅËÄêÂøÉ~Ë∞¢Ë∞¢ Current System Time : 2008-12-11 19:16:03 ACMËØæ‰Ωú‰∏öÔºö 1001 Brave Game 1002 Good Luck in CET-4 Everybody! 1003 Fibonacci again and again 1004 Rabbit and Grass 1005 Being a Good Boy in Spring Festival 1006 Public Sale 1007 ÊÇºÂøµ512Ê±∂Â∑ùÂ§ßÂú∞ÈúáÈÅáÈöæÂêåËÉû‚Äî‚ÄîÈÄâÊãîÂøóÊÑøËÄÖ 1008 kiki‚Äôs game 1009 Calendar Game 1010 A Multiplication Game 1011 Digital Deletions 1012 S-Nim 1536ÁöÑÂèÇËÄÉ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//ÂçöÂºà-Âü∫‰∫éÊ±ÇSGÂÄº//Accepted 1536 578MS 416K 904 B#include‚Äùiostream‚Äùusing namespace std;int f[101],sg[10001],k;int mex(int b)&#123; int a[101]=&#123;0&#125;,i; for(i=0;i&lt;k;i++) &#123; if(b-f&lt;0)//b-fÂêéÁªßÁÇπ break; if(sg[b-f]==-1) &#123; sg[b-f]=mex(b-f); &#125; a[sg[b-f]]=1; &#125; for(i=0;i&lt;k;i++) if(!a) &#123; return i; &#125;&#125;int main()&#123; int i,t,n,s,bead,j; while(cin &gt;&gt; k,k) &#123; for(i=0;i&lt;k;i++) &#123; cin &gt;&gt; f; &#125; memset(sg,-1,sizeof(sg)); for(i=0;i&lt;k;i++) for(j=i+1;j&lt;k;j++) if(f&gt;f[j]) &#123; f+=f[j]; f[j]=f-f[j]; f-=f[j]; &#125; sg[0]=0; cin &gt;&gt; t; while(t‚Äì) &#123; cin &gt;&gt; n; s=0; while(n‚Äì) &#123; cin &gt;&gt; bead;//ËØ•Â†ÜÁöÑÊàêÂëò‰∏™Êï∞ if(sg[bead]==-1) sg[bead]=mex(bead); s=s^sg[bead]; &#125; if(s==0) cout &lt;&lt; ‚ÄúL‚Äù; else cout &lt;&lt; ‚ÄúW‚Äù; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 1517ÂèÇËÄÉ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//ÂçöÂºà-Âü∫‰∫éÊ±ÇSGÂÄº//Accepted 1517 234MS 0K 837 B#include‚Äùiostream‚Äùusing namespace std;int main()&#123; __int64 a[7000]=&#123;1&#125;,min,n; int p[10],sg[7000],i,j,k; for(i=2;i&lt;10;p=0,i++); for(i=1;i&lt;7000;i++) &#123; for(j=2,min=-1;j&lt;10;j++) if(min==-1||a[p[j]]*j&lt;a[p[min]]*min) min=j; a=a[p[min]]*min; min=a[p[min]]*min; if(a&gt;=5000000000) break; for(j=2;j&lt;10;j++) if(a[p[j]]*j==min) p[j]++; &#125;//‰ªéÂ∞èÂà∞Â§ßÊ±ÇÂá∫ÊâÄÊúâ‰πòÁßØ while(scanf(‚Äú%I64d‚Äù,&amp;n)!=EOF) &#123; for(i=0;i&lt;7000;i++) &#123; sg=0; if(a&gt;=n) break; &#125; for(j=i-1;a[j]*9&gt;=n&amp;&amp;j&gt;=0;j‚Äì) sg[j]=1; while(j&gt;=0) &#123; for(k=j+1;k&lt;i&amp;&amp;a[j]*9&gt;=a[k];k++) if(a[k]%a[j]==0&amp;&amp;sg[k]==0) &#123; sg[j]=1; break; &#125; j‚Äì; &#125; puts(sg[0]?‚ÄùStan wins.‚Äù:‚ÄùOllie wins.‚Äù); &#125; return 0;&#125; ËøôÈáåÊÑüË∞¢sh«éÂ¥ΩÂêåÂ≠¶ÁöÑ‰∏ÄÊÆµ‰ª£Á†ÅËÆ©Â∞èÂ≠êÂ≠¶‰ºö‰∫ÜputsÁöÑÂ¶ôÁî® 1907ÂèÇËÄÉ‰ª£Á†Å 12345678910111213141516171819202122#include‚Äùiostream‚Äùusing namespace std;int main()&#123; int temp,t,n,s,x,i; cin &gt;&gt; t; while(t‚Äì) &#123; cin &gt;&gt; n; for(i=s=temp=0;i&lt;n;i++) &#123; cin &gt;&gt; x; if(x&gt;1) temp=1; s^=x; &#125; if((s&amp;&amp;temp)||(!s&amp;&amp;!temp)) cout &lt;&lt; ‚ÄúJohn‚Äù &lt;&lt; endl; else cout &lt;&lt; ‚ÄúBrother‚Äù &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>ÂçöÂºà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Âü∫‰∫éLinuxÔºàÊàñËÄÖMac OS XÔºâÁöÑÂØπÊãçÁ®ãÂ∫è]]></title>
    <url>%2F2017%2F05%2F28%2F%E5%9F%BA%E4%BA%8ELinux%EF%BC%88%E6%88%96%E8%80%85Mac%20OS%20X%EF%BC%89%E7%9A%84%E5%AF%B9%E6%8B%8D%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[ÊØîËµõÊó∂Ë∞ÉÁ®ãÂ∫èÁöÑÂ•áÊ∑´Â∑ßÊäÄ‰πã‰∏ÄÔºöÂØπÊãç„ÄÇ Á®ãÂ∫èbugË∞ÉËØï‰∏çÂá∫Êù•Ôºå‰ΩÜÊòØËÉΩÂÜô‰∏Ä‰∏™Êö¥ÂäõÁöÑ‰øùËØÅÊ≠£Á°ÆÁöÑÁÆóÊ≥ïÔºåÂπ∂‰∏îÁõ¥Êé•Êèê‰∫§Êö¥ÂäõÁöÑÁ®ãÂ∫è‰ºöË∂ÖÊó∂Ôºå‰∫éÊòØËøôÊó∂ÂÄôÂ∞±ÂèØ‰ª•Áî®‚ÄúÂØπÊãç‚ÄùÊù•Ë∞ÉËØï‰∫Ü„ÄÇ Áî±‰∫éACM ICPCÁî®ÁöÑÁ≥ªÁªüÈÉΩÊòØUbuntuÊâÄ‰ª•ÁªôÂá∫‰∏Ä‰∏™Âü∫‰∫éLinuxÁöÑÂØπÊãçÁ®ãÂ∫èÔºàMac OS XÂêåÊ†∑ÈÄÇÁî®Ôºâ data_maker Ôºö‰Ω†ÂÜôÁöÑËÉΩÂ§üÈöèÊú∫ÁîüÊàêÊï∞ÊçÆÁöÑÁ®ãÂ∫èÔºåÊ≥®ÊÑèÁîüÊàêÊï∞ÊçÆÁöÑÊù°‰ª∂ÔºàÊúâ‰∫õÈ¢òÁõÆÂØπÊï∞ÊçÆÁöÑË¶ÅÊ±ÇÊØîËæÉÈ´òÔºåËøôÊó∂ÂÄôÂæàÈöæÁîüÊàêÂèØ‰ª•Áî®ÁöÑÊï∞ÊçÆÔºåÊâÄ‰ª•ÂØπÊãç‰πüÊòØÊúâÂ±ÄÈôêÊÄßÁöÑÔºâ MyProgÔºö‰Ω†ÂÜôÁöÑÈ´òÊïàÁ®ãÂ∫è StdProgÔºöÊö¥ÂäõÁöÑ‰øùËØÅÁ≠îÊ°àÊ≠£Á°ÆÁöÑÁ®ãÂ∫è 12345678910111213while true; do ./data_maker &gt; tmp.in #Âá∫Êï∞ÊçÆ ./MyProg &lt; tmp.in &gt; my.out #Ë¢´ÊµãÁ®ãÂ∫è ./StdProg &lt; tmp.in &gt; std.out #Ê≠£Á°ÆÔºàÊö¥ÂäõÔºâÁ®ãÂ∫è if diff my.out std.out; then #ÊØîËæÉ‰∏§‰∏™ËæìÂá∫Êñá‰ª∂ printf "AC\n" #ÁªìÊûúÁõ∏ÂêåÊòæÁ§∫AC elif diff -B -b my.out std.out; then printf "PE\n" else printf "WA\n" #ÁªìÊûú‰∏çÂêåÊòæÁ§∫WAÔºåÂπ∂ÈÄÄÂá∫ exit 0 fi done ‰∏äÈù¢Ëøô‰∏™Á®ãÂ∫èÈúÄË¶Å‰øùÂ≠òÊàê.shÁöÑÊ†ºÂºèÔºå‰æãÂ¶ÇÔºöÂØπÊãç.shÁõ¥Êé•Âú®ÁªàÁ´ØÈáåÈù¢ËøêË°å ËøêË°åÊñπÊ≥ïÔºö ÊâìÂºÄÁªàÁ´Ø ÊâßË°å ÊñπÊ≥ï‰∏ÄÔºö ËæìÂÖ•ÂëΩ‰ª§ ./aa.sh ÊñπÊ≥ï‰∫åÔºöÁõ¥Êé•Êää aa.sh ÊãñÂÖ•Âà∞ÁªàÁ´ØÈáåÈù¢„ÄÇ Ê≥®ÊÑè‰∫ãÈ°πÔºö Â¶ÇÊûú Ê≤°ÊúâÊàêÂäüÊä•Âá∫ÈóÆÈ¢òÔºö: Permission denied„ÄÇ Â∞±ÊòØÊ≤°ÊúâÊùÉÈôê„ÄÇ Ëß£ÂÜ≥ÂäûÊ≥ïÔºö‰øÆÊîπËØ•Êñá‰ª∂ÂØπÊãç.sh ÁöÑÊùÉÈôê Ôºö‰ΩøÁî®ÂëΩ‰ª§Ôºö chmod 777 ÂØπÊãç.sh „ÄÇ ÁÑ∂ÂêéÂÜçÊâßË°å ‰∏äÈù¢Á¨¨‰∏ÄÊ≠•ÊàñËÄÖÁ¨¨‰∫åÊ≠•ÁöÑÊìç‰ΩúÂ∞± OK ‰∫Ü. ÈôÑËµ†‰∏Ä‰∏™windowsÁöÑÂØπÊãçÁ®ãÂ∫èÔºàËΩ¨ËΩΩ‰∫é‰ªñ‰∫∫Ôºå‰æµÂà†ÔºâÔºöÂØπÊãç.bat ÂØπÊãçÁ®ãÂ∫èÁöÑÂÜôÊ≥ï Â¶Ç‰∏ã 1234567891011@echo off :loop datamaker #Êï∞ÊçÆÁîüÊàêÂô® rand.exe &gt; data.in ËøôÈáåÁöÑÂ§ß‰∫éÁ¨¶Âè∑ÔºåÂ∞è‰∫éÁ¨¶Âè∑‰∏∫ÈáçÂÆöÂêëÁ¨¶Âè∑ std #Ê†áÂáÜÁ®ãÂ∫è std.exe &lt; data.in &gt; std.out myprogram #my.exe &lt; data.in &gt; my.out ÊàëÁöÑÁ®ãÂ∫è fc ans.out std.out //ÊØîËæÉ‰∏§‰∏™Á®ãÂ∫èÁöÑËæìÂá∫ÊòØÂê¶‰∏ÄËá¥Ôºå‰∏ÄËá¥ÂàôËøîÂõû0 if not errorlevel 1 goto loop pause goto loop #ÊúÄÂêé‰∏äËæπÁöÑ ÂÜÖÂÆπ ‰øùÂ≠ò‰∏∫.batÊñá‰ª∂ #rand.exe std.exe my.exe ‰ª•Âèäwindows‰∏ãÁöÑËøô‰∏™ .batÊñá‰ª∂ ÊîæÂú®Âêå‰∏Ä‰∏™ÁõÆÂΩï‰∏ã*************************************************************************************************** ËøôÈáåÊï∞ÊçÆÁîüÊàêÂô®Ôºö Â∞±ÊòØ‰Ω†Ëá™Â∑±ÁºñÂÜô‰∏Ä‰∏™Â∫îÁî®Á®ãÂ∫è rand.exeÔºåËøô‰∏™Â∫îÁî®Á®ãÂ∫èÂ∞±ÊòØÈöèÊú∫ÁöÑÁîüÊàê‰∏ÄÁªÑÁ¨¶ÂêàÈ¢òÊÑèÁöÑËæìÂÖ•Êï∞ÊçÆÂπ∂Â≠òÊîæÂà∞‰∏äËæπÊèêÂà∞ÁöÑ ËæìÂÖ•Êï∞ÊçÆÊñá‰ª∂‰∏≠data.inÈ´òÊïàÁ®ãÂ∫èÔºöÂ∞±ÊòØ‰∏äËæπÊèêÂà∞ÁöÑ È´òÊïàÁÆóÊ≥ï ÂÜôÁöÑÁ®ãÂ∫èÔºåÂç≥ my.exe Êö¥ÂäõÁ®ãÂ∫è ÔºöÂ∞±ÊòØÊåáËÉΩÂ§ü‰øùËØÅÊâÄÊúâËæìÂÖ•Êï∞ÊçÆÈÉΩËÉΩËæìÂá∫Ê≠£Á°ÆÁªìÊûúÁöÑ Á®ãÂ∫èÔºåÂç≥ËøôÈáåÁöÑstd.exe‰∏äËæπÁöÑ. batÊñá‰ª∂ ÁöÑÂäüËÉΩÂ∞±ÊòØÂæ™ÁéØ Âà§Êñ≠È´òÊïàÁ®ãÂ∫èÂíå Êö¥ÂäõÁ®ãÂ∫è Âú®ÂêåÊ†∑ÁöÑËæìÂÖ•Êï∞ÊçÆÊÉÖÂÜµ‰∏ãÔºåËæìÂá∫Êï∞ÊçÆÊòØÂê¶Áõ∏ÂêåÔºå‰ªéËÄåÂÆûÁé∞‰∫ÜÂØπÊãçÁ®ãÂ∫èÁöÑÂäüËÉΩ]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Mac OSX</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[kuangbinÂ∏¶‰Ω†È£û]Âà∑È¢òÈ°∫Â∫è]]></title>
    <url>%2F2017%2F05%2F27%2Fkuangbin%E5%B8%A6%E4%BD%A0%E9%A3%9E-%E5%88%B7%E9%A2%98%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[‰∏Ä‰∫õÂü∫Êú¨ÁÆóÊ≥ïÂíåÊï∞ÊçÆÁªìÊûÑ(ÈòüÂàó Ê†à Ê†ë Âõæ Âπ∂Êü•ÈõÜ Â†Ü DFS BFS ÊúÄÁü≠Ë∑Ø ÊúÄÂ∞èÁîüÊàêÊ†ë ÊãìÊâëÊéíÂ∫è Âä®ÊÄÅËßÑÂàí Ë¥™ÂøÉ ÊêúÁ¥¢ KMP ÂìàÂ∏å Trie ACËá™Âä®Êú∫ Âø´ÈÄüÂπÇ ÈÄÜÂÖÉ Ë¥πÈ©¨Â∞èÂÆöÁêÜ Ê¨ßÊãâÂáΩÊï∞ Á¥†Êï∞Á≠õ ÂàÜËß£Ë¥®Âõ†Êï∞)‰Ω†ÂèØ‰ª•Êâæ‰∏§‰∏™Â∞è‰ºô‰º¥‰∏ÄËµ∑ÂàÜÂ∑•Âêà‰ΩúÔºåÂêÑËá™ËÆ§È¢Ü‰∏ìÈ¢ò „ÄêÂèÇËÄÉ‰π¶Á±çÔºöÂàòÊ±ù‰Ω≥„ÄäÁÆóÊ≥ïÁ´ûËµõÂÖ•Èó®ÁªèÂÖ∏Á¨¨‰∫åÁâà„Äãor„ÄäÁÆóÊ≥ïÁ´ûËµõËÆ≠ÁªÉÊâãÂÜå„ÄãÔºå„ÄäÁÆóÊ≥ïÂØºËÆ∫„Äã„Äë ËøôÊó∂ÂÄôÂèØ‰ª•Âà∑ÁöÑÈ¢òÂ∞±Â§ö‰∫ÜÔºå‰Ω†ÂèØ‰ª•ÈÄâÊã©‰∏Ä‰∫õ‰∏ìÈ¢òËøõË°åÁ™ÅÁ†¥ÔºåÂ≠¶‰π†‰∏Ä‰∏ãÊäÄÂ∑ß ‰æãÂ¶Ç [kuangbinÂ∏¶‰Ω†È£û]‰∏ìÈ¢ò‰∏Ä ÁÆÄÂçïÊêúÁ¥¢ [kuangbinÂ∏¶‰Ω†È£û]‰∏ìÈ¢òÂõõ ÊúÄÁü≠Ë∑ØÁªÉ‰π† [kuangbinÂ∏¶‰Ω†È£û]‰∏ìÈ¢ò‰∫î Âπ∂Êü•ÈõÜ [kuangbinÂ∏¶‰Ω†È£û]‰∏ìÈ¢òÂÖ≠ ÊúÄÂ∞èÁîüÊàêÊ†ë [kuangbinÂ∏¶‰Ω†È£û]‰∏ìÈ¢òÂçÅ‰∫å Âü∫Á°ÄDP [kuangbinÂ∏¶‰Ω†È£û]‰∏ìÈ¢òÂçÅÂõõ Êï∞ËÆ∫Âü∫Á°Ä [kuangbinÂ∏¶‰Ω†È£û]‰∏ìÈ¢òÂçÅÂÖ≠ KMP &amp; Êâ©Â±ïKMP &amp; Manacher [kuangbinÂ∏¶‰Ω†È£û]‰∏ìÈ¢òÂçÅ‰∏É ACËá™Âä®Êú∫ Â¶ÇÊûúËøô‰∫õ‰Ω†Âíå‰Ω†ÁöÑÂ∞è‰ºô‰º¥ÈÉΩËÉΩÁÜüÊÇâÊéåÊè°ÔºåÂπ∂‰∏îËÉΩÂ§üÂ∞ΩÂø´ÂÜôÂá∫Êù•ÔºåÈÇ£‰πàÊ≤°ÊúâÊÑèÂ§ñÁöÑËØùÂ∞±ÂèØ‰ª•Âú®ÁΩëÁªúËµõ‰∏≠ÊãøÂà∞Áé∞Âú∫ËµõÁöÑÈó®Á•®ÔºàÂΩìÁÑ∂ËøòÂæóÁúãÂá∫È¢ò‰∫∫ÁöÑÈ£éÊ†º...Ôºâ ‰∏Ä‰∫õËøõÈò∂ÁöÑÁÆóÊ≥ï‰ª•ÂèäÂ§çÊùÇ‰∏Ä‰∫õÁöÑÊï∞ÊçÆÁªìÊûÑÔºàÊ†ëÁä∂Êï∞ÁªÑ Á∫øÊÆµÊ†ë Âπ≥Ë°°Ê†ë ÂêéÁºÄÊï∞ÁªÑ ‰∫åÂàÜÂõæÂåπÈÖç ÁΩëÁªúÊµÅ Ë¥πÁî®ÊµÅ Ââ≤ÁÇπ Ê°• Âº∫ËÅîÈÄö ÂèåËÅîÈÄö ÊúÄËøëÂÖ¨ÂÖ±Á•ñÂÖà ÂõõÂ§ßDP(Êï∞‰Ωçdp Âå∫Èó¥dp Áä∂Âéãdp Ê¶ÇÁéádp) ÂçöÂºàËÆ∫SGÂáΩÊï∞ Ôºâ „ÄêÂèÇËÄÉËµÑÊñôÔºöÂêÑÁßçÂçöÂÆ¢......„Äë [kuangbinÂ∏¶‰Ω†È£û]‰∏ìÈ¢ò‰∏É Á∫øÊÆµÊ†ë [kuangbinÂ∏¶‰Ω†È£û]‰∏ìÈ¢ò‰πù ËøûÈÄöÂõæ [kuangbinÂ∏¶‰Ω†È£û]‰∏ìÈ¢òÂçÅ ÂåπÈÖçÈóÆÈ¢ò [kuangbinÂ∏¶‰Ω†È£û]‰∏ìÈ¢òÂçÅ‰∏Ä ÁΩëÁªúÊµÅ [kuangbinÂ∏¶‰Ω†È£û]‰∏ìÈ¢òÂçÅ‰∫î Êï∞‰ΩçDP [kuangbinÂ∏¶‰Ω†È£û]‰∏ìÈ¢òÂçÅÂÖ´ ÂêéÁºÄÊï∞ÁªÑ [kuangbinÂ∏¶‰Ω†È£û]‰∏ìÈ¢ò‰∫åÂçÅ‰∏Ä Ê¶ÇÁéá&amp;ÊúüÊúõ [kuangbinÂ∏¶‰Ω†È£û]‰∏ìÈ¢ò‰∫åÂçÅ‰∫å Âå∫Èó¥DP Ëøô‰∫õÊéåÊè°‰πãÂêéÂú®Áé∞Âú∫Ëµõ‰∏≠ÊãøÂà∞ÁâåÂ≠êÂ∫îËØ•Â∞±Ê≤°‰ªÄ‰πàÈóÆÈ¢ò‰∫ÜÔºåÂèëÊå•Âá∫Ëâ≤ËøòËÉΩÊãøÂà∞Èì∂Áâå„ÄÇ„ÄÇ„ÄÇ‰∏çËøáÂ¶ÇÊûúÈÅáÂà∞ÊØîËæÉÂá∂ÊÆãÁöÑËµõÂå∫...2.5 ËøôÊó∂ÂÄôÂ¶ÇÊûúÂºÄÂßãÁªÑÈòü‰∫ÜÔºåÂ∞±ÂèØ‰ª•ÂéªÂà∑‰∏Ä‰∫õÂ•óÈ¢ò‰∫ÜÔºå‰æãÂ¶ÇContests - Virtual Judge ËøôÈáåÊØè‰∏ÄÂú∫ÊØîËµõÈÉΩÊòØËøáÂéªÁúüÂÆûÂèëÁîüÁöÑÂΩïÂÉèÔºå‰Ω†ÂèØ‰ª•clone‰πãÂêéÂíåËá™Â∑±ÁöÑÈòüÂèã‰∏ÄËµ∑ÂÆûÊìç‰∏Ä‰∏ã„ÄÇ Êõ¥È´òÊ∑±ÁöÑÊäÄÂ∑ßÔºåÊõ¥Â§çÊùÇÁöÑÊï∞ÊçÆÁªìÊûÑÔºàÊ†ëÈìæÂâñÂàÜÔºåÂä®ÊÄÅÊ†ëÔºåÂèØÊåÅ‰πÖÂåñÁ∫øÊÆµÊ†ëÔºåDLXÔºåÂêéÁºÄËá™Âä®Êú∫ÔºåÂõûÊñáÊ†ëÔºåÊñúÁéá‰ºòÂåñ/ÂçïË∞ÉÈòüÂàó‰ºòÂåñ/ÂõõËæπÂΩ¢‰ºòÂåñDPÔºåÊèíÂ§¥dpÔºåËé´ÊØî‰πåÊñØÂèçÊºî......Ôºâ ËøôÈÉ®ÂàÜÊúÄËÉΩ‰ΩìÁé∞‰∫∫‰∏é‰∫∫ÁöÑÂ∑ÆÂºÇ‰∫Ü...Êô∫ÂïÜÁ¢æÂéã‰∏ÄËà¨Â∞±Âú®ËøôÈÉ®ÂàÜ„ÄÇËÄåË¶ÅÊÉ≥ÊãøÂà∞ÈáëÁâåÔºå‰∏ÄËà¨Êù•ËØ¥Ëøô‰∫õÁü•ËØÜÈÉΩË¶ÅÂ∞ΩÂèØËÉΩÊéåÊè°„ÄÇ]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>kuangbin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
