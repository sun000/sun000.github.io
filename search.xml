<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Reinforcement-Learning-3-ç®—æ³•ä»‹ç»]]></title>
    <url>%2F2018%2F07%2F18%2FReinforcement-Learning-3-%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[å‰ä¸¤ç¯‡åšå®¢æŠŠReinforcement Learningçš„åŸºæœ¬æ¦‚å¿µï¼Œä»¥åŠæ‰€è§„çº¦æˆçš„æ•°å­¦é—®é¢˜ä»‹ç»äº†ä¸€ä¸‹ï¼Œè¿™ç¯‡åšå®¢æˆ‘ä»¬ä¸»è¦æ¥è®²ä¸€è®²è§£å†³å½“å‰æ•°å­¦é—®é¢˜çš„æ–¹æ³•ã€‚ åœ¨è¿™ä¹‹å‰æˆ‘ä»¬å…ˆæ˜Žç¡®å‡ ä¸ªå¼ºåŒ–å­¦ä¹ çš„æœ¯è¯­ å¼ºåŒ–å­¦ä¹ çš„æœ¯è¯­ å­¦ä¹ ä»»åŠ¡å¯åˆ†ä¸ºä¸¤ç±»ï¼š æƒ…èŠ‚æ€§ä»»åŠ¡(episodic tasks) æŒ‡ï¼ˆå¼ºåŒ–å­¦ä¹ çš„é—®é¢˜ï¼‰ä¼šåœ¨æœ‰é™æ­¥éª¤ä¸‹ç»“æŸã€‚æ¯”å¦‚ï¼šå›´æ£‹ã€‚ è¿žç»­æ€§ä»»åŠ¡(continuing tasks) æŒ‡ï¼ˆå¼ºåŒ–å­¦ä¹ çš„é—®é¢˜ï¼‰æœ‰æ— é™æ­¥éª¤ã€‚ä¸€ä¸ªç‰¹å¾æ˜¯ï¼šæ²¡æœ‰ç»“æŸã€‚æ¯”å¦‚ï¼šè®©ä¸€ä¸ªç«‹åœ¨æŒ‡å°–ä¸Šçš„é•¿æ£ä¸å€’ã€‚ï¼ˆ å­¦ä¹ çš„æ–¹æ³•ï¼š online-policyæ–¹æ³•(online-policy methods) è¯„ä¼°çš„ç­–ç•¥å’Œä¼˜åŒ–çš„ç­–ç•¥æ˜¯åŒä¸€ä¸ªã€‚ offline-policyæ–¹æ³•(offline-policy methods) è¯„ä¼°çš„ç­–ç•¥å’Œä¼˜åŒ–çš„ç­–ç•¥ä¸æ˜¯åŒä¸€ä¸ªã€‚æ„å‘³ç€ä¼˜åŒ–ç­–ç•¥ä½¿ç”¨æ¥è‡ªå¤–éƒ¨çš„æ¨¡æ‹Ÿæ•°æ®ã€‚ å­¦ä¹ çš„ç®—æ³•ï¼š é¢„æµ‹ç®—æ³•(predication algorithms) è®¡ç®—æ¯ä¸ªçŠ¶æ€çš„ä»·å€¼v(s)ã€‚ç„¶åŽé¢„æµ‹(å¯ä»¥å¾—åˆ°æœ€å¤§å›žæŠ¥çš„)æœ€ä¼˜è¡ŒåŠ¨ã€‚ æŽ§åˆ¶ç®—æ³•(predication algorithms) è®¡ç®—æ¯ä¸ªçŠ¶æ€ä¸‹æ¯ä¸ªè¡ŒåŠ¨çš„ä»·å€¼q(s,a)ã€‚ å­¦ä¹ çš„æ–¹æ³•ï¼š åˆ—è¡¨æ–¹æ³•(tabular methods) æŒ‡ä½¿ç”¨è¡¨æ ¼å­˜å‚¨æ¯ä¸ªçŠ¶æ€ï¼ˆæˆ–è€…çŠ¶æ€-è¡ŒåŠ¨ï¼‰çš„ä»·å€¼ã€‚ è¿‘ä¼¼æ–¹æ³•(approximation methods) æŒ‡ä½¿ç”¨ä¸€ä¸ªå‡½æ•°æ¥è®¡ç®—çŠ¶æ€ï¼ˆæˆ–è€…çŠ¶æ€-è¡ŒåŠ¨ï¼‰çš„ä»·å€¼ã€‚ æ¨¡åž‹(model) çŽ¯å¢ƒçš„æ¨¡åž‹ã€‚å¯ä»¥æ¨¡æ‹ŸçŽ¯å¢ƒï¼Œæ¨¡æ‹Ÿè¡ŒåŠ¨çš„ç»“æžœã€‚ Dynamic Programming need a modelã€‚ åŸºäºŽæ¨¡åž‹çš„æ–¹æ³•(model-base methods) é€šè¿‡æ¨¡åž‹æ¥æ¨¡æ‹Ÿã€‚å¯ä»¥æ¨¡æ‹Ÿè¡ŒåŠ¨ï¼ŒèŽ·å¾—ï¼ˆçŠ¶æ€æˆ–è€…è¡ŒåŠ¨ï¼‰ä»·å€¼ã€‚ æ³¨ï¼šè¿™ä¸ªæ¨¡æ‹Ÿå«åšæ¨¡åž‹æ¨¡æ‹Ÿã€‚ æ— æ¨¡åž‹çš„æ–¹æ³•(model-free methods) ä½¿ç”¨è¯•é”™æ³•(trial-and-error)æ¥èŽ·å¾—ï¼ˆçŠ¶æ€æˆ–è€…è¡ŒåŠ¨ï¼‰ä»·å€¼ã€‚ æ³¨ï¼šè¿™ä¸ªæ¨¡æ‹Ÿå«åšè¯•é”™ã€è¯•éªŒã€æ¨¡æ‹Ÿç­‰ã€‚ æ— æ¨¡åž‹çš„æ–¹æ³•ï¼Œå¯ä»¥ç”¨äºŽæœ‰æ¨¡åž‹çš„çŽ¯å¢ƒã€‚ å¼•å¯¼æ€§(bootstrapping) ï¼ˆçŠ¶æ€æˆ–è€…è¡ŒåŠ¨ï¼‰ä»·å€¼æ˜¯æ ¹æ®å…¶å®ƒçš„ï¼ˆçŠ¶æ€æˆ–è€…è¡ŒåŠ¨ï¼‰ä»·å€¼è®¡ç®—å¾—åˆ°çš„ã€‚ å–æ ·æ€§(sampling) ï¼ˆçŠ¶æ€æˆ–è€…è¡ŒåŠ¨ï¼‰ä»·å€¼ï¼Œæˆ–è€…éƒ¨åˆ†å€¼ï¼ˆæ¯”å¦‚ï¼šå¥–èµï¼‰æ˜¯å–æ ·å¾—åˆ°çš„ã€‚ å¼•å¯¼æ€§å’Œå–æ ·æ€§å¹¶ä¸æ˜¯å¯¹ç«‹çš„ã€‚å¯ä»¥æ˜¯å–æ ·çš„ï¼Œå¹¶ä¸”æ˜¯å¼•å¯¼çš„ã€‚ å¼ºåŒ–å­¦ä¹ åˆ†ç±» å¦‚ä½•é€‰æ‹©ç®—æ³• å¦‚æžœæœ‰ä¸€ä¸ªæ¨¡åž‹ï¼Œå¯ä»¥èŽ·å¾—ä»·å€¼å‡½æ•°v(s)æˆ–è€…q(s,a)çš„å€¼ â†’ åŠ¨æ€è§„åˆ’æ–¹æ³• å¦‚æžœå¯ä»¥æ¨¡æ‹Ÿä¸€ä¸ªå®Œæ•´çš„æƒ…èŠ‚ â†’ è’™ç‰¹å¡ç½—æ–¹æ³• å¦‚æžœéœ€è¦åœ¨æ¨¡æ‹Ÿä¸€ä¸ªæƒ…èŠ‚ä¸­é—´å°±è¦å­¦ä¹ ç­–ç•¥ â†’ æ—¶åºå·®åˆ†æ–¹æ³• Î»-returnç”¨æ¥ä¼˜åŒ–è¿‘ä¼¼æ–¹æ³•ä¸­çš„è¯¯å·®ã€‚ èµ„æ ¼è¿¹(Eligibility traces)ç”¨æ¥ä¼˜åŒ–è¿‘ä¼¼æ–¹æ³•ä¸­çš„ï¼Œä»·å€¼å‡½æ•°çš„å¾®åˆ†ã€‚ é¢„æµ‹æ–¹æ³•æ˜¯æ±‚çŠ¶æ€ä»·å€¼æ–¹æ³•V(s)æˆ–è€…\(\hat{V}(s, \theta )\) æŽ§åˆ¶æ–¹æ³•æ˜¯æ±‚è¡ŒåŠ¨ä»·å€¼æ–¹æ³•Q(s,a)æˆ–è€…\(\hat{Q}(s, a, \theta)\) ç­–ç•¥æ¢¯åº¦æ–¹æ³•(Policy Gradient Methods)æ˜¯æ±‚ç­–ç•¥æ–¹æ³•\(\pi(a|s,\theta)\) ç®—æ³•ç±»åˆ« éœ€è¦æ¨¡åž‹ å¼•å¯¼æ€§ æƒ…èŠ‚æ€§ä»»åŠ¡ è¿žç»­æ€§ä»»åŠ¡ åŠ¨æ€è§„åˆ’æ–¹æ³• Y Y - - è’™ç‰¹å¡ç½—æ–¹æ³• N N Y N æ—¶åºå·®åˆ†æ–¹æ³• N Y Y Y ç­–ç•¥æ¢¯åº¦æ–¹æ³• N Y Y Y ç®—æ³•åˆ—è¡¨ è¿™é‡Œåªæ˜¯åšç®€è¦çš„ä»‹ç»ï¼Œå…¶ä¸­å‡ ä¸ªä¸»æµç®—æ³•ä¼šå•ç‹¬ç¼–å†™åšå®¢è®²è§£ã€‚ åŠ¨æ€è§„åˆ’(Dynamic Programming) åŠ¨æ€è§„åˆ’æ˜¯åŸºäºŽæ¨¡åž‹çš„æ–¹æ³•ã€‚ æ³¨ï¼šä¸€ä¸ªå¸¸è§çš„è€ƒè™‘æ˜¯å°†æ¯ä¸ªactionçš„rewardè®¾ä¸º-1ï¼ŒæœŸæœ›çš„ç»“æžœ\(V(S_t)\)ä¸º0ã€‚ Iterative policy evaluation ä½¿ç”¨éšæœºç­–ç•¥\(\pi(a|s)\)æ¥è¿­ä»£è®¡ç®—\(v(s)\) Policy iteration (using iterative policy evaluation) é€šè¿‡ä½¿ç”¨è¿­ä»£ç­–ç•¥\(\pi(s)\)æ¥ä¼˜åŒ–äº†è®¡ç®—\(V(s)\)éƒ¨åˆ†ã€‚ä½†æ˜¯ï¼Œè¿˜æ˜¯ä½¿ç”¨äº†æœŸæœ›å€¼ã€‚ Value iteration ä¼˜åŒ–äº†æ•´ä¸ªæµç¨‹ï¼Œç›´æŽ¥ç”¨è¡ŒåŠ¨çš„æœ€å¤§å›žæŠ¥ä½œä¸º\(V(s)\)çš„å€¼ã€‚ è’™ç‰¹å¡ç½—æ–¹æ³•(Monte Carlo Method) First-visit MC policy evaluation (returns Vâ‰ˆv) åœ¨æ¯ä¸ªæƒ…èŠ‚ä¸­ï¼Œè®°å½•çŠ¶æ€sç¬¬ä¸€ä¸ªGã€‚v(s)=avg(G(s)) Monte Carlo ES (Exploring Starts) ä»Žä¸€ä¸ªç‰¹å®šèµ·å§‹ç‚¹çš„è’™ç‰¹å¡ç½—æ–¹æ³•ã€‚ å˜æˆäº†è®¡ç®—q(s,a)ã€‚ On-policy fi rst-visit MC control (for Ïµ-soft policies) åœ¨æŽ¢ç´¢ä¸­ä½¿ç”¨äº†Ïµ-softç­–ç•¥ã€‚ Incremental o ff-policy every-visit MC policy evaluation æ”¯æŒoff-policyã€‚ Off-policy every-visit MC control (returns Ï€â‰ˆÏ€âˆ—) ä½¿ç”¨äº†è´ªå©ªç­–ç•¥æ¥æ”¯æŒoff-policyã€‚ æ—¶åºå·®åˆ†æ–¹æ³•(Temporal-Difference Learning) æ—¶åºå·®åˆ†æ–¹æ³•çš„æ€æƒ³æ˜¯ï¼š åœ¨ä¸€ä¸ªæƒ…èŠ‚è¿›è¡Œè¿‡ç¨‹ä¸­å­¦ä¹ ã€‚ æ¯”å¦‚ï¼šè®¡ç®—åˆ°å…¬å¸çš„æ—¶é—´é—®é¢˜ã€‚æ—©ä¸Šæ™šèµ·äº†10åˆ†é’Ÿï¼Œå¯ä»¥è®¤ä¸ºä¼šæ¯”ä»¥å¾€æ™šåˆ°10åˆ†é’Ÿã€‚è€Œä¸ç”¨å®Œæˆä»Žå®¶åˆ°å…¬å¸æ•´ä¸ªè¿‡ç¨‹ã€‚ è§†ä¸ºè’™ç‰¹å¡ç½—æ–¹æ³•çš„é€šç”¨åŒ–ã€‚è’™ç‰¹å¡ç½—æ–¹æ³•æ˜¯æ­¥æ•°ä¸ºå®Œæˆæƒ…èŠ‚çš„TDç®—æ³•ã€‚ Tabular TD(0) for estimating vÏ€ è®¡ç®—v(s)çš„å•æ­¥TDç®—æ³•ã€‚ Sarsa: An on-policy TD control algorithm è®¡ç®—q(s,a)çš„å•æ­¥TDç®—æ³•ã€‚ Q-learning: An off -policy TD control algorithm æ˜¯ä¸€ä¸ªçªç ´æ€§ç®—æ³•ã€‚ä½†æ˜¯å­˜åœ¨ä¸€ä¸ªæœ€å¤§åŒ–åå·®(Maximization Bias)é—®é¢˜ã€‚ Double Q-learning è§£å†³äº†æœ€å¤§åŒ–åå·®(Maximization Bias)é—®é¢˜ã€‚ å¤šæ­¥æ—¶åºå·®åˆ†æ–¹æ³• n-step TD for estimating Vâ‰ˆvÏ€ è®¡ç®—v(s)çš„å¤šæ­¥TDç®—æ³•ã€‚ n-step Sarsa for estimating Qâ‰ˆqâˆ—, or Qâ‰ˆqÏ€ for a given Ï€ è®¡ç®—q(s,a)çš„å¤šæ­¥TDç®—æ³•ã€‚ O ff-policy n-step Sarsa for estimating Qâ‰ˆqâˆ—, or Qâ‰ˆqÏ€ for a given Ï€ è€ƒè™‘åˆ°é‡è¦æ ·æœ¬ï¼ŒæŠŠÏå¸¦å…¥åˆ°Sarsaç®—æ³•ä¸­ï¼Œå½¢æˆä¸€ä¸ªoff-policyçš„æ–¹æ³•ã€‚ Ï - é‡è¦æ ·æœ¬æ¯”çŽ‡(importance sampling ratio) \[\rho \leftarrow \prod_{\tau + 1}^{min(\tau+n-1,T-1)}\frac{\pi(A_t|S_t)}{\mu(A_t|S_t)},(\rho_{\tau+n}^{\tau+1})\] n-step Tree Backup for estimating Qâ‰ˆqâˆ—, or Qâ‰ˆqÏ€ for a given Ï€ Tree Backup Algorithmçš„æ€æƒ³æ˜¯æ¯æ­¥éƒ½æ±‚è¡ŒåŠ¨ä»·å€¼çš„æœŸæœ›å€¼ã€‚ æ±‚è¡ŒåŠ¨ä»·å€¼çš„æœŸæœ›å€¼æ„å‘³ç€å¯¹æ‰€æœ‰å¯èƒ½çš„è¡ŒåŠ¨aéƒ½è¯„ä¼°ä¸€æ¬¡ã€‚ Off -policy n-step Q(Ïƒ) for estimating Qâ‰ˆqâˆ—, or Qâ‰ˆqÏ€for a given Ï€ Q(Ïƒ)ç»“åˆäº†Sarsa(importance sampling), Expected Sarsa, Tree Backupç®—æ³•ï¼Œå¹¶è€ƒè™‘äº†é‡è¦æ ·æœ¬ã€‚ å½“Ïƒ=1æ—¶ï¼Œä½¿ç”¨äº†é‡è¦æ ·æœ¬çš„Sarsaç®—æ³•ã€‚ å½“Ïƒ=0æ—¶ï¼Œä½¿ç”¨äº†Tree Backupçš„è¡ŒåŠ¨æœŸæœ›å€¼ç®—æ³•ã€‚ åŸºäºŽæ¨¡åž‹çš„ç®—æ³• è¿™é‡Œçš„æ€æƒ³æ˜¯ï¼šé€šè¿‡ä½“éªŒæ¥ç›´æŽ¥ä¼˜åŒ–ç­–ç•¥å’Œä¼˜åŒ–æ¨¡åž‹ï¼ˆå†ä¼˜åŒ–ç­–ç•¥ï¼‰ã€‚ Random-sample one-step tabular Q-planning é€šè¿‡ä»Žæ¨¡åž‹ä¸­èŽ·å–å¥–èµå€¼ï¼Œè®¡ç®—q(s,a)ã€‚ Tabular Dyna-Q å¦‚æžœn=0ï¼Œå°±æ˜¯Q-learningç®—æ³•ã€‚Dyna-Qçš„ç®—æ³•çš„ä¼˜åŠ¿åœ¨äºŽæ€§èƒ½ä¸Šçš„æé«˜ã€‚ ä¸»è¦åŽŸå› æ˜¯é€šè¿‡å»ºç«‹æ¨¡åž‹ï¼Œå‡å°‘äº†æ‰§è¡Œè¡ŒåŠ¨çš„æ“ä½œï¼Œæ¨¡åž‹å­¦ä¹ åˆ°äº†Model(S,A)â†R,Sâ€²ã€‚ Prioritized sweeping for a deterministic environment æä¾›äº†ä¸€ç§æ€§èƒ½çš„ä¼˜åŒ–ï¼Œåªè¯„ä¼°é‚£äº›è¯¯å·®å¤§äºŽä¸€å®šå€¼Î¸çš„ç­–ç•¥ä»·å€¼ã€‚ è¿‘ä¼¼é¢„æµ‹æ–¹æ³• é¢„æµ‹æ–¹æ³•å°±æ˜¯æ±‚v(s)ã€‚ $$ $$ Gradient Monte Carlo Algorithm for Approximating v^â‰ˆvÏ€ è’™ç‰¹å¡ç½—æ–¹æ³•å¯¹åº”çš„è¿‘ä¼¼é¢„æµ‹æ–¹æ³•ã€‚ Semi-gradient TD(0) for estimating v^â‰ˆvÏ€ å•æ­¥TDæ–¹æ³•å¯¹åº”çš„è¿‘ä¼¼é¢„æµ‹æ–¹æ³•ã€‚ ä¹‹æ‰€ä»¥å«åŠæ¢¯åº¦é€’å‡çš„åŽŸå› æ˜¯TD(0)å’Œn-steps TDè®¡ç®—ä»·å€¼çš„å…¬å¼ä¸æ˜¯ç²¾ç¡®çš„ï¼ˆè€Œè’™ç‰¹å¡ç½—æ–¹æ³•æ˜¯ç²¾ç¡®çš„ï¼‰ã€‚ n-step semi-gradient TD for estimating v^â‰ˆvÏ€ å¤šæ­¥TDæ–¹æ³•å¯¹åº”çš„è¿‘ä¼¼é¢„æµ‹æ–¹æ³•ã€‚ LSTD for estimating v^â‰ˆvÏ€ (O(n2) version)]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>æœºå™¨å­¦ä¹ </tag>
        <tag>å¼ºåŒ–å­¦ä¹ </tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reinforcement-Learning-2-æœ‰é™é©¬å°”ç§‘å¤«å†³ç­–è¿‡ç¨‹&Bellmanæ–¹ç¨‹]]></title>
    <url>%2F2018%2F07%2F18%2FReinforcement-Learning-2-%E6%9C%89%E9%99%90%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[ä¸Šä¸€ç¯‡åšå®¢ç¨å¾®ä»‹ç»äº†ä¸€äº›å¼ºåŒ–å­¦çš„åŸºæœ¬æ¦‚å¿µï¼Œè¿™æ¬¡åœ¨è®²æœ‰é™é©¬å°”ç§‘å¤«å†³ç­–è¿‡ç¨‹ï¼ˆFinite Markov Decision Processesï¼‰ä¹‹å‰ï¼Œå…ˆå¯¹å¼ºåŒ–å­¦ä¹ çš„æ¨¡åž‹æ¥ä¸€ä¸ªæ›´è¯¦ç»†çš„ä»‹ç»ã€‚ åŸºæœ¬æ¦‚å¿µ 1. è§„åˆ™ï¼ˆpolicyï¼‰ Policy å®šä¹‰äº† agents åœ¨ç‰¹å®šçš„æ—¶é—´ç‰¹å®šçš„çŽ¯å¢ƒä¸‹çš„è¡Œä¸ºæ–¹å¼ï¼Œå¯ä»¥è§†ä¸ºæ˜¯ä»ŽçŽ¯å¢ƒçŠ¶æ€åˆ°è¡Œä¸ºçš„æ˜ å°„ï¼Œå¸¸ç”¨ Ï€æ¥è¡¨ç¤ºã€‚policy å¯ä»¥åˆ†ä¸ºä¸¤ç±»ï¼š ç¡®å®šæ€§çš„ policyï¼ˆDeterministic policyï¼‰: \(a=\pi(s)\) éšæœºæ€§çš„ policyï¼ˆStochastic policyï¼‰: \(\pi(a|s)=P[A_t=a|S_t=s]\) å…¶ä¸­ï¼Œtæ˜¯æ—¶é—´ç‚¹ï¼Œt=0,1,2,3,â€¦â€¦ \(S_t \in S\)ï¼ŒSæ˜¯çŽ¯å¢ƒçŠ¶æ€çš„é›†åˆï¼Œ\(S_t\)ä»£è¡¨æ—¶åˆ» \(t\) çš„çŠ¶æ€ï¼Œsä»£è¡¨å…¶ä¸­æŸä¸ªç‰¹å®šçš„çŠ¶æ€ \(A_t \in A(S_t)\)ï¼Œ\(A_(S_t)\) æ˜¯åœ¨çŠ¶æ€\(S_t\)ä¸‹çš„ actions çš„é›†åˆï¼Œ\(A_t\)ä»£è¡¨æ—¶åˆ» t çš„è¡Œä¸ºï¼Œaä»£è¡¨å…¶ä¸­æŸä¸ªç‰¹å®šçš„è¡Œä¸ºã€‚ 2. å¥–åŠ±ä¿¡å·ï¼ˆa reward signalï¼‰ Reward å°±æ˜¯ä¸€ä¸ªæ ‡é‡å€¼ï¼Œæ˜¯æ¯ä¸ª time step ä¸­çŽ¯å¢ƒæ ¹æ® agent çš„è¡Œä¸ºè¿”å›žç»™ agent çš„ä¿¡å·ï¼Œreward å®šä¹‰äº†åœ¨è¯¥æƒ…æ™¯ä¸‹æ‰§è¡Œè¯¥è¡Œä¸ºçš„å¥½åï¼Œagent å¯ä»¥æ ¹æ® reward æ¥è°ƒæ•´è‡ªå·±çš„ policyã€‚å¸¸ç”¨ R æ¥è¡¨ç¤ºã€‚ 3. å€¼å‡½æ•°ï¼ˆvalue functionï¼‰ Reward å®šä¹‰çš„æ˜¯ç«‹å³çš„æ”¶ç›Šï¼Œè€Œ value function å®šä¹‰çš„æ˜¯é•¿æœŸçš„æ”¶ç›Šï¼Œå®ƒå¯ä»¥çœ‹ä½œæ˜¯ç´¯è®¡çš„ rewardï¼Œå¸¸ç”¨ v æ¥è¡¨ç¤ºã€‚ é€šå¸¸æˆ‘ä»¬æœ‰ä¸‰ç§æ–¹æ³•åŽ»è¡¨ç¤ºvalue functionï¼Œ\(V^\pi(s)\)ï¼šè¡¨ç¤ºåœ¨\(\pi\) policyä¸‹ï¼Œä»ŽsçŠ¶æ€å¼€å§‹åˆ°ç»“æŸèƒ½èŽ·å¾—çš„rewardsçš„æœŸæœ› \(V^\pi(s) =E_\pi[\sum_{t=0}^{T}r_t|s_0=s]\) \(V^\pi(s) = lim_{T \rightarrow \infty}E_\pi[\frac{1}{T}\sum_{t=0}^{T}r_t|s_0=s]\) \(V^\pi(s) = E_\pi[\sum_{t=0}^{\infty}\gamma ^tr_t|s_0=s]\) åˆ†åˆ«ä¸º é‡‡ç”¨ç­–ç•¥\(\pi\)çš„æƒ…å†µä¸‹æœªæ¥æœ‰é™hæ­¥çš„æœŸæœ›ç«‹å³å›žæŠ¥æ€»å’Œï¼› é‡‡ç”¨ç­–ç•¥\(\pi\)çš„æƒ…å†µä¸‹æœŸæœ›çš„å¹³å‡å›žæŠ¥ï¼› å€¼å‡½æ•°æœ€å¸¸è§çš„å½¢å¼ï¼Œå¼ä¸­Î³âˆˆ[0,1]ç§°ä¸ºæŠ˜åˆå› å­ï¼Œè¡¨æ˜Žäº†æœªæ¥çš„å›žæŠ¥ç›¸å¯¹äºŽå½“å‰å›žæŠ¥çš„é‡è¦ç¨‹åº¦ã€‚ç‰¹åˆ«çš„ï¼ŒÎ³=0æ—¶ï¼Œç›¸å½“äºŽåªè€ƒè™‘ç«‹å³ä¸è€ƒè™‘é•¿æœŸå›žæŠ¥ï¼ŒÎ³=1æ—¶ï¼Œå°†é•¿æœŸå›žæŠ¥å’Œç«‹å³å›žæŠ¥çœ‹å¾—åŒç­‰é‡è¦ã€‚ æˆ‘ä»¬æœ€å¸¸ç”¨çš„æ˜¯ç¬¬ä¸‰ç§å½¢å¼ï¼ŒæŽ¥ä¸‹æ¥çš„è®¨è®ºä¹Ÿå°†å›´ç»•ç¬¬ä¸‰ç§å½¢å¼è¿›è¡Œ 4. çŽ¯å¢ƒæ¨¡åž‹ï¼ˆa model of the environmentï¼‰ æ•´ä¸ªAgentå’ŒEnvironmentäº¤äº’çš„è¿‡ç¨‹å¯ä»¥ç”¨ä¸‹å›¾æ¥è¡¨ç¤ºï¼š åœ¨æ¯ä¸ªæ—¶é—´æ­¥éª¤ä¸­ï¼Œagent éƒ½ä¼šå®žçŽ°ä¸€ä¸ªä»Ž states åˆ°æ¯ä¸ªå¯èƒ½çš„ actions çš„ probabilities çš„æ˜ å°„(è¿™é‡Œè®²çš„æ˜¯éšæœºæ€§ploicyæ¨¡åž‹ï¼Œç¡®å®šæ€§çš„ç›´æŽ¥è¾“å‡ºa)ï¼Œè¿™ä¸ªæ˜ å°„å‡½æ•°å°±ç§°ä½œæ˜¯è¿™ä¸ª agent çš„ policyï¼Œå¸¸ç”¨ç¬¦å·\(\pi_t\)æ¥è¡¨ç¤ºï¼Œ\(\pi_t(a|s)\)æŒ‡çš„å°±æ˜¯åœ¨çŠ¶æ€\(S_t=s\)ä¸‹é€‰æ‹©æ‰§è¡Œ\(A_t=a\)çš„æ¦‚çŽ‡ã€‚ å…¶å®žæ¦‚æ‹¬çš„æ¥è¯´ï¼Œä¸åŒçš„ RL æ–¹æ³•çš„ä¸»è¦ä¸åŒå°±æ˜¯åˆ©ç”¨ experience æ¥æ”¹å˜è‡ªå·±çš„ Ï€t çš„æ–¹æ³•ï¼Œæ¯•ç«ŸRLå°±æ˜¯ä»Ž experience ä¸­è¿›è¡Œå­¦ä¹ çš„ä¸€ç³»åˆ—æ–¹æ³•ã€‚ 5. Goals&amp;Rewards åœ¨RLä¸­ï¼Œgoalså’Œrewardsæ˜¯ä¸¤ä¸ªé‡è¦çš„æ¦‚å¿µï¼Œåœ¨æ¯ä¸ªæ—¶é—´æ­¥éª¤ä¸­ï¼ŒçŽ¯å¢ƒè¿”å›žç»™ Agent çš„ reward å°±æ˜¯ä¸€ä¸ªç®€å•çš„æ•°å€¼ï¼Œè€Œ Agent çš„ goal å°±æ˜¯æœ€å¤§åŒ–å®ƒæŽ¥å—åˆ°çš„æ‰€æœ‰çš„ reward çš„å’Œï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒçš„ç›®çš„ä¸æ˜¯æœ€å¤§åŒ–å½“å‰æ­¥éª¤çš„ç«‹å³èŽ·å¾—çš„ reward ï¼Œè€Œæ˜¯ä¸€ä¸ªé•¿è¿œçš„ç›®æ ‡ï¼Œå¹¶ä¸”éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™ä¸ª reward æ˜¯ç”± environment å®šä¹‰çš„è€Œéž Agentã€‚ 6. Returns ä¸Šé¢æåˆ°äº†Agentçš„ä»»åŠ¡æ˜¯è¦æœ€å¤§åŒ–Rewardsçš„æ€»å’Œï¼Œé‚£ä¹ˆæˆ‘ä»¬æ¥å®šä¹‰è¿™ä¸ªç›®æ ‡ï¼Œä»¤æ—¶é—´ t èŽ·å¾—çš„ reward ä¸º \(R_{t+1}, R_{t+2}, R_{t+3},...R_{T}\)ä»¤ \(G_t\) ä»£è¡¨returnï¼ˆ\(V^\pi(S_t)\)æ˜¯$G_t $çš„ä¼°è®¡ï¼‰ï¼Œé‚£ä¹ˆæœ€ç®€å•çš„ return çš„å½¢å¼ä¸ºï¼š \[G_t=\sum_{i=t+1}^TR_i\] Tè¡¨ç¤ºçš„æ˜¯æœ€åŽä¸€ä¸ªæ­¥éª¤ã€‚ è¿™é‡Œéœ€è¦å†å¼•å…¥ä¸€ä¸ªæ–°çš„æ¦‚å¿µ episodesï¼Œç¿»è¯‘æˆä¸­æ–‡çš„è¯å°±æ˜¯â€œç‰‡æ®µã€æ’æ›²â€çš„æ„æ€ï¼Œè¿™é‡ŒæŒ‡çš„æ˜¯ä¸€ä¸ªå¯ä»¥è‡ªç„¶ç»“æŸçš„ agent-environment äº¤äº’çš„è¿‡ç¨‹ï¼Œæ¯ä¸ª episode éƒ½ä¼šåœ¨ä¸€ä¸ªç‰¹æ®Šçš„çŠ¶æ€ä¸‹ç»“æŸï¼Œè¿™ä¸ªçŠ¶æ€å°±ç§°ä½œæ˜¯ terminal stateï¼Œå› æ­¤æ¯ä¸ª episode çš„ç›¸åŒç‚¹æ˜¯å®ƒä»¬éƒ½ä»¥ terminal state æ¥ç»“æŸï¼Œä¸åŒå°±æ˜¯æ¯ä¸ª episode èŽ·å¾—çš„ reward ä¸åŒï¼Œé‡‡ç”¨ episodes å½¢å¼çš„ tasks å°±ç§°ä¸ºæ˜¯ episodic tasksï¼Œåœ¨episodic tasks ä¸­ï¼Œå¸¸å¸¸å°†æ‰€æœ‰éžç»ˆæ­¢çš„çŠ¶æ€çš„é›†åˆè®°ä¸ºæ˜¯ Sï¼Œè€ŒæŠŠåŒ…å«ç»ˆæ­¢çŠ¶æ€çš„æ‰€æœ‰çŠ¶æ€çš„é›†åˆè®°ä¸ºæ˜¯ S+ã€‚ ä¸Ž episode task ç›¸å¯¹åº”çš„å¦å¤–ä¸€ç§æ˜¯ continuing tasksï¼Œå®ƒä»¬æŒ‡çš„æ˜¯é‚£äº›ä¸ä¼šè‡ªç„¶ç»“æŸï¼Œä¼šä¸€ç›´æŒç»­è¿›è¡Œçš„ taskï¼Œè¿™æ—¶returnå…¬å¼ï¼ˆ1ï¼‰ä¸­çš„ T=âˆžã€‚ è¿˜æœ‰ä¸€ä¸ªæ¯”è¾ƒé‡è¦çš„æ¦‚å¿µæ˜¯ discountingï¼Œå®ƒæ˜¯å¯¹æœªæ¥ä¸åŒæ—¶åˆ»çš„ reward èµ‹äºˆä¸åŒçš„æƒé‡ï¼Œè·ç¦»çŽ°åœ¨è¾ƒè¿‘çš„ reward çš„æƒé‡è¾ƒé«˜ï¼Œè€Œæ—¶é—´è¶Šè¿œçš„æƒé‡è¶Šä½Žï¼Œè¿™æ—¶é€‰æ‹©è¡Œä¸º At çš„å‡†åˆ™å°±æ˜¯æœ€å¤§åŒ–æœŸæœ›çš„ discounted returnï¼š \[G_t=R_{t+1}+\gamma R_{t+2}+ \gamma^2R_{t+3}+...+\gamma^{T-1}R_T=\sum_{i=0}^\infty\gamma^iR_{i+t+1}\] å…¶ä¸­\(0 \leq \gamma \leq 1\) ç§°ä¸ºæ˜¯ discount rateï¼Œå®ƒä»£è¡¨æœªæ¥ç¬¬ k æ­¥çš„ reward çš„ä»·å€¼åªæ˜¯å½“å‰ç«‹å³èŽ·å¾—çš„ reward çš„\(\gamma^{k-1}\)å€ï¼Œè‹¥ \(\gamma &lt; 1\)ï¼Œåˆ™å½“åºåˆ— {Rk} æœ‰ç•Œçš„æ—¶å€™ Gt å¯ä»¥å¾—åˆ°ä¸€ä¸ªæœ‰é™çš„å€¼ï¼Œè‹¥ Î³=0ï¼Œåˆ™è®¤ä¸ºè¿™ä¸ª agent æ˜¯â€œmyopicâ€ï¼ˆç›®å…‰çŸ­æµ…çš„ï¼‰ï¼Œå®ƒåªå…³å¿ƒå½“å‰çš„ rewardsï¼Œé€‰æ‹©ä¸‹ä¸€ä¸ª \(A_t\) çš„å‡†åˆ™å°±æ˜¯æœ€å¤§åŒ–\(R_{t+1}\)ã€‚Î³ è¶Šè¶‹è¿‘äºŽ 1ï¼Œåˆ™è¿™ä¸ª agent è¶Šæ˜¯å…·æœ‰â€œè¿œè§çš„â€ã€‚ é€æ¸å¿˜è®°æ ‡é¢˜...... æŽ¥ä¸‹æ¥ç»ˆäºŽè¦è®²æœ‰é™é©¬å°”ç§‘å¤«å†³ç­–äº† æœ‰é™é©¬å°”ç§‘å¤«å†³ç­–è¿‡ç¨‹ï¼ˆFinite Markov Decision Processesï¼‰ 1. é©¬å°”ç§‘å¤«æ¨¡åž‹çš„å­æ¨¡åž‹ æœ‰æœºå™¨å­¦ä¹ åŸºç¡€çš„äººï¼Œåº”è¯¥éƒ½çŸ¥é“é©¬å°”ç§‘å¤«é“¾(Markov Chain)å§ï¼Œä¸æ‡‚çš„å¯ä»¥çœ‹è¿™é‡Œï¼šä¼ é€é—¨ï¼Œæˆ‘å°±ä¸åœ¨è¿™é‡Œå¯¹é©¬å°”ç§‘å¤«é“¾å¤šåšè§£é‡Šäº†ï¼Œæ— éžå°±æ˜¯åŸºäºŽæ¦‚çŽ‡çš„çŠ¶æ€è½¬ç§»ç½‘ç»œã€‚ é©¬å°”å¯å¤«å†³ç­–è¿‡ç¨‹(Markov Decision Process, MDP)ä¹Ÿå…·æœ‰é©¬å°”å¯å¤«æ€§ï¼Œä¸Žæ™®é€šçš„é©¬å°”ç§‘å¤«é“¾ä¸åŒçš„æ˜¯MDPè€ƒè™‘äº†åŠ¨ä½œï¼Œå³ç³»ç»Ÿä¸‹ä¸ªçŠ¶æ€ä¸ä»…å’Œå½“å‰çš„çŠ¶æ€æœ‰å…³ï¼Œä¹Ÿå’Œå½“å‰é‡‡å–çš„åŠ¨ä½œæœ‰å…³ã€‚æ¯”å¦‚ä¸‹æ£‹çš„ä¾‹å­ï¼Œå½“æˆ‘ä»¬åœ¨æŸä¸ªå±€é¢ï¼ˆçŠ¶æ€sï¼‰èµ°äº†ä¸€æ­¥(åŠ¨ä½œa)ï¼Œè¿™æ—¶å¯¹æ‰‹çš„é€‰æ‹©ï¼ˆå¯¼è‡´ä¸‹ä¸ªçŠ¶æ€sâ€™ï¼‰æˆ‘ä»¬æ˜¯ä¸èƒ½ç¡®å®šçš„ï¼Œä½†æ˜¯ä»–çš„é€‰æ‹©åªå’Œså’Œaæœ‰å…³ï¼Œè€Œä¸ç”¨è€ƒè™‘æ›´æ—©ä¹‹å‰çš„çŠ¶æ€å’ŒåŠ¨ä½œï¼Œå³sâ€™æ˜¯æ ¹æ®så’Œaéšæœºç”Ÿæˆçš„ã€‚ æˆ‘ä»¬ç”¨ä¸€ä¸ªäºŒç»´è¡¨æ ¼è¡¨ç¤ºä¸€ä¸‹ï¼Œå„ç§é©¬å°”ç§‘å¤«å­æ¨¡åž‹çš„å…³ç³»å°±å¾ˆæ¸…æ¥šäº†ï¼š ä¸è€ƒè™‘åŠ¨ä½œ è€ƒè™‘åŠ¨ä½œ çŠ¶æ€å®Œå…¨å¯è§ é©¬å°”ç§‘å¤«é“¾(MC) é©¬å°”å¯å¤«å†³ç­–è¿‡ç¨‹(MDP) çŠ¶æ€ä¸å®Œå…¨å¯è§ éšé©¬å°”å¯å¤«æ¨¡åž‹(HMM) ä¸å®Œå…¨å¯è§‚å¯Ÿé©¬å°”å¯å¤«å†³ç­–è¿‡ç¨‹(POMDP) 2. é©¬å°”å¯å¤«å†³ç­–è¿‡ç¨‹ ä¸€ä¸ªé©¬å°”å¯å¤«å†³ç­–è¿‡ç¨‹ç”±ä¸€ä¸ªå››å…ƒç»„æž„æˆM = (S, A, Psa, ð‘…) [1] S: è¡¨ç¤ºçŠ¶æ€é›†(states)ï¼Œæœ‰sâˆˆSï¼Œsiè¡¨ç¤ºç¬¬iæ­¥çš„çŠ¶æ€ã€‚ A:è¡¨ç¤ºä¸€ç»„åŠ¨ä½œ(actions)ï¼Œæœ‰aâˆˆAï¼Œ\(a_i\)è¡¨ç¤ºç¬¬iæ­¥çš„åŠ¨ä½œã€‚ ð‘ƒsa: è¡¨ç¤ºçŠ¶æ€è½¬ç§»æ¦‚çŽ‡ã€‚ð‘ƒsð‘Ž è¡¨ç¤ºçš„æ˜¯åœ¨å½“å‰s âˆˆ SçŠ¶æ€ä¸‹ï¼Œç»è¿‡a âˆˆ Aä½œç”¨åŽï¼Œä¼šè½¬ç§»åˆ°çš„å…¶ä»–çŠ¶æ€çš„æ¦‚çŽ‡åˆ†å¸ƒæƒ…å†µã€‚æ¯”å¦‚ï¼Œåœ¨çŠ¶æ€sä¸‹æ‰§è¡ŒåŠ¨ä½œaï¼Œè½¬ç§»åˆ°s'çš„æ¦‚çŽ‡å¯ä»¥è¡¨ç¤ºä¸ºp(s'|s,a)ã€‚ R: SÃ—A\(\rightarrow\)R ï¼ŒRæ˜¯å›žæŠ¥å‡½æ•°(reward function)ã€‚æœ‰äº›å›žæŠ¥å‡½æ•°çŠ¶æ€Sçš„å‡½æ•°ï¼Œå¯ä»¥ç®€åŒ–ä¸ºR: S\(\rightarrow\)â„ã€‚å¦‚æžœä¸€ç»„(s,a)è½¬ç§»åˆ°äº†ä¸‹ä¸ªçŠ¶æ€s'ï¼Œé‚£ä¹ˆå›žæŠ¥å‡½æ•°å¯è®°ä¸ºr(s'|s, a)ã€‚å¦‚æžœ(s,a)å¯¹åº”çš„ä¸‹ä¸ªçŠ¶æ€s'æ˜¯å”¯ä¸€çš„ï¼Œé‚£ä¹ˆå›žæŠ¥å‡½æ•°ä¹Ÿå¯ä»¥è®°ä¸ºr(s,a)ã€‚ MDP çš„åŠ¨æ€è¿‡ç¨‹å¦‚ä¸‹ï¼šæŸä¸ªä¸»ä½“(agent)çš„åˆå§‹çŠ¶æ€ä¸º\(s_0\)ï¼Œç„¶åŽä»Ž A ä¸­æŒ‘é€‰ä¸€ä¸ªåŠ¨ä½œ\(a_0\)æ‰§è¡Œï¼Œæ‰§è¡ŒåŽï¼Œagent æŒ‰\(P_{sa}\)æ¦‚çŽ‡éšæœºè½¬ç§»åˆ°äº†ä¸‹ä¸€ä¸ª\(s_1\)çŠ¶æ€ï¼Œ\(s_1 \in P_{s_0a_0}\)ã€‚ç„¶åŽå†æ‰§è¡Œä¸€ä¸ªåŠ¨ä½œ\(a_1\)ï¼Œå°±è½¬ç§»åˆ°äº†\(s_2\)ï¼ŒæŽ¥ä¸‹æ¥å†æ‰§è¡Œ\(a_2\)â€¦ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸‹é¢çš„å›¾è¡¨ç¤ºçŠ¶æ€è½¬ç§»çš„è¿‡ç¨‹ã€‚ å¦‚æžœå›žæŠ¥ræ˜¯æ ¹æ®çŠ¶æ€så’ŒåŠ¨ä½œaå¾—åˆ°çš„ï¼Œåˆ™MDPè¿˜å¯ä»¥è¡¨ç¤ºæˆä¸‹å›¾ï¼š å¯¹ä¸€ä¸ª Markon çš„çŠ¶æ€ s å’Œä¸‹ä¸€ä¸ªçŠ¶æ€ sâ€²ï¼ŒçŠ¶æ€è½¬ç§»æ¦‚çŽ‡ï¼ˆstatetransition probabilityï¼‰å®šä¹‰ä¸ºï¼š \[P_{ss&#39;}=P[S_{t+1}|S_t=s]\] åˆ™å¯¹åº”çš„æœ‰ä¸€ä¸ªçŠ¶æ€è½¬ç§»çŸ©é˜µï¼ˆState transition matrixï¼‰ï¼šP å®šä¹‰äº†ä»Žæ‰€æœ‰çŠ¶æ€ s åˆ°æ‰€æœ‰å¯èƒ½çš„ä¸‹ä¸€ä¸ªçŠ¶æ€ sâ€² çš„è½¬ç§»æ¦‚çŽ‡ï¼Œå¯ä»¥å†™ä½œä¸ºï¼š æ˜¾ç„¶çŸ©é˜µçš„æ¯ä¸€è¡Œçš„å’Œä¸º1ã€‚ å¯¹äºŽä¸€ä¸ªç‰¹å®šçš„ finite MDPï¼Œå®ƒæ˜¯ç”±çŠ¶æ€è¡Œä¸ºé›†åˆå’ŒçŽ¯å¢ƒçš„ one-step dynamics å®šä¹‰çš„ï¼Œç»™å®šçŠ¶æ€ s å’Œè¡Œä¸º aï¼Œä¸‹ä¸€ä¸ªå¯èƒ½çš„çŠ¶æ€ sâ€² å’Œå¥–åŠ± r å¯¹çš„æ¦‚çŽ‡ä¸ºï¼š \[p(s&#39;,r|s,a)=Pr\{S_{t+1}=S&#39;,R_{t+1}=r|S_t=s,A_t=a\}\] è¿™ä¸ªç­‰å¼å®Œå…¨å®šä¹‰äº†ä¸€ä¸ª finite MDP çš„åŠ¨æ€æ€§ï¼Œä¹‹åŽçš„ç†è®ºåŸºæœ¬éƒ½æ˜¯å»ºç«‹åœ¨å‡è®¾çŽ¯å¢ƒæ˜¯ finite MDP çš„åŸºç¡€ä¸Šçš„ã€‚ åˆæ¥ä¸Šé¢è¿™ä¸ªå¼å­ï¼Œæˆ‘ä»¬å°±å¯ä»¥æŽ¨å¯¼å‡ºå¾ˆå¤šçš„å¼å­ï¼Œæ¯”å¦‚ï¼š state-action pairçš„rewardsæœŸæœ›ä¸ºï¼š \[r(s, a)=E[R_{t+1}|S_t=s,A_t=a]=\sum_{r\in R}r\sum_{s&#39;\in S}p(s&#39;,r|s,a)\] çŠ¶æ€è½¬æ¢æ¦‚çŽ‡ï¼ˆstateâˆ’transitionprobabilitiesï¼‰ä¸ºï¼š \[p(s&#39;,r|s,a)=Pr\{S_{t+1}=S&#39;,R_{t+1}=r|S_t=s,A_t=a\}=\sum_{r\in R}p(s&#39;, r|s, a)\] state-action-next-stateè¿™ä¸ªä¸‰å…ƒç»„åˆå¯¹åº”çš„æœŸæœ› rewards ä¸ºï¼šï¼ˆè¿™ä¸ªæ–¹ç¨‹å…¶å®žç”¨ä¸åˆ°ã€‚ã€‚ã€‚ï¼‰ \[r(s,a, s&#39;)=E[R_{t+1}|S_t=s,At=a,S_{t+1}=s&#39;]=\frac{\sum_{r\in R}rp(s&#39;,r|s,a)}{p(s&#39;|s,a)}\] å¼ºåŒ–å­¦ä¹ æ•°å­¦æ¨¡åž‹ é©¬å°”ç§‘å¤«å†³ç­–è¿‡ç¨‹æ˜¯ä¸€ä¸ªå°†å¼ºåŒ–å­¦ä¹ ä»Žä¸€ä¸ªçŽ°å®žé—®é¢˜è½¬åŒ–æˆæ•°å­¦é—®é¢˜çš„æ¨¡åž‹ å›žé¡¾å¼ºåŒ–å­¦ä¹ é—®é¢˜ å¼ºåŒ–å­¦ä¹ å°±æ˜¯ï¼šè¿½æ±‚æœ€å¤§å›žæŠ¥G è¿½æ±‚æœ€å¤§å›žæŠ¥Gå°±æ˜¯ï¼šæ‰¾åˆ°æœ€ä¼˜çš„ç­–ç•¥Ï€âˆ—ã€‚ ç­–ç•¥Ï€âˆ—å‘Šè¯‰åœ¨çŠ¶æ€sï¼Œåº”è¯¥æ‰§è¡Œä»€ä¹ˆè¡ŒåŠ¨aã€‚ æœ€ä¼˜ç­–ç•¥å¯ä»¥ç”±æœ€ä¼˜ä»·å€¼æ–¹æ³•vâˆ—(s)æˆ–è€…qâˆ—(s,a)å†³å®š æ±‚å‡ºVæˆ–è€…Qå°±ç­‰äºŽè§£å†³äº†å¼ºåŒ–å­¦ä¹ é—®é¢˜ï¼Œå› ä¸ºVå’ŒQèƒ½æŒ‡ç¤ºå‡ºä¸€ä¸ªç­–ç•¥\(\pi\) ç»è¿‡é©¬å°”ç§‘å¤«æ¨¡åž‹çš„è½¬åŒ–ï¼Œå¾—åˆ°æ•°å­¦é—®é¢˜å¦‚ä¸‹ï¼š Reinforcement Learningç›®æ ‡ï¼šå¾—åˆ°ä¸€ä¸ªæœ€ä¼˜ç­–ç•¥\(\pi*â€‹\) æœ€ä¼˜ç­–ç•¥ï¼š\(\pi*=\{\pi(s)|s\in S\}\) å…¶ä¸­æ¯ä¸ªçŠ¶æ€ä¸‹çš„ç­–ç•¥\(\pi(s)\)åˆæœ‰ä¸¤ç§è¡¨ç¤ºæ–¹æ³•ï¼Œåˆ†åˆ«æ˜¯ç”¨stateå’Œstate-actionçš„å€¼å‡½æ•°æ¥è¡¨ç¤º: \(\pi(s)=argmax_aV^\pi(s&#39;|s,a), s&#39;\in S(s)\) \(\pi(s)=argmax_aQ^\pi(s,a)\) ç­‰ä»·äºŽ \(\pi*=V*(s)\) \(\pi*=Q*(s, a)\) ä¸Šå¼è¡¨ç¤ºæˆç¥žç»ç½‘ç»œçš„å½¢å¼å°±æ˜¯ï¼š \(\hat{V}(s,\theta_1)=\theta_1^T\phi(s)\) \(\hat{Q}(s,\theta_2)=\theta_2^T\phi(s, a)\) ä¹Ÿå°±æ˜¯åªè¦æ±‚å‡ºç›®æ ‡çš„Vå’ŒQå°±èƒ½è§£å†³å¼ºåŒ–å­¦ä¹ é—®é¢˜äº†ã€‚ é‚£ä¹ˆå¦‚ä½•æ¥æ±‚Vå’ŒQå‘¢ï¼Ÿ è¿™ä¸ªæ—¶å€™Bellmanå°±è¦å‡ºåœºäº†ã€‚ Bellmanæ–¹ç¨‹ å¥½äº†ç»ˆäºŽè®²åˆ°æˆ‘è®¤ä¸ºReinforcement Learningç†è®ºåŸºç¡€ä¸­æœ€é‡è¦çš„ä¸€ç‚¹äº†ã€‚å¯ä»¥è¯´ä¹‹åŽå¤§éƒ¨åˆ†å¼ºåŒ–å­¦ä¹ éƒ½æ˜¯å»ºç«‹åœ¨Bellmanæ–¹ç¨‹çš„åŸºç¡€ä¹‹ä¸Šçš„ã€‚ é‚£ä¹ˆè®©æˆ‘ä»¬æ¥æŽ¨å¯¼Bellmanæ–¹ç¨‹å§ï¼ˆæ³¨æ„ä¸Šé¢æåˆ°çš„é‚£äº›å…¬å¼å‡ ä¹Žéƒ½æœ‰ç”¨ï¼Œä¸è¦å¿˜äº†ï¼‰ æˆ‘ä»¬å…ˆæ¥åˆ—å‡º\(V^\pi(s)\)çš„å½¢å¼ï¼š \(V^\pi(s)=E_\pi[G_t|S_t=s]\) \(=E_\pi[\sum_{k=0}^\infty\gamma^kR_{t+k+1}|S_t=s]\) \(=E_\pi[R_{t+1}+\gamma\sum_{k=0}^\infty\gamma^kR_{t+k+2}|S_t=s]\) \(=\sum_a\pi(a|s)\sum_{s&#39;}\sum_rp(s&#39;,r|s,a)[r+\gamma E_\pi[\sum_{k=0}^\infty \gamma ^kR_{t+k+2}|S_{t+1}=s&#39;]]\) \(=\sum_a\pi(a|s)\sum_{s&#39;,r}p(s&#39;, r|s,a)[r+\gamma V^\pi(s&#39;)], \forall s\in S\) å…¶ä¸­\(a \in A(s), s&#39; \in S\),ä¸Šé¢çš„å¼å­æˆä¸ºBellman equationï¼Œå¦‚æžœç»™å®šäº†å½“å‰çš„åŠ¨ä½œaé‚£ä¹ˆï¼š \[V^\pi=\sum_{s&#39; \in S}p(s&#39;|s,a)[r(s&#39;|s,a)+\gamma V^\pi(s&#39;)]\] ä¹Ÿå°±æ˜¯ \[Q^\pi(s, a)=\sum_{s&#39; \in S}p(s&#39;|s,a)[r(s&#39;|s,a)+\gamma V^\pi(s&#39;)]\] Bellmanæ–¹ç¨‹çš„å½¢å¼åŒ–ç†è§£ backup diagramsï¼Œå¦‚ä¸‹å›¾çš„ï¼ˆaï¼‰æ‰€ç¤ºï¼Œå…¶ä¸­æ¯ä¸ªç©ºå¿ƒåœ†ä»£è¡¨ä¸€ä¸ªçŠ¶æ€ï¼Œæ¯ä¸ªå®žå¿ƒåœ†ä»£è¡¨ä¸€ä¸ª state-action å¯¹ï¼Œæœ€åˆçš„çŠ¶æ€å³ root node ä½äºŽæœ€ä¸Šé¢ï¼Œåœ¨æ¯ä¸ªçŠ¶æ€ s ä¸‹ï¼Œagent å¯ä»¥ä»Žå¤šä¸ª action ä¸­é€‰æ‹©ï¼Œæ¯å¯¹ (s,a) éƒ½ä¼šä»¥ä¸€å®šçš„æ¦‚çŽ‡è½¬åŒ–åˆ°çŠ¶æ€ sâ€² å¹¶ä¼´éšæœ‰å›žæŠ¥å€¼ rã€‚ ç»“åˆ backup diagramsï¼Œå°±å¯ä»¥æ›´å¥½çš„ç†è§£ Bellman equationï¼Œä»Žå…¬å¼ï¼ˆ3ï¼‰å¯ä»¥çœ‹å‡ºï¼Œå®ƒå¯¹æ‰€æœ‰çš„å¯èƒ½æƒ…å†µè¿›è¡Œäº†å¹³å‡ï¼Œå¹¶ä¸”æ¯ä¸ªéƒ¨åˆ†çš„æƒé‡ä¸ºå®ƒå‘ç”Ÿçš„æ¦‚çŽ‡ã€‚è¿™ç§å›¾ä¹‹æ‰€ä»¥ç§°ä½œæ˜¯ backup diagramsï¼Œæ˜¯å› ä¸ºå®ƒè¡¨è¾¾å‡ºäº† RL æ–¹æ³•ä¸­ update å’Œ backup æ“ä½œçš„åŸºç¡€ï¼Œè¿™äº›æ“ä½œå°† value ä¿¡æ¯ä»Žä¸‹ä¸€ä¸ªçŠ¶æ€ï¼ˆæˆ–ä¸‹ä¸€ä¸ª state-action å¯¹ï¼‰ back åˆ°äº†å½“å‰çš„çŠ¶æ€ï¼ˆæˆ–state-action å¯¹ï¼‰ ä¼˜åŒ–å€¼å‡½æ•° å¥½äº†çŽ°åœ¨æ•°å­¦å…¬å¼å…¨ç»™å‡ºæ¥äº†ï¼Œé‚£ä¹ˆå°±æ˜¯ä¼˜åŒ–ç›®æ ‡äº† è§£å†³RLä»»åŠ¡ï¼Œå°±æ˜¯æ‰¾åˆ°ä¸€ç§ policy æ¥èŽ·å¾—æœ€å¤§çš„é•¿è¿œ rewardï¼Œå¯¹äºŽæœ‰é™çš„MDPsï¼Œå¯ä»¥ç²¾ç¡®åœ°å®šä¹‰ä¸€ç§ä¼˜åŒ–çš„è§„åˆ™ï¼Œä¸Šé¢ä»‹ç»çš„ value function å®šä¹‰äº† policies ä¹‹é—´çš„ä¸€ç§ååºå…³ç³»ï¼Œå› æ­¤å¯ä»¥åˆ©ç”¨å®ƒæ¥å®šä¹‰ optimal policyï¼š å®šä¹‰è§„åˆ™ Ï€ ä¸Ž è§„åˆ™ Ï€â€² ç›¸æ¯”æ›´å¥½æˆ–è€…ç›¸å½“æ˜¯æŒ‡ï¼Œå¯¹æ‰€æœ‰çš„çŠ¶æ€è§„åˆ™Ï€ çš„æœŸæœ› return éƒ½æ¯” è§„åˆ™ Ï€â€² çš„å¤§æˆ–è€…ç›¸ç­‰ã€‚å³ï¼š \[\pi \geq\pi&#39; \sim V^\pi(s) \geq V_{\pi&#39;}(s), \forall s \in S \] åˆ™ optimal policy æŒ‡çš„å°±æ˜¯æ¯”å…¶ä»–æ‰€æœ‰ policies éƒ½å¥½æˆ–è€…ç›¸å½“çš„è§„åˆ™ï¼Œç”¨ç¬¦å· Ï€âˆ— æ¥è¡¨ç¤ºã€‚ åŒæ ·åœ°ï¼Œä¹Ÿå¯ä»¥å®šä¹‰ optimal stateâˆ’value functionï¼Œç”¨ç¬¦å· vâˆ— æ¥è¡¨ç¤ºï¼Œå®šä¹‰å¼ä¸ºï¼š \[V*=max_\pi V^\pi(s), \forall s \in S\] ä¼˜åŒ–çš„ policies ä¹Ÿå…·æœ‰ç›¸åŒçš„ optimal actionâˆ’value functionï¼Œç”¨ qâˆ— æ¥è¡¨ç¤ºï¼Œå®šä¹‰å¼ä¸ºï¼š \[Q*(s,a)=max_\pi Q^\pi(s,a), \forall s \in S, \forall a \in A(s) \] å½“ç„¶ä¼˜åŒ–çš„æ–¹æ³•æœ‰å¾ˆå¤šï¼Œæˆ‘å°†åœ¨ä¸‹ä¸€ç¯‡åšå®¢é‡Œç®€è¦ä»‹ç»ä¼˜åŒ–æ–¹æ³•ï¼Œç„¶åŽå†è¯¦ç»†ä»‹ç»å‡ ä¸ªä¸»æµçš„æ–¹æ³•ã€‚ å‚è€ƒ [1] Reinforcement Learning: An Introduction, Richard S. Sutton and Andrew G. Barto [2] UCL Course on RL [3] https://blog.csdn.net/coffee_cream/article/details/60473789 [4] https://www.cnblogs.com/steven-yang/p/6649213.html]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>æœºå™¨å­¦ä¹ </tag>
        <tag>å¼ºåŒ–å­¦ä¹ </tag>
        <tag>MDP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reinforcement-Learning-1-åŸºæœ¬æ¦‚å¿µ]]></title>
    <url>%2F2018%2F07%2F18%2FReinforcement-Learning-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[å‰è¨€ å¼ºåŒ–å­¦ä¹  (Reinforcement Learning) æ˜¯ä¸€ç±»ç”¨äºŽå¤æ‚åœºæ™¯çš„æœºå™¨å­¦ä¹ ç®—æ³•ï¼Œè¢«å¹¿æ³›åº”ç”¨åœ¨æœºå™¨æŽ§åˆ¶ä»»åŠ¡ä¸­ã€‚è¿‘å‡ å¹´æ¥ï¼Œéšç€ç¥žç»ç½‘ç»œçš„é‡æ–°å…´èµ·ï¼Œå¼ºåŒ–å­¦ä¹ ä¹Ÿè¢«é€æ¸åº”ç”¨åœ¨ä¸€äº›æ–°çš„é¢†åŸŸï¼Œæ¯”å¦‚è‡ªåŠ¨é©¾é©¶ï¼Œè®¡ç®—æœºè§†è§‰ç­‰ã€‚Alpha GO æˆ˜èƒœäººç±»æ£‹æ‰‹æ ‡å¿—ç€æœºå™¨å­¦ä¹ ç‰¹åˆ«æ˜¯å¼ºåŒ–å­¦ä¹ æ­£åœ¨é€æ¸æˆç†Ÿï¼Œæˆä¸ºèƒ½å¤ŸæŽ¨åŠ¨äººå·¥æ™ºèƒ½å–å¾—çªç ´çš„é‡è¦æ–¹å‘ä¹‹ä¸€ã€‚æœ¬æ–‡æ—¨åœ¨ç®€å•çš„ä»‹ç»ä¸€äº›å¼ºåŒ–å­¦ä¹ çš„åŸºæœ¬æ¦‚å¿µï¼Œæ›´åŠ è¯¦ç»†çš„ä»‹ç»ä¼šåœ¨ä»¥åŽçš„åšå®¢ä¸­æ›´æ–°ã€‚ å¼ºåŒ–å­¦ä¹  å®šä¹‰ï¼šReinforcement learning is learning what to do ----how to map situations to actions ---- so as to maximize a numerical reward signal.[1] ç›®å‰çš„æœºå™¨å­¦ä¹ ç®—æ³•ä¸»è¦æœ‰3ç§ï¼š ç›‘ç£å­¦ä¹ ï¼ˆSupervised Learningï¼‰ æ— ç›‘ç£å­¦ä¹ ï¼ˆUnsupervised Learningï¼‰ å¼ºåŒ–å­¦ä¹ ï¼ˆReinforcement Learningï¼‰ ç»“æž„å›¾å¦‚ä¸‹æ‰€ç¤ºï¼š å¼ºåŒ–å­¦ä¹ æ˜¯æœºå™¨å­¦ä¹ çš„ä¸€ä¸ªåˆ†æ”¯ï¼Œä½†æ˜¯å®ƒä¸Žæˆ‘ä»¬å¸¸è§ç›‘ç£å¼å­¦ä¹ ä¸å¤ªä¸€æ ·ã€‚ä»Žå­¦ä¹ æ–¹å¼ä¸Šè®²å¼ºåŒ–å­¦ä¹ æ›´åŠ æŽ¥è¿‘äººç±»çš„å­¦ä¹ ï¼Œå°±åƒæ‰“æ¸¸æˆä¸€æ ·ï¼Œæ¯”å¦‚é¥¥è’ï¼šä¸€å¼€å§‹çŽ©å®¶ä»€ä¹ˆéƒ½ä¸æ‡‚ï¼ŒåªçŸ¥é“è¦æ´»ä¸‹åŽ»ï¼Œæ²¡æœ‰ä»»ä½•æç¤ºã€‚çŽ©æ³•åªèƒ½é€šè¿‡çŽ©å®¶çš„ä¸æ–­çš„å°è¯•ï¼Œé€šè¿‡è¯•é”™å­¦ä¹ ï¼Œç„¶åŽæ ¹æ®çŽ¯å¢ƒç»™äºˆçš„åé¦ˆï¼Œåˆ¤æ–­å½“å‰çš„å°è¯•çš„æ•ˆç›Šï¼Œæœ€åŽç»ˆç»“å‡ºä¸€å¥—æ¸¸æˆçš„ç­–ç•¥ï¼Œæˆä¸ºä¸€åé¥¥è’è€å¸æœºã€‚ å¼ºåŒ–å­¦ä¹ çš„åŸºæœ¬æž„æˆ ä¸»ä½“ï¼ˆAgentï¼‰ï¼šèƒ½å¤Ÿé€šè¿‡åŠ¨ä½œä¸ŽçŽ¯å¢ƒäº¤äº’çš„å¯¹è±¡ï¼Œå¼ºåŒ–å­¦ä¹ ä¸­ä¸»ä½“é€šå¸¸æ˜¯è¿è¡Œä¸­çš„ç®—æ³•ï¼Œæ¯”å¦‚åœ¨é¥¥è’æ¸¸æˆä¸­çš„ä¸»ä½“æ˜¯çŽ©å®¶æŽ§åˆ¶çš„è§’è‰²ï¼Œå¯ä»¥åˆ°å¤„æžç ´å çŽ¯å¢ƒï¼ˆEnvironmentï¼‰ï¼šä¸»ä½“åŠ¨ä½œä½œç”¨çš„å¯¹è±¡ï¼Œ æ¯”å¦‚æ¸¸æˆæœ¬èº«ï¼Œé¥¥è’æ¸¸æˆä¸­çš„çŽ¯å¢ƒå˜åŒ–ï¼Œè§’è‰²çš„å„é¡¹å±žæ€§çš„å˜åŒ–ã€‚ åŠ¨ä½œ ï¼ˆActionï¼‰: æ‰€æœ‰å¯èƒ½ä½œç”¨äºŽçŽ¯å¢ƒä¸Šçš„æ“ä½œï¼Œæ¯”å¦‚æ¸¸æˆä¸­æŽ§åˆ¶è§’è‰²ç æ ‘ã€é‡‡çŸ¿ã€æŠ“èœœèœ‚ç­‰ã€‚ çŠ¶æ€ ï¼ˆStateï¼‰: å¯è¢«ä¸»ä½“æ„ŸçŸ¥çš„å…³äºŽçŽ¯å¢ƒçš„ä¿¡æ¯ï¼Œæ¯”å¦‚æ¸¸æˆä¸­è‡ªç„¶çŽ¯å¢ƒçš„çŠ¶æ€ä»¥åŠè§’è‰²çš„å¥åº·æƒ…å†µ å¥–åŠ± ï¼ˆRewardï¼‰: ç”±çŽ¯å¢ƒå›žé¦ˆç»™ä¸»ä½“çš„æè¿°ä¸Šä¸€ä¸ªåŠ¨ä½œæ•ˆæžœçš„ä¿¡æ¯ï¼Œæ¯”å¦‚è§’è‰²åƒäº†ä¸€ä¸ªé£Ÿç‰©ï¼Œé¥±è…¹æ„Ÿä¸Šå‡ã€åƒäº†è¯ä¹‹åŽï¼Œè¡€é‡å›žå¤ å¼ºåŒ–å­¦ä¹ çš„è¿‡ç¨‹æ˜¯ä¸€ä¸ªé€šè¿‡å’ŒçŽ¯å¢ƒäº¤äº’èŽ·å¾—åé¦ˆï¼Œå†æ ¹æ®åé¦ˆè°ƒæ•´åŠ¨ä½œä»¥æœŸä½¿æ€»å¥–åŠ±æœ€å¤§åŒ–çš„è¿‡ç¨‹ï¼Œè¿™ä¸ªæ˜¯ä¸€ä¸ªå¤šæ­¥ (multi timestep) çš„äº¤äº’çš„è¿‡ç¨‹ï¼Œæ¯ä¸€æ­¥äº¤äº’éƒ½ä¼šå½±å“å…¶åŽçš„æ‰€æœ‰æ­¥éª¤ã€‚å¼ºåŒ–å­¦ä¹ ä¸­çš„ä¸€æ¬¡äº¤äº’æ˜¯æŒ‡ä¸»ä½“å¯¹çŽ¯å¢ƒæ–½åŠ ä¸€ä¸ªåŠ¨ä½œï¼ŒçŽ¯å¢ƒçš„çŠ¶æ€å‘ç”Ÿæ”¹å˜å¹¶ä¸”å›žé¦ˆç»™ä¸»ä½“ä¸€ä¸ªå¥–åŠ±ï¼ˆå¥–åŠ±æ—¢å¯ä»¥æ˜¯æ­£å‘çš„ï¼Œå¦‚æœ¬æ–¹å¾—åˆ†å¢žåŠ ï¼›ä¹Ÿå¯ä»¥æ˜¯è´Ÿå‘çš„ï¼Œå¦‚å¯¹æ–¹å¾—åˆ†å¢žåŠ ï¼‰ã€‚å¼ºåŒ–å­¦ä¹ çš„ç›®æ ‡å°±æ˜¯å¯»æ‰¾ä¸€ä¸ªæœ€ä¼˜çš„ç­–ç•¥ä½¿å¾—æ•´ä¸ªå­¦ä¹ è¿‡ç¨‹ï¼ˆä»Žå¼€å§‹çŠ¶æ€åˆ°ç»ˆç»“çŠ¶æ€ï¼‰èŽ·å¾—çš„å¥–åŠ±æœ€å¤§åŒ–ã€‚ åœ¨å®žçŽ°ä¸Šï¼Œå¼ºåŒ–å­¦ä¹ æ˜¯ä¸€ä¸ªé€šè¿‡å¤šä¸ªè½®æ¬¡é€æ¸ä¼˜åŒ–ç®—æ³•çš„å‚æ•°ä»Žè€Œå¢žå¼ºå­¦ä¹ æ•ˆæžœçš„è¿‡ç¨‹ï¼Œæ¯ä¸ªè½®æ¬¡åŒ…å«ä¸¤éƒ¨åˆ†ï¼šå‰å‘åé¦ˆï¼ˆfeed forwardï¼‰å’Œåå‘ä¼ æ’­ï¼ˆback propagationï¼‰ã€‚å¤„äºŽåˆå§‹çŠ¶æ€çš„ä¸»ä½“æ ¹æ®ç®—æ³•çš„å½“å‰å‚æ•°ç”ŸæˆåŠ¨ä½œä½œç”¨äºŽçŽ¯å¢ƒï¼ŒçŽ¯å¢ƒè¿”å›žç»™ä¸»ä½“æ–°çš„çŠ¶æ€å’Œå¯¹åŠ¨ä½œçš„å¥–åŠ±ï¼Œåœ¨è½®æ¬¡ç»“æŸåŽç®—æ³•é€šè¿‡æ±‡æ€»æ‰€æœ‰åœ¨æœ¬è½®æ”¶é›†åˆ°çš„åé¦ˆè°ƒæ•´ç®—æ³•çš„å‚æ•°å¼€å§‹ä¸‹ä¸€è½®çš„å­¦ä¹ ï¼Œç›´åˆ°å­¦ä¹ çš„æ•ˆæžœä¸å†å¢žå¼ºã€‚ RLä¸Žæœ‰ç›‘ç£å­¦ä¹ ã€æ— ç›‘ç£å­¦ä¹ çš„æ¯”è¾ƒ æœ‰ç›‘ç£çš„å­¦ä¹ æ˜¯ä»Žä¸€ä¸ªå·²ç»æ ‡è®°çš„è®­ç»ƒé›†ä¸­è¿›è¡Œå­¦ä¹ ï¼Œè®­ç»ƒé›†ä¸­æ¯ä¸€ä¸ªæ ·æœ¬çš„ç‰¹å¾å¯ä»¥è§†ä¸ºæ˜¯å¯¹è¯¥situationçš„æè¿°ï¼Œè€Œå…¶labelå¯ä»¥è§†ä¸ºæ˜¯åº”è¯¥æ‰§è¡Œçš„æ­£ç¡®çš„actionï¼Œä½†æ˜¯æœ‰ç›‘ç£çš„å­¦ä¹ ä¸èƒ½å­¦ä¹ äº¤äº’çš„æƒ…æ™¯ï¼Œå› ä¸ºåœ¨äº¤äº’çš„é—®é¢˜ä¸­èŽ·å¾—æœŸæœ›è¡Œä¸ºçš„æ ·ä¾‹æ˜¯éžå¸¸ä¸å®žé™…çš„ï¼Œagentåªèƒ½ä»Žè‡ªå·±çš„ç»åŽ†ï¼ˆexperienceï¼‰ä¸­è¿›è¡Œå­¦ä¹ ï¼Œè€Œexperienceä¸­é‡‡å–çš„è¡Œä¸ºå¹¶ä¸€å®šæ˜¯æœ€ä¼˜çš„ã€‚è¿™æ—¶åˆ©ç”¨RLå°±éžå¸¸åˆé€‚ï¼Œå› ä¸ºRLä¸æ˜¯åˆ©ç”¨æ­£ç¡®çš„è¡Œä¸ºæ¥æŒ‡å¯¼ï¼Œè€Œæ˜¯åˆ©ç”¨å·²æœ‰çš„è®­ç»ƒä¿¡æ¯æ¥å¯¹è¡Œä¸ºè¿›è¡Œè¯„ä»·ã€‚ å› ä¸ºRLåˆ©ç”¨çš„å¹¶ä¸æ˜¯é‡‡å–æ­£ç¡®è¡ŒåŠ¨çš„experienceï¼Œä»Žè¿™ä¸€ç‚¹æ¥çœ‹å’Œæ— ç›‘ç£çš„å­¦ä¹ ç¡®å®žæœ‰ç‚¹åƒï¼Œä½†æ˜¯è¿˜æ˜¯ä¸ä¸€æ ·çš„ï¼Œæ— ç›‘ç£çš„å­¦ä¹ çš„ç›®çš„å¯ä»¥è¯´æ˜¯ä»Žä¸€å †æœªæ ‡è®°æ ·æœ¬ä¸­å‘çŽ°éšè—çš„ç»“æž„ï¼Œè€ŒRLçš„ç›®çš„æ˜¯æœ€å¤§åŒ–reward signalã€‚ æ€»çš„æ¥è¯´ï¼ŒRLä¸Žå…¶ä»–æœºå™¨å­¦ä¹ ç®—æ³•ä¸åŒçš„åœ°æ–¹åœ¨äºŽï¼šå…¶ä¸­æ²¡æœ‰ç›‘ç£è€…ï¼Œåªæœ‰ä¸€ä¸ªrewardä¿¡å·ï¼›åé¦ˆæ˜¯å»¶è¿Ÿçš„ï¼Œä¸æ˜¯ç«‹å³ç”Ÿæˆçš„ï¼›æ—¶é—´åœ¨RLä¸­å…·æœ‰é‡è¦çš„æ„ä¹‰ï¼›agentçš„è¡Œä¸ºä¼šå½±å“ä¹‹åŽä¸€ç³»åˆ—çš„dataã€‚ RLçš„ä¸»è¦ç‰¹ç‚¹ å…¶ä»–è®¸å¤šæœºå™¨å­¦ä¹ ç®—æ³•ä¸­å­¦ä¹ å™¨éƒ½æ˜¯å­¦å¾—æ€Žæ ·åšï¼Œè€ŒRLæ˜¯åœ¨å°è¯•çš„è¿‡ç¨‹ä¸­å­¦ä¹ åˆ°åœ¨ç‰¹å®šçš„æƒ…å¢ƒä¸‹é€‰æ‹©å“ªç§è¡ŒåŠ¨å¯ä»¥å¾—åˆ°æœ€å¤§çš„å›žæŠ¥ã€‚åœ¨å¾ˆå¤šåœºæ™¯ä¸­ï¼Œå½“å‰çš„è¡ŒåŠ¨ä¸ä»…ä¼šå½±å“å½“å‰çš„rewardsï¼Œè¿˜ä¼šå½±å“ä¹‹åŽçš„çŠ¶æ€å’Œä¸€ç³»åˆ—çš„rewardsã€‚RLæœ€é‡è¦çš„3ä¸ªç‰¹å®šåœ¨äºŽï¼š åŸºæœ¬æ˜¯ä»¥ä¸€ç§é—­çŽ¯çš„å½¢å¼ ä¸ä¼šç›´æŽ¥æŒ‡ç¤ºé€‰æ‹©å“ªç§è¡ŒåŠ¨ï¼ˆactionsï¼‰ ä¸€ç³»åˆ—çš„actionså’Œå¥–åŠ±ä¿¡å·ï¼ˆreward signalsï¼‰éƒ½ä¼šå½±å“ä¹‹åŽè¾ƒé•¿çš„æ—¶é—´ã€‚ å¼ºåŒ–å­¦ä¹ æ˜¯æœºå™¨å­¦ä¹ ä¸­ä¸€ä¸ªéžå¸¸æ´»è·ƒä¸”æœ‰è¶£çš„é¢†åŸŸï¼Œç›¸æ¯”å…¶ä»–å­¦ä¹ æ–¹æ³•ï¼Œå¢žå¼ºå­¦ä¹ æ›´æŽ¥è¿‘ç”Ÿç‰©å­¦ä¹ çš„æœ¬è´¨ï¼Œå› æ­¤æœ‰æœ›èŽ·å¾—æ›´é«˜çš„æ™ºèƒ½ï¼Œè¿™ä¸€ç‚¹åœ¨æ£‹ç±»æ¸¸æˆä¸­å·²ç»å¾—åˆ°ä½“çŽ°ã€‚Tesauro(1995)æè¿°çš„TD-Gammonç¨‹åºï¼Œä½¿ç”¨å¢žå¼ºå­¦ä¹ æˆä¸ºäº†ä¸–ç•Œçº§çš„è¥¿æ´‹åŒé™†æ£‹é€‰æ‰‹ã€‚è¿™ä¸ªç¨‹åºç»è¿‡150ä¸‡ä¸ªè‡ªç”Ÿæˆçš„å¯¹å¼ˆè®­ç»ƒåŽï¼Œå·²ç»è¿‘ä¼¼è¾¾åˆ°äº†äººç±»æœ€ä½³é€‰æ‰‹çš„æ°´å¹³ï¼Œå¹¶åœ¨å’Œäººç±»é¡¶çº§é«˜æ‰‹çš„è¾ƒé‡ä¸­å–å¾—40 ç›˜ä»…è¾“1ç›˜çš„å¥½æˆç»©ã€‚ å‚è€ƒ [1] R.Sutton et al. Reinforcement learning: An introduction , 1998 [2] UCL Course on RL]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>æœºå™¨å­¦ä¹ </tag>
        <tag>å¼ºåŒ–å­¦ä¹ </tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ·±åº¦å¼ºåŒ–å­¦ä¹ ï¼ˆDRLï¼‰æ¼«è°ˆ-ä»ŽDQNåˆ°AlphaGo]]></title>
    <url>%2F2018%2F07%2F17%2F%E6%B7%B1%E5%BA%A6%E5%A2%9E%E5%BC%BA%E5%AD%A6%E4%B9%A0%EF%BC%88DRL%EF%BC%89%E6%BC%AB%E8%B0%88-%E4%BB%8EDQN%E5%88%B0AlphaGo%2F</url>
    <content type="text"><![CDATA[æœ€è¿‘åˆšåˆšå¼€å§‹å­¦ä¹ Reinforcement Learningï¼Œçœ‹åˆ°ä¸€ç¯‡ä»‹ç»åšå®¢å†™çš„æ¯”è¾ƒå¥½ï¼Œè½¬è½½ä¸€ä¸‹ã€‚ åŽŸæ–‡é“¾æŽ¥ æ·±åº¦å¼ºåŒ–å­¦ä¹ ï¼ˆDeep reinforcement learning, DRLï¼‰æ˜¯DeepMindï¼ˆåŽè¢«è°·æ­Œæ”¶è´­ï¼‰è¿‘å‡ è¿‘æ¥é‡ç‚¹ç ”ç©¶ä¸”å‘æ‰¬å…‰å¤§çš„æœºå™¨å­¦ä¹ ç®—æ³•æ¡†æž¶ã€‚ä¸¤ç¯‡Natureä¸Šçš„å¥ åŸºæ€§è®ºæ–‡ï¼ˆDQNå’ŒAlphaGoï¼‰ä½¿å¾—DRLè¿™ä¸€æ·±åº¦å­¦ä¹ ï¼ˆDeep learning, DLï¼‰å’Œå¼ºåŒ–å­¦ä¹ ï¼ˆReinforcement learning, RLï¼‰çš„äº¤å‰æ–¹å‘å˜å¾—ç‚™æ‰‹å¯çƒ­ã€‚å†åŠ ä¸Šå¤šä¸ªå½±å“è¾ƒå¤§çš„benchmarkï¼ˆAtari 2600ï¼Œå›´æ£‹ç­‰ï¼‰ä¸Šæ¼‚äº®çš„æˆç»©ä½¿å®ƒå¦‚ä»Šå€å—å­¦æœ¯ç•Œå’Œå•†ä¸šç•Œçš„å…³æ³¨ï¼Œç”šè‡³è®©äººé—»åˆ°äº†æ³¡æ²«çš„å‘³é“ã€‚ä¸ç®¡æ€Žæ ·ï¼Œå®ƒè¿˜æ˜¯éžå¸¸æˆåŠŸåœ°å¼€åˆ›äº†æ–°çš„æ–¹å‘ï¼Œæ—¢å…·æœ‰æžå¤§å­¦æœ¯ä»·å€¼ä¹Ÿå…·æœ‰é¢‡é«˜çš„å•†ä¸šä»·å€¼ã€‚å°½ç®¡ä¹‹åŽç”¨äºŽè§£å†³åƒå›´æ£‹è¿™æ ·çš„å¤§è§„æ¨¡æœç´¢é—®é¢˜ï¼Œä½†DQNå‡ºçŽ°ä¹‹åˆçš„æœ€å¤§æ„ä¹‰åœ¨äºŽç®—æ³•çš„é€šç”¨æ€§ã€‚å› ä¸ºæ³›åŒ–æ€§å‘æ¥æ˜¯æœºå™¨å­¦ä¹ æœ€å¤§çš„æŒ‘æˆ˜ä¹‹ä¸€ï¼Œå®ƒæ‰æ˜¯æœºå™¨å’Œäººç›¸æ¯”å¼±å¤ªå¤šçš„åœ°æ–¹ï¼Œä¹Ÿæ˜¯å¾ˆå¤šæœºå™¨å­¦ä¹ ç®—æ³•æœ€æœ‰å¾…æ”¹è¿›çš„åœ°æ–¹ã€‚ä»Šå¤©æˆ‘ä»¬çœ‹å„ç§å°æŠ¥ä¸Šå¯¹äººå·¥æ™ºèƒ½ç ”ç©¶æˆæžœçš„æŠ¥é“éƒ½å–œæ¬¢æ–­ç« å–ä¹‰ï¼Œæ‹¿ç‰¹å®šæ•°æ®é›†ä¸Šçš„å‡†ç¡®æ€§è¯´äº‹ï¼Œè™½ç„¶é‚£ä¹Ÿå¾ˆç‰›Xï¼Œä½†ä¸€å®šç¨‹åº¦ä¸Šå¿½ç•¥äº†é€šç”¨æ€§ä¹Ÿæ˜¯æœºå™¨å­¦ä¹ èµ°å‘å¤§ä¼—æœ€å¤§ç“¶é¢ˆä¹‹ä¸€çš„äº‹å®žã€‚ ä»Šå¤©æˆ‘ä»¬å°±æŠ±ç€â€œçŸ¥å…¶ç„¶çŸ¥å…¶æ‰€ä»¥ç„¶â€çš„æ€åº¦ï¼Œçœ‹çœ‹å®ƒçš„æ¼”å˜åŽ†ç¨‹ã€‚å…¶å®žDQNå¹¶ä¸æ˜¯ä¸€è¹´è€Œå°±ï¼Œå®ƒæ˜¯åŸºäºŽä¸€ä¸ªå¤è€çš„äººå·¥æ™ºèƒ½æ–¹å‘ï¼Œå³å¼ºåŒ–å­¦ä¹ ã€‚å¼ºåŒ–å­¦ä¹ ä¸åŒä¸Žæœºå™¨å­¦ä¹ ä¸­å…¶å®ƒä¸¤å¤§ç±»å­¦ä¹ æ–¹æ³•-ç›‘ç£å­¦ä¹ ï¼ˆsupervised learning, SLï¼‰å’Œéžç›‘ç£å­¦ä¹ ï¼ˆunsupervised learning, ULï¼‰ï¼Œå…¶åŸºæœ¬æ€æƒ³æ˜¯å€Ÿé‰´äººç±»å­¦ä¹ çš„è¿‡ç¨‹ï¼Œè®©agentï¼ˆæ™ºèƒ½ä½“ï¼Œæˆ–ç§°å­¦ä¹ ä½“ï¼‰é€šè¿‡ä¸æ–­è¯•é”™æ¥æ‰¾å¯»æœ€ä¼˜ç­–ç•¥ï¼Œè€Œæˆ‘ä»¬åªéœ€è¦è®¾ç½®å›žæŠ¥ï¼ˆå¥–åŠ±å’Œæƒ©ç½šï¼‰å³å¯ã€‚ä½†ç”±äºŽå…¶å±€é™æ€§ï¼ˆæ¯”å¦‚å¼ºä¾èµ–äºŽäººå·¥è®¾è®¡çš„ç‰¹å¾è´¨é‡ç­‰ï¼‰ï¼Œé•¿æœŸå¤„äºŽä¸æ¸©ä¸ç«çš„å¢ƒåœ°ï¼Œç›´åˆ°DQNä½¿å®ƒè€æ ‘å‘æ–°èŠ½ï¼Œé‡èŽ·æ–°ç”Ÿã€‚NIPS 2013è®ºæ–‡ã€ŠPlaying Atari with Deep Reinforcement Learningã€‹æå‡ºçš„æ·±åº¦Qå­¦ä¹ ï¼ˆDeep Q-learningï¼ŒDQNï¼‰æ˜¯åŸºäºŽå¼ºåŒ–å­¦ä¹ ä¸­çš„Qå­¦ä¹ ï¼ˆQ-learningï¼‰ã€‚é‚£æˆ‘ä»¬å°±ä»¥å®ƒä¸ºåˆ‡å…¥ç‚¹ï¼Œæ¥çœ‹ä¸€ä¸‹Q-learningæ˜¯æ€Žä¹ˆæ¥çš„ã€‚Suttonçš„ç»å…¸è‘—ä½œã€ŠReinforcement Learning: An Introductionã€‹ä¸­å¯¹å¸¸è§„çš„å¼ºåŒ–å­¦ä¹ æ–¹æ³•åšäº†éžå¸¸å¥½çš„æ€»ç»“ã€‚æˆ‘ä»¬å°±å‚è€ƒå®ƒç²—ç³™åœ°å‹¾å‹’ä¸‹Q-learningåœ¨å…¶ä¸­çš„å¤§ä½“ä½ç½®ã€‚ ä»Žå›¾ä¸­å¯ä»¥çœ‹åˆ°ï¼Œå¼ºåŒ–å­¦ä¹ å‘å±•äº†å‡ åå¹´ï¼Œå·²ç»å¼€æžæ•£å¶ï¼Œæœ‰äº†å¾ˆå¤šåˆ†æ”¯ã€‚1989å¹´ç”±Watkinsæå‡ºçš„Qå­¦ä¹ æ˜¯ä¸€ç§model-freeï¼ˆä¸ç”¨å­¦ä¹ çŽ¯å¢ƒæ¨¡åž‹ï¼‰çš„åŸºäºŽoff-policyï¼ˆå­¦ä¹ è¿‡ç¨‹ä¸­æ‰§è¡Œçš„ç­–ç•¥ä¸Žå€¼ä¼°è®¡ä½¿ç”¨çš„ç­–ç•¥ä¸ä¸€æ ·ï¼‰çš„temporal differenceï¼ˆTDï¼‰æ–¹æ³•ï¼Œä¹Ÿæ˜¯RLä¸­æµä¼ æœ€ä¸ºå¹¿æ³›çš„ä¸€ç§å­¦ä¹ æ–¹æ³•ã€‚ æŽ¥ä¸‹æ¥è¯é”‹ä¸€è½¬å°±éœ€è¦è®²å‡½æ•°é€¼è¿‘ï¼ˆFunction approximationï¼ŒFAï¼‰äº†ã€‚å› ä¸ºæœ€åŽŸå§‹çš„è¡¨æ ¼æ³•ï¼ˆtabular methodï¼‰æ¥è¡¨ç¤ºç›®æ ‡å‡½æ•°ï¼ˆVæˆ–Qå‡½æ•°ï¼‰æ¯•ç«Ÿç”¨é€”æœ‰é™ï¼Œä¸”å¤šç”¨äºŽç¦»æ•£ç©ºé—´ã€‚è€Œå‡½æ•°é€¼è¿‘ç›¸æ¯”ä¹‹ä¸‹å¯æœ‰ä¸å°‘å¥½å¤„ï¼šæ¯”å¦‚ä¸€å¯ä»¥é™ä½Žè¾“å…¥ç»´åº¦ï¼Œå‡å°‘è®¡ç®—é‡ï¼›äºŒå¯ä»¥æé«˜æ³›åŒ–èƒ½åŠ›ï¼Œé¿å…è¿‡å­¦ä¹ ï¼ˆover-fittingï¼‰ï¼›ä¸‰å¯ä»¥ä½¿ç›®æ ‡å‡½æ•°å¯¹äºŽå‚æ•°å¯å¾®ï¼Œç”¨ä¸ŠåŸºäºŽæ¢¯åº¦çš„è®¡ç®—æ–¹æ³•ã€‚å‰é¢æåˆ°RLçš„å±€é™ä¹‹ä¸€å°±æ˜¯éœ€è¦äººå·¥è®¾è®¡çš„ç‰¹å¾ã€‚è®¾è®¡çš„ä¸å¥½åŽé¢çš„ç®—æ³•å†å¥½ä¹Ÿç™½æ­ã€‚è¿™å…¶å®žä¸åªé’ˆå¯¹RLï¼Œä»¥å‰æˆ‘ä»¬çœ‹åˆ°åˆ†ç±»æˆ–å›žå½’é—®é¢˜ç»“æžœä¸å¥½ï¼Œå°±åŽ»æ¢å…¶å®ƒç®—æ³•æˆ–æ”¹è¿›ç®—æ³•æœ¬èº«ã€‚åŽæ¥å‘çŽ°åªè¦ç‰¹å¾é€‰å–åˆé€‚æˆ–è®¾è®¡åˆç†ï¼Œå¾ˆå¤šæ—¶å€™ç®—æ³•çš„ç»“æžœéƒ½æ²¡æœ‰æ˜¾è‘—å·®å¼‚ã€‚å…¶å®žæ·±åº¦å­¦ä¹ æœ¬èº«ä¹Ÿæ­£æ˜¯æŠŠæ›´å¤šæ³¨æ„åŠ›æ‹‰å›žåˆ°ç‰¹å¾å­¦ä¹ ä¸Šæ¥ã€‚å›žåˆ°æ­£é¢˜ï¼Œå‡½æ•°é€¼è¿‘åˆ†ä¸ºä¸¤å¤§ç±»ï¼šçº¿æ€§å’Œéžçº¿æ€§çš„ã€‚å‰è€…ä¸€èˆ¬æ˜¯ç”¨ä¸€ç³»åˆ—ç‰¹å¾çš„çº¿æ€§ç»„åˆï¼Œå®ƒä»¬çš„æƒé‡ä½œä¸ºå‚æ•°ã€‚ä¼˜ç‚¹è‡ªç„¶æ˜¯è®¡ç®—æ–¹ä¾¿ï¼Œç®—æ³•å¥½å®žçŽ°ã€‚åŽè€…å°±æ¯”å¦‚ç”¨ç¥žç»ç½‘ç»œï¼ˆNeural networkï¼ŒNNï¼‰ï¼Œä¼˜ç‚¹æ˜¯è¡¨è¾¾èƒ½åŠ›å¤§å¤§åŠ å¼ºï¼Œç¼ºç‚¹æ˜¯è®­ç»ƒèµ·æ¥ä¹Ÿéº»çƒ¦å¾—å¤šã€‚å½“ç„¶ï¼Œç”¨NNæ¥é€¼è¿‘ç›®æ ‡å‡½æ•°ï¼ˆæ¯”å¦‚å€¼å‡½æ•°ï¼‰æ—©å·²è¢«äººç ”ç©¶è¿‡ï¼Œæ¯•ç«Ÿä¸Šä¸–çºª80å¹´ä»£çš„æ—¶å€™ç¥žç»ç½‘ç»œä¹Ÿå¦‚åŒä»Šå¤©çš„æ·±åº¦å­¦ä¹ ä¸€æ ·é¦™é¥½é¥½ã€‚æ¯”å¦‚ä¸Šä¸–çºªçš„TD-Gammonï¼Œå¯ä»¥è¯´æ˜¯å½“æ—¶RLåœ¨åšå¼ˆåº”ç”¨çš„ç»å…¸ï¼Œå°±æ˜¯ç”¨äº†å¤šå±‚ç¥žç»ç½‘ç»œä½œä¸ºå‡½æ•°é€¼è¿‘ã€‚ä½†æ·±åº¦å­¦ä¹ å‰çš„ç¥žç»ç½‘ç»œåŠŸèƒ½ä¸Šåªç”¨äºŽåˆ†ç±»æˆ–å›žå½’ï¼Œæ²¡æœ‰æ— ç›‘ç£å­¦ä¹ æå–ç‰¹å¾çš„åŠŸèƒ½ï¼Œå› æ­¤éš¾ä»¥ç›´æŽ¥å¤„ç†è£¸æ•°æ®ï¼Œæ¯”å¦‚åƒç´ çº§æ•°æ®ï¼ˆraw pixelsï¼‰ã€‚ NIPS 2013 ã€ŠPlaying Atari with Deep Reinforcement Learningã€‹ åˆ°è¿™é‡Œä¸ºæ­¢ï¼Œè¿˜æ²¡æœ‰æ·±åº¦å­¦ä¹ åŠæ¯›é’±å…³ç³»ï¼Œå¾ˆå¤šéƒ½æ˜¯äºŒï¼Œä¸‰åå¹´å‰çš„ä¸œè¥¿ã€‚ä½œä¸‹ç®€å•çš„é“ºåž«åŽï¼ŒæŽ¥ä¸‹æ¥æˆ‘ä»¬çœ‹ä¸‹DLæ˜¯æ€Žä¹ˆè®©è¿™äº›ç»å…¸æ–¹æ³•æ¢å‘é’æ˜¥çš„ã€‚DQNä¸­çš„è¾“å…¥é‡‡ç”¨çš„æ˜¯åŽŸå§‹å›¾åƒæ•°æ®ï¼Œå¯ä»¥è¯´åŸºæœ¬æ˜¯è£¸æ•°æ®äº†ã€‚è¿™æ˜¯DQNæœ€æœ‰æ„ä¹‰çš„ä¸€æ­¥äº†ã€‚åœ¨DNNå‰å–‚è£¸æ•°æ®ä¸€èˆ¬æ•ˆæžœéƒ½ä¸æ€Žä¹ˆç†æƒ³ï¼Œå› ä¸ºä¸€èˆ¬çš„ANNæ— æ³•é€šè¿‡è‡ªåŠ¨è®­ç»ƒcatchåˆ°å…¶ä¸­çš„éšå«ç‰¹å¾ã€‚è€Œè¿™å‡ å¹´æ¶ŒçŽ°çš„ä¸€äº›æˆæžœï¼Œæ¯”å¦‚è®ºæ–‡ã€ŠImagenet classification with deep convolutional neural networksã€‹ç­‰ï¼Œæžå¤§åœ°å¼ºåŒ–äº†DLå¤„ç†raw pixelsæ•°æ®çš„ä¿¡å¿ƒã€‚è¯´å®žè¯ï¼Œçº¯æ‹¼Atariæˆç»©çš„è¯ï¼Œä»»ä½•ä¸€ä¸ªæ¸¸æˆéƒ½å¯ä»¥é€šè¿‡é’ˆå¯¹æ€§çš„ç®—æ³•å–å¾—éžå¸¸é«˜çš„æˆç»©ï¼Œä½†DQNèƒ½å‘è¡¨åœ¨Natureä¸Šï¼Œäº†ä¸èµ·åœ¨å®ƒçš„ç®—æ³•å¯¹æ‰€æœ‰æ¸¸æˆæ˜¯é€šç”¨çš„ï¼ˆç”šè‡³è¶…å‚æ•°ä¹Ÿæ˜¯é€šç”¨çš„ï¼‰ï¼Œè€Œè¿™ç§é€šç”¨æ€§çš„é‡è¦åŸºç¡€ä¹‹ä¸€å°±æ˜¯å®ƒèƒ½åƒraw pixelsã€‚å½“ç„¶å®ƒçš„æ„ä¹‰ä¸æ­¢äºŽæ­¤ï¼Œå®ƒå®žçŽ°äº†å¾ˆå¥½çš„æ•ˆæžœå‘å…¨ä¸–ç•Œè¯æ˜Žäº†è¯¥æ–¹æ³•çš„æœ‰æ•ˆæ€§ï¼Œè€Œå…¶ä¸­çš„ä¸€å¤§åŠŸè‡£å°±æ˜¯experience replayã€‚è¯¥æ–¹æ³•åœ¨Long-Ji Lin 1993å¹´çš„æ¯•ä¸šè®ºæ–‡ä¸­æœ‰è¾ƒè¯¦ç»†çš„ä»‹ç»ï¼Œå…¶ä¸»è¦ä½œç”¨æ˜¯å…‹æœç»éªŒæ•°æ®çš„ç›¸å…³æ€§ï¼ˆcorrelated dataï¼‰å’Œéžå¹³ç¨³åˆ†å¸ƒï¼ˆnon-stationary distributionï¼‰é—®é¢˜ã€‚å®ƒçš„åšæ³•æ˜¯ä»Žä»¥å¾€çš„çŠ¶æ€è½¬ç§»ï¼ˆç»éªŒï¼‰ä¸­éšæœºé‡‡æ ·è¿›è¡Œè®­ç»ƒã€‚è¿™æ ·è‡³å°‘æœ‰ä¸¤ä¸ªå¥½å¤„ï¼š1. æ•°æ®åˆ©ç”¨çŽ‡é«˜ï¼Œå› ä¸ºä¸€ä¸ªæ ·æœ¬è¢«å¤šæ¬¡ä½¿ç”¨ã€‚2. è¿žç»­æ ·æœ¬çš„ç›¸å…³æ€§ä¼šä½¿å‚æ•°æ›´æ–°çš„æ–¹å·®ï¼ˆvarianceï¼‰æ¯”è¾ƒå¤§ï¼Œè¯¥æœºåˆ¶å¯å‡å°‘è¿™ç§ç›¸å…³æ€§ã€‚æ³¨æ„è¿™é‡Œç”¨çš„æ˜¯éšæœºé‡‡æ ·ï¼Œè¿™ä¹Ÿç»™ä¹‹åŽçš„æ”¹è¿›åŸ‹ä¸‹äº†ä¼ç¬”ã€‚ Nature 2015ã€ŠHuman-level control through deep reinforcement learningã€‹ ä»¥ä¸Šæ˜¯NIPS 2013è®ºæ–‡ä¸­æå‡ºçš„DQNåŽŸåž‹ã€‚ä¹‹åŽNature 2015çš„è®ºæ–‡ã€ŠHuman-level control through deep reinforcement learningã€‹å¯¹ä¹‹ä½œäº†æ”¹è¿›å’Œå®Œå–„ã€‚å…¶ä¸­å¯¹äºŽç®—æ³•ä¸Šçš„å˜åŒ–æœ€ä¸»è¦æ˜¯å¼•å…¥äº†å•ç‹¬çš„Qå‡½æ•°ç½‘ç»œã€‚ç ”ç©¶è€…åœ¨å®žè·µä¸­å‘çŽ°å½“ä½¿ç”¨å¦‚NNè¿™æ ·çš„éžçº¿æ€§å‡½æ•°é€¼è¿‘å™¨é€¼è¿‘Qå‡½æ•°æ—¶RLå­¦ä¹ è¿‡ç¨‹å¹¶ä¸ç¨³å®šã€‚è¿™ç§ä¸ç¨³å®šæœ‰å‡ ç§åŽŸå› ï¼šç»éªŒæ•°æ®ï¼ˆå³è§‚å¯Ÿåºåˆ—ï¼‰å…·æœ‰ç›¸å…³æ€§ã€‚Qå‡½æ•°çš„å¾®å°æ”¹å˜ä¼šå¼•èµ·ç­–ç•¥ï¼ˆpolicyï¼‰çš„å·¨å¤§æ”¹å˜ï¼Œè¿›è€Œæ”¹å˜è®­ç»ƒæ•°æ®åˆ†å¸ƒï¼Œä»¥åŠQå‡½æ•°ä¸ŽQå‡½æ•°ç›®æ ‡ä¹‹é—´çš„å·®å€¼ã€‚å‰è€…å¯ä»¥ç”¨experience replayè§£å†³ï¼ˆå‚è§NIPS 2013è®ºæ–‡ï¼‰ã€‚åŽè€…å¯é‡‡ç”¨è¿­ä»£å¼æ›´æ–°ï¼ˆiterative updateï¼‰è§£å†³ï¼ˆNature 2015å¼•å…¥ï¼‰ã€‚ è¯¥æ–¹æ³•å³Qå‡½æ•°çš„å‚æ•°åªåœ¨ä¸€å®šæ­¥æ•°åŽæ‰æ›´æ–°ï¼Œç›¸å½“äºŽå»¶è¿Ÿæ›´æ–°æ¥å‡å°‘Qå‡½æ•°å’ŒQå‡½æ•°ç›®æ ‡é—´çš„ç›¸å…³æ€§ã€‚ç›´è§‚ä¸Šï¼Œæ•´ä¸ªè®­ç»ƒå­¦ä¹ è¿‡ç¨‹å…¶å®žå°±æ˜¯Qå‡½æ•°å‘Qå‡½æ•°ç›®æ ‡é€¼è¿‘çš„è¿‡ç¨‹ï¼Œè¯•æƒ³ä¸‹ï¼Œå¦‚æžœç›®æ ‡ä¹Ÿè·Ÿç€å­¦ä¹ ä½“ä¸€èµ·å˜ï¼Œé‚£åŠ¿å¿…å¯¹æ”¶æ•›æ€§é€ æˆå½±å“ã€‚ åˆ°è¿™é‡Œä¸ºæ­¢ï¼Œåœ¨Qå­¦ä¹ çš„åŸºç¡€ä¸Šï¼ŒDQNçš„å¤§è‡´æ¼”è¿›è·¯çº¿å¦‚ä¸‹ã€‚ ä¹‹åŽï¼ŒDeepMindçš„å¤§ç‰›ä»¬ä¸€åˆ»ä¸åœåœ°åœ¨AAAIï¼ŒICMLç­‰é¡¶çº§ä¼šè®®ä¸­ç›¸ç»§å¯¹DQNä½œäº†æ”¹è¿›ï¼Œä½¿å…¶æˆç»©ä¸Žæ€§èƒ½æœ‰äº†è´¨çš„é£žè·ƒã€‚æŒ‰æ—¶é—´é¡ºåºä¸»è¦æœ‰ä¸‹é¢è®ºæ–‡ï¼š AAAI 2016 ã€ŠDeep Reinforcement Learning with Double Q-learningã€‹ ç ”ç©¶è€…å‘çŽ°ï¼ŒQå­¦ä¹ ä¸­çš„overestimationé—®é¢˜ï¼ˆåœ¨ç¡®å®šçŠ¶æ€ä¸‹Qå€¼ä¼°è®¡åé«˜ï¼‰å¯èƒ½å¯¼è‡´éžæœ€ä¼˜è§£å’Œå­¦ä¹ è¿‡ç¨‹ç¨³å®šæ€§ä¸‹é™ã€‚æœ€åˆThrun &amp; Schwartzå¼€å§‹æŽ¢è®¨è¯¥é—®é¢˜ï¼Œè¯æ˜Žäº†åœ¨ä½¿ç”¨å‡½æ•°é€¼è¿‘å™¨æ—¶overestimationå¯èƒ½å¯¼è‡´éžæœ€ä¼˜è§£ã€‚ä¹‹åŽvan Hasseltå‘çŽ°å³ä½¿ç”¨è¡¨æ ¼è¡¨ç¤ºæ³•çš„æƒ…å†µä¸‹ï¼ŒçŽ¯å¢ƒä¸­çš„å™ªå£°ä¹Ÿèƒ½å¯¼è‡´overestimationï¼Œå¹¶ä¸”æå‡ºäº†è§£å†³æ–¹æ¡ˆDouble Q-learningã€‚è€ŒDQNæ˜¯åŸºäºŽQ-learningï¼Œæ‰€ä»¥æœ¬è´¨ä¸Šä¹Ÿæœ‰è¿™ä¸ªé—®é¢˜ã€‚å› æ­¤å°†Double Q-learningç»“åˆè¿›DQNå¯ä»¥æ”¹å–„ã€‚å…¶åŸºæœ¬æ€æƒ³æ˜¯å°†é€‰æ‹©å’Œè¯„ä¼°åŠ¨ä½œåˆ†ç¦»ï¼Œè®©å®ƒä»¬ä½¿ç”¨ä¸åŒçš„Qå‡½æ•°ï¼ˆç½‘ç»œï¼‰ã€‚å…¶ä¸­ä¸€ä¸ªç”¨äºŽäº§ç”Ÿè´ªå©ªç­–ç•¥ï¼ˆgreedy policyï¼‰ï¼Œå¦ä¸€ä¸ªç”¨äºŽäº§ç”ŸQå‡½æ•°ä¼°è®¡å€¼ã€‚å®žçŽ°æ—¶ä¼šæœ‰ä¸¤ä¸ªQå‡½æ•°ç½‘ç»œï¼šåŽŸDQNä¸­çš„Qå‡½æ•°ç½‘ç»œç§°ä¸ºåœ¨çº¿ç½‘ç»œï¼ˆonline networkï¼‰ï¼ŒåŽè€…ç§°ä¸ºç›®æ ‡ç½‘ç»œï¼ˆtarget networkï¼‰ã€‚ç”±äºŽNatureç‰ˆDQNå·²ç»å¼•å…¥äº†å•ç‹¬çš„Qç›®æ ‡ç½‘ç»œï¼Œæ‰€ä»¥Double DQNå¯¹DQNæž¶æž„åŸºæœ¬ä¸éœ€ä»€ä¹ˆæ”¹åŠ¨ï¼Œåªéœ€æŠŠç›®æ ‡ç½‘ç»œçš„å‚æ•°å’Œåœ¨çº¿ç½‘ç»œçš„å‚æ•°ç‹¬ç«‹è®­ç»ƒå³å¯ã€‚æ³¨æ„å’Œæœ¬æ–‡æ–¹æ³•ç›¸æ¯”ï¼ŒNature 2015ä¸Šçš„æ–¹æ³•ç›¸å½“äºŽæ˜¯å‚æ•°çš„å»¶è¿Ÿæ›´æ–°ï¼Œåœ¨åŒä¸€æ­¥æ›´æ–°çš„åŠ¨ä½œé€‰å–å’Œå‡½æ•°ä¼°è®¡ä¸­è¿˜æ˜¯ç”¨çš„åŒä¸€ä¸ªå‚æ•°ã€‚ ICLR 2016ã€ŠPrioritized Experience Replayã€‹ åœ¨RLä¸ŽDLç»“åˆçš„å®žè·µä¸­èµ·åˆ°æ¯”è¾ƒå…³é”®ä½œç”¨çš„experience replayç®—æ³•çµæ„Ÿå¯ä»¥è¯´éƒ¨åˆ†æ¥è‡ªç”Ÿç‰©å­¦ï¼Œå®ƒç±»ä¼¼äºŽå¤§è„‘ä¸­æµ·é©¬ä½“åœ¨æˆ‘ä»¬ä¼‘æ¯çš„æ—¶å€™å°†è¿‘æœŸçš„ç»éªŒå›žæ”¾åŠ æ·±å°è±¡çš„æœºåˆ¶ã€‚æœ€åŽŸå§‹çš„RLæ˜¯æ¯æ¬¡è§‚å¯Ÿåˆ°ä¸€æ¬¡çŠ¶æ€è½¬ç§»ï¼ˆè¡¨ç¤ºä¸ºs, a, R, Î³, S'ï¼‰åªæ›´æ–°ä¸€æ¬¡å‚æ•°ã€‚è¿™æ ·ä¸€æ¥æœ‰å‡ ä¸ªé—®é¢˜ï¼š1. å‚æ•°æ›´æ–°å…·æœ‰æ—¶é—´ä¸Šçš„ç›¸å…³æ€§ï¼Œè¿™ä¸Žéšæœºæ¢¯åº¦ä¸‹é™ç®—æ³•çš„å‡è®¾ä¸ç¬¦ã€‚2. é‚£äº›å‡ºçŽ°æ¬¡æ•°å°‘çš„çŠ¶æ€è½¬ç§»ï¼ˆç»éªŒï¼‰å¾ˆå¿«å°±ä¼šè¢«â€œé—å¿˜â€æŽ‰ã€‚DQNä¸­ä½¿ç”¨äº†experience replayæ¥ç¼“è§£è¿™ä¸¤ä¸ªé—®é¢˜ã€‚è¯¥æ–¹æ³•ä¸ä»…ç¨³å®šäº†å‡½æ•°è®­ç»ƒè¿‡ç¨‹ï¼Œä¹Ÿæé«˜äº†ç»éªŒæ•°æ®çš„åˆ©ç”¨çŽ‡ã€‚ç¼ºç‚¹æ˜¯éœ€è¦æ›´å¤šå†…å­˜æ¥å­˜å‚¨ç»éªŒæ± ï¼ˆexperience poolï¼‰ã€‚ è¿™ç§æ–¹æ³•çš„æ•ˆæžœå¾ˆå¥½ï¼Œä½†ç›®å‰çš„åšæ³•è¿˜æ˜¯å¯¹ä»¥å¾€ç»éªŒå‡åŒ€é‡‡æ ·çš„ã€‚ä¸‹ä¸€æ­¥è‡ªç„¶æ˜¯æ ¹æ®ç»éªŒçš„é‡è¦ç¨‹åº¦è¿›è¡Œæœ‰ä¾§é‡çš„replayã€‚ åœ¨RLé¢†åŸŸï¼Œä¸Šä¸ªä¸–çºª90å¹´ä»£å°±æœ‰ç±»ä¼¼çš„æƒ³æ³•ï¼Œå³prioritized sweepingï¼Œåº”ç”¨åœ¨model-basedçš„è§„åˆ’é—®é¢˜ä¸­ã€‚ç›´è§‰ä¸Šï¼Œæˆ‘ä»¬çŸ¥é“ä¸€éƒ¨åˆ†ç»éªŒæ¯”å…¶å®ƒç»éªŒè¦å¯¹å‚æ•°çš„è®­ç»ƒäº§ç”Ÿæ›´å¤§çš„ä½œç”¨ ã€‚åŸºäºŽæ­¤ï¼Œè¯¥æ–¹æ³•çš„åŸºæœ¬æ€æƒ³æ˜¯ä½¿å‚æ•°æ›´æ–°å€¾å‘äºŽä½¿å€¼ä¼°è®¡å˜åŒ–æ›´å¤§çš„ç»éªŒã€‚è€Œæ€Žä¹ˆè¡¡é‡å“ªäº›ç»éªŒå¯¹å€¼ä¼°è®¡çš„è´¡çŒ®å‘¢ï¼Œè¿™å°±éœ€è¦æœ‰å®šé‡çš„æµ‹åº¦ã€‚åœ¨model-freeçš„åœºæ™¯ä¸­ï¼Œè¿™ä¸ªæµ‹åº¦ä¸€èˆ¬é€‰ç”¨TD errorã€‚å…·ä½“åœ°ï¼ŒTD errorè¶Šå¤§ï¼Œä¹Ÿå°±æ˜¯expected learning progressè¶Šé«˜çš„ç»éªŒæ•°æ®ï¼Œå¯ä»¥è®©å®ƒä»¬replayçš„æ¬¡æ•°è¶Šé¢‘ç¹ã€‚åŸºäºŽè¿™ç§æ€æƒ³å®žçŽ°çš„greedy TD-error prioritizationç®—æ³•å°†ç»éªŒæ•°æ®å’Œå…¶TD erroræŒ‰åºå­˜åœ¨replay memoryä¸­ï¼Œæ¯æ¬¡å–æœ€å¤§TD errorçš„ç»éªŒè¿›è¡Œreplayï¼ŒåŒæ—¶å‚æ•°æ›´æ–°çš„é‡ä¹Ÿä¸Žä¹‹åŒæ¯”ã€‚å¦å¤–æ–°çš„ç»éªŒä¼šè®¾æˆæœ€å¤§ä¼˜å…ˆçº§ä»¥ä¿è¯å®ƒè‡³å°‘è¢«è®­ç»ƒä¸€æ¬¡ã€‚ è®ºæ–‡è¿˜æåˆ°è¿™ç§åšæ³•ä¼šå¯¼è‡´loss of diversityé—®é¢˜å’Œå¼•å…¥biasï¼Œä½†æ–‡ä¸­åˆ†åˆ«ç”¨stochastic prioritizationå’Œimportance samplingæ–¹æ³•æ¥å‡è½»å’Œçº æ­£ã€‚æ€»å¾—æ¥è¯´ï¼ŒæŒ‰æ–‡çš„åŽŸè¯è¯´ï¼Œexperience replayä½¿å¾—å‚æ•°çš„æ›´æ–°ä¸å†å—é™äºŽå®žé™…ç»éªŒçš„é¡ºåºï¼Œprioritized experience replayç»§è€Œä½¿ä¹‹ä¸å†å—é™äºŽå®žé™…ç»éªŒçš„å‡ºçŽ°é¢‘çŽ‡ã€‚ ICML 2016ã€ŠDueling Network Architectures for Deep Reinforcementã€‹ è¿™ç¯‡è®ºæ–‡æå‡ºäº†é’ˆå¯¹model-free RLçš„dueling networkæ¡†æž¶ã€‚å®ƒæ˜¯å¯¹ä¼ ç»ŸDQNæž¶æž„å±‚é¢ä¸Šçš„æ”¹åŠ¨ï¼Œå°†åŸºäºŽçŠ¶æ€çš„Vå‡½æ•°ï¼ˆvalue functionï¼‰å’ŒçŠ¶æ€ç›¸å…³çš„advantageå‡½æ•°ï¼ˆadvantage functionï¼‰åˆ†ç¦»ã€‚Advantageå‡½æ•°çš„æ€æƒ³åŸºäºŽ1993å¹´Bairdæå‡ºçš„advantage updatingã€‚é™¤äº†ä¼ ç»Ÿçš„Vå‡½æ•°å¤–ï¼Œå¼•å…¥çš„advantageå‡½æ•° A(x, u)çš„å®šä¹‰æ˜¯å½“é‡‡å–åŠ¨ä½œuç›¸æ¯”äºŽé‡‡å–å½“å‰æœ€ä¼˜åŠ¨ä½œèƒ½å¤šå¸¦æ¥å¤šå°‘ç´¯ç§¯æŠ˜æ‰£å›žæŠ¥ã€‚ç®€å•ç²—æš´å¾—è¯´ï¼Œå°±æ˜¯é€‰è¿™ä¸ªåŠ¨ä½œæ¯”å½“å‰æœ€ä¼˜åŠ¨ä½œï¼ˆæˆ–å…¶å®ƒåŠ¨ä½œï¼‰å¥½å¤šå°‘ã€‚ åŸºäºŽè¿™ä¸ªæ€æƒ³ï¼ŒåŒä¸€ä¸ªç½‘ç»œä¼šåŒæ—¶ä¼°è®¡Vå‡½æ•°å’Œadvantageå‡½æ•°ï¼Œå®ƒä»¬ç»“åˆèµ·æ¥å¯ä»¥å¾—åˆ°Qå‡½æ•°ã€‚ä»Žæž¶æž„ä¸Šæ¥è¯´ï¼Œè¿™æ˜¯ä¸€ä¸ªä¸€åˆ†ä¸ºäºŒï¼Œå†åˆäºŒä¸ºä¸€çš„è¿‡ç¨‹ã€‚å®ƒçš„å‡ºå‘ç‚¹æ˜¯å› ä¸ºå¯¹äºŽå¾ˆå¤šçŠ¶æ€ï¼Œå…¶å®žå¹¶ä¸éœ€è¦ä¼°è®¡æ¯ä¸ªåŠ¨ä½œçš„å€¼ã€‚å¯ä»¥é¢„è§åˆ°ï¼Œå¼•å…¥advantageå‡½æ•°åŽï¼Œå¯¹äºŽæ–°åŠ å…¥çš„åŠ¨ä½œå¯ä»¥å¾ˆå¿«å­¦ä¹ ï¼Œå› ä¸ºå®ƒä»¬å¯ä»¥åŸºäºŽçŽ°æœ‰çš„Vå‡½æ•°æ¥å­¦ä¹ ã€‚å®ƒç›´è§‰ä¸Šçš„æ„ä¹‰åœ¨äºŽå°†Qå‡½æ•°çš„ä¼°è®¡åˆ†ä¸ºä¸¤æ­¥ã€‚è¿™æ ·ï¼Œå¯ä»¥å…ˆä¼°è®¡å“ªäº›çŠ¶æ€æ›´èƒ½èŽ·å¾—æ›´å¤šå›žæŠ¥ï¼Œè€Œä¸å—è¯¥çŠ¶æ€ä¸‹ä¸åŒåŠ¨ä½œçš„å¹²æ‰°ã€‚æ–‡ä¸­ä¸¾äº†å…¸åž‹çš„èµ›è½¦æ¸¸æˆçš„ä¾‹å­ã€‚å¯ä»¥çœ‹åˆ°Vå‡½æ•°ä¸“æ³¨äºŽè¿œå¤„ï¼ˆåœ°å¹³çº¿ï¼‰å’Œåˆ†æ•°ï¼Œä¹Ÿå°±æ˜¯é•¿æœŸç›®æ ‡ï¼Œadvantageå‡½æ•°ä¸“æ³¨äºŽé™„è¿‘éšœç¢ï¼Œä¹Ÿå°±æ˜¯çŸ­æœŸç›®æ ‡ã€‚è¿™è¯´æ˜ŽVå‡½æ•°å’Œadvantageå‡½æ•°åˆ†åˆ«å­¦ä¹ åˆ°äº†ä¸¤ä¸ªå±‚æ¬¡çš„ç­–ç•¥ã€‚è¿™ç§åˆ†å±‚å­¦ä¹ çš„åšæ³•æœ‰å‡ ä¸ªå¥½å¤„ï¼šä¸€æ˜¯Vå‡½æ•°å¯ä»¥å¾—åˆ°æ›´å¤šçš„å­¦ä¹ æœºä¼šï¼Œå› ä¸ºä»¥å¾€ä¸€æ¬¡åªæ›´æ–°ä¸€ä¸ªåŠ¨ä½œå¯¹åº”çš„Qå‡½æ•°ã€‚äºŒæ˜¯Vå‡½æ•°çš„æ³›åŒ–æ€§æ›´å¥½ï¼Œå½“åŠ¨ä½œè¶Šå¤šæ—¶ä¼˜åŠ¿è¶Šæ˜Žæ˜¾ã€‚ç›´è§‚ä¸Šçœ‹ï¼Œå½“æœ‰æ–°åŠ¨ä½œåŠ å…¥æ—¶ï¼Œå®ƒå¹¶ä¸éœ€è¦ä»Žé›¶å¼€å§‹å­¦ä¹ ã€‚ä¸‰æ˜¯å› ä¸ºQå‡½æ•°åœ¨åŠ¨ä½œå’ŒçŠ¶æ€ç»´åº¦ä¸Šçš„ç»å¯¹æ•°å€¼å¾€å¾€å·®å¾ˆå¤šï¼Œè¿™ä¼šå¼•èµ·å™ªå£°å’Œè´ªå©ªç­–ç•¥çš„çªå˜ï¼Œè€Œç”¨è¯¥æ–¹æ³•å¯ä»¥æ”¹å–„è¿™ä¸ªé—®é¢˜ã€‚ å°†è¿™äº›æ”¹è¿›è€ƒè™‘è¿›åŽ»ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠä¸Šé¢çš„å›¾å†å»¶ä¼¸å‡ºåŽ»ï¼š *** Nature 2016 ã€ŠMastering the game of Go with deep neural networks and tree searchã€‹** DRLçš„ç¬¬äºŒæ³¢é«˜æ½®å½“å±žNature 2016 ä¸Šçš„è®ºæ–‡ã€ŠMastering the Game of Go with Deep Neural Networks and Tree Searchã€‹ï¼Œå…¶ä¸­å‘è¡¨äº†AlphaGoçš„ç›¸å…³æˆæžœã€‚å®ƒåº”ç”¨äº†DRLæŠ€æœ¯å°†å›´æ£‹æ™ºèƒ½æ°´å¹³è¾¾åˆ°äº†ä¸€ä¸ªå…¨æ–°çš„é«˜åº¦ã€‚æˆ‘ä»¬éƒ½çŸ¥é“åœ¨è¿™ç±»ä¿¡æ¯å®Œå…¨åšå¼ˆæ¸¸æˆä¸­äººå·¥æ™ºèƒ½è¿Ÿæ—©ä¼šæˆ˜èƒœäººï¼ˆå› ä¸ºåœ¨ç±»ä¼¼äºŽå¯å‘å¼æœç´¢é—®é¢˜ä¸Šï¼Œäººçš„æ™ºèƒ½ä¼šå—åˆ°å¤§è„‘å¼€å‘çš„ç”Ÿç†æžé™é™åˆ¶ï¼Œè€Œè®¡ç®—èƒ½åŠ›çš„å‘å±•å¯ä»¥ä»¥æ•°é‡çº§é€Ÿåº¦å¢žé•¿ï¼Œå†åŠ ä¸Šæœ‰åˆé€‚çš„æ–¹æ³•å‡ºçŽ°å°±å¯ä»¥ä½¿å…¶æœç´¢æ•ˆçŽ‡æžå¤§æé«˜ï¼‰ï¼Œä½†AlphaGoä¼¼ä¹Žè®©å®ƒæå‰äº†å¥½å¤šå¹´å®žçŽ°ã€‚AlphaGoè™½ç„¶ä¹ŸåŸºäºŽDRLï¼Œä½†å…¶æ„ä¹‰ä¸Žä¹‹å‰åŸºäºŽDQNçš„å·¥ä½œå¤§ç›¸å¾„åº­ï¼Œå¦åˆ™ã€ŠNatureã€‹ä¹Ÿä¸ä¼šè®©å®ƒå‘ä¸¤æ¬¡ã€‚å¦‚æžœè¯´ä¹‹å‰çš„æœ€å¼€å§‹æå‡ºçš„DQNè¿˜æ˜¯ä¸€ç§ç®—æ³•çš„è¯ï¼ŒAlphaGoè¿™æ—¶å°±å·²ç»æ˜¯ä¸€å¥—ä¸ºå›´æ£‹ç²¾å¿ƒè®¾è®¡çš„ç®—æ³•æ¡†æž¶äº†ã€‚å‰é¢æåˆ°è¿‡ï¼ŒDQNçš„æ„ä¹‰åœ¨äºŽç®—æ³•å…·æœ‰é€šç”¨æ€§ï¼Œè€ŒAlphaGoçš„æ„ä¹‰åœ¨äºŽå›´æ£‹é—®é¢˜æœ¬èº«çš„æœç´¢ç©ºé—´éžå¸¸ä¹‹å¤§ï¼ŒåŒæ—¶ä¹Ÿæ˜¯ç»å…¸çš„NP-hardé—®é¢˜ã€‚AlphaGoé€šè¿‡è’™ç‰¹å¡æ´›æœç´¢æ ‘ï¼ˆMonte-Carlo Tree Searchï¼ŒMCTSï¼‰å’ŒDRLç»“åˆä½¿å¾—è¿™ä¸ªå¤§è§„æ¨¡æœç´¢é—®é¢˜åœ¨å¯è®¡ç®—èŒƒå›´å†…ã€‚å®ƒæ²¡æœ‰ç”¨raw pixelsä½œè¾“å…¥ï¼ˆä¹Ÿæ— å¿…è¦ï¼‰ï¼Œè€Œæ˜¯ä½¿ç”¨äººå·¥è®¾è®¡çš„ç‰¹å¾ç”¨äºŽpolicy networkå’Œvalue networkçš„è®­ç»ƒã€‚å…¶å®žAlphaGoæ›´å¤šæ˜¯ä¸ªå·¥ç¨‹ä¸Šçš„æ°ä½œã€‚å®ƒåŸºäºŽå‰é¢çš„DRLåŸºç¡€ä¸Šï¼Œåšäº†å¾ˆå¤šé’ˆå¯¹å›´æ£‹é—®é¢˜çš„ç‰¹æœ‰æŠ€æœ¯ï¼Œä¸”ç”¨äº†åˆ†å¸ƒå¼çš„æŠ€æœ¯åŠ é€Ÿè®¡ç®—ã€‚æ€»ä¹‹ï¼Œå®ƒä»¬è¦å±•ç¤ºçš„æ˜¯DRLä¸¤æ–¹é¢çš„èƒ½åŠ›ï¼ŒDQNæ˜¯ç®—æ³•çš„é€šç”¨èƒ½åŠ›ï¼ŒAlphaGoæ˜¯å¯¹äºŽå˜æ€çº§è§„æ¨¡æœç´¢é—®é¢˜çš„è®¡ç®—æœ‰æ•ˆæ€§ã€‚ AlphaGoçš„å¤§ä½“æ€æƒ³æ˜¯ä½¿ç”¨value networkæ¥è¯„ä¼°æ£‹ç›˜ä½ç½®ï¼Œç”¨policy networkæ¥é€‰æ‹©åŠ¨ä½œï¼ŒåŒæ—¶ç»“åˆäº†ç›‘ç£å­¦ä¹ å’ŒDRLæŠ€æœ¯ã€‚å®ƒè¿˜å¼•å…¥äº†ä¸€ç§ç»“åˆMCæ¨¡æ‹Ÿå’Œvalue/policy networkçš„æœç´¢ç®—æ³•ã€‚ æž¶æž„ä¸Šï¼Œvalue networkç”¨äºŽè¯„ä¼°ä½ç½®ï¼Œpolicy networkç”¨äºŽé‡‡æ ·åŠ¨ä½œã€‚æµç¨‹ä¸Šï¼Œå­¦ä¹ åˆ†ä¸ºå‡ ä¸ªé˜¶æ®µï¼šç¬¬ä¸€é˜¶æ®µåŸºäºŽäººç±»ä¸“å®¶çš„æ•°æ®é›†é€šè¿‡ç›‘ç£å­¦ä¹ è®­ç»ƒSL policy networkã€‚å¦å¤–è®­ç»ƒä¸€ä¸ªå•ç‹¬çš„ç­–ç•¥ç”¨äºŽåœ¨ä¹‹åŽçš„rolloutä¸­å¿«é€Ÿé€‰å–åŠ¨ä½œã€‚è¿™ä¸€æ­¥æ›´å¤šæ˜¯ä¸ºäº†ç»“åˆäººç±»å·²æœ‰ç»éªŒï¼ˆæ¯•ç«Ÿçº¯é è‡ªå­¦ä¹ æœ‰äº›æ…¢ï¼‰ï¼Œç”¨äºŽåŽé¢å‡ æ­¥ä½œå…ˆéªŒçŸ¥è¯†ã€‚æŽ¥ç€ï¼Œå°†SL policy networkçš„å‚æ•°æ¥åˆå§‹åŒ–RL policy network ï¼ˆè¯¥policy networkç”¨äºŽä¹‹åŽåœ¨RLä¸­é€šè¿‡self-playåšç­–ç•¥æœç´¢ï¼‰ã€‚ç¬¬äºŒé˜¶æ®µæ˜¯é€šè¿‡RLçš„policy gradientæ–¹æ³•å­¦ä¹ ç­–ç•¥ï¼Œé€šè¿‡éšæœºæ¢¯åº¦ä¸Šå‡ï¼ˆStochastic gradient ascentï¼‰ç®—æ³•æ¥æ›´æ–°RL policy networkå‚æ•°ã€‚ç¬¬ä¸‰é˜¶æ®µï¼Œå­¦ä¹ value networkç”¨äºŽé¢„æµ‹RL policy networkçŽ©æ¸¸æˆæ—¶çš„èƒœç®—ï¼Œè¿™ä¸€æ­¥ä½¿ç”¨éšæœºæ¢¯åº¦ä¸‹é™ï¼ˆStochastic gradient descentï¼ŒSGDï¼‰æ¥æœ€å°åŒ–outcomeï¼ˆå¯¹å½“å‰çŠ¶æ€è€Œè¨€å›´æ£‹ç»“æŸæ—¶çš„å›žæŠ¥ï¼Œå³è¾“èµ¢ï¼‰ä¸ŽVå‡½æ•°ä¹‹é—´çš„å·®ï¼ˆç”¨MSEè¡¨ç¤ºï¼‰ã€‚æœ€åŽï¼Œç¬¬å››é˜¶æ®µä¸­ï¼Œæœ‰äº†ä¸Šé¢çš„policy networkå’Œvalue networkï¼Œå°±å¯ä»¥æ®æ­¤ç”¨MCSTæ¥è¿›è¡Œæœç´¢äº†ã€‚ åœ¨æœ€åŽä¸€ä¸ªé˜¶æ®µä¸­ï¼Œç®—æ³•ä¼šé€šè¿‡MCæ¨¡æ‹Ÿä»Žæ ¹çŠ¶æ€æ¥å¾€ä¸‹å•å‘éåŽ†æœç´¢æ ‘ï¼Œè¿™ä¸€é˜¶æ®µåˆå¯ä»¥åˆ†ä¸ºé€‰å–ï¼ˆselectionï¼‰ï¼Œæ‰©å±•ï¼ˆexpansionï¼‰ï¼Œè¯„ä¼°ï¼ˆevaluationï¼‰å’Œå›žæº¯ï¼ˆbackupï¼‰å››æ­¥ã€‚è¿™å…¶å®žä¹Ÿæ˜¯MCSTç®—æ³•æ¡†æž¶ä¸­çš„ç»å…¸çš„å››ä¸ªæ­¥éª¤ã€‚åªæ˜¯AlphaGoåœ¨è¿™ä¸ªMCTSç®—æ³•ä¸­ç»“åˆäº†policyå’Œvalue networkã€‚å…¶ä¸­é€‰å–è¿™æ­¥åŸºäºŽå‰é¢çš„value networkå–Qå‡½æ•°å€¼æœ€å¤§çš„åŠ¨ä½œã€‚æ³¨æ„è¿™ä¸€æ­¥ä½¿ç”¨çš„æ˜¯UCTæ—ç®—æ³•ï¼Œå®ƒåœ¨åŠ¨ä½œé€‰å–æ—¶é™¤Qå‡½æ•°å€¼è¿˜ä¼šè€ƒè™‘ä¸€ä¸ªä»£è¡¨æœªçŸ¥ç¨‹åº¦çš„é‡ï¼Œç”¨äºŽè§£å†³è‘—åçš„exploration-exploitationé—®é¢˜ã€‚æ¯•ç«Ÿï¼Œæˆ‘ä»¬çš„æœŸæœ›æ˜¯ç¨‹åºä¸ä»…ä»…æ˜¯å¤åˆ¶äººç±»çš„ç»éªŒï¼Œè€Œä¸”èƒ½å¤Ÿè¶…è¶Šã€‚ç¬¬äºŒæ­¥æ‰©å±•æ˜¯é’ˆå¯¹æœç´¢æ ‘ä¸­çš„å¶å­ç»“ç‚¹ï¼Œä½¿ç”¨çš„æ˜¯RL policy networkä¸­å­¦ä¹ åˆ°çš„ç­–ç•¥ã€‚ç¬¬ä¸‰æ­¥è¯„ä¼°æœ‰ä¸¤ç§å®Œå…¨ä¸åŒçš„æ–¹å¼ï¼š1. é€šè¿‡value networkã€‚2.é€šè¿‡éšæœºrolloutç›´åˆ°ç»“æŸï¼ˆä½¿ç”¨fast rollout policyï¼Œä¹Ÿå°±æ˜¯ä¹‹å‰çš„SL policy networkï¼‰æ‰€å¾—åˆ°çš„å›žæŠ¥ã€‚è¿™ä¸¤è€…å¯é€šè¿‡å‚æ•°è¿›è¡Œè°ƒå’Œã€‚æœ€åŽå›žæº¯è¿™æ­¥å³æ ¹æ®å‰é¢çš„æœç´¢è¿›è¡ŒQå‡½æ•°æ›´æ–°ã€‚ æ€»å¾—æ¥è¯´å¯ä»¥å¤§ä½“æ¦‚æ‹¬ä¸ºä¸‹å›¾ï¼š å¯ä»¥çœ‹åˆ°ï¼Œä»Šå¤©çš„çš„äººå·¥æ™ºèƒ½å’Œæœºå™¨å­¦ä¹ é¢†åŸŸï¼Œå·¥ç¨‹å’Œå­¦æœ¯åŒæ ·é‡è¦ã€‚ä¸€æ–¹é¢å¯èƒ½å› ä¸ºDLçš„ç‰¹æ®Šæ€§ï¼Œæ¯•ç«Ÿå®ƒåŸºäºŽçš„ç¥žç»ç½‘ç»œä»Žä¸€å¼€å§‹å°±æ˜¯åå·¥ç¨‹çš„ï¼›å¦ä¸€æ–¹é¢ä»Šå¤©çš„å·¥ä¸šä¸Žå­¦æœ¯ç»“åˆæ›´åŠ ç´§å¯†ï¼Œäº§ä¸šåŒ–é€Ÿåº¦å¤§å¤§åŠ å¿«ã€‚æ¯”å¦‚DRLçš„ideaå¾ˆå¥½ï¼Œä½†å‰ææ˜¯è¦æœ‰å·¥ç¨‹èƒ½åŠ›è¯æ˜Žå®ƒå¥½ã€‚å³ä½¿æœ‰äººæ—©å‡ å¹´æƒ³åˆ°äº†è¿™ä¸ªideaï¼Œå®ƒä»ä¸ä¸€å®šèƒ½ä½¿å®ƒå‘åœ¨Natureè¿™æ ·çš„é«˜çº§åˆ«åˆŠç‰©ä¸Šã€‚å› ä¸ºä»Šå¤©çš„DRLæ˜¯å·¥ç¨‹å’Œå­¦æœ¯çš„å……åˆ†ç»“åˆã€‚å¦å¤–ï¼Œè¿™è¿˜æé†’æˆ‘ä»¬è¦é‡è§†å­¦ç§‘æˆ–è€…è¯´æ˜¯æ–¹å‘çš„äº¤å‰ã€‚å¾ˆå¤šæ—¶å€™ï¼Œä¸€ç¯‡è®ºæ–‡çš„å­¦æœ¯ä»·å€¼å–å†³äºŽå®ƒèƒ½ç»™åŽäººç•™å¤šå°‘å¯ä»¥ç»§ç»­æ·±ç©¶çš„ä¸œè¥¿ã€‚é™¤äº†é‚£äº›èƒ½è‡ªæˆä¸€æ´¾çš„æžç«¯ç‰›äººï¼Œå¤§å¤šæ•°æ—¶å€™èƒ½è¿žæŽ¥ä¸¤ä¸ªæˆ–å¤šä¸ªæ–¹å‘å¹¶è¯æ˜Žå…¶ä»·å€¼æ‰€å¸¦æ¥çš„å½±å“å°±éžå¸¸æ·±è¿œäº†ã€‚]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>æœºå™¨å­¦ä¹ </tag>
        <tag>å¼ºåŒ–å­¦ä¹ </tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeé¢˜è§£]]></title>
    <url>%2F2018%2F07%2F01%2FLeetCode%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[æœ€è¿‘å†™äº†ä¸€ä¸‹LeetCodeï¼Œæœ¬èœðŸ”å‘çŽ°LeetCodeä¸Šæœ‰äº›é¢˜ç›®è´¨é‡è¿˜æ˜¯æŒºé«˜çš„ï¼Œéœ€è¦ä»”ç»†æ€è€ƒæ€è€ƒï¼Œæ‰èƒ½æƒ³åˆ°æ¯”è¾ƒé«˜æ•ˆçš„çš„è§£æ³•ã€‚ å·²ç»å†™äº†å‰ä¸¤ç™¾é¢˜äº†ï¼Œä»£ç åœ¨ GitHubï¼Œåªæ•´ç†äº†éƒ¨åˆ†ä»£ç ï¼Œå‰©ä¸‹çš„ä»£ç ä¼šé™†ç»­ä¸Šä¼ çš„ã€‚ ä¹‹åŽä¼šé€‰å‡ é“æˆ‘åšçš„è¿‡ç¨‹ä¸­æœ‰é—®é¢˜æˆ–è€…æˆ‘è‡ªè®¤ä¸ºæ¯”è¾ƒå¥½çš„é¢˜ç›®å†™ä¸€å†™åˆ†æžã€‚]]></content>
      <categories>
        <category>æœºè¯•</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>æœºè¯•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æµ™å¤§ç ”ç©¶ç”Ÿæœºè¯•21-30é¢˜]]></title>
    <url>%2F2018%2F06%2F26%2F%E6%B5%99%E5%A4%A7%E7%A0%94%E7%A9%B6%E7%94%9F%E6%9C%BA%E8%AF%9521-30%E9%A2%98%2F</url>
    <content type="text"><![CDATA[ç»Ÿè®¡åŒæˆç»©å­¦ç”Ÿäººæ•° é¢˜ç›®é“¾æŽ¥ ä»£ç  12345678910111213141516171819202122232425262728/** @Author: sun000* @Date: 2018-06-25 16:12:55* @Last Modified by: sun000* @Last Modified time: 2018-06-25 16:15:53*/#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int s[105];int main() &#123; int n, tmp; while(scanf("%d", &amp;n) != EOF &amp;&amp; n) &#123; memset(s, 0, sizeof(s)); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;tmp); s[tmp]++; &#125; int tar; scanf("%d", &amp;tar); printf("%d\n", s[tar]); &#125; return 0;&#125; ç»§ç»­XXXå®šå¾‹ é¢˜ç›®é“¾æŽ¥ åˆ†æž æ¯è¾“å…¥ä¸€ä¸ªæ•°ï¼Œæ ‡è®°å…¶èƒ½è¦†ç›–çš„æ‰€æœ‰æ•°æ®ï¼ˆä¸è¦é‡å¤æ ‡è®°ï¼‰ï¼Œæ³¨æ„å˜æ¢è¿‡ç¨‹ä¸­çš„æ•°æ®ä¼šå˜å¾—éžå¸¸å¤§ï¼Œè¿™é‡Œæ•°æ®æ°´äº†ç‚¹ï¼Œæˆ‘ç›´æŽ¥å¼€äº†å¤§æ•°ç»„ï¼Œæœ€å¥½ç”¨setæ ‡è®°ã€‚ ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142/** @Author: sun000* @Date: 2018-06-25 16:35:22* @Last Modified by: sun000* @Last Modified time: 2018-06-25 18:14:33*/#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;bool vis[1000005];//ç©ºé—´å¼€å¤§ä¸€ç‚¹ï¼Œæ˜¯å› ä¸ºè™½ç„¶è¾“å…¥ä¸å¤§ï¼Œä½†æ˜¯åœ¨å˜æ¢è¿‡ç¨‹ä¸­å¯èƒ½ä¼šä¸€ç›´å˜å¤§int num[505], ans[505];int main(void) &#123; int n; while(scanf("%d", &amp;n) != EOF &amp;&amp; n) &#123; memset(vis, false, sizeof vis); vis[1] = true; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;num[i]); int tmp = num[i]; bool f = vis[tmp]; while(!vis[tmp]) &#123;//ä¸è¦é‡å¤æ ‡è®°ï¼Œæ‰€ä»¥æ ‡è®°åˆ°å·²ç»è¢«æ ‡è®°çš„æ•°å°±å¥½äº† vis[tmp] = true; if(tmp &amp; 1) tmp = tmp * 3 + 1; tmp &gt;&gt;= 1; &#125; vis[num[i]] = f; &#125; int cnt = 0; for(int i = 0; i &lt; n; i++) if(!vis[num[i]]) ans[cnt++] = num[i]; for(int i = cnt - 1; i &gt;= 0; i--) printf("%d%c", ans[i], i == 0 ? '\n' : ' '); &#125; return 0;&#125; Head of a Gang é¢˜ç›®é“¾æŽ¥ åˆ†æž é¢˜æ„æ€ï¼Œè¯»æ‡‚é¢˜ç›®å°±å¥½äº†ï¼Œç»´æŠ¤ä¸€ä¸ªå¹¶æŸ¥é›†ï¼ŒåŠå…¶ç›¸å…³å˜é‡ ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** @Author: sun000* @Date: 2018-06-25 18:21:16* @Last Modified by: sun000* @Last Modified time: 2018-06-25 19:01:48*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;char name1[1005], name2[1005];int d[1005]; //æ¯ä¸ªäººæ‰€è¿žçš„è¾¹çš„æƒé‡å’Œï¼Œç”¨äºŽæ‰¾åˆ°headmap&lt;string, int&gt; nameToId;string idToName[1005];int fa[1005], size[1005], tot[1005], head[1005]; //åˆ†åˆ«è¡¨ç¤ºæ¯ä¸ªé›†åˆçš„ä»£è¡¨å…ƒç´ åºå·ï¼Œé›†åˆå¤§å°ï¼Œé›†åˆä¸­çš„è¾¹æƒæ€»å’Œï¼Œæ¯ä¸ªé›†åˆçš„headbool vis[1005]; //ç”¨äºŽè¾“å‡ºæ ‡è®°ï¼Œæ¯ä¸ªé›†åˆåªè¾“å‡ºä¸€æ¬¡void init() &#123; memset(vis, true, sizeof vis); for(int i = 0; i &lt; 1005; i++) &#123; fa[i] = i; head[i] = i; size[i] = 1; tot[i] = 0; &#125;&#125;int find(int x) &#123; if(x == fa[x]) return x; return fa[x] = find(fa[x]);&#125;void un(int x, int y, int t) &#123; x = find(x), y = find(y); if(x != y) &#123; fa[x] = y; vis[x] = true; vis[y] = false; tot[y] += tot[x]; size[y] += size[x]; &#125; tot[y] += t;&#125;int main(void) &#123; int n, k, t; while(scanf("%d%d", &amp;n, &amp;k) != EOF) &#123; init(); nameToId.clear(); memset(d, 0, sizeof d); int cnt = 0; for(int i = 0; i &lt; n; i++) &#123; scanf("%s %s %d", name1, name2, &amp;t); int u, v; string n1 = string(name1), n2 = string(name2); if(nameToId.find(n1) == nameToId.end()) &#123; nameToId[n1] = cnt; idToName[cnt++] = n1; &#125; u = nameToId[n1]; if(nameToId.find(n2) == nameToId.end()) &#123; nameToId[n2] = cnt; idToName[cnt++] = n2; &#125; v = nameToId[n2]; d[u] += t; d[v] += t; un(u, v, t); &#125; for(int i = 0; i &lt; cnt; i++) &#123; int f = find(i); if(d[i] &gt; d[f]) &#123; d[f] = d[i]; head[f] = i; &#125; &#125; string name[1005]; int c = 0; for(int i = 0; i &lt; cnt; i++) &#123; int now = find(i); if(!vis[now] &amp;&amp; tot[now] &gt; k &amp;&amp; size[now] &gt; 2) &#123; vis[now] = true; name[c++] = idToName[now]; &#125; &#125; sort(name, name + c); printf("%d\n", c); for(int i = 0; i &lt; c; i++) cout &lt;&lt; idToName[head[nameToId[name[i]]]] &lt;&lt; " " &lt;&lt; size[nameToId[name[i]]] &lt;&lt; endl; &#125; return 0;&#125; æ¯•ä¸šbg é¢˜ç›®é“¾æŽ¥ åˆ†æž ç®€å•çš„åŠ¨æ€è§„åˆ’ å®šä¹‰\(dp[i][j]\)ï¼šå‰iä¸ªäººåœ¨jæ—¶åˆ»å‰æžâ™‚å®Œçš„æœ€å¤§æ¬¢â™‚ä¹ \(dp[i][j] = max\{dp[i - 1][j], dp[i - 1][j - l] + h\},j \in [t, l]\) ï¼ˆå¯ç”¨ç©ºé—´åŽ‹ç¼©ï¼‰ æ³¨æ„çš„ä¸€ç‚¹ï¼Œåœ¨dpä¹‹å‰è¦ï¼Œå…ˆæŒ‰ç…§ç¦»å¼€æ—¶é—´è¿›è¡ŒæŽ’åºã€‚ ä»£ç  1234567891011121314151617181920212223242526272829303132333435363738394041/** @Author: sun000* @Date: 2018-06-25 20:01:47* @Last Modified by: sun000* @Last Modified time: 2018-06-25 20:15:02*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int dp[2333];struct node &#123; int n, l, t;&#125;g[40];bool cmp(node a, node b) &#123; return a.t &lt; b.t;&#125;int main(void) &#123; int n; while(scanf("%d", &amp;n) != EOF &amp;&amp; n != -1) &#123; memset(dp, 0, sizeof dp); int ans = 0; for(int i = 0; i &lt; n; i++) scanf("%d%d%d", &amp;g[i].n, &amp;g[i].l, &amp;g[i].t); sort(g, g + n, cmp); for(int i = 0; i &lt; n; i++) &#123; for(int j = g[i].t; j &gt;= g[i].l; j--) &#123; dp[j] = max(dp[j], dp[j - g[i].l] + g[i].n); ans = max(ans, dp[j]); &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125; å¼€é—¨äººå’Œå…³é—¨äºº é¢˜ç›®é“¾æŽ¥ ä»£ç  123456789101112131415161718192021222324252627282930313233343536/** @Author: sun000* @Date: 2018-06-25 20:17:58* @Last Modified by: sun000* @Last Modified time: 2018-06-25 20:23:41*/#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main(void) &#123; int n, h, m, s; string b, e, now; while(scanf("%d", &amp;n) != EOF) &#123; int bt = 0xffff, et = -1; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; now; scanf("%d:%d:%d", &amp;h, &amp;m, &amp;s); int t = h * 3600 + m * 60 + s; if(t &lt; bt) &#123; bt = t; b = now; &#125; scanf("%d:%d:%d", &amp;h, &amp;m, &amp;s); t = h * 3600 + m * 60 + s; if(t &gt; et) &#123; et = t; e = now; &#125; &#125; cout &lt;&lt; b &lt;&lt; " " &lt;&lt; e &lt;&lt; endl; &#125; return 0;&#125; æœ€å¤§è¿žç»­å­åºåˆ— é¢˜ç›®é“¾æŽ¥ åˆ†æž åŸºç¡€dpé¢˜ç›® ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243/** @Author: sun000* @Date: 2018-06-25 20:26:01* @Last Modified by: sun000* @Last Modified time: 2018-06-25 20:39:19*/#include &lt;cstdio&gt;long long int num[10005];int main(void) &#123; int n; while(scanf("%d", &amp;n) != EOF &amp;&amp; n) &#123; long long int ans = -0x7fffffff, dp = 0; for(int i = 0; i &lt; n; i++) scanf("%lld", &amp;num[i]); int b = 0, e = 0; int tb = 0, te = 0; for(int i = 0; i &lt; n; i++) &#123; if(dp &lt;= 0) &#123; dp = num[i]; tb = te = i; &#125; else &#123; te = i; dp += num[i]; &#125; if(dp &gt; ans) &#123; ans = dp; b = tb; e = te; &#125; &#125; if(ans &lt; 0) &#123; ans = 0; b = 0; e = n - 1; &#125; printf("%lld %lld %lld\n", ans, num[b], num[e]); &#125; return 0;&#125; A+B é¢˜ç›®é“¾æŽ¥ ä»£ç  12345678910111213141516171819202122232425262728293031/** @Author: sun000* @Date: 2018-06-25 20:42:42* @Last Modified by: sun000* @Last Modified time: 2018-06-25 20:54:07*/#include &lt;cstdio&gt;int main(void) &#123; char c; long long int tmp, a = 0, b = 0; int f = 1; while(scanf("%lld%c", &amp;tmp, &amp;c) != EOF) &#123; b = b * 1000 + tmp * f; if(tmp &lt; 0) f = -1; if(c == ' ') &#123; a = b; b = 0; f = 1; &#125; else if(c == '\n') &#123; printf("%lld\n", a + b); a = b = 0; f = 1; &#125; &#125; return 0;&#125; Graduate Admission é¢˜ç›®é“¾æŽ¥ ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** @Author: sun000* @Date: 2018-06-26 15:28:33* @Last Modified by: sun000* @Last Modified time: 2018-06-26 15:50:21*/#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; int idx, gE, gI; int c[5]; int rank;&#125; app[40005];int mRank[40005];bool cmpByRank(const node &amp;a, const node &amp;b) &#123; if (a.gE + a.gI == b.gE + b.gI) return a.gE &gt; b.gE; return a.gE + a.gI &gt; b.gE + b.gI;&#125;void Rank(int n) &#123; sort(app, app + n, cmpByRank); app[0].rank = 1; mRank[app[0].idx] = 1; for (int i = 1; i &lt; n; i++) &#123; if (app[i].gE + app[i].gI == app[i - 1].gE + app[i - 1].gI &amp;&amp; app[i].gE == app[i - 1].gE) app[i].rank = app[i - 1].rank; else app[i].rank = i + 1; mRank[app[i].idx] = app[i].rank; &#125;&#125;int quo[105];vector&lt;int&gt; ans[105];int main(void) &#123; int n, m, k; while (scanf("%d%d%d", &amp;n, &amp;m, &amp;k) != EOF) &#123; for (int i = 0; i &lt; m; i++) scanf("%d", &amp;quo[i]); for (int i = 0; i &lt; n; i++) &#123; app[i].idx = i; scanf("%d%d", &amp;app[i].gE, &amp;app[i].gI); for (int j = 0; j &lt; k; j++) scanf("%d", &amp;app[i].c[j]); &#125; Rank(n); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; k; j++) &#123; int s = app[i].c[j]; //school if (ans[s].size() &lt; quo[s] || mRank[ans[s].back()] == app[i].rank) &#123; ans[s].push_back(app[i].idx); break; &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) sort(ans[i].begin(), ans[i].end()); for (int i = 0; i &lt; m; i++) &#123; if(!ans[i].size()) printf("\n"); for (int j = 0; j &lt; ans[i].size(); j++) printf("%d%c", ans[i][j], j == ans[i].size() - 1 ? '\n' : ' '); ans[i].clear(); &#125; &#125; return 0;&#125; Median é¢˜ç›®é“¾æŽ¥ ä»£ç  123456789101112131415161718192021222324252627/** @Author: sun000* @Date: 2018-06-26 15:54:03* @Last Modified by: sun000* @Last Modified time: 2018-06-26 16:01:22*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int num[2000005];int main(void) &#123; int n, m; while(scanf("%d", &amp;n) != EOF) &#123; for(int i = 0; i &lt; n; i++) scanf("%d", &amp;num[i]); scanf("%d", &amp;m); for(int i = 0; i &lt; m; i++) scanf("%d", &amp;num[n + i]); n += m; sort(num, num + n); printf("%d\n", num[(n - 1) / 2]); &#125; return 0;&#125; EXCELæŽ’åº é¢˜ç›®é“¾æŽ¥ ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** @Author: sun000* @Date: 2018-06-26 16:04:46* @Last Modified by: sun000* @Last Modified time: 2018-06-26 16:11:49*/#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e5 + 5;struct node &#123; int idx, grade; string name;&#125;s[MAXN];bool cmpByIdx(const node &amp;a, const node &amp;b) &#123; return a.idx &lt; b.idx;&#125;bool cmpByName(const node &amp;a, const node &amp;b) &#123; if(a.name == b.name) return a.idx &lt; b.idx; return a.name &lt; b.name;&#125;bool cmpByGrade(const node &amp;a, const node &amp;b) &#123; if(a.grade == b.grade) return a.idx &lt; b.idx; return a.grade &lt; b.grade;&#125;int main(void) &#123; int n, c; while(scanf("%d%d", &amp;n, &amp;c) != EOF) &#123; for(int i = 0; i &lt; n; i++) cin &gt;&gt; s[i].idx &gt;&gt; s[i].name &gt;&gt; s[i].grade; if(c == 1) sort(s, s + n, cmpByIdx); else if(c == 2) sort(s, s + n, cmpByName); else sort(s, s + n, cmpByGrade); printf("Case:\n"); for(int i = 0; i &lt; n; i++) &#123; printf("%06d ", s[i].idx); cout &lt;&lt; s[i].name &lt;&lt; " " &lt;&lt; s[i].grade &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>æœºè¯•</category>
      </categories>
      <tags>
        <tag>æœºè¯•</tag>
        <tag>æµ™å¤§</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æµ™å¤§CADæµ‹è¯•é¢˜]]></title>
    <url>%2F2018%2F06%2F19%2F%E6%B5%99%E5%A4%A7CAD%E6%B5%8B%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[ä¿ç ”å­£äº†ï¼Œæœ‰åŒå­¦è”ç³»äº†CADçš„è€å¸ˆå¸ƒç½®äº†è¿™é“é¢˜ç›®ï¼ˆä¸çŸ¥é“ä¸ºå•¥è€å¸ˆæ²¡æœ‰è®©æˆ‘åšï¼‰ã€‚ è™½ç„¶æ²¡æœ‰è¦æ±‚æˆ‘åšï¼Œä¸è¿‡æˆ‘è¿˜æ˜¯ç¨å¾®çš„å†™äº†ç‚¹ï¼Œè§£å†³äº†ä¸€ä¸‹è¿™ä¸ªå°é—®é¢˜ã€‚ é¡¹ç›®è¦æ±‚ æµ™å¤§cadæµ‹è¯•é¢˜ç›® è¯·å°½å¿«å®Œæˆä¸‹è¿°è¯•é¢˜å¹¶å°†ç»“æžœå‘å›žï¼š é—®é¢˜è¯´æ˜Žï¼š ç»™å‡ºåˆ†æˆmæ®µ çš„nä¸ªæµ®ç‚¹æ•°ï¼Œè¾“å…¥æ•°æ®å·²æŒ‰æ®µå·æœ‰åºï¼Œä½†æ¯æ®µå†…éƒ¨ æ— åºã€‚ç”¨C/C++ ç¼–å†™ä¸€ä¸ªåˆ†æ®µåŒè°ƒæŽ’åº(Bitonic sort)å‡½æ•°ï¼Œå¯¹æ¯ä¸€æ®µå†…éƒ¨çš„æµ®ç‚¹æ•°è¿›è¡ŒæŽ’åºï¼Œä½† ä¸è¦æ”¹å˜æ®µé—´çš„ä½ç½®ã€‚ æŽ¥å£æ–¹å¼ï¼š void segmentedBitonicSort(float* data, int* seg_id, int* seg_start, int n, int m); è¾“å…¥æ•°æ®ä¸­ï¼ŒdataåŒ…å«éœ€è¦åˆ†æ®µæŽ’åºçš„nä¸ªfloatå€¼ï¼Œseg_idç»™å‡ºdataä¸­nä¸ªå…ƒç´ å„ è‡ªæ‰€åœ¨çš„ æ®µç¼–å·ã€‚seg_startå…±æœ‰m+1ä¸ªå…ƒç´ ï¼Œå‰mä¸ªåˆ†åˆ«ç»™ å‡º0..m-1å…±mä¸ªæ®µçš„èµ· å§‹ä½ç½®ï¼Œseg_start[m]ä¿è¯ç­‰äºŽnã€‚ seg_idä¸­çš„å…ƒç´ ä¿è¯å•è°ƒä¸ä¸‹é™ï¼Œå³å¯¹ä»»æ„çš„i&lt;jï¼Œseg_id[i]&lt;=seg_id[j]ã€‚ seg_idæ‰€æœ‰å…ƒ ç´ å‡åœ¨0åˆ°m-1èŒƒå›´å†…ã€‚ è¾“å‡ºç»“æžœè¦†ç›–dataï¼Œä¿è¯æ¯ä¸€æ®µå†…æŽ’åºï¼Œä½†ä¸æ”¹å˜æ®µé—´å…ƒç´ çš„é¡ºåºã€‚ æ³¨æ„ï¼š 1ã€å¿…é¡»ä½¿ç”¨åŒè°ƒæŽ’åºç®—æ³•è¿›è¡ŒæŽ’åºã€‚ 2ã€å¯ä»¥ç›´æŽ¥ä½¿ç”¨ä»Žç½‘ä¸Šä¸‹è½½çš„åŒè°ƒæŽ’åºä»£ç ï¼Œä½†é¡»æ³¨æ˜Žå‡ºå¤„ã€‚ æ ·ä¾‹è¾“å…¥ï¼š float data[5]={0.8, 0.2, 0.4, 0.6, 0.5}; int seg_id[5]={0, 0, 1, 1, 1} int seg_start[3]={0,2,5}; int n=5; int m=2; æ ·ä¾‹è¾“å‡ºï¼š float data[5]={0.2, 0.8, 0.4, 0.5, 0.6}; åŠ åˆ†æŒ‘æˆ˜ï¼ˆéžå¿…éœ€ï¼‰ï¼š 1ã€ä¸é€’å½’ï¼šsegmentedBitonicSortå‡½æ•°åŠå…¶æ‰€è°ƒç”¨çš„ä»»ä½•å…¶ä»–å‡½æ•°éƒ½ä¸å¾—ç›´æŽ¥æˆ–é—´æŽ¥åœ°è¿›è¡Œé€’å½’ã€‚ 2ã€ä¸è°ƒç”¨å‡½æ•°ï¼šsegmentedBitonicSortä¸è°ƒç”¨é™¤æ ‡å‡†åº“å‡½æ•°å¤–çš„ä»»ä½•å…¶ä»–å‡½æ•°ã€‚ 3ã€å†…å­˜é«˜æ•ˆï¼šsegmentedBitonicSortåŠå…¶æ‰€è°ƒç”¨çš„ä»»ä½•å…¶ä»–å‡½æ•°éƒ½ä¸å¾—è¿›è¡ŒåŠ¨æ€å†…å­˜åˆ†é…ï¼ŒåŒ…æ‹¬mallocã€newå’Œé™æ€å®šä¹‰çš„STLå®¹å™¨ã€‚ 4ã€å¯å¹¶è¡Œï¼šsegmentedBitonicSortæ¶‰åŠåˆ°çš„æ‰€æœ‰æ—¶é—´å¤æ‚åº¦O(n)ä»¥ä¸Šçš„ä»£ç éƒ½å†™ åœ¨forå¾ª çŽ¯ä¸­ï¼Œè€Œä¸”æ¯ä¸ªè¿™æ ·çš„forå¾ªçŽ¯å†…éƒ¨çš„å¾ªçŽ¯é¡ºåºå¯ ä»¥ä»»æ„æ”¹å˜ï¼Œä¸å½±å“ç¨‹ åºç»“æžœã€‚æ³¨ï¼šè‡ªå·±æµ‹è¯•æ—¶å¯ä»¥ç”¨rand()å†³å®šå¾ªçŽ¯é¡ºåºã€‚ 5ã€ä¸éœ€å†…å­˜ï¼šsegmentedBitonicSortä¸è°ƒç”¨ä»»ä½•å‡½æ•°ï¼ˆåŒ…æ‹¬C/C++æ ‡å‡†åº“å‡½æ•°ï¼‰ï¼Œ ä¸ä½¿ç”¨å…¨å±€å˜é‡ï¼Œæ‰€æœ‰å±€éƒ¨å˜é‡éƒ½æ˜¯intã€floatæˆ–æŒ‡é’ˆç±» åž‹ï¼ŒC++ç¨‹åºä¸ä½¿ç”¨new å…³é”®å­—ã€‚ 6ã€ç»å¯¹é²æ£’ï¼šåœ¨è¾“å…¥æ•°æ®ä¸­åŒ…å«NaNæ—¶ï¼ˆä¾‹å¦‚sqrt(-1.f)ï¼‰ï¼Œä¿è¯é™¤NaNä»¥å¤– çš„æ•° æ®æ­£ç¡®æŽ’åºï¼ŒNaNçš„ä¸ªæ•°ä¿æŒä¸å˜ã€‚ ä½ çš„ç¨‹åºæ¯æ»¡è¶³ä»¥ä¸Šçš„ä¸€ä¸ªæ¡ä»¶éƒ½å¯ä»¥èŽ·å¾—é¢å¤–çš„åŠ åˆ†ã€‚ åº”æäº¤çš„ç»“æžœï¼š ç®—æ³•æè¿°ï¼› å°è¯•è¿‡å’Œå®Œæˆäº†çš„åŠ åˆ†æŒ‘æˆ˜ï¼› å¯ä»¥ç‹¬ç«‹è¿è¡Œçš„æºä»£ç ï¼› æµ‹è¯•æ•°æ®ï¼› æ€§èƒ½åˆ†æžï¼› æµ‹è¯•çš„èµ·å§‹å’Œå®Œæˆæ—¶é—´ä»¥åŠå®žé™…ä½¿ç”¨çš„æ—¶é—´ã€‚ æç¤ºï¼š åˆ©ç”¨å¥½ç½‘ä¸Šèµ„æºã€‚ å°½é‡åˆ©ç”¨è¾“å…¥ä¸­çš„å†—ä½™ä¿¡æ¯ã€‚ åˆ©ç”¨å¥½ä½æ“ä½œã€‚ æ³¨æ„ï¼šæœ‰åŒå­¦æµ‹è¯•åŽå°†è‡ªå·±çš„ç­”æ¡ˆæ”¾åœ¨äº†ç½‘ä¸Šï¼Œæˆ‘çœ‹åˆ°çš„å‡ ä¸ªå®žçŽ°éƒ½æ˜¯æœ‰é—®é¢˜çš„ï¼Œè¯·æ³¨æ„ç”„åˆ«ã€‚ å®Œæˆæƒ…å†µ ç›®å‰æ˜¯å®Œæˆäº†æ‰€æœ‰åŠ åˆ†ç‚¹ï¼ˆå½“ç„¶äº†é™¤äº†ä¸èƒ½è°ƒç”¨å¤–éƒ¨å‡½æ•°ï¼Œåªæ˜¯æˆ‘è§‰å¾—è¿™ä¸ªæ²¡æœ‰å¿…è¦ï¼Œå› ä¸ºæˆ‘è°ƒç”¨çš„å‡½æ•°æ²¡æœ‰é€’å½’ï¼Œå¦‚æžœè¦å¼ºè¡Œè§£å†³åŠ åˆ†ç‚¹çš„è¯ï¼Œç›´æŽ¥æŠŠå‡½æ•°å¤åˆ¶åˆ°è°ƒç”¨çš„åœ°æ–¹å°±å¥½äº†ï¼Œä½†æ˜¯è¿™å¾ˆéš¾çœ‹å•Šï¼Œæ‰€ä»¥åªèƒ½å‡è£…è§£å†³äº†æ‰€æœ‰åŠ åˆ†ç‚¹ï¼‰ï¼Œä½†æ˜¯ç‰ºç‰²äº†\([2,\frac{9}{2}]\)çš„æ—¶é—´å¤æ‚åº¦ï¼Œä½†æ˜¯è¿™ä¸ªç®—æ³•æœ¬èº«çš„é‡ç‚¹å°±ä¸åœ¨äºŽæ—¶é—´å¤æ‚åº¦ï¼Œè€Œæ˜¯å¼ºè°ƒé«˜åº¦å¹¶è¡ŒåŒ–ï¼Œè€Œä¸”æˆ‘ä¹Ÿæ˜¯ä¸ºäº†å®Œæˆæ‰€æœ‰çš„åŠ åˆ†ç‚¹ï¼Œåº”è¯•è€Œå·²ã€‚å†µä¸”å¸¸æ•°å€çš„æ—¶é—´å¤æ‚åº¦çš„ç‰ºç‰²ï¼Œåœ¨ä»Ž\(O(nlog(n))\)åˆ°\(O(n^2)\)çš„ç‰ºç‰²é¢å‰æ ¹æœ¬ä¸ç®—ä»€ä¹ˆã€‚ å½“ç„¶ä¹Ÿæœ‰ä¸ç‰ºç‰²æ—¶é—´å¤æ‚åº¦çš„ï¼Œä½†æ˜¯æ²¡æœ‰å–æ¶ˆé€’å½’çš„æ–¹æ³•ï¼Œæˆ‘è§‰å¾—è¿˜æ˜¯æ¯”è¾ƒå¥½çš„ã€‚å¦‚ï¼šä¼ é€é—¨ å†æ¥è®²è®²æˆ‘çš„ä¸»è¦ä¼˜åŒ–æ–¹æ³•ï¼Œå…¶å®žæˆ‘çš„ä¼˜åŒ–æ–¹æ³•éžå¸¸ç®€å•ï¼Œç”šè‡³å¯ä»¥è¯´æ˜¯å¾ˆæ— è„‘äº†ã€‚ æˆ‘æ¨¡æ‹Ÿäº†å†’æ³¡æŽ’åºçš„ç®—æ³•ï¼Œå°†å¾…æŽ’åºçš„åºåˆ—åˆ†æ®µï¼Œè§†æƒ…å†µåˆ†æˆ2æˆ–è€…3æ®µï¼Œå…è®¸æ¯æ®µæœ‰é‡å ï¼Œä½†æ˜¯æ‰€æœ‰çš„æ®µå¿…é¡»è¦†ç›–åŽŸæ¥çš„åºåˆ—ï¼Œä¸”æ¯ä¸€æ®µçš„é•¿åº¦éƒ½æ˜¯\(2^k\)çš„ã€‚ ç„¶åŽå°±å¯ä»¥æ¨¡æ‹Ÿå†’æ³¡æŽ’åºï¼Œå¦‚ä¸‹å›¾è¿›è¡Œä¼˜åŒ–äº†ï¼Œè¿™é‡Œåº”è¯¥ç”»ä¸€ä¸ªå›¾å°±å¾ˆå¥½ç†è§£çš„ï¼Œä½†æ˜¯æˆ‘æ¯”è¾ƒæ‡’-_-ï¼Œå¤§ä½¬ä»¬è‡ªå·±ç”»ä¸ªå›¾å°±å¾ˆå®¹æ˜“ç†è§£äº†ã€‚ 1234567891011121314if(len == step) mySort(data + seg_start[i], len);else if (len &lt;= step + (step &gt;&gt; 1)) &#123; for (int j = 0; j &lt; 2; j++) &#123; mySort(data + seg_start[i], step); mySort(data + seg_start[i] + len - step, step); &#125;&#125;else &#123; for (int j = 0; j &lt; 3; j++) &#123; mySort(data + seg_start[i], step); mySort(data + seg_start[i] + (len - step) / 2, step); mySort(data + seg_start[i] + len - step, step); &#125;&#125; ä»£ç  æˆ‘çš„Githubæœ‰æ›´åŠ è¯¦ç»†çš„ä»£ç ï¼Œè¿˜æœ‰ä¸€ä¸ªå…¶ä»–çš„è§£æ³•ï¼Œä»¥åŠå¯¹æ‹çš„debugç¨‹åºï¼Œæˆ‘æ²¡æœ‰æ”¾ä¸Šæ¥ï¼Œæœ‰å…´è¶£çš„å¯ä»¥è‡ªå·±åŽ»çœ‹ï¼Œä¼ é€é—¨ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** @Author: sun000* @Date: 2018-06-03 09:18:30* @Last Modified by: sun000* @Last Modified time: 2018-06-03 16:05:17*/#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;void mySort(float *data, int n) &#123; //å°±æ˜¯æœ€åŸºç¡€çš„é•¿åº¦ä¸º2^kçš„è§£æ³• for (int unitLen = 2; unitLen &lt;= n; unitLen &lt;&lt;= 1) &#123; bool flag = true; for (int s = 0; s &lt; n; s += unitLen, flag ^= true) &#123; int e = s + unitLen; if (flag) &#123; for (int step = unitLen; step &gt; 1; step &gt;&gt;= 1) &#123; for (int s2 = s; s2 &lt; e; s2 += step) &#123; int e2 = s2 + step; int mid = (s2 + e2) &gt;&gt; 1; for (int i = 0; i &lt; (step &gt;&gt; 1); i++) &#123; if ((data[s2 + i] &gt; data[mid + i]) || (!isnan(data[s2 + i]) &amp;&amp; isnan(data[mid + i])) ) swap(data[s2 + i], data[mid + i]); &#125; &#125; &#125; &#125; else &#123; for (int step = unitLen; step &gt; 1; step &gt;&gt;= 1) &#123; for (int s2 = s; s2 &lt; e; s2 += step) &#123; int e2 = s2 + step; int mid = (s2 + e2) &gt;&gt; 1; for (int i = 0; i &lt; (step &gt;&gt; 1); i++) &#123; if ((data[s2 + i] &lt; data[mid + i]) || (isnan(data[s2 + i]) &amp;&amp; !isnan(data[mid + i])) ) swap(data[s2 + i], data[mid + i]); &#125; &#125; &#125; &#125; &#125; &#125;&#125;void segmentedBitonicSort(float * data, int* seg_id, int* seg_start, int n, int m) &#123; for (int i = 0; i &lt; m; i++) &#123; int len = seg_start[i + 1] - seg_start[i]; int step = 1 &lt;&lt; (int)log2(len); if(len == step) mySort(data + seg_start[i], len); else if (len &lt;= step + (step &gt;&gt; 1)) &#123; for (int j = 0; j &lt; 2; j++) &#123; mySort(data + seg_start[i], step); mySort(data + seg_start[i] + len - step, step); &#125; &#125; else &#123; for (int j = 0; j &lt; 3; j++) &#123; mySort(data + seg_start[i], step); mySort(data + seg_start[i] + (len - step) / 2, step); mySort(data + seg_start[i] + len - step, step); &#125; &#125; &#125;&#125;int main(void) &#123; int n, m; scanf("%d %d", &amp;n, &amp;m); float *data = new float[n]; int *seg_start = new int[m + 1]; for(int i = 0; i &lt; n; i++) scanf("%f", &amp;data[i]); for(int i = 0; i &lt; m + 1; i++) scanf("%d", &amp;seg_start[i]); segmentedBitonicSort(data, nullptr, seg_start, n, m); for (int i = 0; i &lt; m; i++) &#123; for (int j = seg_start[i]; j &lt; seg_start[i + 1]; j++) printf("%f ", data[j]); printf("\n"); &#125;&#125;]]></content>
      <categories>
        <category>æœºè¯•</category>
      </categories>
      <tags>
        <tag>åŒè°ƒæŽ’åº</tag>
        <tag>å¹¶è¡Œå¤„ç†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æµ™å¤§ç ”ç©¶ç”Ÿæœºè¯•11-20é¢˜]]></title>
    <url>%2F2018%2F06%2F03%2F%E6%B5%99%E5%A4%A7%E7%A0%94%E7%A9%B6%E7%94%9F%E6%9C%BA%E8%AF%9511-20%E9%A2%98%2F</url>
    <content type="text"><![CDATA[ç•…é€šå·¥ç¨‹ é¢˜ç›®é“¾æŽ¥ åˆ†æž å¹¶æŸ¥é›†åˆæ±‚è”é€šé‡ ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** @Author: sun000* @Date: 2018-05-31 19:07:17* @Last Modified by: sun000* @Last Modified time: 2018-05-31 19:23:08*/#include &lt;cstdio&gt;int fa[1010];int s;void init(int n) &#123; s = n; for(int i = 0; i &lt;= s; i++) fa[i] = i;&#125;int fin(int x) &#123; if(fa[x] == x) return x; return fa[x] = fin(fa[x]);&#125; void un(int x, int y) &#123; x = fin(x); y = fin(y); if(x != y) &#123; fa[x] = y; s--; &#125;&#125;int main(void) &#123; int n, m, u, v; while(scanf("%d", &amp;n) != EOF &amp;&amp; n) &#123; scanf("%d", &amp;m); init(n); for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d", &amp;u, &amp;v); un(u, v); &#125; printf("%d\n", s - 1); &#125; return 0;&#125; ç»Ÿè®¡å­—ç¬¦ é¢˜ç›®é“¾æŽ¥ ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839/** @Author: sun000* @Date: 2018-05-31 20:35:27* @Last Modified by: sun000* @Last Modified time: 2018-05-31 20:40:16*/#include &lt;cstdio&gt;#include &lt;map&gt;using namespace std;map&lt;char, int&gt; m;char mm[10];int cnt;int main(void) &#123; char tmp; while(scanf("%c", &amp;tmp) != EOF &amp;&amp; tmp != '#') &#123; int cnt = 0; mm[cnt++] = tmp; m.clear(); m[tmp] = 0; while(scanf("%c", &amp;tmp), tmp != '\n') &#123; m[tmp] = 0; mm[cnt++] = tmp; &#125; scanf("%c", &amp;tmp); if(m.find(tmp) != m.end()) m[tmp] += 1; while(scanf("%c", &amp;tmp), tmp != '\n') &#123; if(m.find(tmp) != m.end()) m[tmp] += 1; &#125; for(int i = 0; i &lt; cnt; i++) printf("%c %d\n", mm[i], m[mm[i]]); &#125; return 0;&#125; æ¸¸èˆ¹å‡ºç§Ÿ é¢˜ç›®é“¾æŽ¥ åˆ†æž è¿™é“é¢˜ç›®çš„åº”è¯¥æ˜¯æœ‰é—®é¢˜çš„ï¼Œä¸€è¾†èˆ¹åœ¨æ²¡è¿˜ä¹‹å‰é‡å¤å€Ÿå‡ºï¼Œæœ¬é¢˜æ˜¯ä»¥æœ€åŽä¸€æ¬¡ä¸ºå‡†çš„ï¼Œä¸€è¾†èˆ¹æŽ¥è§¦ä¹‹åŽï¼Œç«Ÿç„¶å¯ä»¥é‡å¤è¿˜ã€‚ä¸å¯æ€è®®ï¼Œåžƒåœ¾é¢˜ã€‚æˆ‘è´´çš„ä»£ç ä¸èƒ½è¿‡ï¼Œä½†æ˜¯æˆ‘æ˜¯è‡ªå·±çš„ç†è§£å†™çš„ã€‚ ä»£ç  123456789101112131415161718192021222324252627282930313233343536/** @Author: sun000* @Date: 2018-05-31 20:42:41* @Last Modified by: sun000* @Last Modified time: 2018-05-31 20:52:43*/#include &lt;cstdio&gt;#include &lt;cstring&gt;int t[120];int main(void) &#123; int ids, h, m, ans, num; char op; memset(t, -1, sizeof(t)); while(scanf("%d", &amp;ids) != EOF &amp;&amp; ids != -1) &#123; scanf(" %c %d:%d", &amp;op, &amp;h, &amp;m); if(ids == 0) &#123; if(num) ans = (int)(1.0 * ans / num + 0.5); printf("%d %d\n", num, ans); ans = 0; num = 0; memset(t, -1, sizeof(t)); &#125; else &#123; if(op == 'S' &amp;&amp; t[ids] == -1) t[ids] = h * 60 + m; else if(t[ids] != -1) &#123; ans += h * 60 + m - t[ids]; t[ids] = -1; num++; &#125; &#125; &#125; return 0;&#125; ç®€å•è®¡ç®—å™¨ é¢˜ç›®é“¾æŽ¥ åˆ†æž è¿™é“é¢˜ç›®ç†è®ºä¸Šæ˜¯åº”è¯¥æ˜¯è½¬æ¢æˆé€†æ³¢å…°è¡¨è¾¾å¼è®¡ç®—çš„ã€‚è¦æ¥é‚£ä¸ªstackï¼Œæ“ä½œçš„æ—¶å€™è¦åˆ¤æ–­å½“å‰ç¬¦å·å’Œæ ˆé¡¶ç¬¦å·çš„ä¼˜å…ˆçº§ã€‚æ‰€ä»¥Pythonå¤§æ³•å¥½ ä»£ç  1234567while True: try: a=input() if a!="0": print("&#123;0:.2f&#125;".format(eval(a))) except: break A+B é¢˜ç›®é“¾æŽ¥ ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** @Author: sun000* @Date: 2018-06-01 14:41:15* @Last Modified by: sun000* @Last Modified time: 2018-06-01 15:00:14*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int getNum(string str) &#123; if(str[0] == 'z') return 0; else if(str[0] == 'o') return 1; else if(str[0] == 't') return str[1] == 'w' ? 2 : 3; else if(str[0] == 'f') return str[1] == 'o' ? 4 : 5; else if(str[0] == 's') return str[1] == 'i' ? 6 : 7; else if(str[0] == 'e') return 8; return 9;&#125;int a, b;bool read() &#123; a = b = 0; string tmp; while(!cin.eof()) &#123; cin &gt;&gt; tmp; if( tmp == "+") break; a = a * 10 + getNum(tmp); &#125; while(!cin.eof()) &#123; cin &gt;&gt; tmp; if( tmp == "=") break; b = b * 10 + getNum(tmp); &#125; return (a &amp;&amp; b);&#125;int main(void) &#123; while(read()) printf("%d\n", a + b); return 0;&#125; ZOJ é¢˜ç›®é“¾æŽ¥ ä»£ç  1234567891011121314151617181920212223242526272829303132333435363738/** @Author: sun000* @Date: 2018-06-03 17:05:57* @Last Modified by: sun000* @Last Modified time: 2018-06-03 17:13:49*/#include &lt;cstdio&gt;#include &lt;cstring&gt;char str[110];int main(void) &#123; while(scanf("%s", str) != EOF) &#123; int z = 0, o = 0, j = 0; for(int i = 0; i &lt; strlen(str); i++) &#123; if(str[i] == 'Z') z++; else if(str[i] == 'O') o++; else j++; &#125; while(z || o || j) &#123; if(z) &#123; printf("Z"); z--; &#125; if(o) &#123; printf("O"); o--; &#125; if(j) &#123; printf("J"); j--; &#125; &#125; printf("\n"); &#125; return 0;&#125; XXXå®šå¾‹ é¢˜ç›®é“¾æŽ¥ ä»£ç  1234567891011121314151617181920212223/** @Author: sun000* @Date: 2018-06-03 17:14:50* @Last Modified by: sun000* @Last Modified time: 2018-06-03 17:23:14*/#include &lt;cstdio&gt;int solve(int x) &#123; if(x == 1) return 0; else if(x &amp; 1) return solve((x * 3 + 1) &gt;&gt; 1) + 1; else return solve(x &gt;&gt; 1) + 1;&#125;int main(void) &#123; int n; while(scanf("%d", &amp;n) != EOF &amp;&amp; n) printf("%d\n", solve(n)); return 0;&#125; è¿˜æ˜¯A+B é¢˜ç›®é“¾æŽ¥ ä»£ç  12345678910111213141516171819/** @Author: sun000* @Date: 2018-06-03 17:24:49* @Last Modified by: sun000* @Last Modified time: 2018-06-03 17:26:34*/#include &lt;cstdio&gt;#include &lt;cmath&gt;int main(void) &#123; int a, b, k; while(scanf("%d%d%d", &amp;a, &amp;b, &amp;k) != EOF &amp;&amp; (a || b)) &#123; k = pow(10, k); if(a % k == b % k) printf("-1\n"); else printf("%d\n", a + b); &#125; return 0;&#125; æœ€å¤§æŠ¥é”€é¢åº¦ é¢˜ç›®é“¾æŽ¥ åˆ†æž æš´åŠ›äºŒè¿›åˆ¶æžšä¸¾æ‰€æœ‰å‘ç¥¨ç»„åˆæƒ…å†µæ¥å¤„ç† ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** @Author: sun000* @Date: 2018-06-03 17:30:49* @Last Modified by: sun000* @Last Modified time: 2018-06-03 17:40:07*/#include &lt;cstdio&gt;double all[50];int main(void) &#123; double q, tmp; int n, m; char c; while(scanf("%lf%d", &amp;q, &amp;n) != EOF) &#123; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;m); bool flag = true; all[i] = 0; for(int j = 0; j &lt; m; j++) &#123; scanf(" %c:%lf", &amp;c, &amp;tmp); if(c != 'A' &amp;&amp; c != 'B' &amp;&amp; c != 'C') flag = false; if(tmp &gt; 600) flag = false; all[i] += tmp; &#125; if(all[i] &gt; 1000 || !flag) all[i] = 0; &#125; long long int g = 1 &lt;&lt; n; double ans = 0; for(int s = 0; s &lt; g; s++) &#123; tmp = 0; for(int j = 0; j &lt; n; j++) &#123; if(s &amp; (1 &lt;&lt; j)) &#123; tmp += all[j]; if(tmp &gt; q) break; &#125; &#125; if(tmp &lt;= q &amp;&amp; tmp &gt; ans) ans = tmp; &#125; printf("%.2f\n", ans); &#125; return 0;&#125; æœ‰ä¸€ç‰ˆA+B é¢˜ç›®é“¾æŽ¥ 123456789101112131415161718192021222324/** @Author: sun000* @Date: 2018-06-03 18:28:38* @Last Modified by: sun000* @Last Modified time: 2018-06-03 18:31:15*/#include &lt;cstdio&gt;void print(long long int num, int m) &#123; if(num / m) print(num / m, m); printf("%lld", num % m);&#125;int main(void) &#123; long long int a, b; int m; while(scanf("%d", &amp;m) != EOF &amp;&amp; m) &#123; scanf("%lld%lld", &amp;a, &amp;b); print(a + b, m); printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>æœºè¯•</category>
      </categories>
      <tags>
        <tag>æœºè¯•</tag>
        <tag>æµ™å¤§</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æµ™å¤§ç ”ç©¶ç”Ÿæœºè¯•1-10é¢˜]]></title>
    <url>%2F2018%2F05%2F30%2F%E6%B5%99%E5%A4%A7%E7%A0%94%E7%A9%B6%E7%94%9F%E6%9C%BA%E8%AF%951-10%E9%A2%98%2F</url>
    <content type="text"><![CDATA[æ¬§æ‹‰å›žè·¯ é¢˜ç›®é“¾æŽ¥ åˆ†æž å…ˆåˆ¤æ–­æ¯ä¸ªç‚¹çš„åº¦æ˜¯å¶æ•°ï¼Œç„¶åŽç”¨å¹¶æŸ¥é›†åˆ¤æ–­è¿žé€šæ€§ï¼Œæ³¨æ„å•ä¸ªç‚¹åˆ†ç¦»å‡ºæ¥æ˜¯å¯ä»¥çš„ã€‚ æ³¨ï¼šç¬¬ä¸€æ¬¡å†™æµ™å¤§çš„é¢˜ç›®ï¼Œè™½ç„¶é¢˜ç›®é‡Œé¢è¯´äº†éšåŽè¾“å…¥0è¡¨ç¤ºè¾“å…¥ç»“æŸï¼Œä½†äº‹å®žæ˜¯ä¸Šè¿˜æ˜¯è¦EOFåˆ¤æ–­ï¼Œæˆ‘è¿™é‡ŒTLEäº†å¥½å‡ æ¬¡ã€‚ ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** @Author: sun000* @Date: 2018-05-30 16:14:36* @Last Modified by: sun000* @Last Modified time: 2018-05-30 16:25:31*/#include &lt;cstdio&gt;#include &lt;cstring&gt;int fa[1010];int s;void init(int n) &#123; s = n; for(int i = 0; i &lt;= s; i++) fa[i] = i;&#125;int fin(int x) &#123; if(x == fa[x]) return x; return fa[x] = fin(fa[x]);&#125;void un(int x, int y) &#123; x = fin(x); y = fin(y); if(x != y) &#123; fa[x] = y; s--; &#125;&#125;int V[1010];bool vis[1010];int main(void) &#123; int n, m, u, v; while(scanf("%d", &amp;n) != EOF &amp;&amp; n) &#123; init(n); memset(V, 0, sizeof(V)); memset(vis, false, sizeof(vis)); scanf("%d", &amp;m); for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d", &amp;u, &amp;v); V[u]++; V[v]++; un(u, v); vis[u] = vis[v] = true; &#125; bool ans = true; for(int i = 1; i &lt;= n; i++) &#123; if(!vis[i]) s--; if(V[i] &amp; 1) &#123; ans = false; break; &#125; &#125; if(s != 1) ans = false; printf("%d\n", ans); &#125; return 0;&#125; å¥¥è¿ä¼šæŽ’åºé—®é¢˜ é¢˜ç›®é“¾æŽ¥ åˆ†æž ç›´æŽ¥æŒ‰ç…§å››ç§æƒ…å†µæŽ’åºç„¶åŽï¼Œç„¶åŽç›´æŽ¥è¾“å‡ºå°±å¯ä»¥äº†ï¼Œç®€å•çš„æ¨¡æ‹Ÿé¢˜ã€‚ ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** @Author: sun000* @Date: 2018-05-30 16:26:13* @Last Modified by: sun000* @Last Modified time: 2018-05-30 16:53:47*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f;struct node &#123; int ids; int gold_cnt, medal_cnt, popu_cnt; int rank[4]; void print() &#123; int r = INF, m = -1; for(int i = 0; i &lt; 4; i++) &#123; if(rank[i] &lt; r) &#123; r = rank[i]; m = i + 1; &#125; &#125; printf("%d:%d\n",r, m); &#125;&#125;c[10010];bool cmp0(node a, node b) &#123; return a.ids &lt; b.ids;&#125;bool cmp1(node a, node b) &#123; return a.gold_cnt &gt; b.gold_cnt;&#125;bool cmp2(node a, node b) &#123; return a.medal_cnt &gt; b.medal_cnt;&#125;bool cmp3(node a, node b) &#123; return a.gold_cnt * b.popu_cnt &gt; b.gold_cnt * a.popu_cnt;&#125;bool cmp4(node a, node b) &#123; return a.medal_cnt * b.popu_cnt &gt; b.medal_cnt * a.popu_cnt;&#125;int main(void) &#123; int n, m; while(scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; for(int i = 0; i &lt; n; i++) &#123; c[i].ids = i; scanf("%d%d%d", &amp;c[i].gold_cnt, &amp;c[i].medal_cnt, &amp;c[i].popu_cnt); &#125; sort(c, c + n, cmp1); c[0].rank[0] = 1; for(int i = 1; i &lt; n; i++) &#123; if(c[i].gold_cnt == c[i - 1].gold_cnt) c[i].rank[0] = c[i - 1].rank[0]; else c[i].rank[0] = i + 1; &#125; sort(c, c + n, cmp2); c[0].rank[1] = 1; for(int i = 1; i &lt; n; i++) &#123; if(c[i].medal_cnt == c[i - 1].medal_cnt) c[i].rank[1] = c[i - 1].rank[1]; else c[i].rank[1] = i + 1; &#125; sort(c, c + n, cmp3); c[0].rank[2] = 1; for(int i = 1; i &lt; n; i++) &#123; if(c[i].gold_cnt * c[i - 1].popu_cnt == c[i - 1].gold_cnt * c[i].popu_cnt) c[i].rank[2] = c[i - 1].rank[2]; else c[i].rank[2] = i + 1; &#125; sort(c, c + n, cmp4); c[0].rank[3] = 1; for(int i = 1; i &lt; n; i++) &#123; if(c[i].medal_cnt * c[i - 1].popu_cnt == c[i - 1].medal_cnt * c[i].popu_cnt) c[i].rank[3] = c[i - 1].rank[3]; else c[i].rank[3] = i + 1; &#125; sort(c, c + n, cmp0); int k; for(int i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;k); c[k].print(); &#125; printf("\n"); &#125; return 0;&#125; ç»§ç»­ç•…é€šé—®é¢˜ é¢˜ç›®é“¾æŽ¥ åˆ†æž æœ€å°ç”Ÿæˆæ ‘ ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** @Author: sun000* @Date: 2018-05-30 16:54:02* @Last Modified by: sun000* @Last Modified time: 2018-05-30 17:11:05*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;struct edge &#123; int u, v, w; edge(int mU = 0, int mV = 0, int mW = 0):u(mU),v(mV),w(mW)&#123;&#125;&#125;E[10000];bool cmp(edge a, edge b) &#123; return a.w &lt; b.w;&#125;int fa[110], s;void init(int n) &#123; s = n; for(int i = 0; i &lt;= n; i++) fa[i] = i;&#125;int fin(int x) &#123; if(fa[x] == x) return x; return fa[x] = fin(fa[x]);&#125;bool un(int x, int y) &#123; x = fin(x); y = fin(y); if(x != y) &#123; s--; fa[x] = y; return true; &#125; return false;&#125;int main(void) &#123; int n, op; while(scanf("%d", &amp;n) != EOF &amp;&amp; n) &#123; init(n); for(int i = 0; i &lt; n * (n - 1) / 2; i++) &#123; scanf("%d%d%d%d", &amp;E[i].u, &amp;E[i].v, &amp;E[i].w, &amp;op); if(op) un(E[i].u, E[i].v); &#125; long long int ans = 0; sort(E, E + n * (n - 1) / 2, cmp); for(int i = 0; i &lt; n * (n - 1)/ 2 &amp;&amp; s &gt; 1; i++) &#123; if(un(E[i].u, E[i].v)) ans += 1LL * E[i].w; &#125; printf("%lld\n", ans); &#125; return 0;&#125; ç•…é€šé—®é¢˜ é¢˜ç›®é“¾æŽ¥ åˆ†æž æœ€å°ç”Ÿæˆæ ‘ ä»£ç  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** @Author: sun000* @Date: 2018-05-30 17:12:51* @Last Modified by: sun000* @Last Modified time: 2018-05-30 17:14:43*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;struct edge &#123; int u, v, w; edge(int mU = 0, int mV = 0, int mW = 0):u(mU),v(mV),w(mW)&#123;&#125;&#125;E[10000];bool cmp(edge a, edge b) &#123; return a.w &lt; b.w;&#125;int fa[110], s;void init(int n) &#123; s = n; for(int i = 0; i &lt;= n; i++) fa[i] = i;&#125;int fin(int x) &#123; if(fa[x] == x) return x; return fa[x] = fin(fa[x]);&#125;bool un(int x, int y) &#123; x = fin(x); y = fin(y); if(x != y) &#123; s--; fa[x] = y; return true; &#125; return false;&#125;int main(void) &#123; int n, m; while(scanf("%d%d", &amp;n, &amp;m) != EOF &amp;&amp; n) &#123; init(m); for(int i = 0; i &lt; n; i++) scanf("%d%d%d", &amp;E[i].u, &amp;E[i].v, &amp;E[i].w); long long int ans = 0; sort(E, E + n, cmp); for(int i = 0; i &lt; n &amp;&amp; s &gt; 1; i++) &#123; if(un(E[i].u, E[i].v)) ans += 1LL * E[i].w; &#125; if(s &gt; 1) printf("?\n"); else printf("%lld\n", ans); &#125; return 0;&#125; Grading é¢˜ç›®é“¾æŽ¥ ä»£ç  1234567891011121314151617181920212223242526272829/** @Author: sun000* @Date: 2018-05-31 09:53:13* @Last Modified by: sun000* @Last Modified time: 2018-05-31 09:58:42*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int main(void) &#123; int p, t, g1, g2, g3, gj; while(scanf("%d%d%d%d%d%d", &amp;p, &amp;t, &amp;g1, &amp;g2, &amp;g3, &amp;gj) != EOF) &#123; if(abs(g1 - g2) &lt;= t) printf("%.1f\n", (g1 + g2) / 2.0); else &#123; if(abs(g1 - g3) &lt;= t &amp;&amp; abs(g2 - g3) &lt;= t) printf("%.1f\n", 1.0 * max(g1, max(g2, g3))); else if(abs(g1 - g3) &lt;= t) printf("%.1f\n", (g1 + g3) / 2.0); else if(abs(g2 - g3) &lt;= t) printf("%.1f\n", (g2 + g3) / 2.0); else printf("%.1f\n", 1.0 * gj); &#125; &#125; return 0;&#125; Sharing é¢˜ç›®é“¾æŽ¥ åˆ†æž åªæœ‰ç¬¬ä¸€ä¸ªå…¬å…±èŠ‚ç‚¹ç”±ä¸¤ä¸ªå…¶ä»–èŠ‚ç‚¹æŒ‡å‘ã€‚é™¤äº†ç‰¹ä¾‹ï¼Œæ¥é‚£ä¸ªå­—ç¬¦ä¸²å®Œå…¨ç›¸åŒï¼Œåˆ™å¼€å§‹çš„é¦–åœ°å€å°±ä¸€æ ·ã€‚ ä»£ç  12345678910111213141516171819202122232425262728293031/** @Author: sun000* @Date: 2018-05-31 10:08:43* @Last Modified by: sun000* @Last Modified time: 2018-05-31 10:14:07*/#include &lt;cstdio&gt;#include &lt;cstring&gt;bool vis[1000010];int main(void) &#123; int s1, s2, n; int a, b; char c; int ans; while(scanf("%d%d%d", &amp;s1, &amp;s2, &amp;n) != EOF) &#123; memset(vis, false, sizeof(vis)); if(s1 == s2) ans = s1; vis[s1 + 1] = vis[s2 + 1] = true; for(int i = 0; i &lt; n; i++) &#123; scanf("%d %c %d", &amp;a, &amp;c, &amp;b); if(vis[b + 1]) ans = b; else vis[b + 1] = true; &#125; if(ans == -1) printf("-1\n"); else printf("%05d\n", ans); &#125; return 0;&#125; æ‰¾å‡ºç›´ç³»äº²å±ž é¢˜ç›®é“¾æŽ¥ ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** @Author: sun000* @Date: 2018-05-31 12:14:20* @Last Modified by: sun000* @Last Modified time: 2018-05-31 12:53:51*/#include &lt;cstdio&gt;#include &lt;cstring&gt;const int INF = 0x3f3f;int fa[30], ma[30];int dfs(int tar,int now) &#123; if(now == tar) return 0; if(fa[now] &gt;= 0) &#123; int tmp = dfs(tar, fa[now]); if(tmp &lt; INF) return tmp + 1; &#125; if(ma[now] &gt;= 0) &#123; int tmp = dfs(tar, ma[now]); if(tmp &lt; INF) return tmp + 1; &#125; return INF;&#125;void print(int k, bool flag) &#123; if(k == 0) printf("-\n"); else if(k == 1) printf("%s\n", flag ? "parent" : "child"); else if(k == 2) printf("%s\n", flag ? "grandparent" : "grandchild"); else &#123; for(int i = 0; i &lt; k - 2; i++) printf("great-"); printf("%s\n", flag ? "grandparent" : "grandchild"); &#125;&#125;void solve(char a, char b) &#123; int ans = dfs(a - 'A', b - 'A'); if(ans &lt; INF) print(ans, true); else &#123; ans = dfs(b - 'A', a - 'A'); if(ans &lt; INF) print(ans, false); else printf("-\n"); &#125;&#125;int main(void) &#123; int n, m; char op[5]; while(scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; memset(fa, -1, sizeof(fa)); memset(ma, -1, sizeof(ma)); for(int i = 0; i &lt; n; i++) &#123; scanf("%s", op); if(op[1] != '-') fa[op[0] - 'A'] = op[1] - 'A'; if(op[2] != '-') ma[op[0] - 'A'] = op[2] - 'A'; &#125; for(int i = 0; i &lt; m; i++) &#123; scanf("%s", op); solve(op[0], op[1]); &#125; &#125; return 0;&#125; å¯»æ‰¾å¤§å¯Œç¿ é¢˜ç›®é“¾æŽ¥ ä»£ç  12345678910111213141516171819202122232425/** @Author: sun000* @Date: 2018-05-31 12:54:34* @Last Modified by: sun000* @Last Modified time: 2018-05-31 13:02:09*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int v[100010];int main(void) &#123; int n, m; while(scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; for(int i = 0; i &lt; n; i++) scanf("%d", &amp;v[i]); sort(v, v + n); for(int i = n - 1; i &gt;= 0 &amp;&amp; m; i--, m--) printf("%d%c", v[i], (i &gt; 0 &amp;&amp; m &gt; 1) ? ' ' :'\n'); &#125; return 0;&#125; äºŒå‰æœç´¢æ ‘ é¢˜ç›®é“¾æŽ¥ ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** @Author: sun000* @Date: 2018-05-31 13:10:40* @Last Modified by: sun000* @Last Modified time: 2018-05-31 13:41:12*/#include &lt;cstdio&gt;#include &lt;cstring&gt;struct node &#123; int num; node *l, *r; node(int mNum = -1):num(mNum)&#123;l = r = nullptr;&#125; void rel() &#123; if(l != nullptr) &#123; l -&gt; rel(); delete l; &#125; if(r != nullptr) &#123; r -&gt; rel(); delete r; &#125; &#125;&#125;*root;char str[20];node* build() &#123; node* r = new node(str[0] - '0'); node * pre = nullptr; node * ptr = r; for(int i = 1; i &lt; strlen(str); i++) &#123; pre = nullptr, ptr = r; int num = str[i] - '0'; while(ptr != nullptr) &#123; pre = ptr; if(ptr -&gt; num &gt; num) ptr = ptr -&gt; l; else ptr = ptr -&gt; r; &#125; node *tmp = new node(num); if(pre -&gt; num &gt; num) pre -&gt; l = tmp; else pre -&gt; r = tmp; &#125; return r;&#125;void release(node* k) &#123; k -&gt; rel(); delete k;&#125;bool ans = true;void dfsCheck(node *a, node * b) &#123; if(!ans || (!a &amp;&amp; !b)) return; if((a &amp;&amp; !b) || (b &amp;&amp; !a)) &#123; ans = false; return; &#125; if(a -&gt; num == b -&gt; num) &#123; dfsCheck(a -&gt; l, b -&gt; l); if(!ans) return; dfsCheck(a -&gt; r, b -&gt; r); &#125; else ans = false;&#125; bool solve() &#123; ans = true; node* tmpR = build(); dfsCheck(root, tmpR); release(tmpR); return ans;&#125;int main(void) &#123; int n; while(scanf("%d", &amp;n) != EOF &amp;&amp; n) &#123; scanf("%s", str); root = build(); for(int i = 0; i &lt; n; i++) &#123; scanf("%s", str); printf("%s\n", solve() ? "YES" : "NO"); &#125; release(root); &#125; return 0;&#125; ç«æ˜ŸA+B é¢˜ç›®é“¾æŽ¥ ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** @Author: sun000* @Date: 2018-05-31 14:03:03* @Last Modified by: sun000* @Last Modified time: 2018-05-31 14:23:34*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int prime[30] = &#123;2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113&#125;;int a[30], b[30];int la, lb;bool read() &#123; char c; la = lb = 0; if(scanf("%d%c", &amp;a[la++], &amp;c) == EOF) return false; else &#123; while(c == ',') scanf("%d%c", &amp;a[la++], &amp;c); scanf("%d%c", &amp;b[lb++], &amp;c); while(c == ',') scanf("%d%c", &amp;b[lb++], &amp;c); &#125; for(int l = 0, r = la - 1; l &lt; r; l++, r--) swap(a[l], a[r]); for(int l = 0, r = lb - 1; l &lt; r; l++, r--) swap(b[l], b[r]); return true;&#125;int ans[30];int cnt;void solve() &#123; cnt = 0; int na, nb, nc = 0; for(int i = 0, j = 0; i &lt; la || j &lt; lb; i++, j++) &#123; if(i &gt;= la) na = 0; else na = a[i]; if(j &gt;= lb) nb = 0; else nb = b[i]; nc += na + nb; ans[cnt] = nc % prime[cnt]; nc /= prime[cnt]; cnt++; &#125; if(nc) ans[cnt++] = nc;&#125;int main(void) &#123; while(read()) &#123; solve(); for(int i = cnt - 1; i &gt;= 0; i--) printf("%d%c", ans[i], i ? ',' : '\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>æœºè¯•</category>
      </categories>
      <tags>
        <tag>æœºè¯•</tag>
        <tag>æµ™å¤§</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BP-NeuralNetworkæ‰‹å†™æ•°å­—è¯†åˆ«]]></title>
    <url>%2F2018%2F05%2F21%2FBP-NeuralNetwork%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[æˆ‘ä¸Šä¸€ç¯‡åšå®¢ä¸­å†™äº†BPç®—æ³•çš„ä¸€äº›æ•°å­¦å…¬å¼çš„æŽ¨å¯¼ï¼Œä½†æ˜¯å…¶ä¸­çš„ä»£ç ä¸å¤Ÿå½¢å¼åŒ–ï¼Œåªèƒ½è§£å†³ç‰¹å®šçš„é—®é¢˜ã€‚æ‰€ä»¥è¿™æ¬¡å†™äº†ä¸€ä¸ªé€‚åˆæ›´å¤šé—®é¢˜çš„ä»£ç ã€‚ BPåŽŸç†å°±ä¸å¤šè¯´äº†ã€‚å¯ä»¥çœ‹ä¸Šä¸€ç¯‡åšå®¢ã€‚ä¼ é€é—¨ è¿™æ¬¡æˆ‘åšçš„ä¸»è¦æ˜¯è§£å†³æ‰‹å†™è¯†åˆ«é—®é¢˜ã€‚ ä¸»è¦æ˜¯ä¸ºäº†ç»ƒä¹ BPçš„å½¢å¼åŒ–å†™æ³•ï¼Œæ‰€ä»¥ä¹Ÿæ²¡æœ‰äº¤å‰éªŒè¯ä»€ä¹ˆçš„ã€‚ä¸»è¦æ˜¯å®žçŽ°å´æ©è¾¾è€å¸ˆçš„deep learningä¸­çš„ç¨‹åºæµç¨‹ã€‚ ä¸»è¦æµç¨‹å›¾ï¼š åœ¨å†™ä»£ç çš„è¿‡ç¨‹ä¸­å‘çŽ°çš„ä¸»è¦å‡ ä¸ªé—®é¢˜æ˜¯ï¼š æœ‰çš„æ—¶å€™å°†æ•°æ®è¿›è¡Œä¸­å¿ƒåŒ–ï¼Œåè€Œä¼šä½¿æ¨¡åž‹å˜å·®ã€‚æˆ‘åœ¨è¿™é‡Œåˆšå¼€å§‹å¯¹Xè¿›è¡Œäº†ä¸­å¿ƒåŒ–ï¼Œä½†æ˜¯ç»“æžœå¹¶ä¸å¥½ï¼ˆä¹Ÿæœ‰å¯èƒ½æ˜¯æˆ‘çš„æ‰“å¼€æ–¹å¼ä¸å¯¹ã€‚ã€‚ã€‚ï¼‰ ç¬¬äºŒä¸ªé—®é¢˜å°±æ˜¯ï¼Œåœ¨å¤šåˆ†ç±»æ¨¡åž‹ä¸­ã€‚ç›´æŽ¥ä½¿ç”¨äºŒåˆ†ç±»çš„æŸå¤±å‡½æ•°ï¼Œå¹¶ä¸æ˜¯å¾ˆå¥½ã€‚å°±æ‹¿è¿™ä¸ªä¾‹å­æ¥è¯´ï¼Œè¿™é‡Œä¸€å…±æœ‰10ä¸ªæ ‡ç­¾ï¼Œå¯¹äºŽæ¯ä¸€ä¸ªæ ·æœ¬å°±åªæœ‰ä¸€ä¸ªæ ‡ç­¾æ˜¯å¯¹çš„ï¼Œå¦‚æžœç›´æŽ¥ä½¿ç”¨æœ€æœ´ç´ çš„æŸå¤±å‡½æ•°,é‚£ä¹ˆä¹Ÿå°±æ˜¯æ¯ä¸€ç§åˆ†ç±»çš„æŸå¤±çš„æƒé‡æ˜¯ä¸€æ ·çš„ã€‚ä½†æ˜¯è¯¯åˆ†ç±»çš„æƒ…å†µæœ‰9ç§ï¼Œè€Œæ­£ç¡®çš„åªæœ‰ä¸€ç§ï¼Œé‚£ä¹ˆä¹Ÿå°±å¯¼è‡´äº†æ­£ç¡®åˆ†ç±»å’Œé”™è¯¯åˆ†ç±»çš„æŸå¤±æƒå€¼ä¸å¹³è¡¡ã€‚æ‰€ä»¥åˆ†ç±»å‡†ç¡®çŽ‡éžå¸¸å·®ã€‚æˆ‘ç›®å‰è¿˜æ²¡æœ‰å­¦ä¹ åˆ°æ­£ç¡®çš„è§£å†³æ–¹æ³•ã€‚è‡ªå·±YYçš„æ–¹å¼ï¼Œæ˜¯åœ¨è®¡ç®—æŸå¤±å‡½æ•°çš„æ—¶å€™ï¼Œç»™æ­£æ ·æœ¬ä¹˜ä¸Šä¸€ä¸ªæƒå€¼ã€‚æˆ‘é€‰çš„æ˜¯1024ä¸è¦é—®æˆ‘ä¸ºä»€ä¹ˆã€‚å¸Œæœ›åœ¨ä»¥åŽçš„å­¦ä¹ ä¸­èƒ½å¤Ÿè§£å†³è¿™ä¸ªé—®é¢˜ã€‚ è¿™é‡Œæˆ‘å·²ç»æ‰¾åˆ°äº†è§£å†³æ–¹æ³•ï¼Œæœ‰ä¸€ä¸ªå«softmaxçš„ç®—æ³•ï¼Œå¯ä»¥é€šè¿‡Cross-entropyæ¥è®¡ç®—loss functionï¼Œä¸è¿‡æˆ‘çš„ä»£ç æš‚æ—¶è¿˜æ²¡æœ‰ä¿®æ”¹ï¼Œæ‰€ä»¥æˆ‘ä»£ç ä¸­çš„losså‡½æ•°æ˜¯é”™è¯¯çš„ã€‚ ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#!/usr/bin/env python3import numpy as npimport matplotlib.pyplot as pltfrom sklearn import datasetsfrom sklearn.metrics import classification_report # è¿™ä¸ªåŒ…æ˜¯è¯„ä»·æŠ¥å‘Šdef sigmoid(z): return 1 / (1 + np.exp(-z))def linear(z): return zdef sigmoid_gradient(z): return sigmoid(z) * (1 - sigmoid(z))def linear_gradient(z): return np.ones(z.shape, keepdims=True)def activate(z, method=linear): return method(z)def activate_gradition(z, method=linear_gradient): return method(z)def transform_target(Y): y_matrix = [] for k in range(0, 10): y_matrix.append((Y == k).astype(int)) return np.array(y_matrix)def paraments_init(layer_dims): np.random.seed(7) L = len(layer_dims) # æ€»çš„æ·±åº¦ w = [0] # ä¿å­˜æ¯ä¸€å±‚çš„w,å…ˆæ”¾å…¥ä¸€ä¸ª0æ˜¯ä¸ºäº†æœ‰æ•ˆå‚æ•°ä¸‹æ ‡ä»Ž1å¼€å§‹ï¼Œæ–¹ä¾¿æ“ä½œ b = [0] # ä¿å­˜æ¯ä¸€å±‚çš„b,å…ˆæ”¾å…¥ä¸€ä¸ª0æ˜¯ä¸ºäº†æœ‰æ•ˆå‚æ•°ä¸‹æ ‡ä»Ž1å¼€å§‹ï¼Œæ–¹ä¾¿æ“ä½œ for l in range(1, L): w.append(np.random.randn(layer_dims[l - 1], layer_dims[l])) b.append(np.zeros((layer_dims[l], 1))) return w, b # è¿”å›žå‚æ•°listdef forward(W, b, X, activation): # å‰å‘ä¼ æ’­ Z = [0] A = [X] L = len(W) for l in range(1, L): Z.append(W[l].T @ A[l - 1] + b[l]) A.append(activate(Z[l], activation[l])) return Z, Adef cost(h, Y): return -np.mean(1024 * Y * np.log(h) + (1 - Y) * np.log(1 - h))def backward(W, b, Z, A, Y, activation_gradition, learning_rate=0.01): L = len(W) m = Y.shape[1] dA = - 1024 * Y / A[L - 1] + (1 - Y) / (1 - A[L - 1]) for l in reversed(range(1, L)): dZ = dA * activate_gradition(Z[l], activation_gradition[l]) dW = A[l - 1] @ dZ.T / m db = np.mean(dZ, axis=1, keepdims=True) dA = W[l] @ dZ W[l] -= learning_rate * dW b[l] -= learning_rate * db return W, bdef BP_model(X, Y, layer_dims, activation, activation_gradition, learning_rate=0.01, epoch=1000): W, b = paraments_init(layer_dims) L = len(layer_dims) costs = [] for e in range(epoch): Z, A = forward(W, b, X, activation) if e % 50 == 0: costs.append(cost(A[L - 1], Y)) W, b = backward(W, b, Z, A, Y, activation_gradition, learning_rate) return W, b, costsdef predict(W, b, X, activation): Z, A = forward(W, b, X, activation) h = np.argmax(A[len(A) - 1], axis=0) return hdef cal_accuracy(h, Y_raw): return np.mean((h == Y_raw).astype(int)) * 100def main(): # æ•°æ®åŠ è½½ digits = datasets.load_digits() X = digits.data.T Y_raw = digits.target Y = transform_target(Y_raw) # æ•°æ®åˆ†å‰² random_index = np.arange(X.shape[1]) np.random.shuffle(random_index) test_m = (int)(X.shape[1] * 0.3) test_X = X[:, 0:test_m] test_Y = Y[:, 0:test_m] test_Y_raw = Y_raw[0:test_m] X = X[:, test_m:] Y = Y[:, test_m:] Y_raw = Y_raw[test_m:] # ç½‘ç»œå®šä¹‰ layer_dims = [X.shape[0], 30, 15, Y.shape[0]] activation = [linear, sigmoid, sigmoid, sigmoid] activation_gradition = [linear_gradient, sigmoid_gradient, sigmoid_gradient, sigmoid_gradient] # è®­ç»ƒ W, b, costs = BP_model(X, Y, layer_dims, activation, activation_gradition, 0.015, 8000) # æŸå¤±å‡½æ•°å›¾ # plt.plot(costs) # plt.show() # å‡†ç¡®åº¦ h = predict(W, b, X, activation) print(classification_report(Y_raw, h)) print(cal_accuracy(h, Y_raw)) # é¢„æµ‹ test_h = predict(W, b, test_X, activation) print(classification_report(test_Y_raw, test_h)) print(cal_accuracy(test_h, test_Y_raw))if __name__ == '__main__': main() å®žéªŒç»“æžœï¼š]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>æœºå™¨å­¦ä¹ </tag>
        <tag>ç¥žç»ç½‘ç»œ</tag>
        <tag>åå‘ä¼ æ’­ç®—æ³•</tag>
        <tag>æ‰‹å†™è¯†åˆ«</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BP-NeuralNetwork-åŽŸç†åŠå®žçŽ°]]></title>
    <url>%2F2018%2F05%2F18%2FBP-NeuralNetwork-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[åŽ†å² 1969å¹´M.Minskyå’ŒS.Papertæ‰€è‘—çš„ã€Šæ„ŸçŸ¥æœºã€‹ä¸€ä¹¦å‡ºç‰ˆï¼Œå®ƒå¯¹å•å±‚ç¥žç»ç½‘ç»œè¿›è¡Œäº†æ·±å…¥åˆ†æžï¼Œå¹¶ä¸”ä»Žæ•°å­¦ä¸Šè¯æ˜Žäº†è¿™ç§ç½‘ç»œåŠŸèƒ½æœ‰é™ï¼Œç”šè‡³ä¸èƒ½è§£å†³è±¡&quot;å¼‚æˆ–&quot;è¿™æ ·çš„ç®€å•é€»è¾‘è¿ç®—é—®é¢˜ã€‚åŒæ—¶ï¼Œä»–ä»¬è¿˜å‘çŽ°æœ‰è®¸å¤šæ¨¡å¼æ˜¯ä¸èƒ½ç”¨å•å±‚ç½‘ç»œè®­ç»ƒçš„ï¼Œè€Œå¯¹äºŽå¤šå±‚ç½‘ç»œåˆ™æ²¡æœ‰è¡Œä¹‹æœ‰æ•ˆçš„ä½Žå¤æ‚åº¦ç®—æ³•ï¼Œæœ€åŽä»–ä»¬ç”šè‡³è®¤ä¸ºç¥žç»å…ƒç½‘ç»œæ— æ³•å¤„ç†éžçº¿æ€§é—®é¢˜ã€‚ç„¶è€ŒäºŽ1974å¹´ï¼ŒPaul Werbosé¦–æ¬¡ç»™å‡ºäº†å¦‚ä½•è®­ç»ƒä¸€èˆ¬ç½‘ç»œçš„å­¦ä¹ ç®—æ³•â€”back propagationã€‚è¿™ä¸ªç®—æ³•å¯ä»¥é«˜æ•ˆçš„è®¡ç®—æ¯ä¸€æ¬¡è¿­ä»£è¿‡ç¨‹ä¸­çš„æ¢¯åº¦ï¼Œè®©ä»¥ä¸Šæˆ‘ä»¬çš„æŽ¨å¯¼å¾—ä»¥å®žçŽ°ï¼ï¼ ä¸å·§çš„æ˜¯ï¼Œåœ¨å½“æ—¶æ•´ä¸ªäººå·¥ç¥žç»ç½‘ç»œç¤¾ç¾¤ä¸­æ— äººçŸ¥æ™“Paulæ‰€æå‡ºçš„å­¦ä¹ ç®—æ³•ã€‚ç›´åˆ°80å¹´ä»£ä¸­æœŸï¼ŒBPç®—æ³•æ‰é‡æ–°è¢«David Rumelhartã€Geoffrey HintonåŠRonald Williamsã€David Parkerå’ŒYann LeCunç‹¬ç«‹å‘çŽ°ï¼Œå¹¶èŽ·å¾—äº†å¹¿æ³›çš„æ³¨æ„ï¼Œå¼•èµ·äº†äººå·¥ç¥žç»ç½‘ç»œé¢†åŸŸç ”ç©¶çš„ç¬¬äºŒæ¬¡çƒ­æ½®ã€‚ ç®€ä»‹ å¥½äº†ï¼ŒçŽ°åœ¨è®©æˆ‘ä»¬æ¥äº†è§£ä¸€ä¸‹BPç¥žç»ç½‘ç»œæ˜¯å¦‚ä½•å­¦ä¹ çš„ã€‚ è®¡ç®—å›¾ é¦–å…ˆï¼Œæˆ‘ä»¬æ¥è®²ä¸€è®²è®¡ç®—å›¾çš„æ¦‚å¿µã€‚æˆ‘å°†\(e = (a + b) \times (b+1)\)ç”»æˆä¸€å¼ è®¡ç®—å›¾ã€‚å¦‚ä¸‹ï¼š å‡è®¾è¾“å…¥a=2ï¼Œb=1ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¾ˆå®¹æ˜“æ±‚å‡ºç›¸é‚»èŠ‚ç‚¹ä¹‹é—´çš„åå¯¼å…³ç³»: ç”¨é“¾å¼æ³•åˆ™ \[\frac{\partial e}{\partial a} =\frac{\partial e}{\partial c} \frac{\partial c}{\partial a} \] \[\frac{\partial e}{\partial b} = \frac{\partial e}{\partial c} \frac{\partial c}{\partial b} + \frac{\partial e}{\partial d} \frac{\partial d}{\partial b}\] \(\frac{\partial e}{\partial a}\)çš„å€¼å°±æ˜¯eåˆ°aè·¯å¾„ä¸Šçš„åå¯¼æ•°ä¹˜ç§¯ï¼Œç±»ä¼¼çš„ï¼Œ\(\frac{\partial e}{\partial b}\)æ˜¯ä»Žeåˆ°bçš„ä¸¤æ¡è·¯å¾„çš„åå¯¼æ•°ä¹˜ç§¯å’Œã€‚ç±»ä¼¼çš„å¯ä»¥æŽ¨å‡ºç½‘çŠ¶ç»“æž„çš„åå¯¼æ•°æ±‚æ³•ã€‚è¿™ä¹Ÿæ˜¯TensorFlowçš„å®žçŽ°åŽŸç†ä¹‹ä¸€ã€‚ è¿™ç§æƒ…å†µä¸‹åå¯¼å¾ˆå®¹æ˜“æ±‚å¾—ï¼Œå› ä¸ºæˆ‘ä»¬å·²ç»çŸ¥é“ç½‘ç»œçš„å‡½æ•°å…³ç³»å¼ï¼Œe=ï¼ˆa+bï¼‰*ï¼ˆb+1ï¼‰ï¼Œè¿™æ˜¯ä¸€ä¸ªæ²¡æœ‰æƒå€¼å¹²é¢„ï¼Œå·²çŸ¥è¾“å…¥ä¸Žè¾“å‡ºä¹‹é—´å…³ç³»çš„ç½‘ç»œã€‚å®žé™…å½“ä¸­æˆ‘ä»¬åªæ˜¯çŸ¥é“eä¸Žè¾“å‡ºä¹‹é—´çš„å…³ç³»ï¼Œå°±æ˜¯ä¸Šé¢è¯´çš„C=ï¼ˆy-tï¼‰^2ï¼Œè€Œä¸”ä¼šæœ‰æˆåƒä¸Šä¸‡çš„æƒå€¼å’Œåç½®å¹²é¢„æ±‚å¯¼çš„è¿‡ç¨‹ã€‚é‚£ä¹ˆæ¢ä¸ªæ€è·¯ï¼Œèƒ½ä¸èƒ½æ±‚è¾“å‡ºå¯¹ç»“æžœçš„åå¯¼å‘¢ï¼Ÿ å†åˆ©ç”¨ä¸Šå›¾çš„å…³ç³»ã€‚èŠ‚ç‚¹cå¯¹eåå¯¼2å¹¶å°†ç»“æžœå †æ”¾èµ·æ¥ï¼ŒèŠ‚ç‚¹då¯¹eåå¯¼3å¹¶å°†ç»“æžœå †æ”¾èµ·æ¥ï¼Œè‡³æ­¤ç¬¬äºŒå±‚å®Œæ¯•ï¼Œæ±‚å‡ºå„èŠ‚ç‚¹æ€»å †æ”¾é‡å¹¶ç»§ç»­å‘ä¸‹ä¸€å±‚å‘é€ã€‚èŠ‚ç‚¹cå‘aå‘é€21å¹¶å¯¹å †æ”¾èµ·æ¥ï¼ŒèŠ‚ç‚¹cå‘bå‘é€21å¹¶å †æ”¾èµ·æ¥ï¼ŒèŠ‚ç‚¹då‘bå‘é€\(3*1\)å¹¶å †æ”¾èµ·æ¥ï¼Œè‡³æ­¤ç¬¬ä¸‰å±‚å®Œæ¯•ï¼ŒèŠ‚ç‚¹aå †æ”¾èµ·æ¥çš„é‡ä¸º2ï¼ŒèŠ‚ç‚¹bå †æ”¾èµ·æ¥çš„é‡ä¸º\(2*1+3*1=5\), å³é¡¶ç‚¹eå¯¹bçš„åå¯¼æ•°ä¸º5ã€‚ç®€è¦çš„æ¦‚æ‹¬ï¼Œå°±æ˜¯ä»Žæœ€ä¸Šå±‚çš„èŠ‚ç‚¹eå¼€å§‹ï¼Œä»¥å±‚ä¸ºå•ä½è¿›è¡Œå¤„ç†ã€‚å¯¹äºŽeçš„ä¸‹ä¸€å±‚çš„æ‰€æœ‰å­èŠ‚ç‚¹ï¼Œå°†1ä¹˜ä»¥eåˆ°æŸä¸ªèŠ‚ç‚¹è·¯å¾„ä¸Šçš„åå¯¼å€¼ï¼Œå¹¶å°†ç»“æžœâ€œå †æ”¾â€åœ¨è¯¥å­èŠ‚ç‚¹ä¸­ã€‚ç­‰eæ‰€åœ¨çš„å±‚æŒ‰ç…§è¿™æ ·ä¼ æ’­å®Œæ¯•åŽï¼Œç¬¬äºŒå±‚çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹éƒ½â€œå †æ”¾&quot;äº›å€¼ï¼Œç„¶åŽæˆ‘ä»¬é’ˆå¯¹æ¯ä¸ªèŠ‚ç‚¹ï¼ŒæŠŠå®ƒé‡Œé¢æ‰€æœ‰â€œå †æ”¾â€çš„å€¼æ±‚å’Œï¼Œå°±å¾—åˆ°äº†é¡¶ç‚¹eå¯¹è¯¥èŠ‚ç‚¹çš„åå¯¼ã€‚ç„¶åŽå°†è¿™äº›ç¬¬äºŒå±‚çš„èŠ‚ç‚¹å„è‡ªä½œä¸ºèµ·å§‹é¡¶ç‚¹ï¼Œåˆå§‹å€¼è®¾ä¸ºé¡¶ç‚¹eå¯¹å®ƒä»¬çš„åå¯¼å€¼ï¼Œä»¥&quot;å±‚&quot;ä¸ºå•ä½é‡å¤ä¸Šè¿°ä¼ æ’­è¿‡ç¨‹ï¼Œå³å¯æ±‚å‡ºé¡¶ç‚¹eå¯¹æ¯ä¸€å±‚èŠ‚ç‚¹çš„åå¯¼æ•°ã€‚ ç®—æ³•æµç¨‹ åœ¨è¿™é‡Œæˆ‘ä¸¾ä¸€ä¸ªä¾‹å­ï¼Œå…³äºŽç”¨ä¸¤å±‚BPç¥žç»ç½‘ç»œæ¥æ±‚è§£å¼‚æˆ–(XOR)ã€‚ å¾ˆæ˜¾ç„¶è¿™æ˜¯ä¸€ä¸ªéžçº¿æ€§æ–¹ç¨‹çš„æ±‚è§£è¿‡ç¨‹ã€‚ å‡è®¾å½“å‰æœ‰å¦‚ä¸‹ç½‘ç»œï¼š å®šä¹‰æƒå€¼\(w^{(1)},w^{(2)}\)åˆ†åˆ«æ˜¯è¾“å…¥å±‚åˆ°éšè—å±‚ï¼Œéšè—å±‚åˆ°è¾“å‡ºå±‚çš„é“¾æŽ¥æƒï¼Œå…¶ä¸­é˜ˆå€¼båœ¨\(w\)ä¸­éšå½¢è¡¨è¾¾ï¼Œåç½®èŠ‚ç‚¹\(x_0,h_0\)çš„å€¼å§‹ç»ˆä¸º1ã€‚ å…¶ä¸­\(w^{(1)}_{ij}\)è¡¨ç¤ºè¾“å…¥èŠ‚ç‚¹\(x_i\)å’Œéšè—èŠ‚ç‚¹\(h_j\)ä¹‹é—´çš„è¿žæŽ¥æƒï¼Œç±»ä¼¼çš„ï¼šå…¶ä¸­\(w^{(2)}_{ij}\)è¡¨ç¤ºè¾“éšè—èŠ‚ç‚¹\(h_i\)å’Œè¾“å‡ºèŠ‚ç‚¹\(o_j\)ä¹‹é—´çš„è¿žæŽ¥æƒã€‚ å®šä¹‰ä»£ä»·å‡½æ•°ï¼š \[Cost(h)= \frac{1}{2} \sum_i^m(h-y)^2\] è¿™æ˜¯æœ€æ™®é€šçš„ä»£ä»·å‡½æ•°ï¼Œå½“ç„¶åœ¨logstical regressioné‡Œé¢è¿˜æœ‰å…¶ä»–çš„å®šä¹‰æ–¹æ³•ï¼Œè¿™é‡Œå°±ä¸å¤šè¯´äº†ã€‚ å®šä¹‰æ¿€æ´»å‡½æ•°ï¼š \[sigmoid(x)=\frac{1}{1+e^{-x}}\] åŒæ ·æ¿€æ´»å‡½æ•°ä¹Ÿä¸æ˜¯å”¯ä¸€çš„ï¼Œè¿˜æœ‰tanhç­‰å…¶ä»–çš„é€‰æ‹©ï¼Œè¿™åªæ˜¯æœ€æ™®é€šçš„ä¸€ç§ã€‚ æ¿€æ´»å‡½æ•°çš„æ¢¯åº¦: \[dsigmoid(x) = \frac{\partial sigmoid(x)}{\partial x}=sigmoid(x) \times (1 - sigmoid(x))\] å®šä¹‰ä¸€ä¸ªç¥žç»å•å…ƒçš„ç»“æž„å¦‚ä¸‹ï¼š å…¶ä¸­\(z=w^TX+b, a=sigmoid(z)\) åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­béšè—åœ¨wä¸­ï¼Œaæ˜¯è¯¥ç¥žç»å…ƒçš„è¾“å‡ºï¼Œä¹Ÿæ˜¯ä¸‹ä¸€å±‚ç¥žç»å…ƒçš„è¾“å…¥ã€‚ æ³¨æ„ï¼šæˆ‘è¿™é‡Œæ‰€è®²çš„BPæ˜¯ç´¯ç§¯BPï¼Œæ˜¯ç»¼åˆå¼€ç»¿æ‰€æœ‰çš„æ ·æœ¬çš„ä»£ä»·å‡½æ•°ã€‚è¿˜æœ‰ä¸€ç§BPç®—æ³•å«åšæ ‡å‡†BPæ¯æ¬¡å¯¹ä¸€ä¸ªé˜³åŽ†è¿›è¡Œæ¢¯åº¦ä¸‹é™ï¼Œé€‚ç”¨äºŽæ ·æœ¬æ›´å¤šçš„æƒ…å†µï¼Œå…·ä½“ç»†èŠ‚è¿™é‡Œå°±ä¸å¤šè¯´äº†ã€‚ éšè—å±‚ -&gt; è¾“å‡ºå±‚ï¼š åå‘ä¼ æ’­ç®—æ³•ï¼Œè¯´çš„å°±æ˜¯è¯¯å·®åå“ä¼ æ’­ã€‚æ‰€ä»¥æˆ‘ä»¬å…ˆæ¥è€ƒè™‘\(w^{(2)}\)å³éšè—å±‚å’Œè¾“å‡ºå±‚ä¹‹é—´çš„å‚æ•°å¦‚ä½•æ¢¯åº¦ä¸‹é™ã€‚ ä¸ºäº†è¡¨è¾¾æ–¹ä¾¿ï¼Œåœ¨è¿™éƒ¨åˆ†\(w^{(2)}\)æˆ‘å°±ç›´æŽ¥å†™åš\(w\)äº† ä»¥\(w_{11}\)ï¼ˆå¦‚å›¾ä¸­çº¢è¾¹ï¼‰ä½œä¸ºä¾‹å­: è¦æ›´æ–°\(w_{11}\)ï¼Œå…³é”®åœ¨äºŽæ±‚å½“å‰çŠ¶æ€ï¼Œå…³äºŽ\(w_{11}\)çš„æ¢¯åº¦ï¼Œä¹Ÿå°±æ˜¯\(\frac{\partial Cost}{\partial w_{11}}\) \[\frac{\partial Cost}{\partial w_{11}} = \frac{\partial Cost}{\partial h_1} \frac{\partial h_1}{\partial z_2} \frac{\partial z_2}{\partial w_{11}} ,(è¿™é‡Œçš„h_1å°±æ˜¯ç¥žç»å•å…ƒç»“æž„ä¸­çš„a_{21}ï¼Œå°±æ˜¯è¾“å‡ºå±‚çš„a1)\] æˆ‘ä»¬å…ˆæ¥æ±‚$ $: \[\frac{\partial Cost}{\partial h_1} =\sum_0^m(h_1^{(i)}-y_1^{(i)})\] ç„¶åŽæ˜¯$ $: \[\frac{\partial h_1}{\partial z_2} =dsigmoid(z_2)\] è¿™é‡Œå®šä¹‰ï¼š \[\sigma^{(2)}_1= \frac{\partial Cost}{\partial h_1} \frac{\partial h_1}{\partial z_1} \] è¡¨ç¤ºåœ¨ç¬¬ä¸€ä¸ªè¾“å‡ºå±‚ç¥žç»å…ƒäº§ç”Ÿçš„è¯¯å·® æœ€åŽæ˜¯\(\frac{\partial z_2}{\partial w_{11}}\),è¿™ä¸€é¡¹å¾ˆç®€å•ï¼Œè¿™å°±æ˜¯\(a_{11}\)å³ï¼Œéšè—å±‚çš„ç¬¬ä¸€ä¸ªè¾“å‡ºï¼ˆé™¤åŽ»åç½®å•å…ƒï¼‰ã€‚ å‘é‡åŒ–ä»£ç è¡¨ç¤ºï¼š 12sigma2 = (h - y) * dsigmoid(z2) # (ny, m)dw2 = (a1 @ sigma2.T) / m # (h, n_y) è¾“å…¥å±‚ -&gt; éšè—å±‚: \(w^{(1)}\)çš„æ›´æ–°å…¶å®žå’Œ\(w^{(2)}\)ç±»ä¼¼ã€‚ä»¥ä¸‹\(w_{(1)}\)ä¹Ÿç®€å†™ä½œ\(w\) ä»¥\(w_{11}\)ï¼ˆå¦‚å›¾ä¸­çº¢è¾¹ï¼‰ä½œä¸ºä¾‹å­: å€¼å¾—æ³¨æ„çš„ï¼Œä¹Ÿæ˜¯å’Œ\(w^{(2)}\)æ›´æ–°ä¸åŒçš„æ˜¯ï¼šè¿™é‡Œçš„è¯¯å·®æ¥ä¸Žè¿žä¸ªåœ°æ–¹ï¼Œä¸€ä¸ªæ˜¯\(o_1\)ï¼Œä¸€ä¸ªæ˜¯\(o_2\) \[\frac{\partial Cost}{\partial w_{11}} = \frac{\partial Cost}{\partial a_1} \frac{\partial a_1}{\partial z_1} \frac{\partial z_1}{\partial w_{11}} \] å…ˆæ¥æ±‚\(\frac{\partial Cost}{\partial a_1}\) \[\frac{\partial Cost}{\partial a_1} = \frac{\partial Cost}{\partial z_2}\frac{\partial z_2}{\partial a_1}=\sigma_2 \frac{\partial z_2}{\partial a_1}\] è¿™é‡Œçš„\(z_2, \sigma_2\)éƒ½æ˜¯çŸ©é˜µï¼Œæœ€åŽçš„ä¹˜æ³•ä¹Ÿæ˜¯çŸ©é˜µä¹˜æ³•ï¼Œè¡¨ç¤ºè¯¯å·®æ¥è‡ªå¤šä¸ªç¥žç»å•å…ƒï¼Œå³æ¥è‡ªä¸Šå›¾ä¸­ä¸¤æ¡ç»¿è¾¹ \[\frac{\partial a_1}{\partial z_1} = dsigmoid(z_1) \] \[\frac{\partial z_1}{\partial w_{11}}=x_1\] å‘é‡åŒ–ä»£ç è¡¨ç¤ºï¼š 12sigma1 = w2[1:, :].reshape(hidden_size, ny) @ sigma2 * dsigmoid(z1)dw1 = (X @ sigma1.T) / m # (n, h) ä¾‹å­ æœ€åŽæ˜¯æ±‚è§£å¼‚æˆ–ç­‰é€»è¾‘è¿ç®—çš„ç¥žç»ç½‘ç»œåŠå…¶BPè®­ç»ƒè¿‡ç¨‹çš„ ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#!/usr/bin/env pythonimport numpy as npimport matplotlib.pyplot as pltX = np.array([[0, 0, 1, 1], [1, 0, 1, 0]])y = np.array([[0, 0, 1, 0], # ä¸Ž [1, 1, 0, 1], # äºŽéž [1, 0, 1, 1], # æˆ– [0, 1, 0, 0], # æˆ–éž [0, 1, 1, 0]]) # å¼‚æˆ–hidden_size = 5 # éšè—å±‚èŠ‚ç‚¹æ•°é‡ï¼ˆä¸åŒ…æ‹¬åç½®å•å…ƒï¼‰def sigmoid(z): return 1 / (1 + np.exp(-z))def dsigmoid(z): # sigmoidçš„æ¢¯åº¦ return sigmoid(z) * (1 - sigmoid(z))def forward(w1, w2, X, y): # å‰å‘ä¼ æ’­ (n, m) = X.shape z1 = w1.T @ np.concatenate((np.ones(m).reshape(1, m), X)) a1 = sigmoid(z1) z2 = w2.T @ np.concatenate((np.ones(m).reshape(1, m), a1)) h = sigmoid(z2) cost = np.mean(np.power((h - y), 2)) / 2 return z1, a1, z2, h, cost # æ‰€æœ‰è¿”å›žä¸åŒ…å«åç½®å•å…ƒçš„ä¿¡æ¯ï¼Œå› ä¸ºåæ‰§å•å…ƒä¸éœ€è¦æ¢¯åº¦ä¸‹é™def back_regression(w1, w2, X, y, epoch=1000, learning_rate=0.01): # åå‘ä¼ æ’­ (n, m) = X.shape # ç‰¹å¾æ•°é‡, æ ·æœ¬æ•°é‡ ny = y.shape[0] cost_list = [] for i in range(epoch): z1, a1, z2, h, cost = forward(w1, w2, X, y) cost_list.append(cost) # æ±‚æ¢¯åº¦ # éšè—å±‚ -&gt; è¾“å‡ºå±‚ sigma2 = (h - y) * dsigmoid(z2) # (ny, m) dw2 = (a1 @ sigma2.T) / m # (h, n_y) # è¾“å…¥å±‚ -&gt; éšè—å±‚ sigma1 = w2[1:, :].reshape(hidden_size, ny) @ sigma2 * dsigmoid(z1) dw1 = (X @ sigma1.T) / m # (n, h) # åç½®å•å…ƒä¸å˜ dw2 = np.concatenate((np.zeros(ny).reshape(1, ny), dw2)) dw1 = np.concatenate( (np.zeros(hidden_size).reshape(1, hidden_size), dw1)) # å‚æ•°æ›´æ–° w1 = w1 - learning_rate * dw1 w2 = w2 - learning_rate * dw2 return w1, w2, cost_listdef main(): w1 = np.random.randn(X.shape[0] + 1, hidden_size) w2 = np.random.randn(hidden_size + 1, y.shape[0]) z1, a1, z2, h, cost = forward(w1, w2, X, y) w1, w2, costs = back_regression(w1, w2, X, y, 20000, 0.1) z1, a1, z2, h, cost = forward(w1, w2, X, y) print(h) # ç”»å‡ºä»£ä»·å‡½æ•°å˜åŒ–å›¾ fig, ax = plt.subplots(figsize=(8, 6)) ax.plot(costs) plt.show()if __name__ == '__main__': main() å‚è€ƒ çŸ¥ä¹Žhttps://www.zhihu.com/question/27239198?rf=24827633 Charlotte77çš„åšå®¢http://www.cnblogs.com/charlotte77/p/5629865.html æ³¨ï¼šæ›´è¯¦ç»†çš„æŽ¨å¯¼è¿‡ç¨‹å¯ä»¥çœ‹è¯¥åšå®¢]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>æœºå™¨å­¦ä¹ </tag>
        <tag>ç¥žç»ç½‘ç»œ</tag>
        <tag>åå‘ä¼ æ’­ç®—æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¸¸è§éšæœºå˜é‡åŠå…¶æ¦‚çŽ‡åˆ†å¸ƒ]]></title>
    <url>%2F2018%2F05%2F16%2F%E5%B8%B8%E8%A7%81%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%2F</url>
    <content type="text"><![CDATA[å¸¸ç”¨çš„ç¦»æ•£åž‹éšæœºå˜é‡åŠå…¶æ¦‚çŽ‡åˆ†å¸ƒ ï¼ˆ0-1ï¼‰åˆ†å¸ƒï¼ˆä¼¯åŠªåˆ©åˆ†å¸ƒ(Bernoulli distribution)ã€ä¸¤ç‚¹åˆ†å¸ƒï¼‰ å¦‚æžœéšæœºå˜é‡ï¼¸ åªå¯èƒ½å–ï¼ä¸Žï¼‘ä¸¤ä¸ªå€¼ï¼Œå…¶æ¦‚çŽ‡åˆ†å¸ƒä¸ºï¼š \[P\{X = 0\} = 1- p, P\{X = 1\} = p, 0 &lt; p &lt; 1\] æˆ–è€…å†™æˆ \[P\{X = k\} = p^k(1-p)^{1-k}, k = 0, 1, 0 &lt; p &lt;1\] åˆ™ç§°éšæœºå˜é‡ï¼¸ æœä»Žï¼ˆï¼ï¼ï¼‘ï¼‰åˆ†å¸ƒæˆ–ä¸¤ç‚¹åˆ†å¸ƒï¼Žå®ƒçš„æ¦‚çŽ‡åˆ†å¸ƒä¹Ÿå¯ä»¥å†™æˆ X 0 1 P 1-p p äºŒé¡¹åˆ†å¸ƒ åœ¨ï½Žé‡ä¼¯åŠªåˆ©è¯•éªŒä¸­ï¼Œå¦‚æžœä»¥ï¼¸è¡¨ç¤ºäº‹ä»¶ï¼¡ å‡ºçŽ°çš„æ¬¡æ•°ï¼Œåˆ™ï¼¸æ˜¯ä¸€ä¸ªç¦»æ•£åž‹éšæœºå˜é‡ï¼Œå®ƒçš„æ‰€æœ‰å¯èƒ½å–å€¼æ˜¯\(0,1,2,â€¦,n.è®¾ï¼°(ï¼¡)ï¼ pï¼ˆï¼ï¼œ pï¼œï¼‘ï¼‰\)ã€‚å…¸åž‹ä¾‹å­æ˜¯æ‰”ç¡¬å¸ï¼Œç¡¬å¸æ­£é¢æœä¸Šæ¦‚çŽ‡ä¸ºp, é‡å¤æ‰”næ¬¡ç¡¬å¸ï¼Œkæ¬¡ä¸ºæ­£é¢çš„æ¦‚çŽ‡å³ä¸ºä¸€ä¸ªäºŒé¡¹åˆ†å¸ƒæ¦‚çŽ‡ã€‚æ¦‚çŽ‡å‡½æ•°ä¸º \[P\{X=k\}=C_n^kp^k(1-p)^{n-k}\] å¤šé¡¹å¼åˆ†å¸ƒ æŠŠäºŒé¡¹åˆ†å¸ƒå…¬å¼å†æŽ¨å¹¿ï¼Œå°±å¾—åˆ°äº†å¤šé¡¹åˆ†å¸ƒã€‚æ¯”å¦‚æ‰”éª°å­ï¼Œä¸åŒäºŽæ‰”ç¡¬å¸ï¼Œéª°å­æœ‰6ä¸ªé¢å¯¹åº”6ä¸ªä¸åŒçš„ç‚¹æ•°ï¼Œè¿™æ ·å•æ¬¡æ¯ä¸ªç‚¹æ•°æœä¸Šçš„æ¦‚çŽ‡éƒ½æ˜¯1/6ï¼ˆå¯¹åº”p1~p6ï¼Œå®ƒä»¬çš„å€¼ä¸ä¸€å®šéƒ½æ˜¯1/6ï¼Œåªè¦å’Œä¸º1ä¸”äº’æ–¥å³å¯ï¼Œæ¯”å¦‚ä¸€ä¸ªå½¢çŠ¶ä¸è§„åˆ™çš„éª°å­ï¼‰,é‡å¤æ‰”næ¬¡ï¼Œå¦‚æžœé—®æœ‰xæ¬¡ç‚¹æ•°kæœä¸Šçš„æ¦‚çŽ‡å°±æ˜¯ï¼š(åªæŠ•ä¸€æ¬¡kæœä¸Šçš„æ¦‚çŽ‡) \[P\{X=k\}=C_n^kp_k^k(1-p_k)^{n-k}\] å‡ ä½•åˆ†å¸ƒ è®¾è¯•éªŒï¼¥åªæœ‰ä¸¤ä¸ªå¯èƒ½çš„å¯¹ç«‹çš„ç»“æžœï¼¡ åŠï¼¡éžï¼Œå¹¶ä¸”\(ï¼°(ï¼¡)ï¼ pï¼Œï¼°(\overline{ï¼¡}ï¼‰ï¼ï¼‘ï¼ pï¼Œå…¶ä¸­ï¼ï¼œ ï½ï¼œï¼‘\)ï¼Žå°†è¯•éªŒï¼¥ç‹¬ç«‹åœ°é‡å¤è¿›è¡Œä¸‹åŽ»ï¼Œç›´åˆ°äº‹ä»¶ï¼¡å‘ç”Ÿä¸ºæ­¢ï¼Žå¦‚æžœä»¥ï¼¸è¡¨ç¤ºæ‰€éœ€è¦çš„è¯•éªŒæ¬¡æ•°ï¼Œåˆ™ï¼¸æ˜¯ä¸€ä¸ªéšæœºå˜é‡ï¼Œå®ƒå¯èƒ½å–çš„å€¼æ˜¯ï¼‘ï¼Œï¼’ï¼Œï¼“ï¼Œâ‹¯ï¼Žç”±äºŽäº‹ä»¶ï½›ï¼¸ ï¼ ï½‹ï½è¡¨ç¤ºå‰ï½‹ï¼ï¼‘æ¬¡è¯•éªŒä¸­äº‹ä»¶ï¼¡éƒ½æ²¡æœ‰å‘ç”Ÿï¼Œè€Œåœ¨ç¬¬ï½‹æ¬¡è¯•éªŒä¸­äº‹ä»¶ï¼¡ å‘ç”Ÿï¼Œå› æ­¤ \[P\{X=k\}=(1-p)^{k-1}p, k = 1, 2, 3,...\] æˆ‘ä»¬ç§°éšæœºå˜é‡Xæœä»Žå‡ ä½•åˆ†å¸ƒã€‚ æ³Šæ¾åˆ†å¸ƒ è®¾éšæœºå˜é‡ï¼¸ çš„æ‰€æœ‰å¯èƒ½å–å€¼ä¸º\(0,1,2,...\)ï¼Œå¹¶ä¸” \[P\{X=k\}=\frac{\lambda^ke^{-\lambda}}{k!},k=0,1,2,3...\] å…¶ä¸­Î»ï¼žï¼æ˜¯å¸¸æ•°ï¼Œåˆ™ç§°éšæœºå˜é‡ï¼¸æœä»Žå‚æ•°ä¸ºÎ»çš„æ³Šæ¾åˆ†å¸ƒï¼Œè®°ä½œï¼¸ï½žÏ€ï¼ˆÎ»ï¼‰ï¼Žæ˜“çŸ¥ \[\frac{\lambda^ke^{-\lambda}}{k!} &gt; 0, k = 0, 1, 2,...\] \[\sum_{k=0}^{âˆž}\frac{\lambda^ke^{-\lambda}}{k!} =e^{-\lambda}\sum_{k=0}^{âˆž}\frac{\lambda^k}{k!}=e^{-\lambda} \times e^\lambda = 1\] åœ¨å®žé™…é—®é¢˜ä¸­ç»å¸¸ä¼šé‡åˆ°æœä»Žæ³Šæ¾åˆ†å¸ƒçš„éšæœºå˜é‡ï¼Žä¾‹å¦‚ï¼Œåœ¨ä¸€ä¸ªé•¿ä¸ºÏ„çš„æ—¶é—´é—´éš”å†…æŸç”µè¯äº¤æ¢å°æ”¶åˆ°çš„ç”µè¯å‘¼å«æ¬¡æ•°ï¼›æŸåŒ»é™¢åœ¨ä¸€å¤©å†…æ¥æ€¥è¯Šçš„ç—…äººæ•°ï¼›æŸä¸€æœ¬ä¹¦çš„ä¸€é¡µä¸­çš„å°åˆ·é”™è¯¯æ•°ç­‰éƒ½æœä»Žæ³Šæ¾åˆ†å¸ƒï¼Ž å½“äºŒé¡¹åˆ†å¸ƒçš„nå¾ˆå¤§è€Œpå¾ˆå°æ—¶ï¼Œæ³Šæ¾åˆ†å¸ƒå¯ä½œä¸ºäºŒé¡¹åˆ†å¸ƒçš„è¿‘ä¼¼ï¼Œå…¶ä¸­Î»ä¸ºnpã€‚ å¸¸ç”¨çš„ç¦»æ•£åž‹éšæœºå˜é‡åŠå…¶æ¦‚çŽ‡åˆ†å¸ƒ å‡åŒ€åˆ†å¸ƒ è®¾è¿žç»­åž‹éšæœºå˜é‡ï¼¸ çš„æ¦‚çŽ‡å¯†åº¦ä¸º \[f(x) = \begin{cases} \frac{1}{b-a}, a &lt; x &lt;b\\0 ,å…¶ä»–\\ \end{cases} \] åˆ™ç§°ï¼¸åœ¨åŒºé—´ï¼»ï½ï¼Œï½‚ï¼½ä¸Šæœä»Žå‡åŒ€åˆ†å¸ƒï¼Žï¼¸ çš„åˆ†å¸ƒå‡½æ•°ä¸º \[F(x) = \begin{cases} 0, x &lt;a\\ \frac{x-a}{b-a}, a \leq x &lt;b\\1 ,b\leq x\\ \end{cases} \] ï¼¸çš„æ¦‚çŽ‡å¯†åº¦å’Œåˆ†å¸ƒå‡½æ•°çš„å›¾å½¢åˆ†åˆ«å¦‚å›¾æ‰€ç¤ºï¼š æŒ‡æ•°åˆ†å¸ƒ è®¾è¿žç»­åž‹éšæœºå˜é‡ï¼¸ å…·æœ‰æ¦‚çŽ‡å¯†åº¦ \[f(x)=\begin{cases} \frac{1}{\theta}e^{-\frac{x}{\theta}}, x&gt;0\\0,x \leq 0\end{cases}\] å…¶ä¸­Î¸ï¼žï¼æ˜¯å¸¸æ•°ï¼Œåˆ™ç§°ï¼¸æœä»Žå‚æ•°ä¸ºÎ¸çš„æŒ‡æ•°åˆ†å¸ƒï¼Žï¼¸çš„åˆ†å¸ƒå‡½æ•°ä¸º \[F(x)=\begin{cases} 1-e^{-\frac{x}{\theta}}, x&gt;0\\0,x \leq 0\end{cases}\] ï¼¸çš„æ¦‚çŽ‡å¯†åº¦åŠåˆ†å¸ƒå‡½æ•°çš„å›¾å½¢åˆ†åˆ«å¦‚å›¾æ‰€ç¤ºï¼š å®žé™…é—®é¢˜ä¸­çš„è®¸å¤šéšæœºå˜é‡ï¼Œä¾‹å¦‚ç”µå­å…ƒä»¶çš„å¯¿å‘½ï¼Œæ—…å®¢åœ¨è½¦ç«™å”®ç¥¨å¤„è´­ä¹°è½¦ç¥¨éœ€è¦ç­‰å¾…çš„æ—¶é—´ç­‰éƒ½å¯ä»¥çœ‹æˆæ˜¯æœä»ŽæŒ‡æ•°åˆ†å¸ƒã€‚ æ­£æ€åˆ†å¸ƒ è®¾éšæœºå˜é‡ï¼¸ å…·æœ‰æ¦‚çŽ‡å¯†åº¦ \[f(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{\frac{(x- \mu)^2}{2\sigma^2}},-âˆž &lt; x &lt; +âˆž\] å…¶ä¸­Î¼ï¼ŒÏƒï¼ˆÏƒï¼žï¼ï¼‰ä¸ºå¸¸æ•°ï¼Œåˆ™ç§°ï¼¸æœä»Žå‚æ•°ä¸ºÎ¼ï¼ŒÏƒçš„æ­£æ€åˆ†å¸ƒï¼Œè®°ä½œï¼¸ï½ž ï¼®ï¼ˆÎ¼ï¼ŒÏƒï¼’ï¼‰ï¼Žï¼¸çš„åˆ†å¸ƒå‡½æ•°ä¸º \[F(x;\mu,\sigma)=\frac{1}{\sigma\sqrt{2\pi}}{\int_{-âˆž}^x(-\frac{(x-\mu)^2}{2\sigma^2}dx)}\] å®ƒä»¬çš„å›¾å½¢åˆ†åˆ«å¦‚å›¾æ‰€ç¤ºï¼š å®¹æ˜“çœ‹åˆ°æ¦‚çŽ‡å¯†åº¦æ›²çº¿ï½™ï¼ ï½†(ï½˜)å…³äºŽç›´çº¿ï½˜ï¼ Î¼å¯¹ç§°ï¼Œå¹¶åœ¨ï½˜ï¼ Î¼å¤„å–å¾—æœ€å¤§å€¼\(\frac{1}{\sqrt{2\pi}\sigma}\),åœ¨æ¨ªåæ ‡ï½˜ï¼ Î¼Â± Ïƒå¤„æœ‰æ‹ç‚¹ï¼Œä»¥ï½˜è½´ä¸ºæ°´å¹³æ¸è¿‘çº¿ï¼Ž å¦‚æžœÎ¼ï¼ï¼ï¼ŒÏƒï¼ï¼‘ï¼Œåˆ™ç§°ï¼¸æœä»Žæ ‡å‡†æ­£æ€åˆ†å¸ƒï¼Œè®°ä½œï¼¸~ï¼®(0,1)ï¼Žå®ƒçš„æ¦‚çŽ‡å¯†åº¦åŠåˆ†å¸ƒå‡½æ•°åˆ†åˆ«è®°ä½œÏ†ï¼ˆï½˜ï¼‰ä¸ŽÎ¦ï¼ˆï½˜ï¼‰ï¼Œå³ \[\varphi(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}, (-âˆž &lt; x &lt; +âˆž) \] \[\Phi(x)=F(x;0,1)=\frac{1}{\sqrt{2\pi}}\int_{-âˆž}^x{e^{-\frac{x^2}{2}}dx}\] å‚è€ƒèµ„æ–™ï¼šæ¦‚çŽ‡è®ºä¸Žæ•°ç†ç»Ÿè®¡ å‰æž—å¤§å­¦]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>æœºå™¨å­¦ä¹ </tag>
        <tag>æ¦‚çŽ‡è®º</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop-MapReduceå…¥é—¨]]></title>
    <url>%2F2018%2F05%2F14%2FHadoop-MapReduce%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[è½¬è‡ªCSDNï¼›æ”¹äº†å‡ ä¸ªç¬”è¯¯ åŽŸåšå®¢é“¾æŽ¥ MapReduceæ˜¯ç”¨äºŽæ•°æ®å¤„ç†çš„ä¸€ç§ç¼–ç¨‹æ¨¡åž‹ï¼Œç®€å•ä½†è¶³å¤Ÿå¼ºå¤§ï¼Œä¸“é—¨ä¸ºå¹¶è¡Œå¤„ç†å¤§æ•°æ®è€Œè®¾è®¡ã€‚ é€šä¿—ç†è§£MapReduce ä¾‹å¦‚ä»Žå¤§é‡åŽ†å²æ•°æ®ä¸­æ‰¾å‡ºå¾€å¹´æœ€é«˜æ°”æ¸©ï¼ŒNCDCå…¬å¼€äº†è¿‡åŽ»æ¯ä¸€å¹´çš„æ‰€æœ‰æ°”æ¸©ç­‰å¤©æ°”æ•°æ®çš„æ£€æµ‹ï¼Œæ¯ä¸€è¡Œè®°å½•ä¸€æ¡è§‚æµ‹è®°å½•ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š MapReduce-1 ä¸ºäº†ä½¿ç”¨MapReduceæ‰¾å‡ºåŽ†å²ä¸Šæ¯å¹´çš„æœ€é«˜æ¸©åº¦ï¼Œæˆ‘ä»¬å°†è¡Œæ•°ä½œä¸ºmapè¾“å…¥çš„keyï¼Œæ¯ä¸€è¡Œçš„æ–‡æœ¬ä½œä¸ºmapè¾“å…¥çš„valueï¼š MapReduce-2 ä¸Šå›¾ä¸­ç²—ä½“éƒ¨åˆ†åˆ†åˆ«è¡¨ç¤ºå¹´ä»½å’Œæ¸©åº¦ã€‚mapå‡½æ•°å¯¹æ¯ä¸€è¡Œè®°å½•è¿›è¡Œå¤„ç†ï¼Œæå–å‡ºï¼ˆå¹´ä»½ï¼Œæ¸©åº¦ï¼‰å½¢å¼çš„é”®å€¼å¯¹ï¼Œä½œä¸ºmapçš„è¾“å‡º 12345(1950,0)(1950,22)(1950,-11)(1949,111)(1947,78) å¾ˆæ˜Žæ˜¾ï¼Œæœ‰äº›æ•°æ®æ˜¯è„ï¼ˆé”™è¯¯ï¼‰çš„ï¼Œæ¯”å¦‚æœ‰äº›å¹´ä»½çš„æ°”æ¸©ä¸¢å¤±ï¼Œæˆ–è€…ä¸åœ¨ç†è®ºèŒƒå›´å†…ï¼Œå› æ­¤mapä¹Ÿæ˜¯è¿›è¡Œè„æ•°æ®å¤„ç†å’Œè¿‡æ»¤çš„å¥½åœ°æ–¹ã€‚åœ¨mapè¾“å‡ºè¢«ä¼ è¾“åˆ°reduceä¹‹å‰ï¼ŒMapReduceæ¡†æž¶ä¼šå¯¹é”®å€¼å¯¹è¿›è¡ŒæŽ’åºï¼Œæ ¹æ®keyè¿›è¡Œåˆ†ç»„ï¼Œç”šè‡³åœ¨keyç›¸åŒçš„ä¸€ç»„å†…å…ˆç»Ÿè®¡å‡ºæœ€é«˜æ°”æ¸©ï¼Œæ‰€ä»¥reduceæ”¶åˆ°çš„æ•°æ®æ ¼å¼åƒè¿™æ ·ï¼š 12(1949,[111,78](1950,[0,22,-11] å¦‚æžœæœ‰å¤šä¸ªmapä»»åŠ¡åŒæ—¶è¿è¡Œï¼ˆé€šå¸¸éƒ½æ˜¯çš„ï¼Œè¿™å°±æ˜¯MapReduceæ¥å¹¶è¡Œè®¡ç®—çš„åŽŸå› ï¼‰ï¼Œé‚£ä¹ˆæ¯ä¸ªmapä»»åŠ¡å®ŒæˆåŽï¼Œéƒ½ä¼šå‘reduceå‘é€ä¸Šé¢æ ¼å¼çš„æ•°æ®ï¼Œå‘é€æ•°æ®çš„è¿‡ç¨‹å«shuffleã€‚ mapçš„è¾“å‡ºä¼šä½œä¸ºreduceçš„è¾“å…¥ï¼Œreduceæ”¶åˆ°çš„æ˜¯keyåŠ ä¸Šä¸€ä¸ªåˆ—è¡¨ï¼Œç„¶åŽå¯¹è¿™ä¸ªåˆ—è¡¨è¿›è¡Œå¤„ç†ï¼Œå¤©æ°”æ•°æ®çš„ä¾‹å­ä¸­ï¼Œå°±æ˜¯æ‰¾å‡ºæœ€å¤§å€¼ä½œä¸ºæœ€é«˜æ°”æ¸©ã€‚æœ€åŽreduceè¾“å‡ºå³ä¸ºæ¯å¹´æœ€é«˜æ°”æ¸©ï¼š 12(1949,111)(1950,22) æ•´ä¸ªMapReduceæ•°æ®æµå¦‚ä¸‹å›¾ï¼š MapReduce-3 å…¶ä¸­çš„3ä¸ªé»‘åœˆåœˆåˆ†åˆ«ä¸ºmapï¼Œshuffleå’Œreduceè¿‡ç¨‹ã€‚åœ¨Hadoopä¸­ï¼Œmapå’Œreduceçš„æ“ä½œå¯ä»¥ç”±å¤šç§è¯­è¨€æ¥ç¼–å†™ï¼Œä¾‹å¦‚Javaã€Pythonã€Rubyç­‰ã€‚ åœ¨å®žé™…çš„åˆ†å¸ƒå¼è®¡ç®—ä¸­ï¼Œä¸Šè¿°è¿‡ç¨‹ç”±æ•´ä¸ªé›†ç¾¤åè°ƒå®Œæˆï¼Œæˆ‘ä»¬å‡è®¾çŽ°åœ¨æœ‰5å¹´ï¼ˆ2011-2015ï¼‰çš„å¤©æ°”æ•°æ®ï¼Œåˆ†å¸ƒå­˜æ”¾åœ¨3ä¸ªæ–‡ä»¶ä¸­: weather1.txtï¼Œweather2.txtï¼Œweather3.txtã€‚å†å‡è®¾æˆ‘ä»¬çŽ°åœ¨æœ‰ä¸€ä¸ª3å°æœºå™¨çš„é›†ç¾¤ï¼Œbå¹¶ä¸”mapä»»åŠ¡å®žä¾‹æ•°é‡ä¸º3ï¼Œreduceå®žä¾‹æ•°é‡2ã€‚é‚£ä¹ˆå®žé™…è¿è¡ŒMapReduceåšä½œä¸šæ—¶ï¼Œæ•´ä¸ªæµç¨‹ç±»ä¼¼äºŽè¿™æ ·ï¼š MapReduce-4 æ³¨æ„åˆ°2014å¹´çš„æ•°æ®åˆ†å¸ƒåœ¨ä¸¤ä¸ªä¸åŒçš„æ–‡ä»¶ä¸­ï¼Œé»„è‰²çš„ç²—çº¿éƒ¨åˆ†ï¼Œä»£è¡¨2014å¹´çš„2ä¸ªmapä½œä¸šçš„è¾“å‡ºéƒ½ç»Ÿä¸€ä¼ è¾“åˆ°ä¸€ä¸ªreduceï¼Œå› ä¸ºä»–ä»¬çš„keyç›¸åŒï¼ˆ2014ï¼‰ã€‚å…¶å®žè¿™ä¸ªè¿‡ç¨‹éžå¸¸å¥½ç†è§£ï¼ŒçŽ°å®žç”Ÿæ´»ä¸­ï¼Œæ¯”å¦‚æœŸæœ«è€ƒè¯•å®Œäº†ï¼Œé‚£è€ƒå·ç”±ä¸åŒçš„è€å¸ˆæ‰¹æ”¹ï¼Œå®ŒæˆåŽå¦‚æžœæƒ³çŸ¥é“å…¨å¹´çº§æœ€é«˜åˆ†ï¼Œé‚£ä¹ˆå¯ä»¥è¿™ä¹ˆåšï¼š å„ä¸ªè€å¸ˆæ ¹æ®è‡ªå·±æ‰¹æ”¹è¿‡çš„æ‰€æœ‰è¯•å·åˆ†æ•°æ•´ç†å‡ºæ¥ï¼ˆmapï¼‰: 1=&gt;(course,[score1,score2,...]) å„ä¸ªè€å¸ˆæŠŠæœ€é«˜åˆ†æ±‡æŠ¥ç»™ç³»ä¸»ä»»ï¼ˆshuffleï¼‰ ç³»ä¸»ä»»ç»Ÿè®¡æœ€é«˜åˆ†ï¼ˆreduceï¼‰ 1=&gt;(courese, highest_score) å½“ç„¶ï¼Œå¦‚æžœè¦å¤šé—¨è¯¾ç¨‹æ··åœ¨ä¸€èµ·ï¼Œç³»ä¸»ä»»å·¥ä½œé‡å¤ªå¤§ï¼ŒäºŽæ˜¯å‰¯ä¸»ä»»ä¹Ÿä¸Šï¼ˆç›¸å½“äºŽ2ä¸ªreduceï¼‰ï¼Œåˆ™è€å¸ˆåœ¨æ±‡æŠ¥æœ€é«˜åˆ†çš„æ—¶å€™ï¼Œç›¸åŒè¯¾ç¨‹è¦æ±‡æŠ¥ç»™åŒä¸€ä¸ªäººï¼ˆç›¸åŒkeyä¼ è¾“ç»™åŒä¸€ä¸ªreduceï¼‰ï¼Œä¾‹å¦‚æ•°å­¦è‹±è¯­æ±‡æŠ¥ç»™ä¸»ä»»ï¼Œæ”¿æ²»æ±‡æŠ¥ç»™å‰¯ä¸»ä»»ã€‚ å®žä¾‹åŠä»£ç å®žçŽ° life is short , show me the code MapReduceçš„æ¦‚å¿µæ¡†æž¶æœ‰Googleæå‡ºï¼ŒHadoopæä¾›äº†ç»å…¸çš„å¼€æºå®žçŽ°ã€‚ä½†æ˜¯å¹¶ä¸æ˜¯Hadoopç‰¹æœ‰çš„ï¼Œä¾‹å¦‚åœ¨æ–‡æ¡£åž‹æ•°æ®åº“MongoDBä¸­ï¼Œå¯ä»¥é€šè¿‡JSæ¥ç¼–å†™Map-Reduceï¼Œå¯¹æ•°æ®åº“ä¸­çš„æ•°æ®è¿›è¡Œå¤„ç†ã€‚æˆ‘ä»¬è¿™é‡Œä»¥Hadoopä¸ºä¾‹è¯´æ˜Žã€‚ æ•°æ®å‡†å¤‡ é¦–å…ˆå°†æœ¬åœ°çš„æ–‡ä»¶ä¸Šä¼ åˆ°HDFSï¼š 1hadoop fs -copyFromLocal /home/data/hadoop_book_input/ hdfs://master:9000/input å¯ä»¥æŸ¥ç®¡ç†ç•Œé¢æŸ¥çœ‹æ˜¯å¦æˆåŠŸä¸Šä¼ ï¼š MapReduce-5 æŸ¥çœ‹ä¸€ä¸‹æ•°æ®å†…å®¹ï¼š 1hadoop fs -text hdfs://master:9000/input/ncdc/sample.txt MapReduce-6 ç¼–å†™Javaä»£ç  é¦–å…ˆå®žçŽ°Mapperç±»ï¼ŒMapperåœ¨æ–°ç‰ˆæœ¬Hadoopä¸­æ”¹å˜ä¸ºç±»ï¼ˆæ—§ç‰ˆä¸ºæŽ¥å£ï¼‰å®šä¹‰å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435// æ”¯æŒæ³›åž‹ï¼Œæ³›åž‹å®šä¹‰mapè¾“å…¥è¾“å‡ºçš„é”®å€¼ç±»åž‹public class Mapper &lt;KEYIN, VALUEIN, KEYOUT, VALUEOUT&gt; &#123; public Mapper() &#123; &#125; // mapä»»åŠ¡å¼€å§‹çš„æ—¶å€™è°ƒç”¨ä¸€æ¬¡ï¼Œç”¨äºŽåšå‡†å¤‡å·¥ä½œ protected void setup(Context context) throws IOException, InterruptedException &#123; // ç©ºå®žçŽ° &#125; // mapé€»è¾‘ é»˜è®¤ç›´æŽ¥å°†è¾“å…¥è¿›è¡Œç±»åž‹è½¬æ¢åŽè¾“å‡º protected void map(KEYIN key, VALUEIN value, Context context) throws IOException, InterruptedException &#123; context.write((KEYOUT) key, (VALUEOUT) value); &#125; // ä»»åŠ¡ç»“æŸåŽè°ƒç”¨ä¸€æ¬¡ï¼Œæ¸…ç†å·¥ä½œï¼Œä¸Žsetupå¯¹åº” protected void cleanup(Context context ) throws IOException, InterruptedException &#123; // ç©ºå®žçŽ° &#125; // mapçš„å®žé™…è¿è¡Œè¿‡ç¨‹å°±æ˜¯è°ƒç”¨runæ–¹æ³•ï¼Œä¸€èˆ¬ç”¨äºŽé«˜çº§å®žçŽ°ï¼Œæ›´ç²¾ç»†åœ°æŽ§åˆ¶ ä»»åŠ¡çš„æ‰§è¡Œè¿‡ç¨‹, ä¸€èˆ¬æƒ…å†µä¸éœ€è¦è¦†ç›–è¿™ä¸ªæ–¹æ³• public void run(Context context) throws IOException, InterruptedException &#123; // å‡†å¤‡å·¥ä½œ setup(context); try &#123; // éåŽ†åˆ†é…ç»™è¯¥ä»»åŠ¡çš„æ•°æ®ï¼Œå¾ªçŽ¯è°ƒç”¨map while (context.nextKeyValue()) &#123; map(context.getCurrentKey(), context.getCurrentValue(), context); &#125; &#125; finally &#123; // æ¸…ç†å·¥ä½œ cleanup(context); &#125; &#125;&#125; å®žçŽ°ä¸­æˆ‘ä»¬åªè¦†ç›–mapæ–¹æ³•ï¼Œå…¶ä»–ä¿ç•™ä¸å˜ã€‚å…·ä½“å®žçŽ°å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637public class MaxTemperatureMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt; &#123; // 9999ä»£è¡¨æ•°æ®ä¸¢å¤± private static final int MISSING = 9999; @Override public void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123; // è¡Œä½œä¸ºè¾“å…¥å€¼ keyåœ¨è¿™é‡Œæš‚æ—¶ä¸éœ€è¦ä½¿ç”¨ String line = value.toString(); // æå–å¹´ä»½ String year = line.substring(15, 19); // æå–æ°”æ¸© int airTemperature = parseTemperature( line ); String quality = line.substring(92, 93); // è¿‡æ»¤è„æ•°æ® boolean isRecordClean = airTemperature != MISSING &amp;&amp; quality.matches("[01459]"); if ( isRecordClean ) &#123; // è¾“å‡ºï¼ˆå¹´ä»½ï¼Œæ¸©åº¦ï¼‰å¯¹ context.write(new Text(year), new IntWritable(airTemperature)); &#125; &#125; private int parseTemperature(String line)&#123; int airTemperature; if (line.charAt(87) == '+') &#123; // parseInt doesn't like leading plus signs airTemperature = Integer.parseInt(line.substring(88, 92)); &#125; else &#123; airTemperature = Integer.parseInt(line.substring(87, 92)); &#125; return airTemperature; &#125;&#125; æŽ¥ç€å®žçŽ°Reducerï¼Œçœ‹çœ‹å®šä¹‰ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Reducer&lt;KEYIN,VALUEIN,KEYOUT,VALUEOUT&gt; &#123; // Reducerä¸Šä¸‹æ–‡ç±»å®šä¹‰ public abstract class Context implements ReduceContext&lt;KEYIN,VALUEIN,KEYOUT,VALUEOUT&gt; &#123; &#125; // åˆå§‹åŒ– åœ¨Reduceä»»åŠ¡å¼€å§‹æ—¶è°ƒç”¨ä¸€æ¬¡ protected void setup(Context context ) throws IOException, InterruptedException &#123; // ç©ºå®žçŽ° &#125; /** * map shuffleè¿‡æ¥çš„æ•°æ®ä¸­ï¼Œæ¯ä¸€ä¸ªkeyè°ƒç”¨ä¸€æ¬¡è¿™ä¸ªæ–¹æ³• */ @SuppressWarnings("unchecked") protected void reduce(KEYIN key, Iterable&lt;VALUEIN&gt; values, Context context ) throws IOException, InterruptedException &#123; // é»˜è®¤å°†æ‰€æœ‰çš„å€¼ä¸€ä¸€è¾“å‡º for(VALUEIN value: values) &#123; context.write((KEYOUT) key, (VALUEOUT) value); &#125; &#125; protected void cleanup(Context context ) throws IOException, InterruptedException &#123; // ç©ºå®žçŽ° æ”¶å°¾å·¥ä½œ &#125; // Reducerçš„è¿è¡Œé€»è¾‘ ä¾›æ›´é«˜çº§çš„å®šåˆ¶ public void run(Context context) throws IOException, InterruptedException &#123; setup(context); try &#123; // éåŽ†è¾“å…¥key while (context.nextKey()) &#123; reduce(context.getCurrentKey(), context.getValues(), context); // ä¸€ä¸ªkeyå¤„ç†å®Œè¦è½¬å‘ä¸‹ä¸€ä¸ªkeyæ—¶ï¼Œé‡ç½®å€¼éåŽ†å™¨ Iterator&lt;VALUEIN&gt; iter = context.getValues().iterator(); if(iter instanceof ReduceContext.ValueIterator) &#123; ((ReduceContext.ValueIterator&lt;VALUEIN&gt;)iter).resetBackupStore(); &#125; &#125; &#125; finally &#123; cleanup(context); &#125; &#125;&#125; æˆ‘ä»¬çš„Reducerå®žçŽ°ä¸»è¦æ˜¯æ‰¾å‡ºæœ€é«˜æ°”æ¸©ï¼š 1234567891011121314151617181920public class MaxTemperatureReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; &#123; @Override public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException &#123; int maxValue = findMax( values ); context.write(key, new IntWritable(maxValue)); &#125; private static int findMax(Iterable&lt;IntWritable&gt; values)&#123; int maxValue = Integer.MIN_VALUE; for (IntWritable value : values) &#123; maxValue = Math.max(maxValue, value.get()); &#125; return maxValue; &#125;&#125; Mapperå’ŒReducerå®žçŽ°åŽï¼Œéœ€è¦ä¸€ä¸ªå…¥å£æäº¤ä½œä¸šåˆ°Hadoopé›†ç¾¤ï¼Œåœ¨æ–°ç‰ˆæœ¬ä¸­ï¼Œä½¿ç”¨YARNæ¡†æž¶æ¥è¿è¡ŒMapReduceä½œä¸šã€‚ä½œä¸šé…ç½®å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829public class MaxTemperature &#123; public static void main(String[] args) throws Exception &#123; if (args.length != 2) &#123; System.err.println("Usage: MaxTemperature &lt;input path&gt; &lt;output path&gt;"); System.exit(-1); &#125; // è®¾ç½®jaråŒ…åŠä½œä¸šåç§° Job job = new Job(); job.setJarByClass(MaxTemperature.class); job.setJobName("Max temperature"); // è¾“å…¥è¾“å‡ºè·¯å¾„ FileInputFormat.addInputPath(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); // è®¾ç½®Mapperå’ŒReducerå®žçŽ° job.setMapperClass(MaxTemperatureMapper.class); job.setReducerClass(MaxTemperatureReducer.class); // è®¾ç½®è¾“å‡ºæ ¼å¼ job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); // ç­‰å¾…ä½œä¸šå®ŒæˆåŽé€€å‡º System.exit(job.waitForCompletion(true) ? 0 : 1); &#125;&#125; è¾“å…¥è¾“å‡ºè·¯å¾„ä½¿ç”¨FileInputFormat/FileOutputFormatçš„é™æ€æ–¹æ³•æ¥è®¾ç½®ï¼Œåœ¨è¿è¡Œä½œä¸šä¹‹å‰ï¼Œè¾“å‡ºç›®å½•ä¸èƒ½å­˜åœ¨ï¼Œè¿™æ˜¯ä¸ºäº†é¿å…è¦†ç›–æ•°æ®å¯¼è‡´æ•°æ®ä¸¢å¤±ã€‚è¿è¡Œä¹‹å‰å¦‚æžœæ£€æµ‹åˆ°ç›®å½•å·²ç»å­˜åœ¨ï¼Œä½œä¸šå°†æ— æ³•è¿è¡Œã€‚ OKï¼ŒæŠŠé¡¹ç›®æ‰“åŒ…ï¼Œå¦‚æžœä½¿ç”¨Eclipseï¼Œä½¿ç”¨ExportåŠŸèƒ½ã€‚å¦‚æžœä½¿ç”¨Mavenå¼€å‘ï¼Œåˆ™ç›´æŽ¥è¿è¡Œpackageå‘½ä»¤ã€‚å‡è®¾æˆ‘ä»¬æœ€åŽçš„jaråŒ…ä¸ºmax-temp.jar.æŠŠjaråŒ…ä¸Šä¼ åˆ°ä½ çš„é›†ç¾¤æœºå™¨ä¸Šï¼Œæˆ–è€…æ”¾åœ¨å®‰è£…äº†Hadoopçš„å®¢æˆ·ç«¯æœºå™¨ä¸Šï¼Œè¿™é‡Œå‡è®¾jaråŒ…æ”¾åœ¨/opt/jobç›®å½•ä¸‹ã€‚ è¿è¡Œ é¦–å…ˆæŠŠä½œä¸šjaråŒ…æ”¾åˆ°CLASSPATHï¼š 12cd /opt/jobexport HADOOP_CLASSPATH=max-temp.jar è¿è¡Œ: 1hadoop MaxTemperature /input/ncdc/sample.txt /output hadoopä¼šè‡ªåŠ¨æŠŠHADOOP_CLASSPATè®¾ç½®çš„è·¯å¾„åŠ å…¥åˆ°CLASSPATHä¸­ï¼ŒåŒæ—¶æŠŠHADOOPç›¸å…³çš„ä¾èµ–åŒ…ä¹ŸåŠ å…¥CLASSPATHï¼Œç„¶åŽå¯åŠ¨ä¸€ä¸ªJVMè¿è¡ŒMaxTemperatureè¿™ä¸ªå¸¦æœ‰mainæ–¹æ³•çš„ç±»ã€‚ ç»“æžœå¦‚ä¸‹ï¼š MapReduce-7 MapReduce-8 æ—¥å¿—ä¸­å¯ä»¥çœ‹åˆ°ä½œä¸šçš„ä¸€äº›è¿è¡Œæƒ…å†µï¼Œä¾‹å¦‚mapä»»åŠ¡æ•°é‡ï¼Œreduceä»»åŠ¡æ•°é‡ï¼Œä»¥åŠè¾“å…¥è¾“å‡ºçš„è®°å½•æ•°ï¼Œå¯ä»¥çœ‹åˆ°è·Ÿå®žé™…æƒ…å†µå®Œå…¨å»åˆã€‚ æˆ‘ä»¬çœ‹ä¸€ä¸‹è¾“å‡ºç›®å½•/output: 1hadoop fs -ls /output MapReduce-9 å¯ä»¥çœ‹åˆ°è¯¥ç›®å½•ä¸‹æœ‰ä¸ªæˆåŠŸæ ‡è¯†æ–‡ä»¶_SUCCESSå’Œç»“æžœè¾“å‡ºæ–‡ä»¶part-r-0000ï¼Œæ¯ä¸ªreducerä¼šè¾“å‡ºä¸€ä¸ªæ–‡ä»¶ã€‚æŸ¥çœ‹ä¸€ä¸‹è¿™ä¸ªè¾“å‡ºæ–‡ä»¶çš„å†…å®¹ï¼š 1hadoop fs -text hdfs://master:9000/output/part-r-00000 å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œæˆ‘ä»¬æˆåŠŸå¾—åˆ°äº†1949å’Œ1950å¹´çš„æœ€é«˜æ¸©åº¦ï¼Œæ— éœ€ç®¡ç»“æžœæ˜¯å¦åˆç†ï¼Œåªè¦æŒ‰ç…§æˆ‘ä»¬æƒ³è¦çš„é€»è¾‘è¿è¡Œå³å¯ã€‚ YARNç®¡ç†ç•Œé¢ä¹Ÿå¯ä»¥çœ‹åˆ°è¯¥ä½œä¸šçš„æƒ…å†µï¼š MapReduce-10 è¿›ä¸€æ­¥ç†è§£MapReduce ä¸€ä¸ªMapReduceä½œä¸šé€šå¸¸åŒ…æ‹¬è¾“å…¥æ•°æ®ã€MapReduceç¨‹åºä»¥åŠä¸€äº›é…ç½®ä¿¡æ¯ã€‚HadoopæŠŠä½œä¸šåˆ†è§£ä¸ºtaskè¿è¡Œï¼Œtaskåˆ†ä¸ºmapä»»åŠ¡å’Œreduceä»»åŠ¡ï¼Œåœ¨æ–°ç‰ˆæœ¬çš„Hadoopä¸­ï¼Œè¿™äº›Taské€šè¿‡èµ„æºç®¡ç†æ¡†æž¶è¿›è¡Œè°ƒåº¦ï¼Œå¦‚æžœä»»åŠ¡å¤±è´¥ï¼ŒMapReduceåº”ç”¨æ¡†æž¶ä¼šé‡æ–°è¿è¡Œä»»åŠ¡ã€‚ ä½œä¸šçš„è¾“å…¥è¢«åˆ’åˆ†ä¸ºå›ºå®šå¤§å°çš„åˆ†ç‰‡ï¼Œå«input splitsï¼Œç®€ç§°splitsã€‚ç„¶åŽä¸ºæ¯ä¸€ä¸ªsplitåˆ†å—åˆ›å»ºä¸€ä¸ªmapä»»åŠ¡ï¼Œmapä»»åŠ¡å¯¹æ¯ä¸€æ¡è®°å½•è¿è¡Œç”¨æˆ·å®šä¹‰çš„mapå‡½æ•°ã€‚åˆ’åˆ†ä¸ºsplitä¹‹åŽï¼Œä¸åŒé…ç½®çš„æœºå™¨å°±å¯ä»¥æ ¹æ®è‡ªå·±çš„èµ„æºåŠè¿ç®—èƒ½åŠ›è¿è¡Œé€‚å½“çš„ä»»åŠ¡ï¼Œå³ä½¿æ˜¯ç›¸åŒé…ç½®çš„æœºå™¨ï¼Œæœ€åŽè¿è¡Œçš„ä»»åŠ¡æ•°ä¹Ÿå¾€å¾€ä¸ç­‰ï¼Œè¿™æ ·èƒ½æœ‰æ•ˆåˆ©ç”¨æ•´ä¸ªé›†ç¾¤çš„è®¡ç®—èƒ½åŠ›ã€‚ä½†æ˜¯splitä¹Ÿä¸å·²å¤ªå¤šï¼Œå¦åˆ™ä¼šè€—è´¹å¾ˆå¤šæ—¶é—´åœ¨åˆ›å»ºmapä»»åŠ¡ä¸Šï¼Œé€šå¸¸è€Œè¨€ï¼ŒæŒ‰é›†ç¾¤Blockå¤§å°ï¼ˆé»˜è®¤ä¸º128Mï¼‰æ¥åˆ’åˆ†splitæ˜¯åˆç†çš„ã€‚ Hadoopä¼šæŠŠmapä»»åŠ¡è¿è¡Œåœ¨è·ç¦»æ•°æ®æœ€è¿‘çš„èŠ‚ç‚¹ä¸Šï¼Œæœ€å¥½çš„æƒ…å†µæ˜¯ç›´æŽ¥åœ¨æ•°æ®ï¼ˆsplitï¼‰æ‰€åœ¨çš„èŠ‚ç‚¹ä¸Šè¿è¡Œmapä»»åŠ¡ï¼Œè¿™æ ·ä¸éœ€è¦å ç”¨å¸¦å®½ï¼Œè¿™ä¸€ä¼˜åŒ–å«åšæ•°æ®æœ¬åœ°ä¼˜åŒ–ï¼ˆdata locality optimization)ã€‚ä¸‹å›¾çš„mapé€‰å€æ–¹æ¡ˆä»Žæœ€ä¼˜åˆ°æœ€æ¬¡ä¸ºaï¼Œbï¼Œcï¼š MapReduce-11 å…³äºŽHadoopå¦‚ä½•è¡¡é‡ä¸¤ä¸ªé›†ç¾¤èŠ‚ç‚¹çš„è·ç¦»ï¼Œå‚è€ƒå¦ä¸€æ‰¹åšå®¢ æ·±å…¥ç†è§£HDFSï¼šHadoopåˆ†å¸ƒå¼æ–‡ä»¶ç³»ç»Ÿã€‚ä½†æ˜¯èŠ‚ç‚¹è·ç¦»ä¸æ˜¯åˆ†é…taskè€ƒè™‘çš„å”¯ä¸€å› ç´ ï¼Œè¿˜ä¼šè€ƒè™‘èŠ‚ç‚¹å½“å‰è´Ÿè½½ç­‰å› ç´ ã€‚ Reduceä»»åŠ¡é€šå¸¸æ— æ³•åˆ©ç”¨æœ¬åœ°æ•°æ®çš„ä¼˜åŒ–ï¼Œå¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œreduceçš„è¾“å…¥éƒ½æ¥è‡ªé›†ç¾¤çš„å…¶ä»–èŠ‚ç‚¹ã€‚reduceé’ˆå¯¹æ¯ä¸€ä¸ªkeyè¿è¡Œreduceå‡½æ•°ä¹‹åŽï¼Œè¾“å‡ºç»“æžœé€šå¸¸ä¿å­˜åœ¨HDFSä¸­ï¼Œå¹¶ä¸”å­˜å‚¨ä¸€å®šçš„å‰¯æœ¬æ•°ï¼Œç¬¬ä¸€ä¸ªå‰¯æœ¬å­˜åœ¨è¿è¡Œreduceä»»åŠ¡çš„æœ¬åœ°æœºå™¨ï¼Œå…¶ä»–å‰¯æœ¬æ ¹æ®HDFSå†™å…¥çš„ç®¡é“åˆ†åˆ«å†™å…¥èŠ‚ç‚¹ï¼Œå…³äºŽæ›´å¤šHDFSçš„æ•°æ®å†™å…¥æµç¨‹ï¼Œå‚è€ƒè¿™é‡Œã€‚ ä¸‹å›¾æ˜¯ä¸€ä¸ªå•reduceçš„æ•°æ®æµç¤ºä¾‹ï¼š MapReduce-12 å¦‚æžœæœ‰å¤šä¸ªreduceä»»åŠ¡ï¼Œé‚£ä¹ˆmapä»»åŠ¡çš„è¾“å‡ºåˆ°åº•è¯¥ä¼ è¾“åˆ°å“ªä¸€ä¸ªreduceä»»åŠ¡å‘¢ï¼Ÿå†³å®šæŸä¸ªkeyçš„æ•°æ®ï¼ˆkey,[value1, value2,...])è¯¥å‘é€ç»™é‚£ä¸ªreduceçš„è¿‡ç¨‹å«partitionã€‚é»˜è®¤æƒ…å†µä¸‹ï¼ŒMapReduceä½¿ç”¨keyçš„å“ˆå¸Œå‡½æ•°è¿›è¡Œåˆ†æ¡¶ï¼Œè¿™é€šå¸¸å·¥ä½œçš„å¾ˆå¥½ã€‚å¦‚æžœéœ€è¦è‡ªè¡ŒæŒ‡å®šåˆ†åŒºå‡½æ•°ï¼Œå¯ä»¥è‡ªå·±å®žçŽ°ä¸€ä¸ªPartitionerå¹¶é…ç½®åˆ°ä½œä¸šä¸­ã€‚keyç›¸åŒçš„mapä»»åŠ¡è¾“å‡ºä¸€å®šä¼šå‘é€åˆ°åŒä¸€ä¸ªreduceä»»åŠ¡ã€‚mapä»»åŠ¡çš„è¾“å‡ºæ•°æ®ä¼ è¾“åˆ°reduceä»»åŠ¡æ‰€åœ¨èŠ‚ç‚¹çš„è¿‡ç¨‹ï¼Œå«åšshuffleã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªæ›´é€šç”¨çš„MapReduceæ•°æ®æµå›¾ï¼š MapReduce-13 å½“ç„¶ï¼Œæœ‰äº›ä½œä¸šä¸­æˆ‘ä»¬å¯èƒ½æ ¹æœ¬ä¸éœ€è¦æœ‰reduceä»»åŠ¡ï¼Œæ‰€æœ‰å·¥ä½œåœ¨mapä»»åŠ¡å¹¶è¡Œæ‰§è¡Œå®Œä¹‹åŽå°±å®Œæ¯•äº†ï¼Œä¾‹å¦‚Hadoopæä¾›çš„å¹¶è¡Œå¤åˆ¶å·¥ä½œdistcpï¼Œå…¶å†…éƒ¨å®žçŽ°å°±æ˜¯é‡‡ç”¨ä¸€ä¸ªåªæœ‰Mapperï¼Œæ²¡æœ‰Reducerçš„MapReduceä½œä¸šï¼Œåœ¨mapå®Œæˆæ–‡ä»¶å¤åˆ¶ä¹‹åŽä½œä¸šå°±å®Œæˆäº†ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š MapReduce-14 åœ¨ä¸Šé¢è®¡ç®—æœ€é«˜å¤©æ°”çš„ä¾‹å­ä¸­ï¼Œæ¯ä¸ªmapå°†æ¯ä¸€æ¡è®°å½•æ‰€äº§ç”Ÿçš„ï¼ˆå¹´ä»½ï¼Œæ¸©åº¦ï¼‰è®°å½•éƒ½shuffleåˆ°reduceèŠ‚ç‚¹ï¼Œå½“æ•°æ®é‡è¾ƒå¤§æ—¶ï¼Œå°†å ç”¨å¾ˆå¤šå¸¦å®½ï¼Œè€—è´¹å¾ˆé•¿æ—¶é—´ã€‚äº‹å®žä¸Šï¼Œå¯ä»¥åœ¨mapä»»åŠ¡æ‰€åœ¨çš„èŠ‚ç‚¹ä¸Šåšæ›´å¤šå·¥ä½œã€‚mapä»»åŠ¡è¿è¡Œå®Œä¹‹åŽï¼Œå¯ä»¥æŠŠæ‰€æœ‰ç»“æžœæŒ‰å¹´ä»½åˆ†ç»„ï¼Œå¹¶ç»Ÿè®¡å‡ºæ¯ä¸€å¹´çš„æœ€é«˜æ¸©åº¦ï¼ˆç±»ä¼¼äºŽsqlä¸­çš„ 1select max(temperature) from table group by year ï¼‰ï¼Œè¿™ä¸ªæœ€é«˜æ¸©åº¦æ˜¯å±€éƒ¨çš„ï¼Œåªåœ¨æœ¬ä»»åŠ¡é‡äº§ç”Ÿçš„æ•°æ®åšæ¯”è¾ƒã€‚åšå®Œå±€éƒ¨ç»Ÿè®¡ä¹‹åŽï¼Œå°†ç»“æžœå‘é€ç»™reduceåšæœ€ç»ˆçš„æ±‡æ€»ï¼Œæ‰¾å‡º å…¨å±€æœ€é«˜æ¸©åº¦ã€‚è¿‡ç¨‹ç¤ºæ„å›¾å¦‚ä¸‹ï¼š MapReduce-15 è¿™ä¹ˆåšä¹‹æ‰€ä»¥ç¬¦åˆé€»è¾‘ï¼Œæ˜¯åŸºäºŽä»¥ä¸‹çš„äº‹å®žï¼š 1max(0,20,10,25,15)=max(max(0,20,10) , max(25,15)) ç¬¦åˆä¸Šè¿°æ€§è´¨çš„å‡½æ•°ç§°ä¸ºæ˜¯commutativeå’Œassociativeï¼Œæœ‰æ—¶å€™ä¹Ÿæˆä¸ºæ˜¯distributiveã€‚å¦‚æžœæ˜¯è®¡ç®—å¹³å‡æ¸©åº¦ï¼Œåˆ™ä¸èƒ½ä½¿ç”¨è¿™ä¸€çš„æ–¹å¼ã€‚ ä¸Šè¿°çš„å±€éƒ¨è®¡ç®—åœ¨Hadoopä¸­ä½¿ç”¨Combineræ¥è¡¨ç¤ºã€‚ä¸ºäº†åœ¨ä½œä¸šä¸­ä½¿ç”¨Combinerï¼Œæˆ‘ä»¬éœ€è¦æ˜Žç¡®æŒ‡å®šï¼Œåœ¨å‰é¢çš„ä¾‹å­ä¸­ï¼Œå¯ä»¥ç›´æŽ¥ä½¿ç”¨Reducerä½œä¸ºCombinerï¼Œå› ä¸ºä¸¤è€…é€»è¾‘æ˜¯ä¸€æ ·çš„ï¼š 1234// è®¾ç½®Mapperå’ŒReducerå®žçŽ°job.setMapperClass(MaxTemperatureMapper.class);job.setCombinerClass(MaxTemperatureReducer.class);job.setReducerClass(MaxTemperatureReducer.class); Hadoop Streaming Hadoopå®Œå…¨å…è®¸æˆ‘ä»¬ä½¿ç”¨Javaä»¥å¤–çš„è¯­è¨€æ¥ç¼–å†™mapå’Œreduceå‡½æ•°ã€‚Hadoop Streamingä½¿ç”¨Unixæ ‡å‡†æµä½œä¸ºHadoopå’Œå…¶ä»–åº”ç”¨ç¨‹åºçš„æŽ¥å£ã€‚æ•°æ®æµçš„å¤§è‡´ç¤ºæ„å›¾å¦‚ä¸‹ï¼š MapReduce-16 æ•´ä¸ªæ•°æ®åœ¨Hadoop MapReduceä¸ŽRubyåº”ç”¨ã€æ ‡å‡†è¾“å…¥è¾“å‡ºä¹‹é—´æµè½¬ï¼Œå› æ­¤å«Streamingã€‚æˆ‘ä»¬ç»§ç»­ä½¿ç”¨å‰é¢æ°”æ¸©çš„ä¾‹å­æ¥è¯´æ˜Žï¼Œå…ˆä½¿ç”¨rubyæ¥ç¼–å†™mapå’Œreduceï¼Œç„¶åŽä½¿ç”¨unixçš„ç®¡é“æ¥æ¨¡æ‹Ÿæ•´ä¸ªè¿‡ç¨‹ï¼Œæœ€åŽè¿ç§»åˆ°Hadoopä¸Šè¿è¡Œã€‚ Rubyç‰ˆæœ¬çš„mapå‡½æ•°ä»Žæ ‡å‡†æµä¸­è¯»å–æ•°æ®ï¼Œè¿ç®—åŽå°†ç»“æžœè¾“å‡ºåˆ°æ ‡å‡†è¾“å‡ºæµï¼š 123456#!/usr/bin/rubySTDIN.each_line do |line| val = line year , temp , q = val[15,4],val[87,5],val[92,1] puts "#&#123;year&#125;\t#&#123;temp&#125;" if (temp != "+9999" &amp;&amp; q =~/[01459]/)end é€»è¾‘ä¸ŽJavaç‰ˆæœ¬å®Œå…¨ä¸€æ ·ï¼ŒSTDINæ˜¯rubyçš„æ ‡å‡†è¾“å…¥ï¼Œeach_lineé’ˆå¯¹æ¯ä¸€è¡Œè¿›è¡Œæ“ä½œï¼Œé€»è¾‘å°è£…åœ¨doå’Œendä¹‹é—´ã€‚putsæ˜¯rubyæ ‡å‡†è¾“å‡ºå‡½æ•°ï¼Œæ‰“å°tabåˆ†å‰²çš„è®°å½•åˆ°æ ‡å‡†è¾“å‡ºæµã€‚ å› ä¸ºè¿™ä¸ªè„šæœ¬ä¸Žæ ‡å‡†è¾“å…¥è¾“å‡ºäº¤äº’ï¼Œæ‰€ä»¥å¾ˆå®¹æ˜“ç»“åˆlinuxçš„ç®¡é“æ¥æµ‹è¯•ï¼š 1cat input/ncdc/sample.txt | ruby max_temp_map.rb MapReduce-17 ä¸€æ ·ç”¨rubyè„šæœ¬æ¥å®Œæˆreduceçš„åŠŸèƒ½ï¼š 123456789101112last_key , max_val = nil , -1000000STDIN.each_line do |line| key , val = line.split("\t") if last_key &amp;&amp; last_key != key puts "#&#123;last_key&#125;\t#&#123;max_val&#125;" last_key , max_val = key , val.to_i else last_key , max_val = key,[max_val , val.to_i].max endend# å¤„ç†æœ€åŽä¸€ä¸ªkeyçš„è¾“å‡ºput "#&#123;last_key&#125;\t#&#123;max_val&#125;" if last_key mapå¤„ç†å®Œä¹‹åŽï¼ŒåŒä¸€ä¸ªkeyçš„ä¸€ç»„é”®å€¼å¯¹ä¸­ï¼Œvalueæ˜¯æŽ’åºçš„ï¼Œæ‰€ä»¥å½“å‰è¯»åˆ°çš„keyå¦‚æžœä¸åŒäºŽä¸Šä¸€ä¸ªkeyï¼Œè¡¨ç¤ºè¿™ä¸ªkeyçš„æ‰€æœ‰å€¼éƒ½å¤„ç†å®Œäº†ï¼ˆå‰æ–‡æåˆ°ä¼šåœ¨åˆ‡æ¢keyä¹‹å‰resetè¾“å…¥ï¼‰ã€‚æˆ‘ä»¬ä½¿ç”¨sortå‘½ä»¤æ¥æ›¿ä»£MapReduceä¸­çš„æŽ’åºè¿‡ç¨‹ï¼ŒæŠŠmapçš„æ ‡å‡†è¾“å‡ºä½œä¸ºsortçš„è¾“å…¥ï¼Œsorté€šè¿‡ç®¡é“è¿žæŽ¥åˆ°mapï¼š 1cat /home/data/hadoop_book_input/ncdc/sample.txt| ruby max_temp_map.rb | sort | ruby max_temp_reduce.rb è¾“å‡ºç»“æžœå¦‚ä¸‹å›¾ï¼Œä¸Žå‰æ–‡å®Œå…¨ä¸€è‡´ã€‚ MapReduce-18 å¾ˆå¥½ï¼Œæˆ‘ä»¬åœ¨Hadoopä¸Šè¿è¡Œè¿™ä¸ªä½œä¸šã€‚éžJavaè¯­è¨€çš„MapReduceä½œä¸šï¼Œéœ€è¦ä½¿ç”¨Hadoop Streamingæ¥è¿è¡Œã€‚Hadoop Streamingä¼šè´Ÿè´£ä½œä¸šçš„Taskåˆ†è§£ï¼ŒæŠŠè¾“å…¥æ•°æ®ä½œä¸ºæ ‡å‡†è¾“å…¥æµä¼ é€’ç»™Rubyå†™çš„mapè„šæœ¬ï¼Œå¹¶æŽ¥å—æ¥è‡ªmapè„šæœ¬çš„æ ‡å‡†è¾“å‡ºï¼ŒæŽ’åºåŽshuffleåˆ°reduceèŠ‚ç‚¹ä¸Šï¼Œå¹¶ä»¥æ ‡å‡†è¾“å…¥ä¼ é€’ç»™reduceï¼Œæœ€åŽæŠŠreduceçš„æ ‡å‡†è¾“å‡ºä¿å­˜åˆ°HDFSæ–‡ä»¶ä¸­ã€‚ æˆ‘ä»¬ä½¿ç”¨hadoop jarå‘½ä»¤,åŒæ—¶æŒ‡å®šè¾“å…¥è¾“å‡ºç›®å½•ï¼Œè„šæœ¬ä½ç½®ç­‰ã€‚ 1hadoop jar /home/hadoop-2.6.0/share/hadoop/tools/lib/hadoop-streaming-2.6.0.jar -files max_temp_map.rb,max_temp_reduce.rb -input /input/ncdc/sample.txt -output /output/max-tem-ruby -mapper max_temp_map.rb -reducer max_temp_reduce.rb -fileå‚æ•°æŠŠè¿™äº›æ–‡ä»¶ä¸Šä¼ åˆ°é›†ç¾¤ä¸­ã€‚æ³¨æ„mapå’Œreduceè„šæœ¬éœ€è¦åœ¨CLASSPATHä¸‹ï¼Œæˆ‘æ˜¯åœ¨å½“å‰ç›®å½•ä¸‹è¿è¡Œçš„ï¼Œé»˜è®¤åŠ å…¥åˆ°ç±»è·¯å¾„ä¸­ã€‚å¦å¤–è¯·ç¡®ä¿é›†ç¾¤ä¸­çš„æ‰€æœ‰æœºå™¨éƒ½å®‰è£…äº†rubyï¼Œå¦åˆ™å¯èƒ½å‡ºçŽ°ç±»ä¼¼subprocess failed with code 127ã€‚è¿™é‡Œçš„è¾“å‡ºæ–‡ä»¶æ˜¯/outp/max-tem-rubyï¼ŒMapReduceä¸å…è®¸å¤šä¸ªä½œä¸šè¾“å‡ºåˆ°åŒä¸€ä¸ªç›®å½•ã€‚ æŸ¥çœ‹è¾“å‡ºæ–‡ä»¶ï¼Œä¸ŽJavaç‰ˆæœ¬å®Œå…¨ä¸€è‡´ã€‚OKï¼Œæˆ‘ä»¬è®¾ç½®combinerï¼Œç„¶åŽåœ¨å¤§çš„æ•°æ®é›†ä¸Šæ„Ÿå—ä¸€ä¸‹ï¼š 1hadoop jar /home/hadoop-2.6.0/share/hadoop/tools/lib/hadoop-streaming-2.6.0.jar -files max_temp_map.rb,max_temp_reduce.rb -input /input/ncdc/all -output /output/max-tem-all -mapper max_temp_map.rb -combiner x_temp_reduce.rb -reducer max_temp_reduce.rb MapReduce-19]]></content>
      <categories>
        <category>æ•°æ®åˆ†æž</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>MapReduce</tag>
        <tag>å¤§æ•°æ®</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Code Jam Round1C-C]]></title>
    <url>%2F2018%2F05%2F05%2FGoogle-Code-Jam-Round1C-C%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›®:Ant Stack Problem Scott has an ant farm containing N ants. Each ant has a certain length and weight. Today, as a challenge for the ants, Scott has placed some food at the top of the ant farm. The ants will try to reach it by arranging themselves into a vertical stack, with each ant in the stack directly holding the next on its back. In this way, each ant bears the weight of all ants above it. Scott's ants are very strong for their size and are able to carry up to 6 times their own weight. For example, an ant that weights 8 milligrams can carry two other ants weighing 24 milligrams each! Each ant also has a body length; the exact lengths are not important, except that they are all different. The stack must be linear. Each ant except for the top ant must be directly below exactly one ant, and each ant except for the bottom ant must be directly above exactly one ant. The lengths of the ants in the stack must be strictly decreasing from the bottom to the top of the stack; this ensures that each new ant that joins the stack will be able to climb up to the top. For each ant, the sum of the weights of all the ants above it in the stack must be no more than 6 times the weight of that ant. What is the maximum number of these ants that can form such a stack? Input The first line of the input gives the number of test cases, T. T test cases follow. Each begins with one line with an integer N: the number of ants in the colony. Then, a second line follows containing N integers W1, W2, ..., WN, where Wi is the weight in milligrams of the i-th ant. The ants are listed in strictly increasing order of length. Notice that no actual length values are given; only the order is important. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum number of the given ants that can form a stack that obeys the rules above. Limits 7 â‰¤ T â‰¤ 100. Time limit: 15 seconds per test set. Memory limit: 1GB. Test set 1 (Visible) For exactly 6 cases, N = 100; for the other T - 6 cases, 2 â‰¤ N â‰¤ 50. 1 â‰¤ Wi â‰¤ 1000, for all i. Test set 2 (Hidden) For exactly 6 cases, \(N= 10^5\); for the other T - 6 cases, 2 â‰¤ N â‰¤ 500. 1 â‰¤ Wi â‰¤ \(10^9\), for all i. Sample Input 3 2 9 1 3 8 4 100 9 10 10 10 10 10 10 10 10 100 Output Case #1: 1 Case #2: 3 Case #3: 8 In Sample Case #1, there are two ants. The first weighs 9 mg; the second weighs 1 mg, and is longer than the first ant. The first ant is strong enough to hold the second ant (since it can hold up to 9 Ã— 6 mg), but it cannot, because the second ant is longer. The second ant is not strong enough to hold the first ant (since it can only hold up to 1 Ã— 6 mg, which is less than 9 mg). So it is only possible to make a &quot;stack&quot; of one of the two ants. In Sample Case #2, it is possible for all three ants to form a stack, with the third holding up the second, which holds up the first. In Sample Case #3, the optimal solution has the ninth ant on the bottom, and then seven of the other ants above it. åˆ†æž å¾ˆå®¹æ˜“æƒ³åˆ°æ˜¯ä¸€ä¸ªåŠ¨æ€è§„åˆ’\(dp[i]\)ï¼šiä¸ªèš‚èšå¾—åœ¨ä¸€èµ·æœ€å°çš„é‡é‡ \(dp[j - 1] &lt;= w[i] * 6\)ï¼šè‹¥å½“å‰çš„èš‚èšå¯ä»¥æ”¯æ’‘èµ·j-1ä¸ªèš‚èšï¼Œ \(dp[j] &gt;= dp[j - 1] + w[i]\)è‹¥ä»¥å½“å‰çš„èš‚èšæ›¿æ¢jä¸ªèš‚èšä¸­çš„èš‚èšï¼Œå¯ä»¥ä½¿èš‚èšçš„æ€»é‡é‡å‡å° è¿™é‡Œå…¶å®žæ˜¯ä¸€ä¸ªæ»šåŠ¨æ•°ç»„ï¼Œå¤æ‚åº¦æ˜¯\(O(N^2)\) ä½†æ˜¯æ³¨æ„åˆ°äº‹å®žä¸Šæ˜¯ä¸¤å±‚å¾ªçŽ¯å±‚å¾ªçŽ¯æžšä¸¾nä¸ªèš‚èšï¼Œå†…å±‚å¾ªçŽ¯æ˜¯ç­”æ¡ˆkï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯\(O(n*k)\) é‚£ä¹ˆkæœ€å¤§æ˜¯å¤šå°‘å‘¢ï¼Ÿ è€ƒè™‘æœ€æžç«¯çš„æƒ…å†µï¼š èš‚èšä»Žä¸Šå¾€ä¸‹çš„é‡é‡åˆ†åˆ«æ˜¯1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 4, 4, 5, 6, â€¦ å› ä¸º\(w \leq 10^9\)å†™ä¸€ä¸ªç¨‹åºå°±çŸ¥é“ Kæœ€å¤§æ˜¯139 æ‰€ä»¥æ—¶é—´å¤æ‚åº¦å¤Ÿã€‚ ä»£ç  12345678910111213141516171819202122232425262728293031323334353637/** @Author: sun000* @Date: 2018-05-05 17:43:30* @Last Modified by: sun000* @Last Modified time: 2018-05-05 18:15:47*/#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAX_N = 1e5 + 10;long long int w[MAX_N], dp[MAX_N];int main(void) &#123; int t, n; scanf("%d", &amp;t); for(int ca = 1; ca &lt;= t; ca++) &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) scanf("%lld", &amp;w[i]); memset(dp, 0x7f, sizeof dp); dp[0] = 0; int ans = 0; for(int i = 1; i &lt;= n; i++) &#123; for(int j = ans + 1; j &gt; 0; j--) &#123; if(dp[j - 1] &lt;= w[i] * 6 &amp;&amp; dp[j] &gt;= dp[j - 1] + w[i]) &#123; dp[j] = dp[j - 1] + w[i]; if(ans &lt; j) ans = j; &#125; &#125; &#125; printf("Case #%d: %d\n", ca, ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NCPC2017-I-Import-SPaghetti]]></title>
    <url>%2F2018%2F03%2F08%2FNCPC2017-I-Import-SPaghetti%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® You just graduated from programming school and nailed a Python programming job. The ï¬rst day at work you realize that you have inherited a mess. The spaghetti design pattern was chosen by the previous maintainer, who recently ï¬‚ed the country. You try to make sense of the code, but immediately discover that different ï¬les depend cyclically on each other. Testing the code, in fact running the code, has not yet been attempted. As you sit down and think, you decide that the ï¬rst thing to do is to eliminate the cycles in the dependency graph. So you start by ï¬nding a shortest dependency cycle. Input The ï¬rst line of input contains a number n, 1 â‰¤ n â‰¤ 500, the number of ï¬les. Then follows one line with n names of ï¬les. Each name is a string with at least 1 and at most 8 lower case letters â€˜aâ€™ to â€˜zâ€™. Then follow n sections, one section per ï¬le name, in the order they were given on the second line. Each section starts with one line containing the name of the ï¬le and an integer k, followed by k lines, each starting with â€œimportâ€. Each â€œimportâ€ line is a comma-space separated line of dependencies. No ï¬le imports the same ï¬le more than once, and every ï¬le imported is listed in the second line of the input. Comma-space separated means that every line will start with â€œimportâ€, then have a list of class names separated by â€œ,â€ (see sample inputs for examples). Output If the code base has no cyclic dependencies, output â€œSHIP ITâ€. Otherwise, output a line containing the names of ï¬les in a shortest cycle, in the order of the cycle. If there are many shortest cycles, any one will be accepted. Sample Input 1 123456789104 a b c d a 1 import d, b, c b 2 import d import c c 1 import c d 0 Sample Output 1 1c Sample Input 2 1234567891011125 classa classb myfilec execd libeclassa 2 import classb import myfilec, libe classb 1 import execd myfilec 1 import libe execd 1 import libe libe 0 Sample Output 2 1SHIP IT Sample Input 3 1234567891011125 classa classb myfilec execd libe classa 2 import classb import myfilec, libe classb 1 import execd myfilec 1 import libe execd 1 import libe, classa libe 0 Sample Output 3 1classa classb execd åˆ†æž é¢˜æ„æ˜¯åœ¨ä¸€ä¸ªå›¾ä¸Šæ±‚æœ€å°çŽ¯ï¼Œæœ€å°çŽ¯çš„æ±‚æ³•æ˜¯ç”¨æœ€çŸ­è·¯ï¼Œå…ˆç”¨Floydç®—æ³•å¤„ç†æ¯ä¸¤ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯(æ—¶é—´å¤æ‚åº¦æ˜¯o(n3)ï¼Œ æžšä¸¾æ¯ä¸€æ¡è¾¹iâ†’j:G[i][j]åˆ™åŒ…å«ç€ä¸€æ¡è¾¹çš„æœ€å°çŽ¯æ˜¯ï¼šjåˆ°içš„æœ€çŸ­è·¯åŠ ä¸Šè¿™æ¡è¾¹ã€‚ è®¾æœ€å°çŽ¯çš„é•¿åº¦æ˜¯ansåˆ™ans=min(ans,G[i][j]+dis[j][i]) æ³¨æ„åˆ¤æ–­è‡ªçŽ¯å¼—æ´›ä¼Šå¾·æ±‚æœ€å°çŽ¯ä¸èƒ½å¤„ç†è‡ªçŽ¯çš„æƒ…å†µ å¤„ç†å®Œæœ€å°çŽ¯è¦è¾“å‡ºè·¯å¾„ã€‚ è¿™é‡Œå°±æ¶‰åŠåˆ°äº†Floydè®°å½•è·¯å¾„çš„ï¼š path[i][j]:iåˆ°jçš„æœ€çŸ­è·¯å¿…é¡»ç»è¿‡path[i][j] ï¼š è¿™æ ·å°±èƒ½åœ¨Flodyçš„è¿‡ç¨‹ä¸­è®°å½•è¯¥æ•°ç»„ï¼Œé‚£ä¹ˆå¦‚ä½•è¾“å‡ºå‘¢ï¼Ÿ æ˜¾ç„¶å¾ˆå®¹æ˜“æƒ³åˆ°,é€’å½’è¾“å‡ºã€‚è¯¦æƒ…çœ‹ä»£ç  ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/** @Author: sun000* @Date: 2017-10-12 11:11:45* @Last Modified by: sun000* @Last Modified time: 2017-10-22 12:50:20*/#include &lt;map&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 510;const int INF = 0x3f3f3f3f;int n;int G[MAXN][MAXN], dis[MAXN][MAXN];map&lt;string, int&gt; name_to_id;string id_to_name[MAXN];void init() &#123; memset(G, 0x3f, sizeof(G)); memset(dis, 0x3f, sizeof(dis)); for(int i = 0; i &lt; n; i++) G[i][i] = dis[i][i] = 0;&#125;bool flag;string gg;void build() &#123; flag = false; char name[100]; int cnt, now; for(int i = 0; i &lt; n; i++) &#123; scanf("%s%d", name, &amp;cnt); // printf("name = %s cnt = %d\n", name, cnt); now = name_to_id[(string)name]; for(int j = 0; j &lt; cnt; j++) &#123; scanf("%s", name); while(scanf("%s", name)) &#123; int len = strlen(name); if(name[len - 1] == ',') &#123; name[len - 1] = '\0'; if (name_to_id[string(name)] == now)&#123; flag = true; gg = (string)name; &#125; G[now][name_to_id[string(name)]] = 1; dis[now][name_to_id[string(name)]] = 1; &#125; else &#123; if (name_to_id[string(name)] == now)&#123; flag = true; gg = (string)name; &#125; G[now][name_to_id[string(name)]] = 1; dis[now][name_to_id[string(name)]] = 1; break; &#125; &#125; &#125; &#125;&#125;int path[MAXN][MAXN];void output(int i, int j) &#123; if(path[i][j] == -1) cout&lt;&lt; id_to_name[j] &lt;&lt; ' '; else&#123; output(i,path[i][j]); output(path[i][j],j); &#125; &#125;void Floyd() &#123; int r1, r2; memset(path, -1, sizeof(path)); if(flag) &#123; cout &lt;&lt; gg &lt;&lt; endl; return; &#125; int ans = INF; for(int k = 0; k &lt; n; k++) &#123; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(i == j) continue; if(dis[i][j] &gt; dis[i][k]+ dis[k][j]) &#123; dis[i][j] = dis[i][k] + dis[k][j]; path[i][j] = k; &#125; if(ans &gt; G[j][i] + dis[i][j]) &#123; ans = G[j][i] + dis[i][j]; r1 = i, r2 = j; &#125; &#125; &#125; &#125; if(ans &gt;= INF) printf("SHIP IT\n"); else &#123; cout &lt;&lt; id_to_name[r1] &lt;&lt; ' '; output(r1, r2); printf("\n"); &#125;&#125;void show() &#123; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) printf("%d\t", G[i][j]); printf("\n"); &#125;&#125;int main(void) &#123; // freopen("in.txt", "r", stdin); char tmp[20]; scanf("%d", &amp;n); init(); for(int i = 0; i &lt; n; i++) &#123; scanf("%s", tmp); name_to_id[(string)tmp] = i; id_to_name[i] = (string)tmp; &#125; build(); Floyd(); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>å›¾è®º</tag>
        <tag>æœ€çŸ­è·¯</tag>
        <tag>æœ€å°çŽ¯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode4-Median of Two Sorted Arrays]]></title>
    <url>%2F2018%2F03%2F08%2FLeetCode4-Median-of-Two-Sorted-Arrays%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example 1: 123nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2: 1234nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 åˆ†æž åˆ†å¥‡å¶è€ƒè™‘ï¼ŒäºŒåˆ†åœ¨ç¬¬ä¸€ä¸ªArraysä¸­é€‰æ‹©çš„æ•°é‡kï¼Œç„¶åŽå¯ä»¥å”¯ä¸€ç¡®å®šåœ¨ç¬¬äºŒä¸ªArraysä¸­çš„æ•°é‡ï¼Œkçš„é€‰æ‹©æ˜¯æ»¡è¶³äºŒåˆ†çš„ï¼Œå½“ç¬¬ä¸€ä¸ªArraysä¸­é€‰æ‹©çš„æœ€å¤§çš„æ•°æ®ï¼Œå°äºŽç­‰äºŽArraysä¸­æ²¡æœ‰é€‰æ‹©çš„æœ€å°æ•°æ®ï¼Œæ—¶ï¼Œè¯´æ˜Žå½“å‰kæ»¡è¶³æ¡ä»¶ï¼Œç„¶åŽå·¦è¾¹ç•Œå˜å¤§ï¼Œä¸€ç›´äºŒåˆ†é€‰å‡ºæ»¡è¶³è¦æ±‚çš„æœ€å¤§çš„kï¼Œå…¶ä¸­ä¸¤ä¸ªArraysä¸­æœ‰ä¸€ä¸ªå…¨ä¸é€‰æˆ–åˆ™å…¨é€‰åœ¨è®¡ç®—ç­”æ¡ˆçš„æ—¶å€™è¦ç‰¹æ®Šå¤„ç†ã€‚ ä»£ç ï¼ˆC++ï¼‰ 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: bool check(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int a) &#123; int l1 = nums1.size(), l2 = nums2.size(), b; if((l1 + l2) &amp; 1) b = (l1 + l2 + 1) / 2 - a; else b = (l1 + l2) / 2 - a; if(!a || b &gt;= l2) return true; else if(b &lt; 0) return false; return nums1[a - 1] &lt;= nums2[b]; &#125; double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int l1 = nums1.size(), l2 = nums2.size(); int m = (l1 + l2) / 2; int l = 0, r = l1 + 1; int k = 0; while(r - l &gt; 1) &#123; k = (l + r) / 2; if(check(nums1, nums2, k)) l = k; else r = k; &#125; if((l1 + l2) &amp; 1) &#123; int a = l, b = m + 1 - l; if(!a) return nums2[b - 1]; else if(!b) return nums1[a - 1]; return max(nums1[a - 1], nums2[b - 1]); &#125; else &#123; int a = l, b = m - l; int aa, bb; if(!a) aa = nums2[b - 1]; else if(!b) aa = nums1[a - 1]; else aa = max(nums1[a - 1], nums2[b - 1]); if(a == l1) bb = nums2[b]; else if(b == l2) bb = nums1[a]; else bb = min(nums1[a], nums2[b]); return (aa + bb) / 2.0; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>æœºè¯•</category>
      </categories>
      <tags>
        <tag>äºŒåˆ†</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Latexæ•°å­¦ç¬¦å·]]></title>
    <url>%2F2017%2F10%2F09%2FLatex%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[ç¬¦å· ç¼–ç  ç¬¦å· ç¼–ç  ç¬¦å· ç¼–ç  ç¬¦å· ç¼–ç  \(\alpha\) \alpha \(\beta\) \beta \(\gamma\) \gamma \(\delta\) \delta \(\epsilon\) \epsilon \(\varepsilon\) \varepsilon \(\zeta\) \zeta \(\eta\) \eta \(\theta\) \theta \(\vartheta\) \vartheta \(\iota\) \iota \(\kappa\) \kappa \(\lambda\) \lambda \(\mu\) \mu \(\nu\) \nu \(\xi\) \xi \(\omicron\) \omicron \(\pi\) \pi \(\varpi\) \varpi \(\rho\) \rho \(\varrho\) \varrho \(\sigma\) \sigma \(\varsigma\) \varsigma \(\tau\) \tau \(\upsilon\) \upsilon \(\phi\) \phi \(\varphi\) \varphi \(\chi\) \chi \(\psi\) \psi \(\omega\) \omega \(\Gamma\) \Gamma \(\Delta\) \Delta \(\Theta\) \Theta \(\Lambda\) \Lambda \(\Xi\) \Xi \(\Pi\) \Pi \(\Sigma\) \Sigma \(\Upsilon\) \Upsilon \(\Phi\) \Phi \(\Psi\) \Psi \(\Omega\) \Omega \(\leq\) \leq \(\geq\) \geq \(\equiv\) \equiv \(\models\) \models \(\prec\) \prec \(\succ\) \succ \(\sim\) \sim \(\perp\) \perp \(\preceq\) \preceq \(\succeq\) \succeq \(\simeq\) \simeq \(\mid\) \mid \(\ll\) \ll \(\gg\) \gg \(\asymp\) \asymp \(\parallel\) \parallel \(\subset\) \subset \(\supset\) \supset \(\approx\) \approx \(\bowtie\) \bowtie \(\subseteq\) \subseteq \(\supseteq\) \supseteq \(\cong\) \cong \(\sqsubset\) \sqsubset \(\sqsupset\) \sqsupset \(\neq\) \neq \(\smile\) \smile \(\sqsubseteq\) \sqsubseteq \(\sqsupseteq\) \sqsupseteq \(\doteq\) \doteq \(\frown\) \frown \(\in\) \in \(\ni\) \ni \(\propto\) \propto \(\vdash\) \vdash \(\dashv\) \dashv \(\leftarrow\) \leftarrow \(\longleftarrow\) \longleftarrow \(\Leftarrow\) \Leftarrow \(\Longleftarrow\) \Longleftarrow \(\rightarrow\) \rightarrow \(\longrightarrow\) \longrightarrow \(\Rightarrow\) \Rightarrow \(\Longrightarrow\) \Longrightarrow \(\uparrow\) \uparrow \(\Uparrow\) \Uparrow \(\downarrow\) \downarrow \(\Downarrow\) \Downarrow \(\leftrightarrow\) \leftrightarrow \(\longleftrightarrow\) \longleftrightarrow \(\Leftrightarrow\) \Leftrightarrow \(\Longleftrightarrow\) \Longleftrightarrow \(\updownarrow\) \updownarrow \(\Updownarrow\) \Updownarrow \(\mapsto\) \mapsto \(\longmapsto\) \longmapsto \(\nearrow\) \nearrow \(\searrow\) \searrow \(\nwarrow\) \nwarrow \(\swarrow\) \swarrow \(\hookleftarrow\) \hookleftarrow \(\hookrightarrow\) \hookrightarrow \(\leftharpoonup\) \leftharpoonup \(\rightharpoonup\) \rightharpoonup \(\leftharpoondown\) \leftharpoondown \(\rightharpoondown\) \rightharpoondown \(\sum\) \sum \(\prod\) \prod \(\coprod\) \coprod \(\int\) \int \(\oint\) \oint \(\bigcap\) \bigcap \(\bigcup\) \bigcup \(\bigsqcup\) \bigsqcup \(\bigvee\) \bigvee \(\bigwedge\) \bigwedge \(\bigodot\) \bigodot \(\bigotimes\) \bigotimes \(\bigoplus\) *** \(\biguplus\) \biguplus \(\lfloor\) \lfloor \(\rfloor\) \rfloor \(\lceil\) \lceil \(\rceil\) \rceil \(\langle\) \langle \(\rangle\) \rangle \(\backslash\) \backslash \(\boxdot\) \boxdot \(\boxplus\) \boxplus \(\boxtimes\) \boxtimes \(\square\) \square \(\blacksquare\) \blacksquare \(\boxminus\) \boxminus \(\lozenge\) \lozenge \(\blacklozenge\) \blacklozenge \(\circlearrowright\) \circlearrowright \(\circlearrowleft\) \circlearrowleft \(\leftrightharpoons\) \leftrightharpoons \(\centerdot\) \centerdot \(\Vdash\) \Vdash \(\Vvdash\) \Vvdash \(\vDash\) \vDash \(\twoheadrightarrow\) \twoheadrightarrow \(\twoheadleftarrow\) \twoheadleftarrow \(\leftleftarrows\) \leftleftarrows \(\rightrightarrows\) \rightrightarrows \(\upuparrows\) \upuparrows \(\downdownarrows\) \downharpoonleft \(\upharpoonright\) \upharpoonright \(\upharpoonleft\) \upharpoonleft \(\downharpoonright\) \downharpoonright \(\downharpoonleft\) \downharpoonleft \(\rightarrowtail\) \rightarrowtail \(\leftarrowtail\) \leftarrowtail \(\rightleftarrows\) \rightleftarrows \(\leftrightarrows\) \leftrightarrows \(\Lsh\) \Lsh \(\Rsh\) \Rsh \(\rightsquigarrow\) \rightsquigarrow \(\leftrightsquigarrow\) \leftrightsquigarrow \(\looparrowleft\) \looparrowleft \(\looparrowright\) \looparrowright \(\circeq\) \circeq \(\succsim\) \succsim å…ˆæ›´æ–°è¿™ä¹ˆå¤šã€‚ã€‚ã€‚ã€‚ã€‚]]></content>
      <categories>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces-Gym-101201F-Illumination]]></title>
    <url>%2F2017%2F10%2F09%2FCodeForces-Gym-101201F-Illumination%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® You inherited a haunted house. Its floor plan is an n-by-n square grid with l lamps in fixedlocations and no interior walls. Each lamp can either illuminate its row or its column, but not bothsimultaneously. The illumination of each lamp extends by r squares in both directions, so a lampunobstructed by an exterior wall of the house can illuminate as many as 2r + 1 squares. If a square is illuminated by more than one lamp in its row, or by more than one lamp in its column,the resulting bright spot will scare away ghosts forever, diminishing the value of your property. Isit possible for all lamps to illuminate a row or column, without scaring any ghosts? Note that asquare illuminated by two lamps, one in its row and the other in its column, will not scare awaythe ghosts. Input The first line of input contains three positive integers, n, r and l \((1 \leqslant n, r, l \leqslant 1,000)\). Each of the next l lines contains two positive integers ri and ci \((1 \leqslant r_i,c_i \leqslant n)\), indicating that there is a lamp in row \(r_i\) and column \(c_i\). It is guaranteed that all lamps are in distinct locations. Output Print, on a single line, YES if it is possible to illuminate all lamps as stated above; otherwise, print NO. åˆ†æž å…¸åž‹çš„2-SATé—®é¢˜ æ¯ä¸ªç¯æ³¡æœ‰ä¸¤ä¸ªçŠ¶æ€ï¼ŒçŠ¶æ€ä¹‹é—´ç›¸äº’å½±å“ã€‚ ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;int n, r, l;struct node &#123; int x, y;&#125; p[1010];vector&lt;int&gt; G[2010], rG[2010], vs;bool used[2010];int cmp[2010];void addedge(int u, int v) &#123; G[u].push_back(v); rG[v].push_back(u);&#125;void build() &#123; for (int i = 0; i &lt; l; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (p[i].y == p[j].y &amp;&amp; abs(p[i].x - p[j].x) &lt;= 2 * r) &#123; addedge(i, l + j); addedge(j, l + i); &#125; if (p[i].x == p[j].x &amp;&amp; abs(p[i].y - p[j].y) &lt;= 2 * r) &#123; addedge(l + i, j); addedge(l + j, i); &#125; &#125; &#125;&#125;void dfs(int v) &#123; used[v] = true; for (int i = 0; i &lt; (int)G[v].size(); ++i) &#123; if (!used[G[v][i]]) dfs(G[v][i]); &#125; vs.push_back(v);&#125;void rdfs(int v, int k) &#123; used[v] = true; cmp[v] = k; for (int i = 0; i &lt; (int)rG[v].size(); ++i) &#123; if (!used[rG[v][i]]) rdfs(rG[v][i], k); &#125;&#125;int scc() &#123; memset(used, 0, sizeof(used)); vs.clear(); for (int i = 0; i &lt; 2 * l; ++i) &#123; if (!used[i]) dfs(i); &#125; memset(used, 0, sizeof(used)); int k = 0; for (int i = vs.size() - 1; i &gt;= 0; --i) &#123; if (!used[vs[i]]) rdfs(vs[i], k++); &#125; return k;&#125;int main(void) &#123; scanf("%d%d%d", &amp;n, &amp;r, &amp;l); for (int i = 0; i &lt; l; i++) scanf("%d%d", &amp;p[i].x, &amp;p[i].y); build(); scc(); for (int i = 0; i &lt; l; i ++) &#123; if (cmp[i] == cmp[l + i]) &#123; printf("NO\n"); return 0; &#125; &#125; printf("YES\n"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
        <tag>å›¾è®º</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NAIPC-2017-A]]></title>
    <url>%2F2017%2F10%2F09%2FNAIPC-2017-A%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® You are teaching a class in programming, and you want to cover balanced parentheses. Youâ€™ve got a great visual aid, a sign with a very long, balanced string of parentheses. But, alas, somehow, your visual aid has been broken into pieces, and some pieces may be missing! Youâ€™ve got to try to put it back together as best you can. Given the string of parentheses on each piece, what is the longest balanced string you can form by concatenating some of them in some order? Each piece may be used at most once, and the pieces cannot be reversed. A balanced string of parentheses is defined as: The empty string ABAB where AA and BB are both balanced strings of parentheses (AA) where AA is a balanced string of parentheses Input Each input will consist of a single test case. Note that your program may be run multiple times on different inputs. The first line of input will contain a single integer nn (1â‰¤nâ‰¤3001â‰¤nâ‰¤300), which is the number of pieces. Each of the next nn lines will hold a single string ss (1â‰¤|s|â‰¤3001â‰¤|s|â‰¤300), which consists only of the characters â€™(â€™ and â€™)â€™. This describes one of the pieces. Output Output a single integer, which is the length of the longest string of balanced parentheses you can form from the pieces. Note that the empty string is technically a balanced string of parentheses, so it is always possible to form a string of length at least 00 (although the empty string is not a very effective visual aid!). Example sample input1 12343())((())() sample output1 110 sample input2 1234565))))))(())((( sample output2 12 åˆ†æž é¢˜æ„æ˜¯ç»™å®šnä¸ªç”±æ‹¬å·ç»„æˆçš„å­—ç¬¦ä¸²ï¼Œé—®é€‰æ‹©ä¸€äº›å­—ç¬¦ä¸²æ¥æ‹¼æŽ¥ï¼Œèƒ½å¾—åˆ°çš„æ‹¬å·åŒ¹é…çš„æœ€é•¿çš„æœ€é•¿çš„å­—ç¬¦ä¸²çš„é•¿åº¦ã€‚ å…ˆå°†æ¯ä¸ªå­—ç¬¦ä¸²ä¸­å·²ç»èƒ½å¤ŸåŒ¹é…çš„æ‹¬å·æ¶ˆåŽ»ï¼Œå¾—åˆ°ä¸€ä¸ª))...(((è¿™ç§ç±»åž‹çš„å­—ç¬¦ä¸² dp[i][j] è¡¨ç¤ºå¤„ç†å®Œå‰iä¸ªå­—ç¬¦ä¸²ï¼Œå·¦æ‹¬å·è¿˜å‰©ä¸‹çš„jä¸ªå­—ç¬¦ä¸²çš„æœ€å¤§é•¿åº¦ \(dp[i + 1][j] = max(dp[i][j], dp[i][j + p[i].r - p[i].l] + p[i].w\) ç»“æž„ä½“p{l:å¤„ç†åŽå·¦æ‹¬å·ä¸ªæ•°, r: å¤„ç†åŽå³æ‹¬å·ä¸ªæ•°, w:åŽŸå­—ç¬¦ä¸²çš„é•¿åº¦} è¿™ä¸ªé¢˜ç›®çš„é‡ç‚¹åœ¨äºŽæŽ’åºï¼Œå¾ˆå®¹æ˜“å°±èƒ½æƒ³åˆ°è¿™æ ·çš„dpæ–¹ç¨‹ æŽ’åºï¼šåªæœ‰å·¦æ‹¬å·çš„æŽ’åœ¨æœ€å‰é¢ï¼Œåªæœ‰å³æ‹¬å·çš„æŽ’åœ¨æœ€åŽé¢ï¼Œç„¶åŽå¯¹äºŽä¸­ é—´çš„ä½¿å·¦æ‹¬å·å¢žåŠ çš„æŽ’åœ¨å‡å°‘çš„ä¹‹å‰ï¼Œå¯¹äºŽéƒ½å¢žåŠ æˆ–è€…éƒ½å‡å°‘çš„çš„ï¼Œå³æ‹¬å·å°‘çš„æŽ’åœ¨å‰é¢ã€‚ï¼ˆè¿™é‡Œå°±æ˜¯ä¸€ä¸ªè´ªå¿ƒï¼‰ ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123;//é¢„å¤„ç†åŽçš„å­—ç¬¦ä¸²çš„å·¦æ‹¬å·å’Œå³æ‹¬å·çš„ä¸ªæ•°è¿˜æœ‰åŽŸå­—ç¬¦ä¸²çš„é•¿åº¦ int l, r, w;&#125; p[310];bool cmp(node a, node b) &#123; if(a.r == 0 &amp;&amp; b.r != 0) return true; else if(a.r != 0 &amp;&amp; b.r == 0) return false; else if(a.r == 0 &amp;&amp; b.r == 0) return a.l &lt; b.l; if(a.l == 0 &amp;&amp; b.l != 0) return false; else if(a.l != 0 &amp;&amp; b.l == 0) return true; else if(a.l == 0 &amp;&amp; b.l == 0) return a.r &lt; b.r; if(a.l - a.r &gt;= 0 &amp;&amp; b.l - b.r &gt;= 0) return a.r &lt; b.r; if (a.l - a.r &gt;= 0 &amp;&amp; b.l - b.r &lt; 0) return true; if (b.l - b.r &gt;= 0 &amp;&amp; a.l - a.r &lt; 0) return false; return a.r - a.l &lt; b.r - b.l;&#125;int dp[310][90010];char tmp[310];int main(void) &#123; int n; int cntl, cntr; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; cntl = cntr = 0; scanf("%s", tmp); p[i].w = (int)strlen(tmp); for (int j = 0; j &lt; p[i].w; j++) &#123; if (tmp[j] == '(') cntl++; else &#123; if (cntl) cntl--; else cntr++; &#125; &#125; p[i].l = cntl; p[i].r = cntr; &#125; sort(p, p + n, cmp); memset(dp, -0x3f, sizeof(dp)); dp[0][0] = 0; for (int i = 0; i &lt; n ; i++) &#123; for(int j = 0; j &lt; p[i].l; j++) dp[i + 1][j] = dp[i][j]; for (int j = p[i].l; j &lt;= 90000 &amp;&amp; j + p[i].r - p[i].l &lt;= 90000; j++) dp[i + 1][j] = max(dp[i][j], dp[i][j + p[i].r - p[i].l] + p[i].w); &#125; printf("%d\n", dp[n][0]);&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>è´ªå¿ƒ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces-868C-Qualification-Rounds]]></title>
    <url>%2F2017%2F10%2F08%2FCodeForces-868C-Qualification-Rounds%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® Snark and Philip are preparing the problemset for the upcoming pre-qualification round for semi-quarter-finals. They have a bank of nproblems, and they want to select any non-empty subset of it as a problemset. k experienced teams are participating in the contest. Some of these teams already know some of the problems. To make the contest interesting for them, each of the teams should know at most half of the selected problems. Determine if Snark and Philip can make an interesting problemset! Input The first line contains two integers n, k (1 â‰¤ n â‰¤ 105, 1 â‰¤ k â‰¤ 4) â€” the number of problems and the number of experienced teams. Each of the next n lines contains k integers, each equal to 0 or 1. The j-th number in the i-th line is 1 if j-th team knows i-th problem and 0 otherwise. Output Print &quot;YES&quot; (quotes for clarity), if it is possible to make an interesting problemset, and &quot;NO&quot; otherwise. You can print each character either upper- or lowercase (&quot;YeS&quot; and &quot;yes&quot; are valid when the answer is &quot;YES&quot;). Examples input 1234565 31 0 11 1 01 0 01 0 01 0 0 output 1NO input 12343 21 01 10 1 output 1YES Note In the first example you can't make any interesting problemset, because the first team knows all problems. In the second example you can choose the first and the third problems. åˆ†æž ç”±äºŽé˜Ÿä¼çš„æ•°é‡æœ€å¤šåªæœ‰4ä¸ªï¼Œé‚£ä¹ˆå¯¹äºŽä¸€é“é¢˜ç›®çš„çŠ¶æ€æœ€å¤šä¹Ÿåªæœ‰16ç§ï¼Œå‡è®¾å­˜åœ¨ä¸€é“é¢˜ç›®æ‰€æœ‰çš„é˜Ÿä¼éƒ½ä¸ä¼šï¼Œé‚£ä¹ˆåªè¦é€‰è¿™ä¸€é“é¢˜æ˜¯è‚¯å®šå¯ä»¥çš„ã€‚ çŽ°åœ¨è€ƒè™‘æ²¡æœ‰æ‰€æœ‰äººéƒ½ä¸ä¼šçš„é¢˜ç›®ï¼Œåˆ™è‡³å°‘å…ˆé€‰ä¸€é“é¢˜ç›®ï¼ˆå¹¶ä¸”è¿™é“é¢˜ç›®è‡³å°‘è¢«ä¸€ä¸ªé˜Ÿä¼çŸ¥é“ï¼‰ï¼Œå‡è®¾è¿™é“é¢˜ç›®çš„çŠ¶æ€æ˜¯â€œ1000â€åˆ™çŽ°åœ¨è‡³å°‘è¦é€‰æ‹©ä¸€é“é¢˜ç›®æ¥æŠµæ¶ˆç¬¬ä¸€ä¸ªé˜Ÿä¼ï¼Œå› ä¸ºç¬¬ä¸€ä¸ªé˜Ÿä¼å·²ç»çŸ¥é“äº†ä¸€é“é¢˜ç›®äº†ï¼ŒçŽ°åœ¨è‡³å°‘è¦é€‰ä¸€ä¸ªâ€œ0***â€çš„é¢˜ç›®ï¼Œè‹¥å­˜åœ¨è¿™æ ·çš„é¢˜ç›®åˆ™ç­”æ¡ˆè‚¯å®šæ˜¯â€œYESâ€çš„ï¼ŒçŽ°åœ¨è€ƒè™‘æ›´åŠ å¤æ‚çš„æƒ…å†µã€‚ ç­”æ¡ˆå­˜åœ¨å½“ä¸”ä»…å½“å­˜åœ¨ä¸¤é“é¢˜ç›®çš„çŠ¶æ€æ˜¯aå’Œbä¸”a&amp;b = 0 å¿…è¦æ€§æ˜¾è€Œæ˜“è§ã€‚ å¯¹äºŽå……åˆ†æ€§ï¼šç”±ä¸Šé¢çš„ä¾‹å­è€ƒè™‘è·Ÿå®¶å¤æ‚ç­‰æƒ…å†µï¼Œå½“æˆ‘ä»¬é€‰æ‹©äº†ä¸€é“é¢˜ç›®åŽï¼Œåœ¨é€‰æ‹©ç¬¬äºŒé“é¢˜ç›®çš„æ—¶å€™å¿…é¡»é€‰æ‹©ä¸€é“é¢˜æŠµæ¶ˆç¬¬ä¸€é“çŠ¶æ€ä¸Šæ˜¯1é˜Ÿä¼ï¼Œè¿™ä¸ªæ—¶å€™è‚¯å®šè¦å…ˆé€‰æ‹©è¿™äº›ä½ç½®ä¸º0çš„ï¼Œè‹¥å­˜åœ¨å…¶ä»–ç­”æ¡ˆï¼Œé€‰æ‹©äº†ä¸º1çš„ï¼Œåˆ™1å¢žåŠ äº†ï¼Œé¢˜ç›®è¦æ±‚æ¯ä¸ªé˜Ÿä¼çš„0æ¯”1å¤šï¼Œåˆ™é€šè¿‡äº¤æ¢é€‰æ‹©é¢˜ç›®çš„é¡ºåºï¼Œè¿™ä¸ªæ—¶å€™è‚¯å®šè¦é€‰ä¸€ä¸ªåœ¨ç¬¬ä¸€æ¬¡é€‰æ‹©çš„æ—¶å€™ä¸º1çš„é˜Ÿä¼ï¼Œæ­¤æ—¶ä¸º0çš„é¢˜ç›®ã€‚ å…±æœ‰16ç§çŠ¶æ€16*16æžšä¸¾ä¸€ä¸‹å°±å¥½äº† ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int n, k;bool vis[20];int main(void) &#123; memset(vis, false, sizeof(vis)); scanf("%d%d", &amp;n, &amp;k); int gg; for (int i = 0; i &lt; n; i++) &#123; int tmp = 0; for (int j = 0; j &lt; k; j++) &#123; scanf("%d", &amp;gg); tmp = tmp * 2 + gg; &#125; vis[tmp] = true; &#125; bool flag = false; if (vis[0]) flag = true; else &#123; for(int i = 0; i &lt; 16; i++) &#123; if(vis[i]) &#123; for(int j = 0; j &lt; i; j++) &#123; if(vis[j] &amp;&amp; !(i &amp; j)) &#123; flag = true; break; &#125; &#125; &#125; if(flag) break; &#125; &#125; if(flag) printf("YES\n"); else printf("NO\n"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>æ•°å­¦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces-869c-The-Intriguing-Obsession]]></title>
    <url>%2F2017%2F10%2F08%2FCodeForces-869c-The-Intriguing-Obsession%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® â€”This is not playing but duty as allies of justice, Nii-chan! â€” Not allies but justice itself, Onii-chan! With hands joined, go everywhere at a speed faster than our thoughts! This time, the Fire Sisters â€” Karen and Tsukihi â€” is heading for somewhere they've never reached â€” water-surrounded islands! There are three clusters of islands, conveniently coloured red, blue and purple. The clusters consist of a, b and c distinct islands respectively. Bridges have been built between some (possibly all or none) of the islands. A bridge bidirectionally connects two different islands and has length 1. For any two islands of the same colour, either they shouldn't be reached from each other through bridges, or the shortest distance between them is at least 3, apparently in order to prevent oddities from spreading quickly inside a cluster. The Fire Sisters are ready for the unknown, but they'd also like to test your courage. And you're here to figure out the number of different ways to build all bridges under the constraints, and give the answer modulo 998 244 353. Two ways are considered different if a pair of islands exist, such that there's a bridge between them in one of them, but not in the other. Input The first and only line of input contains three space-separated integers a, b and c (1 â‰¤ a, b, c â‰¤ 5 000) â€” the number of islands in the red, blue and purple clusters, respectively. Output Output one line containing an integer â€” the number of different ways to build bridges, modulo 998 244 353. Examples input 11 1 1 output 18 input 11 2 2 output 163 input 11 3 5 output 13264 input 16 2 9 output 1813023575 Note In the first example, there are 3 bridges that can possibly be built, and no setup of bridges violates the restrictions. Thus the answer is 23 = 8. In the second example, the upper two structures in the figure below are instances of valid ones, while the lower two are invalid due to the blue and purple clusters, respectively. img åˆ†æž ç”±äºŽä»»æ„ä¸¤ç§é¢œè‰²çš„å½±å“æ˜¯ç‹¬ç«‹çš„ï¼Œæ‰€ä»¥å¯ä»¥ç»¼åˆè€ƒè™‘ä»»æ„ä¸¤ç§é¢œè‰²ä¹‹é—´çš„è¿žæŽ¥æƒ…å†µï¼Œç„¶åŽæŠŠä¸‰ä¸ªæ•°ä¹˜èµ·æ¥ï¼Œå°±æ˜¯æœ€åŽçš„ç­”æ¡ˆã€‚ è€ƒè™‘ä¸¤ç§é¢œè‰²ä¹‹é—´çš„æ–¹æ¡ˆæ•°ç›®ã€‚ dp[i][j]è¡¨ç¤ºçš„æ˜¯ä¸¤ç§é¢œè‰²åˆ†åˆ«ä¸ºiä¸ªå’Œjä¸ªä¹‹é—´çš„é¢œè‰²ï¼Œåˆ™çŽ°åœ¨è€ƒè™‘iè¡¨ç¤ºçš„é¢œè‰²å¢žåŠ äº†ä¸€ä¸ªç‚¹ï¼Œåˆ™è¿™ä¸ªç‚¹å’Œjè¡¨ç¤ºçš„é¢œè‰²ç›¸è¿žçš„æ–¹æ¡ˆæ•°ç›®æ˜¯\(j * dp[i][j - 1]\),è‹¥ä¸ä¸Žjä¸­ä»»æ„ä¸€ä¸ªé¢œè‰²ç›¸è¿žåˆ™æ˜¯\(dp[i][j]\) åˆ™\[dp[i + 1][j] = j * dp[i ][j - 1] + dp[i ][j]\] å³\[dp[i][j] = j * dp[i - 1][j - 1] + dp[i - 1][j]\] ä»£ç  12345678910111213141516171819202122232425#include &lt;cstdio&gt;const long long int MOD = 998244353;const int MAXN = 5e3 + 10;int dp[MAXN][MAXN];void init() &#123; for(int i = 0; i &lt; MAXN; i++) dp[i][0] = dp[0][i] = 1; for(int i = 1; i &lt; MAXN; i++) &#123; for(int j = 1; j &lt; MAXN; j++) &#123; dp[i][j] = (j * 1LL * dp[i - 1][j - 1] + dp[i - 1][j]) % MOD; &#125; &#125;&#125;int main(void) &#123; init(); int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); int ans = ((1LL * dp[a][b] * dp[a][c]) % MOD) * dp[b][c] % MOD; printf("%d\n", ans); return 0; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>æž„é€ </tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU5242-Game]]></title>
    <url>%2F2017%2F09%2F12%2FHDU5242-Game%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® Problem Description It is well known that Keima Katsuragi is The Capturing God because of his exceptional skills and experience in ''capturing'' virtual girls in gal games. He is able to play k games simultaneously. One day he gets a new gal game named ''XX island''. There are n scenes in that game, and one scene will be transformed to different scenes by choosing different options while playing the game. All the scenes form a structure like a rooted tree such that the root is exactly the opening scene while leaves are all the ending scenes. Each scene has a value , and we use wi as the value of the i-th scene. Once Katsuragi entering some new scene, he will get the value of that scene. However, even if Katsuragi enters some scenes for more than once, he will get wi for only once. For his outstanding ability in playing gal games, Katsuragi is able to play the game k times simultaneously. Now you are asked to calculate the maximum total value he will get by playing that game for k times. Input The first line contains an integer T(Tâ‰¤20), denoting the number of test cases. For each test case, the first line contains two numbers n,k(1â‰¤kâ‰¤nâ‰¤100000), denoting the total number of scenes and the maximum times for Katsuragi to play the game ''XX island''. The second line contains n non-negative numbers, separated by space. The i-th number denotes the value of the i-th scene. It is guaranteed that all the values are less than or equal to 231âˆ’1. In the following nâˆ’1 lines, each line contains two integers a,b(1â‰¤a,bâ‰¤n), implying we can transform from the a-th scene to the b-th scene. We assume the first scene(i.e., the scene with index one) to be the opening scene(i.e., the root of the tree). Output For each test case, output ''Case #t:'' to represent the t-th case, and then output the maximum total value Katsuragi will get. Sample Input 1234567891011121325 24 3 2 1 11 21 52 32 45 34 3 2 1 11 21 52 32 4 Sample Output 12Case #1: 10Case #2: 11 åˆ†æž è¿™é¢˜æ˜¯ä¸€ä¸ªè´ªå¿ƒï¼Œç”±äºŽæ¯æ¬¡é€‰æ‹©çš„è·¯å¾„è‚¯å®šæ˜¯ä»Žæ ¹èŠ‚ç‚¹åˆ°ä¸€ä¸ªå¶ç»“ç‚¹çš„ï¼Œåˆ™é¦–å…ˆdfsè®¡ç®—å‡ºä»Žæ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ä¸Šæ‰€æœ‰ç‚¹çš„æƒå€¼å’Œï¼Œç„¶åŽå°†å¶ç»“ç‚¹æŒ‰ç…§è·¯å¾„æƒå€¼å’Œçš„ä»Žå¤§åˆ°å°æŽ’åºï¼Œç„¶åŽæ ¹æ®è¿™ä¸ªé¡ºåºå‘ä¸Šèµ°åˆ°æ ¹èŠ‚ç‚¹æˆ–åˆ™èµ°åˆ°è¢«é€‰æ‹©çš„èŠ‚ç‚¹ï¼Œè®¡ç®—æƒå€¼å’Œï¼Œç„¶åŽè®¡ç®—å‡ºcntï¼ˆå¶ç»“ç‚¹ä¸ªæ•°ï¼‰ä¸ªæƒå€¼å’Œï¼Œç„¶åŽä»Žå¤§åˆ°å°æŽ’åºï¼Œé€‰å‰kæ¡è·¯å°±æ˜¯æœ€ä¼˜çš„è·¯ã€‚ è´ªå¿ƒè¯æ˜Žï¼šè€ƒè™‘ä¸€èˆ¬æƒ…å†µï¼Œæœ‰ä¸€é¢—å­æ ‘ï¼šaæœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹bå’Œcï¼Œå‡è®¾æ ¹èŠ‚ç‚¹åˆ°bçš„è·¯å¾„æƒå€¼å’Œæ¯”è¾ƒå¤§ï¼Œåˆ™é€‰æ‹©bå‘ä¸Šèµ°åˆ°ä¸€ä¸ªå·²ç»è¢«é€‰æ‹©çš„èŠ‚ç‚¹æˆ–è€…æ ¹èŠ‚ç‚¹è‚¯å®šæ¯”cè¦æ›´ä¼˜ï¼Œå› ä¸ºbå’Œcçš„æœ€è¿‘å…¬å…±ç¥–å…ˆæ˜¯açš„æ ¹èŠ‚ç‚¹ï¼Œä¸”æœ€è¿‘å…¬å…±ç¥–å…ˆåˆ°bå’Œcçš„è·¯å¾„éƒ½æ²¡æœ‰è¢«æŸ“è‰²ï¼Œåˆ™è€ƒè™‘æ›´å¤æ‚çš„æƒ…å†µï¼Œå¯ä»¥å‘çŽ°ï¼Œå¯¹äºŽåŒä¸€æ£µå­æ ‘ä¹‹ä¸­ï¼Œå¶å­åˆ°å­æ ‘æ ¹èŠ‚ç‚¹çš„è·¯å¾„æƒå€¼å’Œçš„ååºå…³ç³»å’Œæ ¹èŠ‚ç‚¹åˆ°è¯¥å¶èŠ‚ç‚¹çš„è·¯å¾„æƒå€¼å’Œçš„ååºå…³ç³»æ˜¯ç›¸åŒçš„ã€‚ ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e5 +10;vector&lt;int&gt; G[MAXN];long long int val[MAXN], g[MAXN]; int fa[MAXN], d[MAXN], cnt;bool vis[MAXN]; bool cmp(int a, int b) &#123; return val[a] &gt; val[b];&#125;void dfs(int s) &#123; for(int i = 0; i &lt; G[s].size(); i++) &#123; val[G[s][i]] += val[s]; dfs(G[s][i]); &#125; if(!G[s].size()) d[cnt++] = s;&#125;long long int getNum(int k) &#123; long long int ret = 0; while(!vis[k]) &#123; ret += g[k]; vis[k] = true; k = fa[k]; &#125; return ret;&#125;int main(void) &#123; int t, n, k, u, v; scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; cas++) &#123; scanf("%d%d", &amp;n, &amp;k); for(int i = 1; i &lt;= n; i++) &#123; G[i].clear(); vis[i] = false; scanf("%lld", &amp;val[i]); g[i] = val[i]; &#125; for(int i = 0; i &lt; n- 1; i++) &#123; scanf("%d%d", &amp;u, &amp;v); fa[v] = u; G[u].push_back(v); &#125; cnt = 0; dfs(1); sort(d, d + cnt, cmp); for(int i = 0; i &lt; cnt; i++) &#123; val[i] = getNum(d[i]); &#125; sort(val, val + cnt); long long int ans = 0; for(int i = cnt - 1; i &gt;= cnt - k; i--) ans += val[i]; printf("Case #%d: %lld\n",cas, ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>è´ªå¿ƒ</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU5245-Joyful]]></title>
    <url>%2F2017%2F09%2F12%2FHDU5245-Joyful%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® Problem Description Sakura has a very magical tool to paint walls. One day, kAc asked Sakura to paint a wall that looks like an MÃ—N matrix. The wall has MÃ—N squares in all. In the whole problem we denotes (x,y) to be the square at the x-th row, y-th column. Once Sakura has determined two squares (x1,y1) and (x2,y2), she can use the magical tool to paint all the squares in the sub-matrix which has the given two squares as corners. However, Sakura is a very naughty girl, so she just randomly uses the tool for K times. More specifically, each time for Sakura to use that tool, she just randomly picks two squares from all the MÃ—N squares, with equal probability. Now, kAc wants to know the expected number of squares that will be painted eventually. Input The first line contains an integer T(Tâ‰¤100), denoting the number of test cases. For each test case, there is only one line, with three integers M,N and K. It is guaranteed that 1â‰¤M,Nâ‰¤500, 1â‰¤Kâ‰¤20. Output For each test case, output ''Case #t:'' to represent the t-th case, and then output the expected number of squares that will be painted. Round to integers. Sample Input 12323 3 14 4 2 Sample Output 12Case #1: 4Case #2: 8 Hint The precise answer in the first test case is about 3.56790123. åˆ†æž è®¡ç®—å‡ºæ¯ä¸€ä¸ªæ ¼å­è¢«ä¸Šè‰²çš„æ¦‚çŽ‡ï¼Œç´¯åŠ å››èˆäº”å…¥å°±æ˜¯ç­”æ¡ˆï¼Œæ¯ä¸ªæ ¼å­è¢«ä¸Šè‰²çš„æ¦‚çŽ‡å°±æ˜¯1å‡åŽ»ä¸è¢«ä¸Šè‰²çš„æ¦‚çŽ‡çš„kæ¬¡æ–¹ã€‚è®¡ç®—ä¸€ä¸ªæ ¼å­ä¸è¢«ä¸Šè‰²çš„æ¦‚çŽ‡ç”¨åˆ°ä¸€ä¸ªå®¹æ–¥å®šç†ã€‚ è®¡ç®—ä¸¤æ¬¡é€‰æ‹©éƒ½é€‰åœ¨è¯¥æ ¼å­ä¸€é¢çš„æ¦‚çŽ‡ï¼Œç´¯åŠ å››ä¸ªé¢çš„æ¦‚çŽ‡ï¼Œç”±äºŽç´¯åŠ çš„æ—¶å€™é‡å¤è®¡ç®—äº†åœ¨æ ¼å­çš„å››ä¸ªè§’çš„æ¦‚çŽ‡ï¼Œåˆ™ç”¨å®¹æ–¥å®šåŠ›å‡åŽ»ã€‚ ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;double q_pow(double a, int b) &#123; double ans = 1.0, tmp = a; while(b) &#123; if(b &amp; 1) ans = ans * tmp; tmp = tmp * tmp; b &gt;&gt;= 1; &#125; return ans;&#125;int main(void) &#123; int t, k; double n, m; scanf("%d", &amp;t); int nn, mm; for(int cas = 1; cas &lt;= t; cas++) &#123; double ans = 0.5; scanf("%lf%lf%d", &amp;n, &amp;m, &amp;k); nn= (int)n, mm = (int)m; for(int i = 1; i &lt;= nn; i++) &#123; for(int j = 1; j &lt;= mm; j++) &#123; ans += 1.0 - q_pow((m * (i - 1) * m * (i - 1) + m * (n - i) * m * (n - i) + n * (j - 1) * n * (j - 1) + n * (m - j) * n * (m - j) - ((double)i - 1) * (j - 1) * (i - 1) * (j - 1) - (n - i) * (m - j) * (n - i) * (m - j) - (n - i) * (j - 1) * (n - i) * (j - 1) - (i - 1) * (m - j) * (i - 1) * (m - j)) / (n * m * n * m), k); &#125; &#125; printf("Case #%d: %d\n", cas, (int)ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>æ•°å­¦</tag>
        <tag>å®¹æ–¥</tag>
        <tag>æ¦‚çŽ‡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6146 Pokemon-GO]]></title>
    <url>%2F2017%2F08%2F25%2FHDU6146-Pokemon-GO%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® Problem Description ä¼—æ‰€å‘¨çŸ¥ï¼Œåº¦åº¦ç†Šæœ€è¿‘æ²‰è¿·äºŽ PokÃ©mon GOã€‚ ä»Šå¤©å®ƒå†³å®šè¦æŠ“ä½æ‰€æœ‰çš„ç²¾çµçƒï¼ ä¸ºäº†ä¸è®©åº¦åº¦ç†Šå¤±æœ›ï¼Œç²¾çµçƒå·²ç»è¢«äº‹å…ˆæ”¾ç½®åœ¨ä¸€ä¸ª2*Nçš„æ ¼å­ä¸Šï¼Œæ¯ä¸€ä¸ªæ ¼å­ä¸Šéƒ½æœ‰ä¸€ä¸ªç²¾çµçƒã€‚åº¦åº¦ç†Šå¯ä»¥é€‰æ‹©ä»»æ„ä¸€ä¸ªæ ¼å­å¼€å§‹æ¸¸æˆï¼ŒæŠ“æ•æ ¼å­ä¸Šçš„ç²¾çµçƒï¼Œç„¶åŽç§»åŠ¨åˆ°ä¸€ä¸ªç›¸é‚»çš„è‡³å°‘æœ‰ä¸€ä¸ªå…¬å…±ç‚¹çš„æ ¼å­ä¸Šç»§ç»­æŠ“æ•ã€‚ä¾‹å¦‚ï¼Œ(2, 2) çš„ç›¸é‚»æ ¼å­æœ‰(1, 1), (2, 1) å’Œ (1, 2) ç­‰ç­‰ã€‚ çŽ°åœ¨åº¦åº¦ç†Šå¸Œæœ›çŸ¥é“å°†æ‰€æœ‰ç²¾çµçƒéƒ½æŠ“åˆ°å¹¶ä¸”æ­¥æ•°æœ€å°‘çš„æ–¹æ¡ˆæ•°ç›®ã€‚ä¸¤ä¸ªæ–¹æ¡ˆè¢«è®¤ä¸ºæ˜¯ä¸åŒï¼Œå½“ä¸”ä»…å½“ä¸¤ä¸ªæ–¹æ¡ˆè‡³å°‘æœ‰ä¸€æ­¥æ‰€åœ¨çš„æ ¼å­æ˜¯ä¸åŒçš„ã€‚ Input ç¬¬ä¸€è¡Œä¸ºTï¼Œè¡¨ç¤ºè¾“å…¥æ•°æ®ç»„æ•°ã€‚ æ¯ç»„æ•°æ®åŒ…å«ä¸€ä¸ªæ•°Nã€‚ â—1â‰¤Tâ‰¤100 â—1â‰¤Nâ‰¤10000 Output å¯¹æ¯ç»„æ•°æ®è¾“å‡ºæ–¹æ¡ˆæ•°ç›®ï¼Œç»“æžœå¯¹ 1 000 000 007 å–æ¨¡ã€‚ Sample Input 12343123 Sample Output 12322496 åˆ†æž DP[i][0]ï¼šä¸€ä¸ªé•¿åº¦ä¸ºiçš„å›¾ä»Žå·¦ä¸Šè§’å‡ºå‘ï¼Œæ‰€æœ‰çš„æ–¹æ¡ˆæ•°ã€‚ DP[i][1]ï¼šä¸€ä¸ªé•¿åº¦ä¸ºiçš„å›¾ä»Žå·¦ä¸Šè§’å‡ºå‘å›žåˆ°å·¦ä¸‹è§’çš„æ–¹æ¡ˆæ•°ã€‚ åˆ™æ˜¾ç„¶è¦å›žåˆ°ä¸‹é¢åˆ™ï¼Œä»Žç¬¬ä¸€ä¸ªç‚¹å‡ºå‘è¿›å…¥[i - 1]çš„å‰©ä½™éƒ¨åˆ†æœ‰ä¸¤ç§èµ°æ³•ï¼Œå³ dp[i][1] = 2 * dp[i - 1][0] å¦‚æžœä¸è¦æ±‚å›žåˆ°å·¦ä¸‹è§’ï¼Œåˆ™ dp[i][0] = ((dp[i - 1][1] + dp[i - 1][0] + dp[i - 2][0] * 2 ) * 2 å…¶ä¸­æ¯ä¸€é¡¹çš„æ„ä¹‰ï¼š dp[i - 1][1]:å…ˆå‘å³èµ°ï¼Œæœ€åŽå›žåˆ°å·¦ä¸‹è§’ dp[i - 1][0]:å…ˆå‘ä¸‹èµ°ï¼Œç„¶åŽèµ°å‰©ä¸‹çš„å³è¾¹å‰©ä½™éƒ¨åˆ† dp[i - 2][0]:å…ˆåœ¨æœ€å¼€å§‹çš„ç”°å­—æ ¼é‡Œèµ°ä¸€ä¸ªå‰ï¼Œäº¤å‰çš„èµ°å®Œç”°å­—æ ¼ï¼Œç„¶åŽèµ°å‰©ä¸‹çš„éƒ¨åˆ†ã€‚ æœ€åŽç»Ÿè®¡ç­”æ¡ˆæ—¶ï¼Œæžšä¸¾èµ·ç‚¹ç„¶åŽæŠŠå›¾åˆ†æˆå·¦å³ä¸¤éƒ¨åˆ†ï¼Œå°±å¯ä»¥ç”¨dpé‡Œçš„æ•°å€¼æ¥ç»Ÿè®¡ç­”æ¡ˆã€‚ ä»£ç  1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstring&gt;const long long int MOD = 1e9 + 7;const int MAXN = 1e4 + 10;long long int dp[MAXN][2];int main(void) &#123; dp[1][0] = 1; dp[1][1] = 1; dp[2][0] = 6; dp[2][1] = 2; for(int i = 3; i &lt; MAXN; i++) &#123; dp[i][1] = dp[i - 1][1] * 2 % MOD; dp[i][0] = (((dp[i - 1][1] + dp[i - 1][0]) % MOD + dp[i - 2][0] * 2 % MOD) % MOD) * 2 % MOD; &#125; int t, n; scanf("%d", &amp;t); while(t--) &#123; scanf("%d", &amp;n); if(n == 1) &#123; printf("2\n"); continue; &#125; long long int ans = dp[n][0]; for(int i = 2; i &lt; n; i++) &#123; ans = (ans + (dp[i][1] * dp[n - i][0] % MOD + dp[n - i + 1][1] * dp[i - 1][0] % MOD) % MOD) % MOD; &#125; ans = (ans * 4) % MOD; printf("%I64d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6134-Battlestation-Operational]]></title>
    <url>%2F2017%2F08%2F25%2FHDU6134-Battlestation-Operational%2F</url>
    <content type="text"><![CDATA[è½¬è½½é“¾æŽ¥ï¼šhttp://blog.csdn.net/v5zsq/article/details/77338191 é¢˜ç›®é“¾æŽ¥ é¢˜ç›® Problem Description The Death Star, known officially as the DS-1 Orbital Battle Station, also known as the Death Star I, the First Death Star, Project Stardust internally, and simply the Ultimate Weapon in early development stages, was a moon-sized, deep-space mobile battle station constructed by the Galactic Empire. Designed to fire a single planet-destroying superlaser powered by massive kyber crystals, it was the pet project of the Emperor, Darth Vader, and its eventual commander Grand Moff Wilhuff Tarkin to expound the military philosophy of the aptly named Tarkin Doctrine. â€” Wookieepedia In the story of the Rogue One, the rebels risked their lives stolen the construction plan of the Death Star before it can cause catastrophic damage to the rebel base. According to the documents, the main weapon of the Death Star, the Superlaser, emits asymmetric energy in the battlefield that cause photons to annihilate and burns everything in a single shot. You are assigned the task to estimate the damage of one shot of the Superlaser. Assuming that the battlefield is an nÃ—n grid. The energy field ignited by the Superlaser is asymmetric over the grid. For the cell at i-th row and j-th column, âŒˆi/jâŒ‰ units of damage will be caused. Furthermore, due to the quantum effects, the energies in a cell cancel out if gcd(i,j)â‰ 1 or i&lt;j. The figure below illustrates the damage caused to each cell for n=100. A cell in black indicates that this cell will not be damaged due to the quantum effects. Otherwise, different colors denote different units of damages. img Your should calculate the total damage to the battlefield. Formally, you should compute f(n)=âˆ‘i=1nâˆ‘j=1iâŒˆijâŒ‰[(i,j)=1], where [(i,j)=1] evaluates to be 1 if gcd(i,j)=1, otherwise 0. Input There are multiple test cases. Each line of the input, there is an integer n (1â‰¤nâ‰¤106), as described in the problem. There are up to 104 test cases. Output For each test case, output one integer in one line denoting the total damage of the Superlaser, f(n) mod 109+7. Sample Input 12341 2310 Sample Output 1234138110 åˆ†æž img ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 1000005#define mod 1000000007typedef long long ll;int prime[maxn],mu[maxn],euler[maxn],res,d[maxn],temp[maxn];void Moblus(int n=1000000)&#123; mu[1]=euler[1]=d[1]=1; res=0; for(int i=2;i&lt;=n;i++) &#123; if(!temp[i]) &#123; prime[res++]=i; mu[i]=-1; euler[i]=i-1; temp[i]=i; d[i]=2; &#125; for(int j=0;j&lt;res&amp;&amp;i*prime[j]&lt;=n;j++) &#123; if(i%prime[j]==0) &#123; mu[i*prime[j]]=0; euler[prime[j]*i]=euler[i]*prime[j]; temp[i*prime[j]]=temp[i]*prime[j]; d[i*prime[j]]=d[i/temp[i]]*(d[temp[i]]+1); break; &#125; mu[i*prime[j]]=-mu[i]; euler[prime[j]*i]=euler[i]*(prime[j]-1); temp[i*prime[j]]=prime[j]; d[i*prime[j]]=2*d[i]; &#125; &#125;&#125;void inc(int &amp;x,int y)&#123; x=x+y&gt;=mod?x+y-mod:x+y;&#125;void dec(int &amp;x,int y)&#123; x=x-y&lt;0?x-y+mod:x-y;&#125;int ans[maxn];void init(int n=1000000)&#123; for(int i=1;i&lt;=n;i++) for(int j=i;j&lt;=n;j+=i) if(mu[j/i]==-1)dec(ans[j],d[i]); else if(mu[j/i]==1)inc(ans[j],d[i]); for(int i=1;i&lt;=n;i++) inc(ans[i],euler[i]),dec(ans[i],1),inc(ans[i],ans[i-1]);&#125;int main()&#123; Moblus(); for(int i=2;i&lt;=1000000;i++)d[i]+=d[i-1]; init(); int n; while(~scanf("%d",&amp;n)) printf("%d\n",ans[n]); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>æ•°å­¦</tag>
        <tag>èŽ«æ¯”ä¹Œæ–¯åæ¼”</tag>
        <tag>ç§¯æ€§å‡½æ•°</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6107-Typesetting]]></title>
    <url>%2F2017%2F08%2F14%2FHDU6107-Typesetting%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® Problem Description Yellowstar is writing an article that contains N words and 1 picture, and the i-th word contains ai characters. The page width is fixed to W characters. In order to make the article look more beautiful, Yellowstar has made some rules: The fixed width of the picture is pw. The distance from the left side of the page to the left side of the photo fixed to dw, in other words, the left margin is dw, and the right margin is W - pw - dw. The photo and words can't overlap, but can exist in same line. The relative order of words cannot be changed. Individual words need to be placed in a line. If two words are placed in a continuous position on the same line, then there is a space between them. Minimize the number of rows occupied by the article according to the location and height of the image. However, Yellowstar has not yet determined the location of the picture and the height of the picture, he would like to try Q different locations and different heights to get the best look. Yellowstar tries too many times, he wants to quickly know the number of rows each time, so he asked for your help. It should be noted that when a row contains characters or pictures, the line was considered to be occupied. Input The first line of the input gives the number of test cases T; T test cases follow. Each case begins with one line with four integers N, W, pw, dw : the number of words, page width, picture width and left margin. The next line contains N integers ai, indicates i-th word consists of ai characters. The third line contains one integer Q. Then Q lines follow, each line contains the values of xi and hi, indicates the starting line and the image height of the image. Limits Tâ‰¤10 1â‰¤N,W,Qâ‰¤105 1â‰¤pw,aiâ‰¤W 0â‰¤dwâ‰¤Wâˆ’pw Output For each query, output one integer denotes the minimum number of rows. Sample Input 123456789101122 7 4 31 331 22 25 23 8 2 31 1 311 1 Sample Output 12342331 åˆ†æž åœ¨å›ºå®šæŸä¸ªå®½åº¦çš„å‰æä¸‹ï¼Œé¢„å¤„ç†ä»¥ç¬¬iä¸ªå•è¯å¼€å§‹ï¼Œä¸€è¡Œå†…æœ€å¤šèƒ½æ”¾ç½®çš„å•è¯ä¸ªæ•°ã€‚å› ä¸ºé¡µé¢å®½åº¦ï¼Œå›¾ç‰‡çš„å·¦å³è¾¹è·éƒ½å›ºå®šäº†ï¼Œæ‰€ä»¥åªè¦é¢„å¤„ç†è¿™3ç§å®½åº¦ã€‚ç”¨\(f_{i,j}\)è¡¨ç¤ºä»Žç¬¬iä¸ªå•è¯å¼€å§‹ï¼Œå ç”¨\(2^j\)è¡Œèƒ½æ”¾ç½®çš„æœ€å¤§å•è¯ä¸ªæ•°ã€‚å›¾ç‰‡æœ€å¤šå°†nä¸ªå•è¯åˆ’åˆ†æˆ3éƒ¨åˆ†ï¼Œæ¯éƒ¨åˆ†éƒ½ä½¿ç”¨å€å¢žå³å¯å®Œæˆå¿«é€ŸæŸ¥è¯¢ã€‚ä¸ºäº†æ–¹ä¾¿ï¼Œå¯ä»¥æ·»åŠ ç¬¬n+1ä¸ªå•è¯ï¼Œå•è¯é•¿åº¦å¤§äºŽé¡µé¢å®½åº¦ä¸”è¯¥å•è¯ä¸å æ®è¡Œã€‚ æ—¶é—´å¤æ‚åº¦ O((n+q)log(n) ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/** @Author: sun000* @Date: 2017-08-11 13:14:44* @Last Modified by: sun000* @Last Modified time: 2017-08-11 20:00:59*/#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAXN = 1e5 + 10;int n, w, pw, dw;int dp[3][MAXN][19];int l[MAXN], b[20];void init() &#123; memset(dp, 0, sizeof(dp)); int pl = 0, pr = 0, len = 0; for (; pl &lt; n; pl++) &#123; for(;pr &lt; n; pr++) &#123; if(len + l[pr] &gt; w + 1) break; else len += l[pr]; &#125; //printf("$$ %d %d %d\n", pl, pr, len); dp[0][pl][0] = pr - pl; len -= l[pl]; &#125; pl = 0, pr = 0, len = 0; for (; pl &lt; n; pl++) &#123; for(;pr &lt; n; pr++) &#123; if(len + l[pr] &gt; dw + 1) break; else len += l[pr]; &#125; //printf("$$ %d %d %d\n", pl, pr, len); dp[1][pl][0] = pr - pl; len -= l[pl]; &#125; pl = 0, pr = 0, len = 0; for (; pl &lt; n; pl++) &#123; for(;pr &lt; n; pr++) &#123; if(len + l[pr] &gt; w - dw - pw + 1) break; else len += l[pr]; &#125; //printf("$$ %d %d %d\n", pl, pr, len); dp[2][pl][0] = pr - pl; len -= l[pl]; &#125; for(int i = 0; i &lt; n; i++) dp[1][i][0] = dp[1][i][0] + dp[2][ i + dp[1][i][0] ][0]; for (int j = 1; j &lt; 18; j++) &#123; for (int i = 0; i &lt; n; i++) &#123; dp[0][i][j] = dp[0][i][j - 1] + dp[0][i + dp[0][i][j - 1]][j - 1]; dp[1][i][j] = dp[1][i][j - 1] + dp[1][i + dp[1][i][j - 1]][j - 1]; &#125; &#125;&#125;int query(int x, int h) &#123; int ret = 0, ans = 0; int tx = x, tl = 0; while (tx) &#123; if (tx &amp; 1) ret += dp[0][ret][tl]; tx &gt;&gt;= 1; tl++; &#125; if (ret &gt;= n) &#123; ret = 0; while (ret &lt; n) &#123; for (int i = 1; i &lt; 17; i++) &#123; if (dp[0][ret][i] == dp[0][ret][i + 1]) &#123; ans += b[i - 1]; ret += dp[0][ret][i - 1]; break; &#125; &#125; &#125; return ans + h; &#125; tx = h, tl = 0; while (tx) &#123; if (tx &amp; 1) ret += dp[1][ret][tl]; tx &gt;&gt;= 1; tl++; &#125; ans = x + h; if (ret &gt;= n) return ans; while (ret &lt; n) &#123; for (int i = 1; i &lt; 17; i++) &#123; if (dp[0][ret][i] == dp[0][ret][i + 1]) &#123; ans += b[i - 1]; ret += dp[0][ret][i - 1]; break; &#125; &#125; &#125; return ans;&#125;int main(void) &#123; // freopen("in.txt", "r", stdin); // freopen("out.txt", "w", stdout); b[0] = 1; for (int i = 1; i &lt; 20; i++) b[i] = b[i - 1] &lt;&lt; 1; int t, q, x, h; scanf("%d", &amp;t); while (t--) &#123; memset(dp, 0, sizeof(dp)); scanf("%d%d%d%d", &amp;n, &amp;w, &amp;pw, &amp;dw); for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;l[i]); l[i]++; &#125; init(); scanf("%d", &amp;q); for (int i = 0; i &lt; q; i++) &#123; scanf("%d%d", &amp;x, &amp;h); printf("%d\n", query(x - 1, h)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>å€å¢žæ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6103-Kirinriki]]></title>
    <url>%2F2017%2F08%2F14%2FHDU6103-Kirinriki%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® Problem Description We define the distance of two strings A and B with same length n is \(dis(A,B)=\sum_{i=0}^{(nâˆ’1)}{|A_iâˆ’B_{nâˆ’1âˆ’i}|}\) The difference between the two characters is defined as the difference in ASCII. You should find the maximum length of two non-overlapping substrings in given string S, and the distance between them are less then or equal to m. Input The first line of the input gives the number of test cases T; T test cases follow. Each case begins with one line with one integers m : the limit distance of substring. Then a string S follow. Limits Tâ‰¤100 0â‰¤mâ‰¤5000 Each character in the string is lowercase letter, 2â‰¤|S|â‰¤5000 âˆ‘|S|â‰¤20000 Output For each test case output one interge denotes the answer : the maximum length of the substring. Sample Input 12315abcdefedcb Sample Output 123455Hint[0, 4] abcde[5, 9] fedcbThe distance between them is abs(&apos;a&apos; - &apos;b&apos;) + abs(&apos;b&apos; - &apos;c&apos;) + abs(&apos;c&apos; - &apos;d&apos;) + abs(&apos;d&apos; - &apos;e&apos;) + abs(&apos;e&apos; - &apos;f&apos;) = 5 åˆ†æž å®¹æ˜“å¾—åˆ°å–å‡ºçš„å­—ä¸²æ˜¯ä¸€ä¸ªå›žæ–‡ä¸²ï¼Œå½“å›žæ–‡ä¸²çš„å¯¹ç§°è½´å›ºå®šçš„æ—¶å€™ï¼Œè®¡ç®—å‡ºæœ‰å¤šå°‘æ»¡è¶³æ¡ä»¶çš„å›žæ–‡ä¸²çš„æ—¶é—´å¤æ‚åº¦æ˜¯O(n)çš„ï¼šåªè¦ç»´æŠ¤å››ä¸ªæŒ‡é’ˆï¼Œå·¦å³å„ä¸¤ä¸ªï¼ŒæŒ‡é’ˆåªä¼šå¾€å¤–ç§»åŠ¨ï¼Œè‹¥æ»¡è¶³æ¡ä»¶ï¼Œåˆ™å¤–æŒ‡é’ˆå¾€å¤–ç§»åŠ¨ï¼Œå¦åˆ™å†…è„‚é’ˆå‘å¤–ç§»åŠ¨ä¸€ç›´åˆ°æ»¡è¶³æ¡ä»¶ä¸ºæ­¢ï¼Œé‚£ä¹ˆæ€»çš„æ—¶é—´å¤æ‚çš„æ˜¯\(O(n^2)\)çš„ã€‚ ä»£ç  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** @Author: sun000* @Date: 2017-08-11 11:24:20* @Last Modified by: sun000 * @Last Modified time: 2017-08-11 11:41:25*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;char str[5010];int dis(char a, char b) &#123; int d = a - b; if(d &lt; 0) d = -d; return d;&#125;int main(void) &#123; int t, m; scanf("%d", &amp;t); while(t--) &#123; scanf("%d", &amp;m); scanf("%s", str); int len = strlen(str); int ls, le, rs, re; int ans = 0; for(int mid = 0; mid &lt; len; mid++) &#123; ls = le = mid, rs = re = mid + 1; int d = 0; for(;le &gt;= 0 &amp;&amp; re &lt; len; le--, re++) &#123; d += dis(str[le], str[re]); while(d &gt; m) &#123; d -= dis(str[ls], str[rs]); ls--; rs++; &#125; ans = max(ans, re - rs + 1); &#125; ls = le = mid - 1, rs = re = mid + 1; d = 0; for(;le &gt;= 0 &amp;&amp; re &lt; len; le--, re++) &#123; d += dis(str[le], str[re]); while(d &gt; m) &#123; d -= dis(str[ls], str[rs]); ls--; rs++; &#125; ans = max(ans, re - rs + 1); &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>æš´åŠ›</tag>
        <tag>å­—ç¬¦ä¸²</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6053-TrickGCD]]></title>
    <url>%2F2017%2F08%2F14%2FHDU6053-TrickGCD%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® Problem Description You are given an array A , and Zhu wants to know there are how many different array B satisfy the following conditions? 1â‰¤Biâ‰¤Ai For each pair( l , r ) (1â‰¤lâ‰¤râ‰¤n) , gcd(bl,bl+1...br)â‰¥2 Input The first line is an integer T(1â‰¤Tâ‰¤10) describe the number of test cases. Each test case begins with an integer number n describe the size of array A. Then a line contains n numbers describe each element of A You can assume that 1â‰¤n,Aiâ‰¤105 Output For the kth test case , first output &quot;Case #k: &quot; , then output an integer as answer in a single line . because the answer may be large , so you are only need to output answer mod 109+7 Sample Input 123144 4 4 4 Sample Output 1Case #1: 17 åˆ†æž æžšä¸¾gcdç„¶åŽç”¨èŽ«æ¯”ä¹Œæ–¯åæ¼”æ¥è®¡ç®—ã€‚ è®¾: â€‹ f(d): gcdæ˜¯dæ—¶çš„æ–¹æ¡ˆæ•°é‡ â€‹ F(n): gcdæ˜¯nçš„å€æ•°çš„æ–¹æ¡ˆæ•°é‡ åˆ™ \[F(n)=\sum_{d|n}f(d) \\f(n)=\sum_{d|n}\mu(d)F(\frac{n}{d})\\f(n)=\sum_{d|n}\mu(\frac{n}{d})F(n)\] é‚£ä¹ˆé—®é¢˜å°±å˜æˆäº†å¦‚ä½•å¿«é€Ÿçš„æ±‚å‡ºF(n) â€‹ \[F(n) = \sum_{i=1}^{n}{Ai/n}\] å®¹æ˜“çœ‹å‡ºè¿™æ ·è®¡ç®—Fçš„å¤æ‚åº¦æ˜¯\(O(n^2)\)çš„ï¼Œè¿™éœ€è¦ä¼˜åŒ–ã€‚ æˆ‘ä»¬ç”¨ä¸€ä¸ªpreæ ‡è®°ï¼Œå¦‚æžœæœ‰ä¸€ä¸ªæ•°tmpåˆ™pre[tmp]++,æœ€åŽå¤„ç†æˆå‰ç¼€å’Œçš„å½¢å¼pre[i] += pre[i - 1]ã€‚ é‚£ä¹ˆpre[i]å°±è¡¨ç¤ºiåŠå…¶ä¹‹å‰å‡ºçŽ°äº†å‡ ä¸ªæ•°å­—ã€‚é‚£ä¹ˆæˆ‘ä»¬æžšä¸¾F(n)é‡Œgcdæ˜¯nçš„å€æ•°çš„è¿™ä¸ªâ€œå€æ•°kâ€åˆ™\(F(n)=\sum{k^{pre[(k+1)*n-1]-pre[k*n-1]}}â€‹\) ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** @Author: sun000* @Date: 2017-08-07 16:13:26* @Last Modified by: sun000* @Last Modified time: 2017-08-07 17:09:34*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 2e5 + 10;const int INF = 0x3f3f3f3f;const long long int MOD = 1e9 + 7;int U[MAXN];void mobus()&#123; bool mark[MAXN]; int prime[MAXN]; int pcnt = 0; memset(mark, 0, sizeof(mark)); U[1] = 1; for (int i = 2; i &lt; MAXN; i++) &#123; if (mark[i] == 0) &#123; prime[pcnt++] = i; U[i] = -1; &#125; for (int j = 0; j &lt; pcnt &amp;&amp; i * prime[j] &lt; MAXN; j++) &#123; int tmp = i * prime[j]; mark[tmp] = 1; if (i % prime[j] == 0) &#123; U[tmp] = 0; break; &#125; U[tmp] = -U[i]; &#125; &#125;&#125;long long int pre[MAXN], F[MAXN];long long int q_pow(long long int a, int b) &#123; long long int ans = 1, temp = a; while (b) &#123; if (b &amp; 1) ans = ans * temp % MOD; temp = temp * temp % MOD; b &gt;&gt;= 1; &#125; return ans;&#125;int main(void) &#123; //freopen("in.txt", "r", stdin); //freopen("out.txt", "w", stdout); int t, n, temp; mobus(); scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; cas++) &#123; memset(pre, 0, sizeof(pre)); scanf("%d", &amp;n); int mi = INF, ma = -INF; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;temp); mi = min(mi, temp); ma = max(ma, temp); pre[temp]++; &#125; for (int i = 1; i &lt; MAXN; i++) pre[i] += pre[i - 1]; for (int d = 1; d &lt;= mi; d++) &#123; F[d] = 1; for (int k = 1; k &lt;= ma / d; k++) F[d] = (F[d] * q_pow((long long int)k, pre[(k + 1) * d - 1] - pre[k * d - 1])) % MOD; &#125; long long int ans = 0; for(int d = 2; d &lt;= mi; d++) for(int num = 1; num * d &lt;= ma; num++) ans = (ans + (long long int)U[num] * F[d * num] % MOD) % MOD; printf("Case #%d: %lld\n", cas, ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>æ•°å­¦</tag>
        <tag>èŽ«æ¯”ä¹Œæ–¯åæ¼”</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6050 Funny Function]]></title>
    <url>%2F2017%2F08%2F08%2FHDU6050-Funny-Function%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® Problem Description Function Fx,ysatisfies: For given integers N and M,calculate Fm,1 modulo 1e9+7. Input There is one integer T in the first line. The next T lines,each line includes two integers N and M . 1&lt;=T&lt;=10000,1&lt;=N,M&lt;2^63. Output For each given N and M,print the answer in a single line. Sample Input 12322 23 3 Sample Output 12233 åˆ†æž è¿™æ˜¯ä¸€ä¸ªæ•°å­¦æŽ¨å¯¼é¢˜ï¼Œé¦–å…ˆä¸éš¾å‘çŽ°å¯¹äºŽæ¯ä¸€ä¸ªiéƒ½æœ‰\(F_{i,j}=F_{i,j-1}+2*F_{i,j-2}\)åˆ™\(F_{i,j}+F_{i,j-1}=2*(F_{i,j-1}+F_{i,j-2})\)å³ \[ F_{i,j}+F_{i,j-1}=4*(F_{i,j-2}+F_{i,j-3}) \] åˆ™å¯¹äºŽæ¯ä¸€è¡Œï¼Œæ¯ä¸¤ä¸ªè¿žç»­çš„ä¸¤é¡¹çœ‹æˆä¸€é¡¹ï¼Œé‚£ä¹ˆçŽ°åœ¨å¯¹äºŽnæˆ‘ä»¬åˆ†å¥‡å¶æ¥è€ƒè™‘ï¼Œé¦–å…ˆè€ƒè™‘ å½“nä¸ºå¶æ•°æ—¶ \[F_{i,1}=\sum_{k=1}^{n}{F_{i-1,k}} = F_{i-1,1}+F_{i-1,2}+â€¦â€¦F_{i-1,n-1}+F_{i-1,n}\] \[=\left(F_{i-1,1}+F_{i-1,2}\right)+4*\left(F_{i-1,1}+F_{i-1,2}\right)â€¦â€¦+4^{\frac{n}{2}-1}*\left(F_{i-1,1}+F_{i-1,2}\right)\] â€‹ \[=\frac{2^n- 1}{3}*F_{i-1,1}+\frac{2^n- 1}{3}*F_{i-1,2}\] â€‹ \[F_{i,2}=\sum_{k=2}^{n+1}{F_{i-1,k}}=F_{i-1,2}+F_{i-1,3}+â€¦â€¦F_{i-1,n}+F_{i-1,n+1}\] â€‹ \[=\left(F_{i-1,2}+F_{i-1,3}\right)+4*\left(F_{i-1,2}+F_{i-1,3}\right)â€¦â€¦+4^{\frac{n}{2}-1}*\left(F_{i-1,2}+F_{i-1,3}\right)\] â€‹ \[=\frac{2^n-1}{3}*\left(F_{i-1,2}+F_{i-1,3}\right)=\frac{2*\left(2^n-1\right)}{3}*F_{i-1,1}+\frac{2*\left(2^n-1\right)}{3}*F_{i-1,2}\] å½“nä¸ºå¥‡æ•°æ—¶ \[F_{i,1}=\sum_{k=1}^{n}{F_{i-1,k}} = F_{i-1,1}+F_{i-1,2}+â€¦â€¦F_{i-1,n-1}+F_{i-1,n}\] â€‹ \[=F_{i-1,1}+\left(F_{i-1,2}+F_{i-1,3}\right)+4*\left(F_{i-1,2}+F_{i-1,3}\right)â€¦â€¦+4^{\frac{n-1}{2}-1}*\left(F_{i-1,2}+F_{i-1,3}\right)\] â€‹ \[=F_{i-1,1}+\left(F_{i-1,2}+F_{i-1,3}\right)\frac{2^{n-1}-1}{3}=F_{i-1,1}+\left(F_{i-1,1}+F_{i-1,2}\right)\frac{2^n-2}{3}\] â€‹ \[=\frac{2^n+1}{3}*F_{i-1,1}+\frac{2^n-2}{3}*F_{i-1,2}\] â€‹ \[F_{i,2}=\sum_{k=2}^{n+1}{F_{i-1,k}}=F_{i-1,2}+F_{i-1,3}+â€¦â€¦F_{i-1,n}+F_{i-1,n+1}\] â€‹ \[=F_{i-1,2}+\left(F_{i-1,3}+F_{i-1,4}\right)+4*\left(F_{i-1,3}+F_{i-1,4}\right)â€¦â€¦+4^{\frac{n-1}{2}-1}*\left(F_{i-1,3}+F_{i-1,4}\right)\] â€‹ \[=F_{i-1,2}+\left(F_{i-1,3}+F_{i-1,4}\right)\frac{2^{n-1}-1}{3}=F_{i-1,2}+\left(F_{i-1,1}+F_{i-1,2}\right)\frac{2^{n+1}-4}{3}\] â€‹ \[=\frac{2^{n+1}-4}{3}*F_{i-1,1}+\frac{2^{n+1}-1}{3}*F_{i-1,2}\] è¿™æ ·å°±å¯ä»¥ç”¨çŸ©é˜µå¿«é€Ÿå¹‚åœ¨o(log(n))çš„æ—¶é—´å¤æ‚åº¦ä¸‹æ±‚è§£äº†ã€‚ ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** @Author: sun000* @Date: 2017-08-07 12:38:12* @Last Modified by: sun000 * @Last Modified time: 2017-08-07 13:41:28*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const long long int mod = 1e9 + 7;const long long int inv3 = 333333336;//é™¤3å–æ¨¡è¦æ±‚é€†å…ƒstruct MAT&#123; int r, c; long long int mx[2][2]; MAT()&#123;&#125; MAT(int rr = 0, int cc = 0):r(rr),c(cc)&#123;&#125; friend MAT operator *(MAT ta, MAT tb)&#123; MAT tc(ta.r, tb.c); for(int i = 0; i &lt; tc.r; i++) for(int j = 0; j &lt; tc.c; j++)&#123; tc.mx[i][j] = 0; for(int k = 0; k &lt; tb.r; k++) tc.mx[i][j] = (tc.mx[i][j] + ta.mx[i][k] * tb.mx[k][j] % mod) % mod; &#125; return tc; &#125; friend MAT operator ^(MAT ta, long long int num)&#123; MAT ret(ta.r, ta.c); memset(ret.mx, 0, sizeof(ret.mx)); for(int i = 0; i &lt; ta.r; i++) ret.mx[i][i] = 1; while(num)&#123; if(num &amp; 1) ret = ta * ret; num &gt;&gt;= 1; ta = ta * ta; &#125; return ret; &#125;&#125;;long long int q_pow(long long int a, long long int b) &#123; long long int ans = 1, temp = a; while(b) &#123; if(b &amp; 1) ans = (ans * temp) % mod; temp = (temp * temp) % mod; b &gt;&gt;= 1; &#125; return ans;&#125;MAT getMAT(long long int n) &#123; if(n == 1) return 1; MAT m(2, 2); if(n &amp; 1) &#123; m.mx[0][0] = (q_pow(2, n) + 1) * inv3 % mod; m.mx[0][1] = (((q_pow(2, n + 1) - 4 ) * inv3 % mod) + mod) % mod; m.mx[1][0] = (((q_pow(2, n) - 2) * inv3 % mod) + mod) % mod; m.mx[1][1] = (((q_pow(2, n + 1) - 1) * inv3 % mod) + mod) % mod; &#125;else &#123; m.mx[0][0] = m.mx[1][0] = ((q_pow(2, n) - 1) * inv3 % mod + mod) % mod; m.mx[0][1] = m.mx[1][1] = (((q_pow(2, n) - 1) * 2 % mod) * inv3 % mod + mod) % mod; &#125; //printf("-----\n%lld %lld\n%lld %lld\n-----\n", m.mx[0][0], m.mx[0][1], m.mx[1][0], m.mx[1][1]); //getchar(); return m;&#125;long long int solve(long long int n, long long int m) &#123; MAT s(2, 2); MAT g(2, 2); g = getMAT(n); s.mx[0][0] = s.mx[0][1] = 1; s.mx[1][0] = s.mx[1][1] = 0; MAT ans = s * (g ^ (m - 1)); return ans.mx[0][0];&#125;int main(void) &#123; // freopen("in.txt", "r", stdin); // freopen("out.txt", "w", stdout); int t; long long int n, m; scanf("%d", &amp;t); while(t--) &#123; scanf("%lld%lld", &amp;n, &amp;m); printf("%lld\n", solve(n, m)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>æ•°å­¦</tag>
        <tag>çŸ©é˜µå¿«é€Ÿå¹‚</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6044 Limited Permutation]]></title>
    <url>%2F2017%2F07%2F26%2FHDU6044-Limited-Permutation%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® Problem Description As to a permutation p1,p2,â‹¯,pn from 1 to n, it is uncomplicated for each 1â‰¤iâ‰¤n to calculate (li,ri) meeting the condition that min(pL,pL+1,â‹¯,pR)=pi if and only if liâ‰¤Lâ‰¤iâ‰¤Râ‰¤ri for each 1â‰¤Lâ‰¤Râ‰¤n. Given the positive integers n, (li,ri) (1â‰¤iâ‰¤n), you are asked to calculate the number of possible permutations p1,p2,â‹¯,pn from 1 to n, meeting the above condition. The answer may be very large, so you only need to give the value of answer modulo 109+7. Input The input contains multiple test cases. For each test case: The first line contains one positive integer n, satisfying 1â‰¤nâ‰¤106. The second line contains n positive integers l1,l2,â‹¯,ln, satisfying 1â‰¤liâ‰¤i for each 1â‰¤iâ‰¤n. The third line contains n positive integers r1,r2,â‹¯,rn, satisfying iâ‰¤riâ‰¤n for each 1â‰¤iâ‰¤n. It's guaranteed that the sum of n in all test cases is not larger than 3â‹…106. Warm Tips for C/C++: input data is so large (about 38 MiB) that we recommend to use fread() for buffering friendly. 1size_t fread(void *buffer, size_t size, size_t count, FILE *stream); // reads an array of count elements, each one with a size of size bytes, from the stream and stores them in the block of memory specified by buffer; the total number of elements successfully read is returned. Output For each test case, output &quot;Case #x: y&quot; in one line (without quotes), where x indicates the case number starting from 1 and y denotes the answer of corresponding case. Sample Input 3 1 1 3 1 3 3 5 1 2 2 4 5 5 2 5 5 5 Sample Output Case #1: 2 Case #2: 3 åˆ†æž æ³¨æ„åˆ°é¢˜ç›®ä¸­ï¼šæœ‰nä¸ªåŒºé—´ï¼Œå¯¹äºŽç¬¬iä¸ªåŒºé—´[li,ri]æœ‰li&lt;=i&lt;=ri,å¯¹äºŽä»»æ„1&lt;=L&lt;=i&lt;=R&lt;=nï¼Œå½“å‰ä»…å½“li&lt;=L&lt;=i&lt;=R&lt;=riæ—¶P[i]=min(P[L],P[L+1],...,P[R])ï¼Œå³å¯¹äºŽP[i]ä¸€å®šæœ‰P[i]&gt;P[li-1]ä¸”P[i]&gt;P[ri+1]ï¼Œä¹Ÿå°±æ˜¯è¯´åŒºé—´\([l_i,r_i]\)(é™¤äº†[1,n])ä¸€å®šè¢«æŸä¸ªåŒºé—´[lj,rj]åŒ…å«,ä¸”j=li-1æˆ–j=ri+1 å³åŒºé—´jå¯åˆ†æˆ[lj,j-1]å’Œ[j+1,rj]ã€‚ æ³¨æ„åˆ°ä¸€ä¸ªéžå¸¸å·§å¦™çš„ç‚¹ï¼šæˆ‘ä»¬å°†åŒºé—´æŒ‰ç…§Lå‡åºï¼ŒRé™åºçš„é¡ºåºæŽ’åºï¼šå¾—åˆ°çš„è¿™ä¸ªåºåˆ—æ°å¥½å°±æ˜¯è¿™å¯ç¬›å¡å°”æ ‘çš„å…ˆè·ŸDFSåº åˆ™æˆ‘ä»¬dfså¾€ä¸‹èµ°ï¼Œæ¯ä¸€ä¸ªåŒºé—´å’Œç»™å®šçš„åŒºé—´æ°å¥½æ˜¯ä¸€ä¸€å¯¹åº”çš„ï¼Œå¦åˆ™æž„ä¸æˆç¬›å¡å°”æ ‘ï¼Œåˆ™æ— ç­”æ¡ˆã€‚ è‹¥å­˜åœ¨ä¸€æ£µç¬›å¡å°”æ ‘ï¼ˆä¸èƒ½çœŸçš„åŽ»å»ºæ ‘ï¼Œä¼šçˆ†å†…å­˜ï¼Œggï¼‰ï¼Œåˆ™è¿™æ£µç¬›å¡å°”æ ‘æ˜¯å”¯ä¸€çš„ã€‚æ¯æ£µå­æ ‘éƒ½åŸºäºŽç›¸ä¼¼çš„å­é—®é¢˜ï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦åœ¨åˆå¹¶å­æ ‘æ—¶è®¡ç®—å­æ ‘çš„ç»„åˆå³å¯ã€‚ä¾‹å¦‚ u æœ‰ä¸¤ä¸ªå„¿å­ v1 å’Œ v2 ï¼Œå®ƒä»¬çš„å­æ ‘å¯¹åº”çš„æ–¹æ¡ˆæ•°åˆ†åˆ«ä¸º f(v1) å’Œ f(v2) ï¼Œå­æ ‘å¤§å°åˆ†åˆ«ä¸º s(v1) å’Œ s(v2) ï¼Œåˆ™ u çš„å­æ ‘å¯¹åº”çš„æ–¹æ¡ˆæ•°ä¸º \(f(u)=C(s(v1)+s(v2), s(v1))*f(v1)*f(v2)\) C(a, b)æ˜¯æ±‚ç»„åˆæ•°çš„æ„æ€ï¼Œè¦å–æ¨¡ï¼Œæ‰€ä»¥è¦æ±‚é€†å…ƒã€‚ ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/** @Author: sun000* @Date: 2017-07-26 20:13:20* @Last Modified by: sun000* @Last Modified time: 2017-07-26 21:58:52*/#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e6 + 10;const long long int MOD = 1e9 + 7;namespace fastIO &#123; const int MAXN = 4e7; char buf[MAXN]; int p, len;//æŒ‡å‘å½“å‰è¯»åˆ°çš„ä½å­çš„æŒ‡é’ˆ void begin() &#123; p = 0; len = fread(buf, 1, MAXN, stdin); &#125; inline bool isNum(char c) &#123; if('0' &lt;= c &amp;&amp; c &lt;= '9') return true; return false; &#125; inline bool read(int &amp;t) &#123; t = 0; while(p &lt; len &amp;&amp; !isNum(buf[p])) p++; if(p &gt;= len) return false; while(isNum(buf[p])) t = t * 10 + buf[p++] -'0'; return true; &#125;&#125;int n;struct node &#123; int l, r, id; node *lson, *rson; node()&#123;&#125; node(int _l, int _r):l(_l),r(_r)&#123; lson = rson = NULL; &#125;&#125;s[MAXN], *root;bool cmp(const node &amp;a,const node &amp;b) &#123; if(a.l == b.l) return a.r &gt; b.r; return a.l &lt; b.l;&#125;int inv[MAXN];void init()&#123; inv[1] = 1; for (int i = 2; i &lt; MAXN; i++) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;&#125;long long int C(int a, int b) &#123; // printf("c(%d %d)\n", a, b); b = min(b, a - b); if(!b) return 1; long long int temp = 1; long long int B = (long long int)b; long long int A = (long long int)a; for(long long int i = 0; i &lt; B; i++) temp = (temp * (A - i) % MOD * (long long int)inv[i + 1]) % MOD; return temp;&#125;bool flag;int cnt;long long int dfs(int l, int r) &#123; if(!flag) return 0; if(l &gt; r) return 1; if(s[cnt].l == l &amp;&amp; s[cnt].r == r) &#123; node now = s[cnt++]; long long int temp = (C(now.r - now.l, now.id - now.l) * dfs(now.l, now.id - 1) % MOD) * dfs(now.id + 1, now.r) % MOD; if(temp == 0) flag = false; return temp; &#125; else &#123; flag = false; return 0; &#125;&#125;long long int solve() &#123; flag = true; cnt = 0; sort(s, s + n, cmp); return dfs(1, n);&#125;int main(void) &#123; init(); fastIO::begin(); int cas = 1; while(fastIO::read(n)) &#123; for(int i = 0; i &lt; n; i++) fastIO::read(s[i].l), s[i].id = i + 1; for(int i = 0; i &lt; n; i++) fastIO::read(s[i].r); printf("Case #%d: %lld\n", cas++, solve()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>æ•°å­¦</tag>
        <tag>å›¾è®º</tag>
        <tag>æœç´¢</tag>
        <tag>å¤šæ ¡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6040 Hints of sd0061]]></title>
    <url>%2F2017%2F07%2F26%2FHDU6040-Hints-of-sd0061%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® Problem Description sd0061, the legend of Beihang University ACM-ICPC Team, retired last year leaving a group of noobs. Noobs have no idea how to deal with m coming contests. sd0061 has left a set of hints for them. There are n noobs in the team, the i-th of which has a rating ai. sd0061 prepares one hint for each contest. The hint for the j-th contest is a number bj, which means that the noob with the (bj+1)-th lowest rating is ordained by sd0061 for the j-th contest. The coach asks constroy to make a list of contestants. constroy looks into these hints and finds out: bi+bjâ‰¤bk is satisfied if biâ‰ bj, bi]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>æ•°å­¦</tag>
        <tag>å¤šæ ¡</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6035 Colorful Tree]]></title>
    <url>%2F2017%2F07%2F26%2FHDU6035-Colorful-Tree%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® Problem Description There is a tree with n nodes, each of which has a type of color represented by an integer, where the color of node i is ci. The path between each two different nodes is unique, of which we define the value as the number of different colors appearing in it. Calculate the sum of values of all paths on the tree that has n(nâˆ’1)2 paths in total. Input The input contains multiple test cases. For each test case, the first line contains one positive integers n, indicating the number of node. (2â‰¤nâ‰¤200000) Next line contains n integers where the i-th integer represents ci, the color of node i. (1â‰¤ciâ‰¤n) Each of the next nâˆ’1 lines contains two positive integers x,y (1â‰¤x,yâ‰¤n,xâ‰ y), meaning an edge between node x and node y. It is guaranteed that these edges form a tree. Output For each test case, output &quot;Case #x: y&quot; in one line (without quotes), where x indicates the case number starting from 1 and y denotes the answer of corresponding case. Sample Input 3 1 2 1 1 2 2 3 6 1 2 1 3 2 1 1 2 1 3 2 4 2 5 3 6 Sample Output Case #1: 6 Case #2: 29 åˆ†æž â€‹ å•ç‹¬è€ƒè™‘æ¯ä¸€ç§é¢œè‰²ï¼Œç­”æ¡ˆå°±æ˜¯å¯¹äºŽæ¯ç§é¢œè‰²è‡³å°‘ç»è¿‡ä¸€æ¬¡è¿™ç§çš„è·¯å¾„æ¡æ•°ä¹‹å’Œã€‚åè¿‡æ¥æ€è€ƒåªéœ€è¦æ±‚æœ‰å¤šå°‘æ¡è·¯å¾„æ²¡æœ‰ç»è¿‡è¿™ç§é¢œè‰²å³å¯ã€‚ç›´æŽ¥åšå¯ä»¥é‡‡ç”¨è™šæ ‘çš„æ€æƒ³ï¼ˆä¸ç”¨çœŸæ­£å»ºå‡ºæ¥ï¼‰ï¼Œå¯¹æ¯ç§é¢œè‰²çš„ç‚¹æŒ‰ç…§ dfs åºåˆ—æŽ’ä¸ªåºï¼Œå°±èƒ½æ±‚å‡ºè¿™äº›ç‚¹æŠŠåŽŸæ¥çš„æ ‘åˆ’åˆ†æˆçš„å—çš„å¤§å°ã€‚è¿™ä¸ªè¿‡ç¨‹å®žé™…ä¸Šå¯ä»¥ç›´æŽ¥ä¸€æ¬¡ dfs æ±‚å‡ºã€‚ è¿™äº›éƒ½æ˜¯å®˜æ–¹é¢˜è§£ï¼Œå…¶å®žæˆ‘å°±æ˜¯DFSçžŽè®°å½•äº†ä¸€äº›å€¼æžäº†é«˜å°±å¥½äº†ï¼Œçœ‹ä»£ç å°±èƒ½çœ‹æ‡‚ï¼Œéƒ½æœ‰æ³¨é‡Šã€‚å’Œå®˜æ–¹é¢˜è§£ä¸€æ ·è½¬åŒ–ï¼Œæ±‚åé¢çš„è·¯å¾„æ•°é‡ï¼Œæ±‚æ³•å¦‚ä»£ç DFSã€‚ ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** @Author: sun000* @Date: 2017-07-25 10:27:08* @Last Modified by: sun000* @Last Modified time: 2017-07-25 11:16:17*/#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 2e5 + 10;vector&lt;int&gt; g[MAXN];int del[MAXN];//è®°å½•å½“å‰æ¯ä¸ªé¢œè‰²å·²ç»åˆ†å‡ºæ¥çš„å—çš„å¤§å°bool vis[MAXN];int col[MAXN], n;long long int ans;//è®°å½•çš„æ˜¯åé¢ï¼Œä¸ç»è¿‡æŸä¸ªé¢œè‰²çš„è·¯å¾„æ•°é‡int cnt; //æ—¶é—´æˆ³void addEdge(int u, int v) &#123; g[u].push_back(v);&#125;long long int cal(long long int k) &#123; if(k == 0) return 0; return k * (k - 1) / 2;&#125;void dfs(int u) &#123; cnt++; int v, now = cnt; int pre = del[col[u]];//ä¸åœ¨è¿™æ¡è·¯çš„å­æ ‘é‡Œçš„å·²ç»åˆ†å‡ºæ¥å— for(int i = 0; i &lt; g[u].size(); i++) &#123; v = g[u][i]; if(!vis[v]) &#123; vis[v] = true;; dfs(v); int temp = cnt - now - (del[col[u]] - pre); //é‡æ–°å›žåˆ°uçš„vå­æ ‘çš„å¤§å°-ï¼ˆvå­æ ‘é‡Œ+ä¹‹å‰åˆ†å‡ºçš„å—çš„æ€»å’Œï¼‰+ä¸æ˜¯vå­æ ‘çš„å—çš„æ•°é‡ ans += cal(temp); del[col[u]] += temp; &#125; &#125; del[col[u]]++;//åŠ ä¸Šué¢œè‰²æœ¬èº«&#125;int main(void) &#123; int cas = 1; while(scanf("%d", &amp;n) != EOF) &#123; ans = 0, cnt = 0; memset(vis, false, sizeof(vis)); memset(del, 0, sizeof(del)); for(int i = 1; i &lt;= n; i++) &#123; g[i].clear(); scanf("%d", &amp;col[i]); &#125; int u, v; for(int i = 0; i &lt; n - 1; i++) &#123; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); &#125; vis[1] = true; dfs(1); long long int tot = 0; memset(vis, false, sizeof(vis)); for(int i = 1; i &lt;= n; i++) &#123;//æœ€åŽè®¡ç®—æ ¹èŠ‚ç‚¹æ‰€åœ¨çš„å„ç§é¢œè‰²çš„åˆ†å—æ•°é‡ if(!vis[col[i]]) &#123; tot += cal(n); ans += cal(n - del[col[i]]); vis[col[i]] = true; &#125; &#125; printf("Case #%d: %lld\n", cas++, tot - ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>å›¾è®º</tag>
        <tag>DFS</tag>
        <tag>å¤šæ ¡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces832D. Misha, Grisha-and-Underground]]></title>
    <url>%2F2017%2F07%2F24%2FCodeForces832D-Misha-Grisha-and-Underground%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® Misha and Grisha are funny boys, so they like to use new underground. The underground has n stations connected with n - 1 routes so that each route connects two stations, and it is possible to reach every station from any other. The boys decided to have fun and came up with a plan. Namely, in some day in the morning Misha will ride the underground from station s to station f by the shortest path, and will draw with aerosol an ugly text &quot;Misha was here&quot; on every station he will pass through (including s and f). After that on the same day at evening Grisha will ride from station t to station f by the shortest path and will count stations with Misha's text. After that at night the underground workers will wash the texts out, because the underground should be clean. The boys have already chosen three stations a, b and c for each of several following days, one of them should be station s on that day, another should be station f, and the remaining should be station t. They became interested how they should choose these stations s, f, tso that the number Grisha will count is as large as possible. They asked you for help. Input The first line contains two integers n and q (2 â‰¤ n â‰¤ 105, 1 â‰¤ q â‰¤ 105) â€” the number of stations and the number of days. The second line contains n - 1 integers p2, p3, ..., *p**n* (1 â‰¤ pi â‰¤ n). The integer pi means that there is a route between stations *p**i* and i. It is guaranteed that it's possible to reach every station from any other. The next q lines contains three integers a, b and c each (1 â‰¤ a, b, c â‰¤ n) â€” the ids of stations chosen by boys for some day. Note that some of these ids could be same. Output Print q lines. In the i-th of these lines print the maximum possible number Grisha can get counting when the stations s, t and f are chosen optimally from the three stations on the i-th day. Examples input 3 2 1 1 1 2 3 2 3 3 output 2 3 input 4 1 1 2 3 1 2 3 output 2 Note In the first example on the first day if s = 1, f = 2, t = 3, Misha would go on the route 1 -&gt; 2, and Grisha would go on the route 3 -&gt; 1 -&gt;2. He would see the text at the stations 1 and 2. On the second day, if s = 3, f = 2, t = 3, both boys would go on the route 3 -&gt; 1 -&gt; 2. Grisha would see the text at 3 stations. In the second examle if s = 1, f = 3, t = 2, Misha would go on the route 1 -&gt; 2 -&gt; 3, and Grisha would go on the route 2 -&gt; 3 and would see the text at both stations. åˆ†æž æžšä¸¾fæ˜¯å“ªä¸€ä¸ªç‚¹ï¼Œ æ±‚å‡ºs-&gt;f, t-&gt;f,s-&gt;tçš„é•¿åº¦ï¼Œ\(l_0,l_1,l_2\)åˆ™\(ans = (l_0 + l_1 - l_2) / 2 + 1\) ç®€å•è¯æ˜Žï¼š å¦‚å›¾s-få’Œt-fçš„è·¯å¾„ä¸Šçš„å…¬å…±é•¿åº¦æ˜¯$(l_0 + l_1 - l_2) / 2 $åŠ ä¸Šæœ¬èº«çš„ç‚¹å°±æ˜¯ansäº† IMG_2558 LCAå°±ç”¨åœ¨æ±‚è·¯å¾„ä¸Šï¼Œæ¯”å¦‚ï¼šè¦æ±‚aåˆ°bçš„è·¯å¾„é•¿åº¦ deep[a] +deep[b] - 2 * deep[ lca(a, b)] é™„ä¸Šå€å¢žæ³•LCAé“¾æŽ¥http://sun000.cn/2017/07/24/å€å¢žæ³•LCA/ ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int head[100010], cnt;int fa[100010][20];//èŠ‚ç‚¹içš„2^jä¸ªäººç¥–å…ˆæ˜¯ä»€ä¹ˆint deep[100010]; //deepä¿å­˜æ¯ä¸ªèŠ‚ç‚¹çš„æ·±åº¦ï¼ŒCNTä¸ºä¿å­˜å›¾çš„è™šæ‹ŸæŒ‡é’ˆint n, m, root; // rootä¸ºæ ¹èŠ‚ç‚¹ç¼–å·struct node &#123; int next, v;&#125; e[1000010];void add(int a, int b)&#123; e[cnt].v = b; e[cnt].next = head[a]; head[a] = cnt; cnt++;&#125;void dfs(int x) &#123;//è®¡ç®—æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„æ·±åº¦ for (int i = head[x]; i; i = e[i].next) &#123; int v = e[i].v; if (!deep[v]) &#123; deep[v] = deep[x] + 1; fa[v][0] = x; dfs(v); &#125; &#125;&#125;void init() &#123; memset(deep, 0, sizeof(deep)); deep[1] = 1; dfs(root); cnt = 1; for (int i = 1; i &lt; 20; i++) for (int j = 1; j &lt;= n; j++) fa[j][i] = fa[fa[j][i - 1]][i - 1];&#125;int lca(int x, int y) &#123; if (deep[x] &lt; deep[y]) swap(x, y); // å¦‚æžœæ·±åº¦ä¸åŒ è°ƒåˆ°åŒä¸€æ·±åº¦ for (int i = 19; i &gt;= 0; i--) &#123; if (deep[fa[x][i]] &gt;= deep[y]) x = fa[x][i]; &#125; if (x == y) return x; for (int i = 19; i &gt;= 0; i--) if (fa[x][i] != fa[y][i]) &#123;//åŒæ—¶å‘ä¸Šè·³ x = fa[x][i]; y = fa[y][i]; &#125; return fa[x][0];&#125;int getlen(int a, int b) &#123; int l = lca(a, b); return deep[a] +deep[b] - 2 * deep[l];&#125;int main()&#123; int q; scanf("%d%d", &amp;n, &amp;q); int temp; for (int i = 2; i &lt;= n; i++) &#123; scanf("%d", &amp;temp); add(i, temp); add(temp, i); &#125; root = 1; init(); for (int i = 0; i &lt; q; i++) &#123; int ans = -1; int x, y, z; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); int xy = getlen(x, y); int xz = getlen(x, z); int yz = getlen(y, z); ans = max(ans, xy + xz - yz); ans = max(ans, xy + yz - xz); ans = max(ans, yz + xz - xy); printf("%d\n", ans / 2 + 1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>å›¾è®º</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å€å¢žæ³•LCA]]></title>
    <url>%2F2017%2F07%2F24%2F%E5%80%8D%E5%A2%9E%E6%B3%95LCA%2F</url>
    <content type="text"><![CDATA[ç®€ä»‹ ä»Šå¤©å­¦ä¹ äº†ä¸€ä¸ªå€å¢žæ³•LCAå®žçŽ°èµ·æ¥å¾ˆæ–¹ä¾¿ï¼Œè€Œä¸”ç®—æ³•å¤æ‚åº¦\(log_2(d)\)å…¶ä¸­dæ˜¯æ ‘çš„æ·±åº¦ï¼Œå…¶å®žå†™æ³•ä¹Ÿå¾ˆç®€å•ï¼Œå°±æ˜¯ç”¨ä¸€ä¸ªï¼š fa[i][j]æ•°ç»„ç”¨æ¥è®°å½•iæ ‡å·çš„èŠ‚ç‚¹çš„ç¬¬\(2^j\)ä¸ªç¥–å…ˆ å¾ˆå®¹æ˜“å°±èƒ½å¾—åˆ°fa[i][j]çš„é€’æŽ¨å¼å­æ˜¯ï¼š fa[i][j] = fa[fa[i][j - 1]][j - 1] æ ¹æ®äºŒè¿›åˆ¶çš„åŽŸç†ï¼Œiå¯ä»¥é€šè¿‡äºŒè¿›åˆ¶å‘ä¸Šè·³åˆ°è¾¾ä»»ä½•ç¥–å…ˆã€‚ æŸ¥è¯¢è¿‡ç¨‹lca(u, v) uå’Œvæ‰€åœ¨çš„æ ‘çš„å±‚æ•°å¦‚æžœä¸€æ ·ï¼Œä»¤u'=uã€‚å¦åˆ™éœ€è¦å¹³è¡¡æ“ä½œï¼ˆå‡è®¾uæ›´æ·±ï¼‰ï¼Œå…ˆæ‰¾åˆ°uçš„ä¸€ä¸ªç¥–å…ˆu', ä½¿å¾—u'çš„å±‚æ•°å’Œvä¸€æ ·ï¼Œæ­¤æ—¶lca(u,v)=lca(u',v) ã€‚ è¯æ˜Žå¾ˆç®€å•ï¼šå¦‚æžœLCA(u,v)=v , é‚£ä¹ˆu'ä¸€å®šç­‰äºŽv ;å¦‚æžœLCA(u,v)=k ï¼Œk!=v ï¼Œé‚£ä¹ˆk çš„æ·±åº¦ä¸€å®šå°äºŽ v ï¼Œ uã€u'ã€v ä¸€å®šåœ¨kçš„å­æ ‘ä¸­ï¼›ç»¼ä¸Šæ‰€è¿°ï¼Œlca(u,v)=lca(u',v)ä¸€å®šæˆç«‹ã€‚ æ­¤æ—¶u' å’Œ v çš„ç¥–å…ˆåºåˆ—ä¸­ä¸€å¼€å§‹çš„éƒ¨åˆ†ä¸€å®šæœ‰æ‰€é‡å ï¼Œé‡å éƒ¨åˆ†çš„æœ€åŽä¸€ä¸ªå…ƒç´ ï¼ˆä¹Ÿå°±æ˜¯æ·±åº¦æœ€æ·±ï¼Œä¸Žu'ã€væœ€è¿‘çš„å…ƒç´ ï¼‰å°±æ˜¯æ‰€æ±‚çš„lca(u,v)ã€‚è¿™é‡Œfaæ•°ç»„å°±å¯ä»¥æ´¾ä¸Šç”¨åœºäº†ã€‚æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸é‡å çš„èŠ‚ç‚¹kï¼Œlca(u,v)=fa[k][0] ã€‚ æ‰¾kçš„è¿‡ç¨‹åˆ©ç”¨äºŒè¿›åˆ¶è´ªå¿ƒæ€æƒ³ï¼Œå…ˆå°½å¯èƒ½è·³åˆ°æœ€ä¸Šå±‚çš„ç¥–å…ˆï¼Œå¦‚æžœä¸¤ç¥–å…ˆç›¸ç­‰ï¼Œè¯´æ˜Žå®Œå…¨å¯ä»¥è·³å°ç‚¹ï¼Œè·³çš„è·ç¦»é™¤2ï¼Œè¿™æ ·ä¸€æ­¥æ­¥è·³ä¸‹åŽ»ä¸€å®šå¯ä»¥æ‰¾åˆ°kã€‚ æ¨¡ç‰ˆ â€‹ ä¾‹é¢˜ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int head[100010], cnt;int fa[100010][20];//èŠ‚ç‚¹içš„2^jä¸ªäººç¥–å…ˆæ˜¯ä»€ä¹ˆint deep[100010]; //deepä¿å­˜æ¯ä¸ªèŠ‚ç‚¹çš„æ·±åº¦ï¼ŒCNTä¸ºä¿å­˜å›¾çš„è™šæ‹ŸæŒ‡é’ˆint n, m, root; // rootä¸ºæ ¹èŠ‚ç‚¹ç¼–å·struct node &#123; int next, v;&#125; e[1000010];void add(int a, int b)&#123; e[cnt].v = b; e[cnt].next = head[a]; head[a] = cnt; cnt++;&#125;void dfs(int x) &#123;//è®¡ç®—æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„æ·±åº¦ for (int i = head[x]; i; i = e[i].next) &#123; int v = e[i].v; if (!deep[v]) &#123; deep[v] = deep[x] + 1; fa[v][0] = x; dfs(v); &#125; &#125;&#125;void init() &#123; memset(deep, 0, sizeof(deep)); deep[1] = 1; dfs(root); cnt = 1; for (int i = 1; i &lt; 20; i++) for (int j = 1; j &lt;= n; j++) fa[j][i] = fa[fa[j][i - 1]][i - 1];&#125;int lca(int x, int y) &#123; if (deep[x] &lt; deep[y]) swap(x, y); // å¦‚æžœæ·±åº¦ä¸åŒ è°ƒåˆ°åŒä¸€æ·±åº¦ for (int i = 19; i &gt;= 0; i--) &#123; if (deep[fa[x][i]] &gt;= deep[y]) x = fa[x][i]; &#125; if (x == y) return x; for (int i = 19; i &gt;= 0; i--) if (fa[x][i] != fa[y][i]) &#123;//åŒæ—¶å‘ä¸Šè·³ x = fa[x][i]; y = fa[y][i]; &#125; return fa[x][0];&#125;int getlen(int a, int b) &#123; int l = lca(a, b); return deep[a] +deep[b] - 2 * deep[l];&#125;int main()&#123; int q; scanf("%d%d", &amp;n, &amp;q); int temp; for (int i = 2; i &lt;= n; i++) &#123; scanf("%d", &amp;temp); add(i, temp); add(temp, i); &#125; root = 1; init(); for (int i = 0; i &lt; q; i++) &#123; int ans = -1; int x, y, z; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); int xy = getlen(x, y); int xz = getlen(x, z); int yz = getlen(y, z); ans = max(ans, xy + xz - yz); ans = max(ans, xy + yz - xz); ans = max(ans, yz + xz - xy); printf("%d\n", ans / 2 + 1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>å›¾è®º</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yet another card game]]></title>
    <url>%2F2017%2F07%2F23%2FYet-another-card-game%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® Petr and Snuke are playing a cooperative card game. The game is played with special cards: each card is labeled with some positive integer. The integers on cards are not necessarily distinct. At the beginning of the game Petr is holding some cards in his hand and Snuke is holding all the other cards in his hand. You are given int[]s petr and snuke that describe the state at the beginning of the game: the elements of petr are the numbers on Petr's cards and the elements of snuke are the numbers on Snuke's cards. During the game the players will place some of their cards onto a pile. Initially, the pile is empty. The players take alternating turns, Petr goes first. In each turn, if the current player has no cards in his hand, the game ends. Otherwise, the player must make exactly one valid move. There are three types of valid moves: If the pile is empty, the player may choose any card and place it onto the pile. If the pile is not empty, the player may choose any card and place it on top of the pile. However, this move is only valid if the number on the new card is strictly greater than the number on the card that was previously on the top of the pile. The player may always choose one of his cards and eat it. Petr and Snuke have a common goal: they want to create a pile with as many cards as possible. Return the size of the pile at the end of the game, assuming that they cooperate and play the game optimally. Input The first line contains integer n â€” number of cards of Petr and Snuke (1 â‰¤ n â‰¤ 50). Next line contains numbers f1, f2... *f**n* â€” numbers written on Petr's cards. Next line contains numbers s1, s2... *s**n* â€” numbers written on Snuke's cards. 1 â‰¤ fi, si â‰¤ 100. Output Output integer â€” the maximum size of the pile, that can be created. Examples input 2 2 5 3 1 output 3 input 5 1 1 1 1 1 1 1 1 1 1 output 1 input 5 1 4 6 7 3 1 7 1 5 7 output 6 åˆ†æž åŠ¨æ€è§„åˆ’ï¼Œå®šä¹‰dp[i][j]è®°å½•ç¬¬iæ¬¡æ“ä½œä¸‹å †é¡¶ä¸ºæœ€å¤§æ˜¯jçš„æƒ…å†µä¸‹çš„size è½¬ç§»æ–¹ç¨‹è§ä»£ç ï¼Œå¯ä»¥æ»šåŠ¨æ•°ç»„ï¼Œæˆ‘å†™çš„æœ‰ç‚¹ä¸‘ï¼Œä½†æ˜¯æ„æ€æ˜¯é‚£ä¹ˆä¸ªæ„æ€ã€‚ ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243/** @Author: sun000* @Date: 2017-07-23 13:31:11* @Last Modified by: sun000* @Last Modified time: 2017-07-23 14:07:04*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int dp[105][105];//ç¬¬iæ¬¡æ“ä½œåŽpileé¡¶æœ€å¤§æ˜¯jçš„æœ€å¤§sizeint f[55], s[55];int main(void) &#123; int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;f[i]); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;s[i]); memset(dp, 0, sizeof(dp)); for (int i = 1; i &lt;= 2 * n; i++) &#123; for (int j = 0; j &lt; n; j++) for (int k = 0; k &lt; f[j]; k++) dp[i + 1][f[j]] = dp[i][f[j]] = max(dp[i][f[j]], dp[i - 1][k] + 1); i++; for (int j = 0; j &lt; n; j++) for (int k = 0; k &lt; s[j]; k++) dp[i + 1][s[j]] = dp[i][s[j]] = max(dp[i][s[j]], dp[i - 1][k] + 1); &#125; int ans = -1; for (int i = 0; i &lt;= 100; i++) ans = max(ans, dp[n * 2][i]); printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 3760 Ideal Path]]></title>
    <url>%2F2017%2F07%2F22%2FHDU-3760-Ideal-Path%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® Problem Description New labyrinth attraction is open in New Lostland amusement park. The labyrinth consists of n rooms connected by m passages. Each passage is colored into some color ci. Visitors of the labyrinth are dropped from the helicopter to the room number 1 and their goal is to get to the labyrinth exit located in the room number n. Labyrinth owners are planning to run a contest tomorrow. Several runners will be dropped to the room number 1. They will run to the room number n writing down colors of passages as they run through them. The contestant with the shortest sequence of colors is the winner of the contest. If there are several contestants with the same sequence length, the one with the ideal path is the winner. The path is the ideal path if its color sequence is the lexicographically smallest among shortest paths. Andrew is preparing for the contest. He took a helicopter tour above New Lostland and made a picture of the labyrinth. Your task is to help him find the ideal path from the room number 1 to the room number n that would allow him to win the contest. Note A sequence (a1, a2, â€¦, ak) is lexicographically smaller than a sequence (b1, b2, â€¦, bk) if there exists i such that ai &lt; bi, and aj = bj for all j &lt; i. Input The input begins with an integer T. The next T blocks each represents a case. The first line of each case contains integers n and m - the number of rooms and passages, respectively (2 â‰¤ n â‰¤ 100 000, 1 â‰¤ m â‰¤ 200 000). The following m lines describe passages, each passage is described with three integer numbers: ai, bi, and ci - the numbers of rooms it connects and its color (1 â‰¤ ai, bi â‰¤ n, 1 â‰¤ ci â‰¤ 109). Each passage can be passed in either direction. Two rooms can be connected with more than one passage, there can be a passage from a room to itself. It is guaranteed that it is possible to reach the room number n from the room number 1. Output For each case, the first line of the output must contain k - the length of the shortest path from the room number 1 to the room number n. The second line must contain k numbers - the colors of passages in the order they must be passed in the ideal path. Sample Input 1 4 6 1 2 1 1 3 2 3 4 3 2 3 1 2 4 4 3 1 1 Output 2 1 3 åˆ†æž å…ˆBFSæ±‚å‡ºæ‰€æœ‰çš„æœ€çŸ­è·¯ï¼Œç„¶åŽåœ¨æœ€çŸ­è·¯æž„æˆçš„å›¾ä¸Šåˆ†å±‚æœç´¢ï¼Œæ±‚å‡ºå­—å…¸åºæœ€å°çš„è·¯å¾„ã€‚åˆ¤æ–­ä¸€ä¸ªç‚¹æ˜¯å¦åœ¨æœ€çŸ­è·¯ä¸Šï¼šåªè¦æ±‚å‡ºèµ·ç‚¹åˆ°è¿™ä¸€ç‚¹çš„æœ€çŸ­è·¯aå’Œç»ˆç‚¹åˆ°è¿™ä¸€ç‚¹çš„æœ€çŸ­è·¯bå¦‚æžœa+bç­‰äºŽèµ·ç‚¹åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·¯Låˆ™è¿™ä¸€ç‚¹åœ¨æœ€çŸ­è·¯ä¸Šã€‚è‡³äºŽåˆ†å±‚çš„è¯ï¼Œæ‰€åœ¨çš„å±‚å°±æ˜¯èµ·ç‚¹åˆ°è¿™ä¸€ç‚¹çš„æœ€çŸ­è·¯ã€‚mapåŽ»é‡å°ä¼˜åŒ–ã€‚ ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/** @Author: sun000* @Date: 2017-07-22 12:46:55* @Last Modified by: sun000* @Last Modified time: 2017-07-22 22:00:56*/#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;const int MAXN = 1e5 + 10 ;const int MAXM = 4e5 + 10;struct EDGE &#123; int v, w, next;&#125; edge[MAXM * 2];int head[MAXN], cnt;int dis[2][MAXN];bool vis[MAXN];void init() &#123; memset(head, -1, sizeof(head)); cnt = 0;&#125;void add(int u, int v, int w) &#123; edge[cnt].v = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt++;&#125;int n, m;int L;//æœ€çŸ­è·¯void bfs_clolr() &#123; memset(vis, false, sizeof(vis)); queue&lt;int&gt; q; q.push(1); vis[1] = true; int temp[MAXN]; int u, v, w, pre = 1, now, d = 1, minw; while (!q.empty() &amp;&amp; d &lt;= L) &#123; minw = 0x3f3f3f3f; for (int i = 0; i &lt; pre; i++) &#123; u = q.front(); q.pop(); temp[i] = u; for (int j = head[u]; j != -1; j = edge[j].next) &#123; v = edge[j].v; w = edge[j].w; if (dis[0][v] == d &amp;&amp; dis[0][v] + dis[1][v] == L) &#123; minw = min(minw, w); &#125; &#125; &#125; printf("%d%c", minw, d == L ? '\n' : ' '); now = 0; for (int i = 0; i &lt; pre; i++) &#123; u = temp[i]; for (int j = head[u]; j != -1; j = edge[j].next) &#123; v = edge[j].v; w = edge[j].w; if (dis[0][v] == d &amp;&amp; dis[0][v] + dis[1][v] == L &amp;&amp; minw == w &amp;&amp; !vis[v]) &#123; q.push(v); vis[v] = true; now++; &#125; &#125; &#125; d++; pre = now; &#125;&#125;void bfs(int src, int k) &#123; memset(vis, false, sizeof(vis)); queue&lt;int&gt; q; q.push(src); dis[k][src] = 0; int u, v; while (!q.empty()) &#123; u = q.front(); q.pop(); for (int i = head[u]; i != -1; i = edge[i].next) &#123; v = edge[i].v; if (!vis[v]) &#123; dis[k][v] = min(dis[k][v], dis[k][u] + 1); vis[v] = true; q.push(v); &#125; &#125; &#125; if (k == 0) L = dis[k][n];&#125;void solve() &#123; memset(dis, 0x3f, sizeof(dis)); bfs(1, 0); bfs(n, 1); printf("%d\n", L); bfs_clolr();&#125;map&lt;pair&lt;int, int&gt;, int&gt; mm;int main() &#123; int u, v, w, t; scanf("%d", &amp;t); while (t--) &#123; scanf("%d%d", &amp;n, &amp;m); init(); mm.clear(); while (m--) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); if (u == v) continue; if (u &gt; v) swap(u, v); pair&lt;int, int&gt; temp = make_pair(u, v); if (mm.count(temp)) mm[temp] = min(mm[temp], w); else mm[temp] = w; &#125; for (map&lt;pair&lt;int, int&gt;, int&gt;::iterator it = mm.begin(); it != mm.end(); it++) &#123; add((it -&gt; first).first, (it -&gt; first).second, it -&gt; second); add((it -&gt; first).second, (it -&gt; first).first, it -&gt; second); &#125; solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>å›¾è®º</tag>
        <tag>æœ€çŸ­è·¯</tag>
        <tag>æœç´¢</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A+B]]></title>
    <url>%2F2017%2F07%2F22%2FA%2BB%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® Andrew is studying in the seventh grade. The class has recently learned about periodic decimals, so Andrew is very curious how to work with them. Recall that a periodic decimal is the way to represent rational numbers by specifying the preperiod and the period of its infinite decimal representation. For example, 1 / 7 = 0.(142857), 1 / 12 = 0.08(3). There are some numbers that have two representations as periodic decimals, those that are actually finite decimals such as 0.(9) = 1.(0). In this problem such numbers must be represented as ending with zeroes, so 0.(9) is an incorrect periodic decimal for the purpose of this problem. Now Andrew wants to add two numbers given as periodic decimals. The sum of two periodic decimals is always again a periodic decimal, but the length of the period can be quite big. Therefore Andrew only asks you to find some particular digits of the sum. You have to output digits at positions a1, a2, ..., *a**n*. To simplify the task, Andrew only wants to add numbers of the form 0.(Î±) where Î± is a period. Input The input contains multiple test cases. The first line of the input contains t â€” the number of tests in the input. The first two lines of each test case contain periods of the two numbers to add, the periods contain digits from 0 to 9. The length of each period is at most 200. The following line contains n â€” the number of queries, the line with n integers *a**i* follows (1 â‰¤ n â‰¤ 300 000, 1 â‰¤ *a**i* â‰¤ 1018). The total length of periods of all numbers in the input doesn't exceed 200 000. The sum of n in the input doesn't exceed 300 000. Output For each *a**i* in the test case print a digits that is at the *a**i*-th position after the decimal point in the sum of two periodic decimals specified in the input. Positions are numbered from 1. Do not separate digits by spaces. Print answer for each test case on a separate line. Example input 2 142857 3 10 1 2 3 4 5 6 7 8 9 10 4 5 3 1 2 3 output 4761904761 000 åˆ†æž ç›´æŽ¥æš´åŠ›æ¨¡æ‹Ÿï¼Œæœ‰ä¸€ä¸ªå‘ç‚¹å°±æ˜¯(9)+(9)å¹¶ä¸æ˜¯æ¯ä¸€ä½éƒ½æ˜¯9ï¼Œä¸éœ€è¦æ›¿æ¢æˆ0ï¼Œå› ä¸ºæœ€åŽä¸€ä½æ°¸è¿œéƒ½æ˜¯8ã€‚ ä»£ç  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;cstring&gt;char a[100100], b[100100];int g;int gcd(int a, int b) &#123; if (!b) return a; return gcd(b, a % b);&#125;void init() &#123; int la = strlen(a); int lb = strlen(b); g = la / gcd(la, lb) * lb; for (int i = 1; i &lt; g / la; i++) for (int j = 0; j &lt; la; j++) a[i * la + j] = a[j]; for (int i = 1; i &lt; g / lb; i++) for (int j = 0; j &lt; lb; j++) b[i * lb + j] = b[j]; a[g] = b[g] = '\0'; int gg = 0, now; for (int i = g - 1; i &gt;= 0; i--) &#123; now = (a[i] - '0' + b[i] - '0') + gg; a[i] = '0' + now % 10; gg = now / 10; &#125; if (!gg) &#123; bool flag = true; for (int i = 0; i &lt; g; i++) if (a[i] != '9') &#123; flag = false; break; &#125; if (flag) &#123; for (int i = 0; i &lt; g; i++) a[i] = '0'; return; &#125; &#125; while (gg) &#123; for (int i = g - 1; i &gt;= 0; i--) &#123; now = a[i] - '0' + gg; a[i] = '0' + now % 10; gg = now / 10; &#125; &#125;&#125;int main(void) &#123; int t, m; long long int q; scanf("%d", &amp;t);// while (t--) &#123; scanf("%s", a); scanf("%s", b); init(); scanf("%d", &amp;m); for (int i = 0; i &lt; m; i++) &#123; scanf("%lld", &amp;q); q = (q - 1) % (long long int)g; printf("%c", a[(int)q]); &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>æš´åŠ›</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hash Code Hacker]]></title>
    <url>%2F2017%2F07%2F22%2FHash-Code-Hacker%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® According to Java standard library documentation, the hash code of String is computed ass[0]31^(n-1) + s[1]31^(n-2) + ... + s[n-1] Here s[i] is the i-th character of the string, n is the length of the string, and Ë† indicates exponentiation.Computation uses signed 32-bit integers in twoâ€™s complement form. Heather is going to hack the servers of Not Entirely Evil Recording Company (NEERC). To performan attack she needs k distinct query strings that have equal hash codes. Unfortunately, NEERC serversaccept query string containing lower- and uppercase English letters only. Heather hired you to write a program that generates such query strings for her. Input The single line of the input file contains integer k â€” the number of required query strings to generate(2 â‰¤ k â‰¤ 1000). Output Output k lines. Each line should contain a single query string. Each query string should be non-emptyand its length should not exceed 1000 characters. Query string should contain only lower- and uppercaseEnglish letters. All query strings should be distinct and should have equal hash codes. Example Input 4 Output edHs mENAGeS fEHs edIT åˆ†æž è§‚å¯Ÿæ ·ä¾‹ï¼Œå¾ˆå®¹æ˜“å‘çŽ°hash(&quot;Hs&quot;)=hash(&quot;IT&quot;)ï¼Œå¾—åˆ°è§„å¾‹hash(&quot;Aa&quot;)=hash(&quot;BB&quot;),hash(&quot;Bb&quot;)=hash(&quot;CC&quot;)........ç”±äºŽæœ€å¤§çš„kæ˜¯1000åˆ™æœ€å¤šå–10å¯¹ï¼Œç”¨äºŒè¿›åˆ¶æžšä¸¾æ¯ä¸€å¯¹æ˜¯ä»€ä¹ˆå°±èƒ½å¾—åˆ°ç­”æ¡ˆäº†ã€‚ ä»£ç  12345678910111213141516171819#include &lt;cstdio&gt;char a[10][3] = &#123;"Aa", "Bb", "Cc", "Dd", "Ee", "Ff", "Gg", "Hh", "Ii", "Jj"&#125;;char b[10][3] = &#123;"BB", "CC", "DD", "EE", "FF", "GG", "HH", "II", "JJ", "KK"&#125;;int main(void) &#123; int k; scanf("%d", &amp;k); for(int i = 0; i &lt; k; i++) &#123; for(int j = 0; j &lt; 10; j++) &#123; if((i &gt;&gt; j) &amp; 1) printf("%s", a[j]); else printf("%s", b[j]); &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>æž„é€ </tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[èŽ«é˜Ÿ]]></title>
    <url>%2F2017%2F07%2F13%2F%E8%8E%AB%E9%98%9F%2F</url>
    <content type="text"><![CDATA[è½¬è½½è‡ª æ‘˜è¦ èŽ«é˜Ÿç®—æ³•æ˜¯ä¸€ä¸ªå¯¹äºŽåŒºé—´ã€æ ‘æˆ–å…¶ä»–ç»“æž„ç¦»çº¿ï¼ˆåœ¨çº¿ï¼‰ç»´æŠ¤çš„ç®—æ³•ï¼Œæ­¤ç®—æ³•åŸºäºŽä¸€äº›åŸºæœ¬ç®—æ³•ï¼Œä¾‹å¦‚æš´åŠ›ç»´æŠ¤ï¼Œæ ‘çŠ¶æ•°ç»„ï¼Œåˆ†å—ï¼Œæœ€å°æ›¼å“ˆé¡¿è·ç¦»ç”Ÿæˆæ ‘ï¼Œå¯¹å…¶è¿›è¡Œæ‰åˆä»Žè€Œäº§ç”Ÿçš„ä¸€ä¸ªç®€å•æ˜“æ‡‚ä¸”çŸ­å°å¥½å†™çš„ç®—æ³•ã€‚æ­¤ç®—æ³•åœ¨å¾ˆå¤šæƒ…å†µä¸‹å¯ä»¥å¾ˆè½»æ¾çš„åˆ‡æŽ‰ä¸€äº›å¤æ‚è€Œä¸”éš¾å†™çš„æ•°æ®ç»“æž„é—®é¢˜ã€‚ å…³é”®è¯ ç¨‹åºè®¾è®¡ã€ç®—æ³•ã€ç®—æ³•ä¼˜åŒ–ï¼Œæš´åŠ›ç®—æ³•ï¼Œåˆ†å—ç®—æ³•ï¼Œæœ€å°æ›¼å“ˆé¡¿è·ç¦»ç”Ÿæˆæ ‘ã€‚ èƒŒæ™¯ ä¼—æ‰€å‘¨çŸ¥ï¼Œåœ¨OIç«žèµ›ã€è½¯ä»¶çš„è®¾è®¡ä¸­éƒ½ä¼šè¦æ±‚æˆ‘ä»¬åŽ»å¤„ç†å„ç§å„æ ·çš„æ£˜æ‰‹çš„é—®é¢˜ï¼Œè€Œè¿™äº›é—®é¢˜ä¹‹ä¸­ï¼Œæœ‰ä¸€å¤§ç±»å°±æ˜¯ç»´æŠ¤é—®é¢˜ï¼šæ¯”å¦‚è¯´å¯¹äºŽä¸€ä¸ªåºåˆ—çš„ç»´æŠ¤ï¼Œå¯¹äºŽæ£µäºŒå‰æˆ–è€…å¤šå‰æ ‘çš„ç»´æŠ¤â€¦â€¦è¿™äº›é—®é¢˜å¾€å¾€ä¼šéœ€è¦æˆ‘ä»¬åŽ»ä½¿ç”¨ä¸€ä¸ªæˆ–å¤šä¸ªé«˜ç«¯çš„æ•°æ®ç»“æž„å¤åˆæ¥å®Œç¾Žè§£å†³ï¼Œé€šå¸¸é¢˜ç›®çš„ä»£ç ååˆ†å†—é•¿è€Œä¸”å‡ºé”™å¯èƒ½æ€§ååˆ†å¤§ï¼Œæ˜¯å¹¿å¤§OIerã€Acmerã€Coderæ‰€å®³æ€•çš„é¢˜ç›®ã€‚é‚£ä¹ˆæœ‰æ²¡æœ‰ä¸€ç§æ–¹æ³•å¯ä»¥æ—¢ç®€å•åˆå¿«æ·çš„è§£å†³è¿™ç±»é—®é¢˜ï¼ˆè¿™ç±»é—®é¢˜ä¸­çš„ä¸€å¤§éƒ¨åˆ†ï¼‰å‘¢ï¼ŸèŽ«é˜Ÿç®—æ³•å°±è¯žç”Ÿè¾£ï¼ ç†è®º1 åºåˆ—èŽ«é˜Ÿï¼šæˆ‘ä»¬çŽ°åœ¨æœ‰ä¸€ä¸ªé•¿ä¸ºnçš„é™æ€çš„åºåˆ—ï¼Œå¯¹äºŽåºåˆ—ï¼Œæˆ‘ä»¬æœ‰mæ¬¡æŸ¥è¯¢ï¼Œæˆ‘ä»¬è¦åŠ¨æ€æŸ¥è¯¢låˆ°rä¹‹é—´å¤§äºŽaå°äºŽbçš„æ•°çš„ä¸ªæ•°ä»¥åŠç§ç±»ã€‚é‡åˆ°äº†è¿™ä¸ªé—®é¢˜æˆ‘ä»¬é€šå¸¸éœ€è¦ä½¿ç”¨ä¹¦å¥—æ ‘çš„æ•°æ®ç»“æž„ï¼Œå³ä¸€é¢—ä»¥è‡ªå¹³è¡¡äºŒå‰æŸ¥æ‰¾æ ‘ä¸ºèŠ‚ç‚¹çš„çº¿æ®µæ ‘ï¼ˆæ—¶é—´å¤æ‚åº¦å¤§çº¦æ˜¯O(mlognlogn)ï¼‰ï¼Œè€Œä¸”ç”±äºŽç©ºé—´é™åˆ¶ï¼Œæˆ‘ä»¬è¿˜å¿…é¡»åŠ¨æ€åˆ›å»ºçº¿æ®µæ ‘çš„èŠ‚ç‚¹ï¼Œè¿™æ ·ä¸€æ¥ååˆ†éš¾å†™ï¼Œä¸€äº›å¤§çº¦è¦ä¸ª400-500è¡Œï¼Œè°ƒè¯•èµ·æ¥ä¹Ÿå¾ˆå›°éš¾ã€‚è¿™æ—¶å€™æˆ‘ä»¬æ¥è€ƒè™‘æš´åŠ›ç®—æ³•ï¼Œå¦‚æžœæš´åŠ›çš„å¤„ç†é¢˜ç›®ä¸­çš„é—®é¢˜é‚£ä¹ˆå¤æ‚åº¦æ˜¯å¤šå°‘å‘¢ï¼Ÿè¿™ä¸ªä¸éš¾è®¡ç®—ï¼Œå¯¹äºŽæ¯ä¸ªè¯¢é—®æˆ‘ä»¬éƒ½è¦O(n)çš„æ—¶é—´å¤„ç†,ä¸€å…±æœ‰mä¸ªè¯¢é—®ï¼Œé‚£ä¹ˆæš´åŠ›å¤„ç†çš„å¤æ‚åº¦å°±æ˜¯O(nm)çš„ï¼Œæ˜Žæ˜¾å¤„ç†é—®é¢˜èŠ±è´¹çš„æ—¶é—´æˆ‘ä»¬æ˜¯ä¸èƒ½æŽ¥å—çš„ã€‚è¿™æ˜¯æˆ‘ä»¬æƒ³åˆ°å¯ä»¥äº¤æ¢è¯¢é—®å’Œè¯¢é—®ä¹‹é—´çš„å…ˆåŽæ¬¡åºï¼Œè¿™æ ·æ¯æ¬¡è¯¢é—®åœ¨å‰ä¸€æ¬¡è¯¢é—®çš„åŸºç¡€ä¸Šè½¬ç§»å°±å¯ä»¥èŠ‚çœä¸€äº›æ—¶é—´äº†ã€‚ ä½†æ˜¯å¦‚ä½•é‡æ–°æŽ’åˆ—è¯¢é—®ä¹‹é—´çš„é¡ºåºæ˜¯ä¸€ä¸ªé—®é¢˜ã€‚æˆ‘ä»¬éœ€è¦è¿›è¡Œä¸€äº›ç†è®ºåˆ†æžã€‚æˆ‘ä»¬å†ä¸Šä¸€ä¸ªè¯¢é—®çš„åŸºç¡€ä¸Šæš´åŠ›åœ°ç»´æŠ¤ä¸€ä¸ªè¯¢é—®ï¼ˆå‡è®¾ä¸Šä¸€ä¸ªè¯¢é—®è¯¢é—®åŒºé—´ä¸º[l0,r0]ï¼Œè¿™ä¸ªè¯¢é—®åŒºé—´ä¸º[l,r]ï¼‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ‰€è°“çš„æš´åŠ›ç»´æŠ¤å°±æ˜¯å…ˆæŠŠçŽ°æœ‰ç­”æ¡ˆçš„å³è¾¹ç•Œä»Žr0ç§»åŠ¨åˆ°rï¼Œå†æŠŠå·¦è¾¹ç•Œä»Žl0ç§»åŠ¨åˆ°lï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„æ€»èŠ±è´¹æ˜¯O(|l-l0|+|r-r0|)ã€‚ä»”ç»†çœ‹ä¸€çœ‹ï¼Œæ²¡é”™ï¼Œè¿™å°±æ˜¯æˆ‘ä»¬çš„æ›¼å“ˆé¡¿è·ç¦»çš„è®¡ç®—å…¬å¼ï¼Œæœ‰äº†è¿™ä¸ªæ€è·¯ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä»Žå›¾å½¢çš„è§’åº¦æ¥æ€è€ƒäº†ï¼Œå¯¹äºŽä¸€ä¸ªè¯¢é—®[l,r]æˆ‘ä»¬å¯ä»¥å°†å®ƒæ˜ å°„ä¸ºå¹³é¢ä¸Šåœ¨(l,r)ä½ç½®çš„ç‚¹ï¼Œé‚£ä¹ˆä¸¤ä¸ªè¯¢é—®ä¹‹é—´è½¬ç§»çš„ä»£ä»·å°±æ˜¯è¯¢é—®æ‰€å¯¹åº”çš„ç‚¹ä¹‹é—´çš„æ›¼å“ˆé¡¿è·ç¦»ã€‚æœ‰äº†è¿™ä¸€ä¸ªç»“è®ºï¼Œæˆ‘ä»¬ä¾¿æƒ³åˆ°å¯ä»¥ç”¨æœ€å°æ›¼å“ˆé¡¿ç”Ÿæˆæ ‘æ¥å¤„ç†è¯¢é—®çš„é¡ºåºã€‚ç”±æ­¤èŽ«é˜Ÿç®—æ³•ä¾¿è¯žç”Ÿå•¦ï¼èŽ«é˜Ÿç®—æ³•å°±æ˜¯å…ˆå°†è¯¢é—®æŠ½è±¡æˆå¹³é¢ä¸Šçš„ç‚¹ï¼Œç„¶åŽè¿›è¡Œä¸€è¾¹æœ€å°æ›¼å“ˆé¡¿è·ç¦»ç”Ÿæˆæ ‘ï¼Œç„¶åŽæŒ‰ç…§ç”Ÿæˆæ ‘çš„é¡ºåºæ¥å¤„ç†è¯¢é—®ï¼Œè¿™æ ·çš„ç®—æ³•å¤æ‚åº¦å¤§çº¦æ˜¯O(mSqrt(n))çš„ã€‚å¦‚æ­¤ï¼Œé—®é¢˜ä¾¿ç®€å•äº†è®¸å¤šã€‚ ä½†æ˜¯ç”±äºŽæœ€å°æ›¼å“ˆé¡¿è·ç¦»ç”Ÿæˆæ ‘ä¹Ÿä¸æ˜¯é‚£ä¹ˆçš„å¥½å†™ï¼Œæ‰€ä»¥èŽ«é˜Ÿç®—æ³•è¿˜èƒ½å†ç®€å•ä¸€ç‚¹ä¹ˆï¼Ÿæˆ‘ä»¬æ€è€ƒæ˜¯å¦å¯ä»¥ç”¨ä¸€ä¸ªç®€å•è€Œæš´åŠ›çš„ç®—æ³•ä»£æ›¿èŽ«é˜Ÿç®—æ³•å‘¢ã€‚å¾ˆå¿«ä¾¿èƒ½æƒ³åˆ°åˆ†å—ç®—æ³•ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨åˆ†å—ç®—æ³•æ¥å¤„ç†è¯¢é—®ä¹‹é—´çš„æ¬¡åºé—®é¢˜ã€‚å†åŽ»çœ‹é‚£ä¸ªè¯¢é—®å¯¹åº”çš„ç‚¹æ‰€åœ¨çš„å¹³é¢ï¼Œæˆ‘ä»¬æ‰¾åˆ°å®ƒçš„Xè½´ï¼Œæˆ‘ä»¬æŠŠXè½´å¹³å‡åˆ†å‰²æˆråˆ†ï¼Œç„¶åŽæˆ‘ä»¬æŠŠåœ¨ä¸€ä¸ªå—å†…çš„è¯¢é—®ç»Ÿä¸€å…ˆå¤„ç†ï¼Œä¸åœ¨ä¸€ä¸ªå—å†…çš„è¯¢é—®æˆ‘ä»¬æŒ‰ç…§å·¦ç«¯ç‚¹å‡åºå³ç«¯ç‚¹å‡åºæŽ’åºä¾æ¬¡å¤„ç†ã€‚è¿™æ ·åšæœ‰ä»€ä¹ˆå¥½å¤„å‘¢ï¼Ÿå¯¹äºŽmå¹²ä¸ªè¯¢é—®ï¼Œå¦‚æžœåœ¨ä¸€ä¸ªå—é‡Œé¢ï¼Œé‚£ä¹ˆå¤„ç†è¿™äº›è¯¢é—®èŠ±è´¹çš„å¤æ‚åº¦æ˜¯O(n/rnm)ï¼Œå¦‚æžœæœ‰ä¸¤ä¸ªè¯¢é—®ä¸åœ¨ä¸€ä¸ªåŒä¸€ä¸ªå—é‡Œé¢ï¼ŒæŒ‰ç…§æˆ‘ä»¬ä¹‹å‰çš„æŽ’åºè§„åˆ™ï¼Œæˆ‘ä»¬æŠŠå·¦åŒºé—´å’Œå³åŒºé—´åœ¨å—ä¹‹é—´ç§»åŠ¨çš„æ¬¡æ•°æœ€å¤šä¸ºr(n/r)ræ¬¡ï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„å¤æ‚åº¦å°±æ˜¯O(r(n/r)r)æ¬¡ï¼Œç»è¿‡ç®€å•çš„æ•°å­¦åˆ†æžï¼Œæˆ‘ä»¬å¯ä»¥å‘çŽ°r=Sqrt(n)æ˜¯æ—¶é—´å¤æ‚åº¦æœ€ä½Žä¸ºO(nSqrt(n))æ¬¡ï¼Œæ˜¯å¯ä»¥æŽ¥å—çš„æ—¶é—´å¤æ‚åº¦ã€‚è¿™æ ·æˆ‘ä»¬çš„èŽ«é˜Ÿç®—æ³•å°±åˆç®€å•æœ‰å¼ºå¤§äº†ã€‚ä½†æ˜¯åœ¨å¦ä¸€äº›æƒ…å†µä¸‹ï¼Œé¢˜ç›®ä¼šæ— è€»çš„é™å®šæˆ‘ä»¬å¯ä»¥ä½¿ç”¨çš„ç©ºé—´ï¼ˆä¸€èˆ¬ä¸ä¼šï¼Œå› ä¸ºè¿™æ ·é«˜çº§æ•°æ®ç»“æž„çš„å¤åˆä¹Ÿéš¾ä»¥è§£å†³è¿™æ ·çš„é—®é¢˜äº†ï¼‰ã€‚é‚£ä¹ˆå¦‚æžœç©ºé—´è¢«é™å®šäº†ï¼Œæˆ‘ä»¬åº”è¯¥å¦‚ä½•è§£å†³é—®é¢˜å‘¢ï¼Ÿå…¶å®žå¾ˆç®€å•ï¼Œ è¿˜è®°å¾—æˆ‘ä»¬ä¹‹å‰çš„rä¹ˆï¼Ÿæˆ‘ä»¬ä¸ºäº†æ±‚çš„æ—¶é—´å¤æ‚åº¦æœ€å°ä»¤r=Sqrt(n),å¦‚æžœæˆ‘ä»¬ä»¤r=n ^ (2 / 3)ï¼Œé‚£ä¹ˆä¾¿æ˜¯ä¸€ä¸ªæ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦è¾ƒä¸ºå¹³è¡¡çš„æƒ…å†µï¼Œè¿™æ ·å¯ä»¥å¾ˆå¥½çš„è§£å†³é—®é¢˜ã€‚ ä¾‹é¢˜ è¾“å…¥æ•°æ®é¦–å…ˆè¾“å…¥ä¸¤ä¸ªæ•´æ•°N,Qï¼Œåˆ†åˆ«ä»£è¡¨åºåˆ—çš„é•¿åº¦å’Œè¯¢é—®çš„ä¸ªæ•°ã€‚è¿™ä¸¤ä¸ªæ•°å­—å°†å•ç‹¬å æ®ä¸€è¡Œå¹¶ç”¨ä¸€ä¸ªç©ºæ ¼åˆ†å¼€ã€‚è¾“å…¥æ•°æ®çš„ç¬¬äºŒè¡ŒåŒ…å«äº†Nä¸ªç”±ä¸€ä¸ªç©ºæ ¼åˆ†å¼€çš„æ­£æ•´æ•°ï¼Œä»£è¡¨äº†æ•´ä¸ªåºåˆ—ï¼Œä»Žå·¦å‘å³ä¾æ¬¡ç¼–å·ä¸ºA1, A2â€¦â€¦Anã€‚æŽ¥ä¸‹æ¥Qè¡Œï¼Œæ¯è¡Œä¸¤ä¸ªæ•´æ•°i,jè¡¨ç¤ºäº†ä¸€ä¸ªè¯¢é—®åŒºé—´ã€‚è¾“å…¥æ•°æ®ä¿è¯1â‰¤i &lt;j&lt;=N 2038: [2009å›½å®¶é›†è®­é˜Ÿ]å°Zçš„è¢œå­(hose) Description ä½œä¸ºä¸€ä¸ªç”Ÿæ´»æ•£æ¼«çš„äººï¼Œå°Zæ¯å¤©æ—©ä¸Šéƒ½è¦è€—è´¹å¾ˆä¹…ä»Žä¸€å †äº”é¢œå…­è‰²çš„è¢œå­ä¸­æ‰¾å‡ºä¸€åŒæ¥ç©¿ã€‚ç»ˆäºŽæœ‰ä¸€å¤©ï¼Œå°Zå†ä¹Ÿæ— æ³•å¿å—è¿™æ¼äººçš„æ‰¾è¢œå­è¿‡ç¨‹ï¼ŒäºŽæ˜¯ä»–å†³å®šå¬å¤©ç”±å‘½â€¦â€¦ å…·ä½“æ¥è¯´ï¼Œå°ZæŠŠè¿™Nåªè¢œå­ä»Ž1åˆ°Nç¼–å·ï¼Œç„¶åŽä»Žç¼–å·Låˆ°R(L å°½ç®¡å°Zå¹¶ä¸åœ¨æ„ä¸¤åªè¢œå­æ˜¯ä¸æ˜¯å®Œæ•´çš„ä¸€åŒï¼Œç”šè‡³ä¸åœ¨æ„ä¸¤åªè¢œå­æ˜¯å¦ä¸€å·¦ä¸€å³ï¼Œä»–å´å¾ˆåœ¨æ„è¢œå­çš„é¢œè‰²ï¼Œæ¯•ç«Ÿç©¿ä¸¤åªä¸åŒè‰²çš„è¢œå­ä¼šå¾ˆå°´å°¬ã€‚ ä½ çš„ä»»åŠ¡ä¾¿æ˜¯å‘Šè¯‰å°Zï¼Œä»–æœ‰å¤šå¤§çš„æ¦‚çŽ‡æŠ½åˆ°ä¸¤åªé¢œè‰²ç›¸åŒçš„è¢œå­ã€‚å½“ç„¶ï¼Œå°Zå¸Œæœ›è¿™ä¸ªæ¦‚çŽ‡å°½é‡é«˜ï¼Œæ‰€ä»¥ä»–å¯èƒ½ä¼šè¯¢é—®å¤šä¸ª(L,R)ä»¥æ–¹ä¾¿è‡ªå·±é€‰æ‹©ã€‚ Input è¾“å…¥æ–‡ä»¶ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ­£æ•´æ•°Nå’ŒMã€‚Nä¸ºè¢œå­çš„æ•°é‡ï¼ŒMä¸ºå°Zæ‰€æçš„è¯¢é—®çš„æ•°é‡ã€‚æŽ¥ä¸‹æ¥ä¸€è¡ŒåŒ…å«Nä¸ªæ­£æ•´æ•°Ciï¼Œå…¶ä¸­Ciè¡¨ç¤ºç¬¬iåªè¢œå­çš„é¢œè‰²ï¼Œç›¸åŒçš„é¢œè‰²ç”¨ç›¸åŒçš„æ•°å­—è¡¨ç¤ºã€‚å†æŽ¥ä¸‹æ¥Mè¡Œï¼Œæ¯è¡Œä¸¤ä¸ªæ­£æ•´æ•°Lï¼ŒRè¡¨ç¤ºä¸€ä¸ªè¯¢é—®ã€‚ Output åŒ…å«Mè¡Œï¼Œå¯¹äºŽæ¯ä¸ªè¯¢é—®åœ¨ä¸€è¡Œä¸­è¾“å‡ºåˆ†æ•°A/Bè¡¨ç¤ºä»Žè¯¥è¯¢é—®çš„åŒºé—´[L,R]ä¸­éšæœºæŠ½å‡ºä¸¤åªè¢œå­é¢œè‰²ç›¸åŒçš„æ¦‚çŽ‡ã€‚è‹¥è¯¥æ¦‚çŽ‡ä¸º0åˆ™è¾“å‡º0/1ï¼Œå¦åˆ™è¾“å‡ºçš„A/Bå¿…é¡»ä¸ºæœ€ç®€åˆ†æ•°ã€‚ï¼ˆè¯¦è§æ ·ä¾‹ï¼‰ æ ·ä¾‹è§£é‡Š è¯¢é—®1ï¼šå…±C(5,2)=10ç§å¯èƒ½ï¼Œå…¶ä¸­æŠ½å‡ºä¸¤ä¸ª2æœ‰1ç§å¯èƒ½ï¼ŒæŠ½å‡ºä¸¤ä¸ª3æœ‰3ç§å¯èƒ½ï¼Œæ¦‚çŽ‡ä¸º(1+3)/10=4/10=2/5ã€‚ è¯¢é—®2ï¼šå…±C(3,2)=3ç§å¯èƒ½ï¼Œæ— æ³•æŠ½åˆ°é¢œè‰²ç›¸åŒçš„è¢œå­ï¼Œæ¦‚çŽ‡ä¸º0/3=0/1ã€‚ è¯¢é—®3ï¼šå…±C(3,2)=3ç§å¯èƒ½ï¼Œå‡ä¸ºæŠ½å‡ºä¸¤ä¸ª3ï¼Œæ¦‚çŽ‡ä¸º3/3=1/1ã€‚ æ³¨ï¼šä¸Šè¿°C(a, b)è¡¨ç¤ºç»„åˆæ•°ï¼Œç»„åˆæ•°C(a, b)ç­‰ä»·äºŽåœ¨aä¸ªä¸åŒçš„ç‰©å“ä¸­é€‰å–bä¸ªçš„é€‰å–æ–¹æ¡ˆæ•°ã€‚ æ•°æ®è§„æ¨¡å’Œçº¦å®š 30%çš„æ•°æ®ä¸­ N,M â‰¤ 5000ï¼› 60%çš„æ•°æ®ä¸­ N,M â‰¤ 25000ï¼› 100%çš„æ•°æ®ä¸­ N,M â‰¤ 50000ï¼Œ1 â‰¤ L &lt; R â‰¤ Nï¼ŒCi â‰¤ Nã€‚ å•ä¸ªæµ‹è¯•ç‚¹æ—¶é™2S å¯¹äºŽä¸Šè¿°è¿™é“é¢˜ï¼Œ30%çš„æ•°æ®æˆ‘ä»¬å¯ä»¥å¯¹äºŽæ¯ä¸ªè¯¢é—®éƒ½æ‰«æè¯¢é—®åŒºé—´ä¸­æ‰€å­˜åœ¨çš„æ•°ç„¶åŽè®¡ç®—ï¼Œè¿™æ ·å•æ¬¡å¤æ‚åº¦æ˜¯O(N)çš„ï¼Œä½†æœ‰Mçš„è¯¢é—®ï¼Œæ€»å¤æ‚åº¦æ˜¯Oï¼ˆMNï¼‰ã€‚è¿™å°±æ˜¾å¾—æœ‰ç‚¹ä¸å¤ªèƒ½æŽ¥å—äº†ã€‚ ä½†æ˜¯å½“æˆ‘ä»¬çŸ¥é“ä¸€ä¸ªè¯¢é—®[l,r]çš„ç­”æ¡ˆåŽï¼Œ[l+1,r],[l-1,r],[l,r+1],[l,r-1]è¿™å››ä¸ªåŒºé—´çš„ç­”æ¡ˆå¯ä»¥é€šè¿‡è®¡ç®—åšåˆ°O(1)çš„æ—¶é—´å†…å¾—åˆ° æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è€ƒè™‘èŽ«é˜Ÿç®—æ³•ï¼Œåˆ†ä¸ºå¦‚ä¸‹ä¸‰æ­¥ã€‚ 1ã€åˆ†å— 2ã€æŠŠæ‰€æœ‰è¯¢é—®å·¦ç«¯ç‚¹æŽ’åº 3ã€å¯¹äºŽå·¦ç«¯ç‚¹åœ¨åŒä¸€å—å†…çš„è¯¢é—®æŒ‰å³ç«¯ç‚¹æŽ’åºï¼Œç„¶åŽåˆ†ä¸‰ç§æƒ…å†µç»Ÿè®¡ã€‚ è€Œå¤æ‚åº¦æ­£å¦‚ç†è®ºéƒ¨åˆ†æ‰€è¯´çš„ä¸€æ ·ï¼Œ ä¸€ã€iä¸Ži+1åœ¨åŒä¸€å—å†…ï¼Œrå•è°ƒé€’å¢žï¼Œæ‰€ä»¥ræ˜¯O(N)çš„ã€‚ç”±äºŽæœ‰sqrt(N)å—,æ‰€ä»¥è¿™ä¸€éƒ¨åˆ†æ—¶é—´å¤æ‚åº¦æ˜¯Nsqrt(N)ã€‚ äºŒã€iä¸Ži+1è·¨è¶Šä¸€å—ï¼Œræœ€å¤šå˜åŒ–nï¼Œç”±äºŽæœ‰sqrt(N)å—ï¼Œæ‰€ä»¥è¿™ä¸€éƒ¨åˆ†æ—¶é—´å¤æ‚åº¦æ˜¯Nsqrt(N) ä¸‰ã€iä¸Ži+1åœ¨åŒä¸€å—å†…æ—¶å˜åŒ–ä¸è¶…è¿‡sqrt(N)ï¼Œè·¨è¶Šä¸€å—ä¹Ÿä¸ä¼šè¶…è¿‡2* sqrt(N)ï¼Œä¸å¦¨çœ‹ä½œæ˜¯sqrt(N)ã€‚ç”±äºŽæœ‰Nä¸ªæ•°ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦æ˜¯O(Nsqrt(N)) å¯ä»¥è¯æ˜Žå¤æ‚åº¦æ˜¯O(Nsqrt(N))äº† ç†è®º2 å¯çŽ°åœ¨æœ‰å¾ˆå¤šé—®é¢˜éƒ½è®¾ç½®äº†ä¿®æ”¹æ“ä½œï¼Œå¯¹äºŽè¿™ç±»æˆ‘ä»¬æˆ‘ä»¬åˆè¯¥å¦‚ä½•å¤„ç†å‘¢ï¼Ÿ ä¾‹é¢˜ æˆ‘ä»¬çŽ°åœ¨æœ‰ä¸€ä¸ªé•¿ä¸ºnçš„ï¼Œå¯¹äºŽåºåˆ—ï¼Œæˆ‘ä»¬æœ‰mæ¬¡æ“ä½œï¼Œæ“ä½œåˆ†ä¸ºä¸¤ç§ 1ã€è¯¢é—®åœ¨[l,r]ä¸­æŠ½åˆ°ä¸¤ä¸ªæ•°å­—ç›¸åŒçš„æ¦‚çŽ‡ 2ã€æŠŠæŸä¸ªä½ç½®çš„æ•°aiæ”¹æˆx 100%çš„æ•°æ®ä¸­ N,M â‰¤100000ï¼Œ1 â‰¤ L &lt; R â‰¤ Nï¼ŒCi â‰¤ Nã€‚ å•ä¸ªæµ‹è¯•ç‚¹æ—¶é™10S æˆ‘ä»¬ä¼šå‘çŽ°ï¼ŒåŠ ä¸Šäº†ä¿®æ”¹æ“ä½œåŽã€‚å°±æ²¡åŠžæ³•ç›´æŽ¥æŒ‰ç…§åˆ†å—æ¥å¤„ç†è§£å†³è¯¢é—®çš„é¡ºåºã€‚ å®šä¹‰Bä¸ºåˆ†å—çš„å¤§å°ã€‚ &gt; é¦–å…ˆè€ƒè™‘æ²¡æœ‰ä¿®æ”¹æ“ä½œï¼Œé‚£ä¹ˆå°±å’Œç†è®º1ä¸­å°Zçš„è¢œå­ä¸€æ ·ï¼Œä»¤B = sqrt(n) ã€‚æŠŠæ‰€æœ‰è¯¢é—®å·¦ç«¯ç‚¹æŽ’åºï¼Œå¯¹äºŽå·¦ç«¯ç‚¹åœ¨åŒä¸€å—å†…çš„è¯¢é—®æŒ‰å³ç«¯ç‚¹æŽ’åº,ç„¶åŽå†™èŽ«é˜Ÿç®—æ³•ï¼ŒæŒ‰é¡ºåºæ‰«è¯¢é—®ï¼Œè¿™æ ·æ˜¯O(n sqrt(n))ã€‚å¦‚æžœçŽ°åœ¨åŠ ä¸Šä¿®æ”¹æ“ä½œè€ƒè™‘ä¸€ä¸ªè¯¢é—®(l,r)ï¼Œè¿™æ ·æ˜¯è‚¯å®šä¸å¤Ÿçš„ã€‚ &gt; äºŽæ˜¯å˜æˆï¼š(l,r,ti)ï¼Œtiæ˜¯è¯¢é—®æ—¶çš„æ—¶é—´ï¼Œå³è¿™æ¬¡è¯¢é—®æ˜¯ç¬¬å‡ æ¬¡æ“ä½œã€‚æŠŠæ‰€æœ‰è¯¢é—®å·¦ç«¯ç‚¹læŽ’åºï¼Œå¯¹äºŽå·¦ç«¯ç‚¹åœ¨åŒä¸€å—å†…çš„è¯¢é—®æŒ‰å³ç«¯ç‚¹ræ‰€åœ¨çš„å—æŽ’åºï¼Œå¯¹å³ç«¯ç‚¹ræ‰€åœ¨å—ç›¸åŒçš„æˆ‘ä»¬å†æŒ‰ç…§æ—¶é—´tiæŽ’åºã€‚ ç„¶åŽåšèŽ«é˜Ÿç®—æ³•ï¼ŒæŒ‰é¡ºåºæ‰«è¯¢é—®ï¼Œæ—¶é—´æœ‰æ—¶å‘å‰æœ‰æ—¶å€’æµã€‚è¿™æ ·ä»¤B = n ^ (2 / 3)ï¼Œå› ä¸ºåœ¨æ¯ä¸€å—ä¸­æ—¶é—´æœ€å¤šä»Ž1åˆ°Tæ”¹å˜ä¸€æ¬¡ï¼Œè®¾è¯¢é—®æ“ä½œp1æ¬¡ï¼Œä¿®æ”¹æ“ä½œp2æ¬¡ï¼Œåˆ™åœ¨æœ€å·®æƒ…å†µä¸‹çš„æ—¶é—´å¤æ‚åº¦æ˜¯O(p1 n^(2 / 3)+p2 n^(1 / 3) n^(1 / 3))=O(n^(5 / 3))ã€nä¸Žmç­‰ä»·ã€‘ï¼Œè¿™åœ¨æ—¶é™ä¸‹åŸºæœ¬æ˜¯å¯ä»¥å¾—åˆ°ç­”æ¡ˆçš„ã€‚ &gt; é‚£ä¹ˆè¿˜æœ‰ä¸ªé—ç•™çš„é—®é¢˜ï¼Œå¦‚ä½•å¤„ç†æ—¶é—´ã€‚æˆ‘ä»¬åªéœ€è¦è®°å½•ä¿®æ”¹å‰å’Œä¿®æ”¹åŽè¯¥ç‚¹çš„å€¼å°±å¯ä»¥äº†ã€‚ &gt; è‡³æ­¤è¿™ä¸ªé—®é¢˜å®Œç¾Žè§£å†³ã€‚ æ€»ç»“ ä¹Ÿè®¸èŽ«é˜Ÿæ˜¯ä¸€ç§çœ‹èµ·æ¥å¤æ‚åº¦éžå¸¸é«˜çš„ç®—æ³•ï¼Œä½†å¦‚æžœåˆç†åœ°å¤„ç†å¥½åˆ†å—çš„å¤§å°å’Œè¯¢é—®çš„é¡ºåºï¼Œï¼Œå®ƒä¾¿å¯ä»¥å˜æˆä¸€ä¸ªæžå…¶æœ‰æ•ˆçš„å·¥å…·ã€‚ è¾žè°¢ Vfleakingã€èŽ«æ¶› å‚è€ƒæ–‡çŒ® å›½å®¶é›†è®­é˜Ÿå‘½é¢˜ã€Šå°zçš„è¢œå­ã€‹]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>æš´åŠ›</tag>
        <tag>æ•°æ®ç»“æž„</tag>
        <tag>èŽ«é˜Ÿ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 617E XOR and Favorite Number]]></title>
    <url>%2F2017%2F07%2F13%2FCodeForces-617E-XOR-and-Favorite-Number%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® Bob has a favorite number k and *a**i* of length n. Now he asks you to answer m queries. Each query is given by a pair *l**i* and *r**i* and asks you to count the number of pairs of integers i and j, such that l â‰¤ i â‰¤ j â‰¤ r and the xor of the numbers ai, ai + 1, ..., *a**j* is equal to k. Input The first line of the input contains integers n, m and k (1 â‰¤ n, m â‰¤ 100 000, 0 â‰¤ k â‰¤ 1 000 000) â€” the length of the array, the number of queries and Bob's favorite number respectively. The second line contains n integers *a**i* (0 â‰¤ *a**i* â‰¤ 1 000 000) â€” Bob's array. Then m lines follow. The i-th line contains integers *l**i* and *r**i* (1 â‰¤ li â‰¤ ri â‰¤ n) â€” the parameters of the i-th query. Output Print m lines, answer the queries in the order they appear in the input. Examples input 6 2 3 1 2 1 1 0 3 1 6 3 5 output 7 0 input 5 3 1 1 1 1 1 1 1 5 2 4 1 3 output 9 4 4 Note In the first sample the suitable pairs of i and j for the first query are: (1, 2), (1, 4), (1, 5), (2, 3), (3, 6), (5, 6), (6, 6). Not a single of these pairs is suitable for the second query. In the second sample xor equals 1 for all subarrays of an odd length. åˆ†æž å¤šæ¬¡è¯¢é—®æ²¡æœ‰ä¿®æ”¹ï¼Œå…¸åž‹çš„èŽ«é˜Ÿé—®é¢˜ã€‚ åˆšå­¦èŽ«é˜Ÿçš„ç¬¬ä¸€é“é¢˜ç›®æ‰€ä»¥è®²ç®€å•çš„ä»‹ç»ä¸€ä¸‹ ä¼ é€é—¨ cnt[]è¡¨ç¤ºcnt[åœ¨[l - 1, r]ä¹‹é—´å‡ºçŽ°çš„å‰ç¼€]åœ¨[l - 1, r]ä¹‹é—´å‡ºçŽ°çš„çš„æ•°é‡ é¦–å…ˆå¤„ç†å¥½å‰ç¼€å¼‚æˆ–å’Œï¼Œæ³¨æ„å¤„ç†çš„æ•°æ®æ˜¯[l - 1, r]å› ä¸ºäº‹å®žä¸Šè¿™é‡Œçš„èŽ«é˜Ÿè‡ªå¸¦å·¦å¼€å³é—­å±žæ€§(ç”±äºŽç”¨å‰ç¼€å’Œå¤„ç†)ï¼Œåœ¨è¿™é‡Œå¡äº†å¾ˆä¹…ã€‚ ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** @Author: sun000* @Date: 2017-07-13 10:13:19* @Last Modified by: sun000* @Last Modified time: 2017-07-13 15:54:49*/#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e5 +10;int n, m, block = 1;int cnt[1048586];long long int num[MAXN];long long int k;struct SEC &#123; int l, r, id; long long int ans; SEC()&#123;&#125;&#125;sec[MAXN];bool cmp_block(SEC a, SEC b) &#123; if(a.l / block == b.l / block) return a.r &lt; b.r; return a.l &lt; b.l;&#125;bool cmp_id(SEC a, SEC b) &#123; return a.id &lt; b.id;&#125;long long int nans;void plus(int in) &#123; nans += cnt[num[in] ^ k]; cnt[num[in]]++;&#125;void dec(int in) &#123; cnt[num[in]]--; nans -= cnt[num[in] ^ k];&#125;int main(void) &#123; memset(cnt, 0, sizeof(cnt)); scanf("%d%d%lld", &amp;n, &amp;m, &amp;k); block = (int)sqrt(n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%lld", &amp;num[i]); num[i] ^= num[i - 1]; &#125; for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d", &amp;sec[i].l, &amp;sec[i].r); sec[i].id = i; sec[i].l--;//æŸ¥è¯¢[l,r]æ˜¯num[r]å‰ç¼€ä¸Žnum[l - 1]å‰ç¼€å¤„ç†çš„ç»“æžœ sec[i].ans = 0; &#125; sort(sec, sec + m, cmp_block); int l = 0, r = 0; nans = 0, cnt[0] = 1; for(int i = 0; i &lt; m; i++) &#123; while(l &gt; sec[i].l) plus(--l); while(r &lt; sec[i].r) plus(++r); while(l &lt; sec[i].l) dec(l++); while(r &gt; sec[i].r) dec(r--); sec[i].ans = nans; &#125; sort(sec, sec + m, cmp_id); for(int i = 0; i &lt; m; i++) printf("%lld\n", sec[i].ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>æš´åŠ›</tag>
        <tag>æ•°æ®ç»“æž„</tag>
        <tag>èŽ«é˜Ÿ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces161D Distance in Tree]]></title>
    <url>%2F2017%2F07%2F09%2FCodeForces161D-Distance-in-Tree%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® A tree is a connected graph that doesn't contain any cycles. The distance between two vertices of a tree is the length (in edges) of the shortest path between these vertices. You are given a tree with n vertices and a positive number k. Find the number of distinct pairs of the vertices which have a distance of exactly k between them. Note that pairs (v, u) and (u, v) are considered to be the same pair. Input The first line contains two integers n and k (1 â‰¤ n â‰¤ 50000, 1 â‰¤ k â‰¤ 500) â€” the number of vertices and the required distance between the vertices. Next n - 1 lines describe the edges as &quot;*a**i* bi&quot; (without the quotes) (1 â‰¤ ai, bi â‰¤ n, ai â‰  bi), where ai and *b**i* are the vertices connected by the i-th edge. All given edges are different. Output Print a single integer â€” the number of distinct pairs of the tree's vertices which have a distance of exactly k between them. Please do not use the %lld specifier to read or write 64-bit integers in Ð¡++. It is preferred to use the cin, cout streams or the %I64dspecifier. Examples input 5 2 1 2 2 3 3 4 2 5 output 4 input 5 3 1 2 2 3 3 4 4 5 output 2 Note In the first sample the pairs of vertexes at distance 2 from each other are (1, 3), (1, 5), (3, 5) and (2, 4). åˆ†æž å®šä¹‰ä¸€ä¸ªdp[i][j]è¡¨ç¤ºiçš„å­æ ‘ä¸­è·ç¦»içš„è·ç¦»ä¸ºjçš„ç‚¹çš„ä¸ªæ•°ã€‚ç”¨ä¸€ä¸ªdfsæ±‚dpçš„å€¼ï¼Œç„¶åŽæ±‚ç­”æ¡ˆï¼Œåˆ™iå­æ ‘ä¸­åŒ…å«çš„ans=sum{dp[son[i]][j - 1] * (dp[i][k - j] - dp[son[i]][k - j - 1])} æ³¨æ„æ•°æ®èŒƒå›´long long ans ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** @Author: sun000* @Date: 2017-07-09 11:05:44* @Last Modified by: sun000* @Last Modified time: 2017-07-09 12:58:06*/#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int dp[50010][505];vector&lt;int&gt; e[50010];int n, k;long long int ans;void addedge(int u, int v) &#123; e[u].push_back(v); e[v].push_back(u);&#125;void dfs(int s, int pre) &#123; int u, v; if(e[s].size() == 1 &amp;&amp; e[s][0] == pre) return; for(int i = 0; i &lt; e[s].size(); i++) &#123; v = e[s][i]; if(v != pre) &#123; dfs(v, s); for(int j = 1; j &lt;= k; j++) dp[s][j] += dp[v][j - 1]; &#125; &#125; long long int temp = 0; for(int i = 0; i &lt; e[s].size(); i++) &#123; u = e[s][i]; if (u != pre) &#123; temp += dp[u][k - 1] * 2; for(int l = 1; l &lt; k; l++) temp += dp[u][l - 1] * (dp[s][k - l] - dp[u][k - l - 1]); &#125; &#125; ans += temp / 2;&#125;void debug() &#123; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= k; j++) printf("dp[%d][%d] = %d\n", i, j, dp[i][j]);&#125;int main(void)&#123; int u, v; scanf("%d%d", &amp;n, &amp;k); for(int i = 0; i &lt; n - 1; i++) &#123; scanf("%d%d", &amp;u, &amp;v); addedge(u, v); &#125; if(k == 1) &#123; printf("%d\n", n - 1); return 0; &#125; memset(dp, 0, sizeof(dp)); for(int i = 1; i &lt;= n; i++) dp[i][0] = 1; ans = 0; dfs(1, 0); // debug(); printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>æ ‘å½¢DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces13E Holes]]></title>
    <url>%2F2017%2F07%2F09%2FCodeForces13E-Holes%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® Little Petya likes to play a lot. Most of all he likes to play a game Â«HolesÂ». This is a game for one person with following rules: There are N holes located in a single row and numbered from left to right with numbers from 1 to N. Each hole has it's own power (hole number i has the power a i). If you throw a ball into hole i it will immediately jump to hole i + a i, then it will jump out of it and so on. If there is no hole with such number, the ball will just jump out of the row. On each of the M moves the player can perform one of two actions: Set the power of the hole a to value b. Throw a ball into the hole a and count the number of jumps of a ball before it jump out of the row and also write down the number of the hole from which it jumped out just before leaving the row. Petya is not good at math, so, as you have already guessed, you are to perform all computations. Input The first line contains two integers N and M (1 â‰¤ N â‰¤ 105, 1 â‰¤ M â‰¤ 105) â€” the number of holes in a row and the number of moves. The second line contains N positive integers not exceeding N â€” initial values of holes power. The following M lines describe moves made by Petya. Each of these line can be one of the two types: 0 a b 1 a Type 0 means that it is required to set the power of hole a to b, and type 1 means that it is required to throw a ball into the a-th hole. Numbers a and b are positive integers do not exceeding N. Output For each move of the type 1 output two space-separated numbers on a separate line â€” the number of the last hole the ball visited before leaving the row and the number of jumps it made. Examples input 8 5 1 1 1 1 1 2 8 2 1 1 0 1 3 1 1 0 3 4 1 2 output 8 7 8 5 7 3 åˆ†æž åˆ†å—å¤„ç†ï¼ŒæŠŠæ¯ä¸€ä¸ªç»™å®šçš„æ•°ç»„åˆ†æˆkå—ï¼Œåˆ™åªè¦æ›´æ–°çš„æ—¶å€™åªè¦æ›´æ–°å—å†…å°±å¥½äº†ï¼ŒæŸ¥è¯¢çš„æ—¶å€™æŸ¥è¯¢æ‰€æœ‰å—ï¼Œæ¯ä¸ªå—å†…æŸ¥è¯¢æ—¶é—´å¤æ‚åº¦æ˜¯o(1)ï¼Œåˆ™æŸ¥è¯¢çš„æ—¶é—´å¤æ‚åº¦æ˜¯nï¼kã€‚è¿™æ ·çš„è¯ï¼Œæ€»æ—¶é—´å¤æ‚åº¦æ˜¯o(m*(k+n / k)), æ˜¾ç„¶ï¼Œå½“kæ˜¯âˆšnçš„æ—¶å€™æœ€ä¼˜ï¼Œæ­¤æ—¶çš„æ—¶é—´å¤æ‚çš„æ˜¯mâˆšn ä»£ç  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** @Author: sun000* @Date: 2017-07-09 08:08:59* @Last Modified by: sun000* @Last Modified time: 2017-07-09 09:24:56*/#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e5 + 10;int n, m, block;int p[MAXN];int cnt[MAXN];//ä»Žiè·³å‡ºå½“å‰å—çš„æ­¥æ•°int la[MAXN];//ä»Žè·³å‡ºå½“å‰ä½ç½®åœ¨è¯¥å—ä¸­ç»è¿‡çš„æœ€åŽä¸€ä¸ªä½ç½®void update_one(int a, int b) &#123;//æ›´æ–°ä¸€ä¸ªä¸‹æ ‡ if(b &gt;= n) &#123;//è·³å‡º la[a] = a; cnt[a] = 1; &#125; else if(a / block == b / block) &#123;//åŒä¸€ä¸ªå—ä¸­ cnt[a] = cnt[b] + 1; la[a] = la[b]; &#125; else &#123;//è·³åˆ°å…¶ä»–å— cnt[a] = 1; la[a] = a; &#125;&#125;void update(int a, int b) &#123;//æ›´æ–°æ‰€æœ‰ï¼Œå³æ›´æ–°å½“å‰æ®µ p[a] = b; int now = a / block * block; for(int i = a; i &gt;= now; i--) &#123; update_one(i, i + p[i]); &#125;&#125;void init() &#123; for(int i = n - 1; i &gt;= 0; i--) update_one(i, i + p[i]);&#125;int las;int query(int a) &#123; if(la[a] + p[la[a]] &gt;= n) &#123; las = la[a] + 1; return cnt[a]; &#125; else return cnt[a] + query(la[a] + p[la[a]]);&#125;void debug() &#123; for(int i = 0; i &lt; n; i++) printf("%d ", cnt[i]); printf("\n"); for(int i = 0; i &lt; n; i++) printf("%d ", la[i]); printf("\n");&#125;int main(void)&#123; scanf("%d%d", &amp;n, &amp;m); block = (int)sqrt(n); for(int i = 0; i &lt; n; i++) scanf("%d", &amp;p[i]); init(); // printf("block %d\n", block); // debug(); int op, a, b; for(int i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;op); if(!op) &#123; scanf("%d%d", &amp;a, &amp;b); update(a - 1, b); &#125; else &#123; scanf("%d", &amp;a); int ans = query(a - 1); printf("%d %d\n", las, ans); &#125; // debug(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>åˆ†å—</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces546E Soldier and Traveling]]></title>
    <url>%2F2017%2F07%2F08%2FCodeForces546E-Soldier-and-Traveling%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® In the country there are n cities and m bidirectional roads between them. Each city has an army. Army of the i-th city consists of *a**i*soldiers. Now soldiers roam. After roaming each soldier has to either stay in his city or to go to the one of neighboring cities by at moving along at most one road. Check if is it possible that after roaming there will be exactly *b**i* soldiers in the i-th city. Input First line of input consists of two integers n and m (1 â‰¤ n â‰¤ 100, 0 â‰¤ m â‰¤ 200). Next line contains n integers a1, a2, ..., *a**n* (0 â‰¤ *a**i* â‰¤ 100). Next line contains n integers b1, b2, ..., *b**n* (0 â‰¤ *b**i* â‰¤ 100). Then m lines follow, each of them consists of two integers p and q (1 â‰¤ p, q â‰¤ n, p â‰  q) denoting that there is an undirected road between cities p and q. It is guaranteed that there is at most one road between each pair of cities. Output If the conditions can not be met output single word &quot;NO&quot;. Otherwise output word &quot;YES&quot; and then n lines, each of them consisting of n integers. Number in the i-th line in the j-th column should denote how many soldiers should road from city i to city j (if i â‰  j) or how many soldiers should stay in city i (if i = j). If there are several possible answers you may output any of them. Examples input 4 4 1 2 6 3 3 5 3 1 1 2 2 3 3 4 4 2 output YES 1 0 0 0 2 0 0 0 0 5 1 0 0 0 2 1 input 2 0 1 2 2 1 output NO åˆ†æž åƒè¿™ç§ç”±açŠ¶æ€è½¬ç§»åˆ°çŠ¶æ€çš„éƒ½å¯ä»¥ç”¨ç½‘ç»œæµæ¥å†™ï¼Œæºç‚¹0åˆ°[1,n]è¿™äº›ç‚¹çš„æµé‡åˆ†åˆ«æ˜¯a[i],[n + 1, 2n]åˆ°æ±‡ç‚¹2n + 1çš„æµé‡åˆ†åˆ«æ˜¯b[i - n];(å£«å…µåªèƒ½æµåŠ¨ä¸€æ¬¡æ‰€ä»¥æ‹†ç‚¹)ã€‚åœ¨ç‚¹iå’Œi+nä¹‹é—´è¿žè¾¹æµé‡æ— é™å¤§ï¼Œå³å£«å…µåœ¨è‡ªå·±çš„åŸŽå¸‚ä¸ç§»åŠ¨ï¼Œè‹¥åŸŽå¸‚é—´æœ‰è¾¹[i,j]åˆ™åœ¨ç½‘ç»œæµçš„å›¾ä¸­è¿žè¾¹[i, j + n]å’Œ[j, i + n]ï¼Œè¾¹çš„æµé‡éƒ½æ˜¯æ— é™å¤§ã€‚æœ€åŽåªè¦åˆ¤æ–­æœ€å¤§æµæ˜¯ä¸æ˜¯ç­‰äºŽå¼€å§‹çŠ¶æ€çš„å£«å…µå’Œå¹¶ç­‰äºŽç»“æŸçŠ¶æ€çš„å£«å…µå’Œï¼Œå¦‚æžœç­”æ¡ˆå¯è¡Œè¦è¾“å‡ºæµçš„æ–¹å¼ï¼Œåˆ™åªè¦è¾“å‡ºæ®‹é‡ç½‘ç»œä¸­çš„åå‘è¾¹æµé‡å°±å¥½äº†ï¼Œè¡¨ç¤ºç”¨æŽ‰çš„æµé‡ã€‚ ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/** @Author: sun000* @Date: 2017-07-08 16:15:42* @Last Modified by: sun000* @Last Modified time: 2017-07-08 21:41:12*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int MAXN = 210;const int INF = 0x3f3f3f3f;struct node &#123; int u, v, next, flow;&#125;;node edge[MAXN * MAXN];int head[MAXN], dis[MAXN];int cnt;//è¾¹æ•°void init() &#123; memset(head, -1, sizeof(head)); memset(dis, -1, sizeof(dis)); cnt = 0;&#125;void addedge(int a, int b, int c) &#123; edge[cnt].u = a; edge[cnt].v = b; edge[cnt].flow = c; edge[cnt].next = head[a]; head[a] = cnt++;//åå‘è¾¹(å¶æ•°ä¸‹æ ‡æ­£å‘è¾¹ï¼Œå¥‡æ•°ä¸‹æ ‡åå‘è¾¹) edge[cnt].u = b; edge[cnt].v = a; edge[cnt].flow = 0; edge[cnt].next = head[b]; head[b] = cnt++;&#125;bool bfs(int sp, int tp) &#123;// ç»™å„ç‚¹åˆ†å±‚ï¼Œç¦»æºç‚¹çš„è¿œè¿‘åˆ† memset(dis, -1, sizeof(dis)); queue&lt;int&gt; q; dis[sp] = 0; q.push(sp); int cur; while(!q.empty()) &#123; cur = q.front(); q.pop(); for(int i = head[cur]; i != -1; i = edge[i].next) &#123; if (dis[edge[i].v] == -1 &amp;&amp; edge[i].flow &gt; 0) &#123; dis[edge[i].v] = dis[cur] + 1; q.push(edge[i].v); &#125; &#125; &#125; if (dis[tp] &lt; 0) return false; return true;&#125;int Find(int x, int low, int tp) &#123; //æ‰¾å¢žå¹¿ int temp; if (x == tp) return low; for (int i = head[x]; i != -1; i = edge[i].next) &#123; int v = edge[i].v; if (dis[v] == dis[x] + 1 &amp;&amp; edge[i].flow &gt; 0 &amp;&amp; (temp = Find(v, min(low, edge[i].flow), tp))) &#123; edge[i].flow -= temp; edge[i ^ 1].flow += temp; return temp; &#125; &#125; return 0;&#125;int dinic(int sp, int tp) &#123; int ans = 0; while (bfs(sp, tp)) ans += Find(sp, INF, tp); return ans;&#125;int main(void) &#123; int n, m, temp, u, v; int sum1 = 0, sum2 = 0; scanf("%d%d", &amp;n, &amp;m); init(); int sp = 0;//æºç‚¹ int tp = 2 * n + 1;//æ±‡ç‚¹ for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;temp); addedge(sp, i, temp); sum1 += temp; addedge(i, i + n, INF); &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;temp); sum2 += temp; addedge(i + n, tp, temp); &#125; for (int i = 0; i &lt; m; i++) &#123; scanf("%d%d", &amp;u, &amp;v); addedge(u, v + n, INF); addedge(v , u + n, INF); &#125; int ans = dinic(sp, tp); if (ans == sum1 &amp;&amp; ans == sum2) &#123; printf("YES\n"); int g[110][110], r; memset(g, 0, sizeof(g)); for(int i = 1; i &lt; cnt; i += 2) &#123; u = edge[i].u; v = edge[i].v; r = edge[i].flow; if(u &gt; n) u -= n; if(v &gt; n) v -= n; g[v][u] = r; &#125; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) printf("%d%c", g[i][j], j == n ? '\n' : ' '); &#125; else printf("NO\n"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>å›¾è®º</tag>
        <tag>å»ºå›¾</tag>
        <tag>ç½‘ç»œæµ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces754D Fedor and coupons]]></title>
    <url>%2F2017%2F07%2F08%2FCodeForces754DFedor-and-coupons%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® All our characters have hobbies. The same is true for Fedor. He enjoys shopping in the neighboring supermarket. The goods in the supermarket have unique integer ids. Also, for every integer there is a product with id equal to this integer. Fedor has ndiscount coupons, the i-th of them can be used with products with ids ranging from *l**i* to *r**i, inclusive. Today Fedor wants to take exactly k*coupons with him. Fedor wants to choose the k coupons in such a way that the number of such products x that all coupons can be used with this product xis as large as possible (for better understanding, see examples). Fedor wants to save his time as well, so he asks you to choose coupons for him. Help Fedor! Input The first line contains two integers n and k (1 â‰¤ k â‰¤ n â‰¤ 3Â·105) â€” the number of coupons Fedor has, and the number of coupons he wants to choose. Each of the next n lines contains two integers *l**i* and *r**i* ( - 109 â‰¤ li â‰¤ ri â‰¤ 109) â€” the description of the i-th coupon. The coupons can be equal. Output In the first line print single integer â€” the maximum number of products with which all the chosen coupons can be used. The products with which at least one coupon cannot be used shouldn't be counted. In the second line print k distinct integers p1, p2, ..., *p**k* (1 â‰¤ *p**i â‰¤ n*) â€” the ids of the coupons which Fedor should choose. If there are multiple answers, print any of them. Examples input 4 2 1 100 40 70 120 130 125 180 output 31 1 2 input 3 2 1 12 15 20 25 30 output 0 1 2 input 5 2 1 10 5 15 14 50 30 70 99 100 output 21 3 4 Note In the first example if we take the first two coupons then all the products with ids in range [40, 70] can be bought with both coupons. There are 31 products in total. In the second example, no product can be bought with two coupons, that is why the answer is 0. Fedor can choose any two coupons in this example. åˆ†æž è´ªå¿ƒï¼šè‹¥å­˜åœ¨ç­”æ¡ˆï¼Œåˆ™æ˜¾ç„¶è¿™äº›åŒºé—´æ˜¯ç›¸é‚»çš„ï¼Œè¿™æ˜¯æœ€ä¼˜çš„ã€‚ å°†åŒºé—´[l,r]æŒ‰ç…§lä»Žå°åˆ°è¾¾æŽ’åºï¼Œå°†åŒºé—´æ”¾åˆ°ä¸€ä¸ªå…³äºŽrçš„æœ€å°å †é‡Œï¼Œåˆ™ç»´æŠ¤ä¸€ä¸ªå¤§å°ä¸ºkçš„æœ€å°å †ï¼Œæœ‰ä¸€ä¸ªåŒºé—´[l0,r0]ï¼Œå°†è¿™ä¸ªåŒºé—´æ”¾å…¥å †ä¸­åŽï¼Œå°†å †ä¸­æ‰€æœ‰rå°äºŽl0çš„åŒºé—´popï¼Œå½“å †çš„å¤§å°å°äºŽkæ—¶ï¼Œä¸æ»¡è¶³è¦æ±‚ï¼›å½“å †çš„å¤§å°æ˜¯kæ—¶ï¼Œæ˜¾ç„¶è¿™äº›åŒºé—´æ˜¯æ»¡è¶³è¦æ±‚çš„ï¼Œæ±‚å¾—ä¸€ä¸ªç­”æ¡ˆäºŽä¸ŽåŽŸç­”æ¡ˆå–Maxï¼›è‹¥å †çš„å¤§å°å¤§äºŽkæ—¶ï¼Œåˆ™popä¸€ä¸ªåŒºé—´ï¼ˆè¿™ä¸ªåŒºé—´æ˜¯ræœ€å°çš„ï¼Œæ˜¾ç„¶è¿™æ ·æ˜¯æœ€ä¼˜çš„ï¼Œè¿™ä¹Ÿæ˜¯ä¸€ä¸ªè´ªå¿ƒï¼‰ã€‚ ä»£ç  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** @Author: sun000* @Date: 2017-07-08 14:31:47* @Last Modified by: sun000* @Last Modified time: 2017-07-08 15:14:45*/#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 3e5 + 10;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;struct SEC &#123; int l, r, in; SEC() &#123;&#125; SEC(int _l, int _r): l(_l), r(_r) &#123;&#125; bool operator &lt; (const SEC &amp;s) const &#123;//ç”¨äºŽsortæŽ’åº return l &lt; s.l; &#125; bool operator &gt; (const SEC &amp;s) const &#123;//ç”¨äºŽä¼˜å…ˆé˜Ÿåˆ—æŽ’åº return r &gt; s.r; &#125;&#125; sec[MAXN];int main(void)&#123; int n, k, ans = 0; scanf("%d%d", &amp;n, &amp;k); for (int i = 0; i &lt; n; i++) &#123; scanf("%d%d", &amp;sec[i].l, &amp;sec[i].r); sec[i].in = i + 1; &#125; sort(sec, sec + n); for (int i = 0; i &lt; n; i++) &#123; while (!q.empty() &amp;&amp; q.top() &lt; sec[i].l) q.pop(); q.push(sec[i].r); while (q.size() &gt; k) q.pop(); if (q.size() == k) ans = max(ans, q.top() - sec[i].l + 1); &#125; printf("%d\n", ans); if (!ans) for (int i = 0; i &lt; k; i++) printf("%d%c", i + 1, i == k - 1 ? '\n' : ' '); else &#123; int temp = 0; priority_queue&lt;SEC, vector&lt;SEC&gt;, greater&lt;SEC&gt;&gt; g; for (int i = 0; i &lt; n; i++) &#123; while (!g.empty() &amp;&amp; (g.top()).r &lt; sec[i].l) g.pop(); g.push(sec[i]); while (g.size() &gt; k) g.pop(); if (g.size() == k) &#123; temp = max(temp, (g.top()).r - sec[i].l + 1); if (temp == ans) &#123; for (int j = 0; j &lt; k; j++) &#123; printf("%d%c", (g.top()).in, j == k - 1 ? '\n' : ' '); g.pop(); &#125; break; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>è´ªå¿ƒ</tag>
        <tag>ä¼˜å…ˆé˜Ÿåˆ—</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces755F PolandBall and Gifts]]></title>
    <url>%2F2017%2F07%2F08%2FCodeForces755F-PolandBall-and-Gifts%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® It's Christmas time! PolandBall and his friends will be giving themselves gifts. There are n Balls overall. Each Ball has someone for whom he should bring a present according to some permutation p, *p**i â‰  i* for all i. Unfortunately, Balls are quite clumsy. We know earlier that exactly k of them will forget to bring their gift. A Ball number i will get his present if the following two constraints will hold: Ball number i will bring the present he should give. Ball x such that *p**x = i* will bring his present. What is minimum and maximum possible number of kids who will not get their present if exactly k Balls will forget theirs? Input The first line of input contains two integers n and k (2 â‰¤ n â‰¤ 106, 0 â‰¤ k â‰¤ n), representing the number of Balls and the number of Balls who will forget to bring their presents. The second line contains the permutation p of integers from 1 to n, where *p**i* is the index of Ball who should get a gift from the i-th Ball. For all i, *p**i â‰  i* holds. Output You should output two values â€” minimum and maximum possible number of Balls who will not get their presents, in that order. Examples input 5 2 3 4 1 5 2 output 2 4 input 10 1 2 3 4 5 6 7 8 9 10 1 output 2 2 Note In the first sample, if the third and the first balls will forget to bring their presents, they will be th only balls not getting a present. Thus the minimum answer is 2. However, if the first ans the second balls will forget to bring their presents, then only the fifth ball will get a present. So, the maximum answer is 4. åˆ†æž å»ºå›¾ï¼šè®¾aè¦ç»™bå¸¦ç¤¼ç‰©ï¼Œåˆ™åœ¨åœ¨a-&gt;bä¹‹é—´è¿žä¸€æ¡æœ‰å‘è¾¹ï¼Œ åˆ™æœ€åŽçš„å›¾æ˜¯è‹¥å¹²ä¸ªçŽ¯ï¼Œå¹¶ä¸”æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„å…¥åº¦å’Œå‡ºåº¦éƒ½æ˜¯1ï¼Œå³æ¯ä¸ªçŽ¯ä¹‹é—´æ²¡æœ‰äº¤ç‚¹ï¼Œå› ä¸ºæ¯ä¸ªæ²¡æœ‰å¸¦ç¤¼ç‰©çš„äººä¼šå¯¼è‡´è¦ä»Žä»–ç€èŽ·å¾—ç¤¼ç‰©çš„äººå’Œä»–è‡ªå·±éƒ½æ²¡æœ‰ç¤¼ç‰©ï¼Œåˆ™æœ€åæƒ…å†µæ˜¯ä¸€ä¸ªè´ªå¿ƒï¼šå°½é‡ä½¿ä¸€ä¸ªæ²¡å¸¦ç¤¼ç‰©çš„äººå¯¼è‡´ä¸¤ä¸ªäººä¸èƒ½æ”¶åˆ°ç¤¼ç‰©ã€‚æœ€å°çš„æƒ…å†µçš„è¯ï¼Œå°±æ˜¯ä½¿è¦ä»Žæ²¡å¸¦ç¤¼ç‰©çš„äººé‚£é‡ŒèŽ·å¾—ç¤¼ç‰©çš„äººè‡ªå·±ä¹Ÿæ²¡æœ‰å¸¦ç¤¼ç‰©ï¼Œåˆ™è¿™æ ·çš„è¯å°±æ˜¯å°½é‡é€‰æ‹©ä¸€äº›åœ¨å›¾ä¸­è¿žç»­çš„ç‚¹ä¹ˆï¼Œè¿™æ ·çš„è¯æ³¨æ„åˆ°è¿™ä¸ªåºåˆ—çš„æœ€åŽä¸€ä¸ªç‚¹ä¼šå¯¼è‡´ä»–çš„ä¸‹ä¸€ä¸ªç‚¹ä¹Ÿæ”¶ä¸åˆ°ç¤¼ç‰©ï¼Œè¿™æ ·çš„è¯å¯ä¼šå¯¼è‡´å¤šä¸€ä¸ªäººæ”¶ä¸åˆ°ç¤¼ç‰©ï¼Œä½†æ˜¯å¦‚æžœè¿™ä¸ªåºåˆ—åˆšå¥½æ˜¯ä¸€ä¸ªçŽ¯çš„è¯ï¼Œåˆ™æ²¡æœ‰è¿™ç§æƒ…å†µï¼Œç»¼åˆè€ƒè™‘ï¼Œè¿™ä¸ªåºåˆ—å¯ä»¥å°½é‡é€‰æ‹©ä¸€äº›çŽ¯ï¼Œåˆ™å¦‚æžœæ°å¥½å­˜åœ¨ä¸€äº›çŽ¯çš„ç‚¹æ•°å’Œä¸ºkçš„è¯æœ€å°ç­”æ¡ˆå°±æ˜¯kå¦åˆ™å°±æ˜¯k+1ï¼Œè¿™æ ·çš„è¯é—®é¢˜å°±å˜æˆé‡Œæ±‚ç»™å®šçš„ä¸€äº›çŽ¯æ˜¯å¦èƒ½æ°å¥½æ±‚å’Œæˆkï¼Œè¿™æ˜¯ä¸€ä¸ªå¤šé‡èƒŒåŒ…ï¼Œè€ƒè™‘åˆ°æ—¶é—´å¤æ‚åº¦ï¼Œéœ€è¦ç”¨äºŒè¿›åˆ¶ä¼˜åŒ–å’Œbitsetä¼˜åŒ–ã€‚ ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** @Author: sun000* @Date: 2017-07-07 18:07:58* @Last Modified by: sun000* @Last Modified time: 2017-07-07 18:46:08*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;bitset&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int p[1000010];int num[1000010];int c[500010];bitset&lt;1000010&gt; dp;int cnt;void init(int s) &#123; for(int i = 0; i &lt;= s; i++) &#123; p[i] = i; num[i] = 1; &#125;&#125;int fin(int x) &#123; if(p[x] == x) return x; return p[x] = fin(p[x]);&#125;bool un(int x, int y) &#123; int a = fin(x); int b = fin(y); if(a == b) &#123; c[cnt++] = num[a]; return true; &#125; p[a] = b; num[b] += num[a]; return false;&#125;int main(void) &#123; cnt = 0; int n, k, temp; scanf("%d%d", &amp;n, &amp;k); init(n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;temp); un(i, temp); &#125; sort(c, c + cnt); int maxans; int co = 0, odd = 0; for(int i = 0; i &lt; cnt; i++) &#123; co += c[i] &gt;&gt; 1; if(c[i] &amp; 1) odd++; &#125; if(co &gt;= k) maxans = k * 2; else maxans = min(n, co * 2 + (k - co)); c[cnt++] = -1; int s = 0, pre = c[0], now = 1; for(int i = 1; i &lt; cnt; i++) &#123; if(pre == c[i]) now++; else &#123; int g = 1; while(now) &#123; now -= g; c[s++] = pre * g; g &lt;&lt;= 1; while(now - g &lt; 0) g &gt;&gt;= 1; &#125; now = 1; pre = c[i]; &#125; &#125; cnt = s; int minans = k + 1; dp.reset(); dp.set(0); for(int i = 0; i &lt; cnt; i++) dp |= (dp &lt;&lt; c[i]); if(dp[k]) minans--; printf("%d %d\n", minans, maxans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>å›¾è®º</tag>
        <tag>è´ªå¿ƒ</tag>
        <tag>BITSET</tag>
        <tag>èƒŒåŒ…</tag>
        <tag>å¹¶æŸ¥é›†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ITMOSummerCampDay1 GPick Your Team]]></title>
    <url>%2F2017%2F07%2F05%2FITMOSummerCampDay1GPick-Your-Team%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® This is it. The final battle between EPFL and Mars. The rules of the game are as follows. Neither side wants to sacrifice their own people, so we will be picking two teams of Unil students to fight each other instead. You have been chosen to pick the team that will fight for EPFL's honour! You are given a list containing the strength of each Unil student. You start by choosing one student to join your team, then the Martians will choose another student, and so on, until all n students are chosen. If you had no extra information, clearly you'd pick the strongest Unil student in each turn. However, we managed to figure out the preference of the Martians. More specifically, we have a permutation P of the first n numbers, representing the indices of the Unil students, which the Martians prefer to pick in order. Take a look at the example inputs to understand this further. You want to pick the team that maximises the difference between your team's strength and theirs. What's the maximum difference? Input The first line of the input has of an even integer n (2 â‰¤ n â‰¤ 100), the number of Unil students. The next line contains n space-separated integers si, the strength of each student (1 â‰¤ si â‰¤ 107). The last line contains n space-separated integers between 1 and n, representing the permutation P. Output Print the maximum difference in strength between your team and the Martians' team. Examples input 4 3 9 1 7 4 1 2 3 output 12 input 10 1 1 2 3 4 5 6 6 8 10 9 8 7 6 5 4 10 1 2 3 output 14 Note In the first example, there are four Unil students with strengths 3, 9, 1, 7. The Martians prefer to pick them in this order: 4, 1, 2, 3. This means that in their first turn, they'll pick student 4 (strength = 7) if that student hadn't been picked, otherwise they'll pick the next student on their list (student 1, strength = 3). If you had used the simple strategy of picking the strongest available student each turn, you'd have ended up with a total strength of 9 + 3 = 12, and the Martians with 7 + 1 = 8, giving you a difference of 4. Given this extra information, you can first pick student 4 (strength = 7), then student 2 (strength = 9) in your next turn. You'd have a difference of 9 + 7 - 3 - 1 = 12. In this case, this is the best strategy. åˆ†æž: æŒ‰ç…§ç«æ˜Ÿäººçš„é€‰æ‹©é¡ºåºæ¥é€‰ï¼Œåˆ™å‰2kä¸ªç«æ˜Ÿäººæœ€å°‘åªèƒ½é€‰kä¸ªï¼Œé‚£ä¹ˆå€’è¿‡æ¥è€ƒè™‘ï¼ŒåŽ2kä¸ªåœ°çƒäººè‡³å°‘èƒ½é€‰kä¸ªï¼Œåˆ™ç”¨ä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—ï¼Œä»ŽåŽå¾€å‰ï¼Œåœ°çƒäººæ¯æ¬¡å¾—åˆ°ä¸¤ä¸ªæ–°çš„å¯é€‰æ‹©çš„ï¼Œä»Žæ€»å…±çš„å¯é€‰æ‹©çš„é‡Œé¢é€‰åŽ»ä¸€ä¸ªï¼Œè¿™ç§é€‰æ‹©å¯¹äºŽåœ°çƒäººæ¥è¯´æ˜¯å¯ä»¥åšåˆ°çš„ï¼Œç”¨ä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—æ¥ä¿è¯åœ°çƒäººçš„é€‰æ‹©æœ€ä¼˜ã€‚ ä»£ç  1234567891011121314151617181920212223242526272829303132333435363738/** @Author: sun000* @Date: 2017-07-05 18:37:42* @Last Modified by: sun000* @Last Modified time: 2017-07-08 13:09:59*/#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q;int num[110], p[110];int main(void) &#123; int n, sum = 0; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;num[i]); sum += num[i]; &#125; for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;p[i]); int ans = 0; for(int i = n; i &gt; 0;) &#123; q.push(num[p[i--]]); q.push(num[p[i--]]); ans += q.top(); q.pop(); &#125; printf("%d\n", 2 * ans - sum); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>è´ªå¿ƒ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces76E Points]]></title>
    <url>%2F2017%2F07%2F04%2FCodeForces76E-Points%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® You are given N points on a plane. Write a program which will find the sum of squares of distances between all pairs of points. Input The first line of input contains one integer number N (1 â‰¤ N â‰¤ 100 000) â€” the number of points. Each of the following N lines contain two integer numbers X and Y ( - 10 000 â‰¤ X, Y â‰¤ 10 000) â€” the coordinates of points. Two or more points may coincide. Output The only line of output should contain the required sum of squares of distances between all pairs of points. Examples input 4 1 1 -1 -1 1 -1 -1 1 output 32 åˆ†æž ç­”æ¡ˆæ˜¯: \[ \sum_{i=1}^{n}{\sum_{j=i+1}^{n}{(x_i-x_j)^2+(y_i-y_j)^2}} \] è¿™é‡Œä»…è®¡ç®—xéƒ¨åˆ†ï¼Œyéƒ¨åˆ†ç›¸åŒ \[ \sum_{i=1}^n{\sum_{j=i+1}^n(x_i-x_j)^2} \] \[ =\sum_{i = 1}^n{\sum_{j = 1} ^n(x_i-x_j)^2}/2 \] \[ =\sum_{i = 1}^n{\sum_{j = 1} ^n(x_i^2-2x_ix_j+x_j^2)}/2 \] \[ =\sum_{i = 1}^n{\sum_{j = 1} ^n(x_i^2+x_j^2)}/2-\sum_{i = 1}^n{\sum_{j = 1} ^n(2x_ix_j)}/2 \] \[ =n\sum_{i = 1}^n{x_i^2}-\sum_{i = 1}^n{\sum_{j = 1} ^nx_ix_j} \] ç”±äºŽ \[ (\sum_{i=1}^n{x_i})^2=\sum_{i=1}^n{x_i}^2+2\sum_{i=1}^n{\sum_{j=i + 1}^n{x_ix_j}}=\sum_{i=1}^n{\sum_{j=1}^n{x_ix_j}} \] åˆ™ \[ \sum_{i = 1}^n{\sum_{j = i + 1} ^n(x_i-x_j)^2}=n\sum_{i = 1}^n{x_i^2}-(\sum_{i=1}^n{x_i})^2 \] åˆ™æœ€ç»ˆçš„ç­”æ¡ˆæ˜¯ \[ \sum_{i=1}^n{\sum_{j = i + 1}^n}{(x_i-x_j)^2 + (y_i-y_j)^2}=nï¼ˆ\sum_{i = 1}^n{x_i^2}+\sum_{i = 1}^n{y_i^2}ï¼‰-((\sum_{i=1}^n{x_i})^2+(\sum_{i=1}^n{y_i})^2) \] è¿™æ ·å°±å¯ä»¥O(n)å¤æ‚çš„å†™å‡ºæ¥äº† ä»£ç  1234567891011121314151617181920212223242526/** @Author: sun000* @Date: 2017-07-05 07:30:42* @Last Modified by: sun000* @Last Modified time: 2017-07-08 13:41:30*/#include &lt;cstdio&gt;long long int sumx, sumy, sumbx, sumby;int main(void) &#123; long long int n, x, y; sumx = sumy = sumbx = sumby = 0; scanf("%lld", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%lld%lld", &amp;x, &amp;y); sumx += x; sumbx += x * x; sumy += y; sumby += y * y; &#125; long long int ans = (n * (sumbx + sumby) - (sumx * sumx + sumy * sumy)); printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>æ•°å­¦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 768E:Game of Stones]]></title>
    <url>%2F2017%2F07%2F04%2FCodeForces-768E-Game-of-Stones%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® Sam has been teaching Jon the Game of Stones to sharpen his mind and help him devise a strategy to fight the white walkers. The rules of this game are quite simple: The game starts with n piles of stones indexed from 1 to n. The i-th pile contains *s**i* stones. The players make their moves alternatively. A move is considered as removal of some number of stones from a pile. Removal of 0stones does not count as a move. The player who is unable to make a move loses. Now Jon believes that he is ready for battle, but Sam does not think so. To prove his argument, Sam suggested that they play a modified version of the game. In this modified version, no move can be made more than once on a pile. For example, if 4 stones are removed from a pile, 4 stones cannot be removed from that pile again. Sam sets up the game and makes the first move. Jon believes that Sam is just trying to prevent him from going to battle. Jon wants to know if he can win if both play optimally. Input First line consists of a single integer n (1 â‰¤ n â‰¤ 106) â€” the number of piles. Each of next n lines contains an integer *s**i* (1 â‰¤ *s**i â‰¤ 60) â€” the number of stones in i*-th pile. Output Print a single line containing &quot;YES&quot; (without quotes) if Jon wins, otherwise print &quot;NO&quot; (without quotes) Examples input 1 5 output NO input 2 1 2 output YES Note In the first case, Sam removes all the stones and Jon loses. In second case, the following moves are possible by Sam: In each of these cases, last move can be made by Jon to win the game as follows: åˆ†æž è§£æ³•ä¸€ï¼šæš´åŠ›sgæ‰“è¡¨ï¼ˆç•¥ï¼‰ è§£æ³•äºŒï¼šå‡è®¾ä¸€ä¸ªå †æœ‰né¢—çŸ³å­ï¼Œé‚£ä¹ˆåŽ»åˆ°å®ƒä¸èƒ½å†å–ï¼Œè‡³å°‘è¦å–kæ¬¡ï¼Œè¿™ç§æƒ…å†µåŽ»çŸ³å­çš„åºåˆ—æ˜¯ 1ï¼Œ2ï¼Œ3â€¦â€¦kï¼Œ å…¶ä¸­0 &lt;= n-(1+2+3+â€¦â€¦+k) &lt;= k åˆ™è¿™ä¸ªç”±äºŽå¯ä»¥ä¸æŒ‰ç…§åŽ»æœ€å°‘æ¬¡æ•°çš„å–æ³•å–ï¼Œåˆ™ä¸€æ¬¡å¯ä»¥å–ai+ajé¢—çŸ³å­ï¼Œ1&lt;=ai,aj&lt;=kï¼Œåˆ™è¿™ä¸ªå †çŸ³å­å¯ä»¥è½¬åŒ–æˆæœ‰ké¢—çŸ³å­ï¼Œæ¯æ¬¡ä»»å–å‡ é¢—ï¼Œä¸å¯ä¸å–ï¼Œé‚£è¿™æ ·å°±æˆäº†æ™®é€šçš„NIMæ¸¸æˆäº†ï¼Œåˆ™å¯ä»¥ä¸Žå¤„ç†æ‰€æœ‰çš„çŸ³å¤´å †çŸ³å¤´ä¸ªæ•°ï¼Œç„¶åŽç”¨æ™®é€šçš„NIMæ¸¸æˆçš„åšæ³•ï¼Œå¼‚æˆ–ä¸€éå°±å¯ä»¥äº†ã€‚ ä»£ç  12345678910111213141516171819202122232425262728293031/** @Author: sun000* @Date: 2017-07-04 22:31:00* @Last Modified by: sun000* @Last Modified time: 2017-07-04 22:37:24*/#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int getNimNum(int n) &#123; int k = (int)sqrt(2.0 * n); while(k * (k + 1) &lt;= 2 * n) k++; //printf("k = %d\n", k - 1); return k - 1;&#125;int main(void) &#123; int n, temp, ans = 0; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;temp); ans ^= getNimNum(temp); &#125; printf("%s\n", ans ? "NO" : "YES"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>åšå¼ˆ</tag>
        <tag>NIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è®¡è’œä¹‹é“2017å¤èµ›Dé¢˜ï¼šç™¾åº¦åœ°å›¾å¯¼èˆª]]></title>
    <url>%2F2017%2F06%2F11%2F%E8%AE%A1%E8%92%9C%E4%B9%8B%E9%81%932017%E5%A4%8D%E8%B5%9BD%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%AF%BC%E8%88%AA%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® ç™¾åº¦åœ°å›¾ä¸Šæœ‰ n ä¸ªåŸŽå¸‚ï¼ŒåŸŽå¸‚ç¼–å·ä¾æ¬¡ä¸º 1 åˆ° nã€‚åœ°å›¾ä¸­æœ‰è‹¥å¹²ä¸ªåŸŽå¸‚ç¾¤ï¼Œç¼–å·ä¾æ¬¡ä¸º 1 åˆ° mã€‚æ¯ä¸ªåŸŽå¸‚ç¾¤åŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ªåŸŽå¸‚ï¼›æ¯ä¸ªåŸŽå¸‚å¯èƒ½å±žäºŽå¤šä¸ªåŸŽå¸‚ç¾¤ï¼Œä¹Ÿå¯èƒ½ä¸å±žäºŽä»»ä½•åŸŽå¸‚ç¾¤ã€‚ åœ°å›¾ä¸­æœ‰ä¸¤ç±»é“è·¯ã€‚ç¬¬ä¸€ç±»é“è·¯æ˜¯ åŸŽå¸‚ä¹‹é—´çš„å¿«é€Ÿè·¯ï¼Œä¸¤ä¸ªåŸŽå¸‚ u,v ä¹‹é—´å¢žåŠ ä¸€æ¡è·ç¦»ä¸º c çš„è¾¹ï¼›ç¬¬äºŒç±»é“è·¯æ˜¯ åŸŽå¸‚ç¾¤ä¹‹é—´çš„é«˜é€Ÿè·¯ï¼Œè¿žæŽ¥ä¸¤ä¸ªåŸŽå¸‚ç¾¤ a,bï¼Œé€šè¿‡è¿™æ¡é«˜é€Ÿè·¯ï¼ŒåŸŽå¸‚ç¾¤ a é‡Œçš„æ¯ä¸ªåŸŽå¸‚ä¸ŽåŸŽå¸‚ç¾¤ b é‡Œçš„æ¯ä¸ªåŸŽå¸‚ä¹‹é—´ä¸¤ä¸¤å¢žåŠ ä¸€æ¡è·ç¦»ä¸º c çš„è¾¹ã€‚å›¾ä¸­æ‰€æœ‰è¾¹å‡ä¸ºæ— å‘è¾¹ã€‚ ä½ éœ€è¦è®¡ç®—ä»ŽåŸŽå¸‚ s åˆ°åŸŽå¸‚ t çš„æœ€çŸ­è·¯ã€‚ è¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡Œè¾“å…¥n(1â‰¤nâ‰¤20000), m(0â‰¤mâ‰¤20000)ï¼Œåˆ†åˆ«è¡¨ç¤ºåŸŽå¸‚æ€»æ•°å’ŒåŸŽå¸‚ç¾¤æ€»æ•°ã€‚ æŽ¥ä¸‹æ¥ä¸€å…±è¾“å…¥ m è¡Œã€‚ ç¬¬ ii è¡Œé¦–å…ˆè¾“å…¥ä¸€ä¸ªki(1â‰¤kiâ‰¤n)ï¼Œè¡¨ç¤ºç¬¬ ii ä¸ªåŸŽå¸‚ç¾¤ä¸­çš„åŸŽå¸‚æ•°ä¸º kiã€‚æŽ¥ä¸‹æ¥è¾“å…¥ ki ä¸ªæ•°ï¼Œè¡¨ç¤ºç¬¬ i ä¸ªåŸŽå¸‚ç¾¤ä¸­æ¯ä¸ªåŸŽå¸‚çš„ç¼–å·,ä¿è¯ä¸€ä¸ªåŸŽå¸‚ç¾¤å†…çš„åŸŽå¸‚ç¼–å·ä¸é‡å¤ä¸”åˆæ³• \[ \sum_{i = 1}^m{k_i}â‰¤20000 \] ä¸‹ä¸€è¡Œè¾“å…¥ä¸€ä¸ªæ•´æ•° m1(0â‰¤m1â‰¤20000)ï¼Œè¡¨ç¤ºæœ‰ m1 æ¡ç¬¬ä¸€ç±»é“è·¯ï¼Œå³ åŸŽå¸‚ä¹‹é—´çš„å¿«é€Ÿè·¯ã€‚ æŽ¥ä¸‹æ¥ m1 è¡Œï¼Œæ¯è¡Œè¾“å…¥ä¸‰ä¸ªæ•´æ•° ui,vi(1â‰¤ui,viâ‰¤n),ci(1â‰¤ciâ‰¤106)ï¼Œåˆ†åˆ«è¡¨ç¤ºå¿«é€Ÿè·¯è¿žæŽ¥çš„ä¸¤ä¸ªåŸŽå¸‚ç¼–å·å’Œè¾¹çš„è·ç¦»ã€‚ ä¸‹ä¸€è¡Œè¾“å…¥ä¸€ä¸ªæ•´æ•° m2(0â‰¤m2â‰¤20000)ï¼Œè¡¨ç¤ºæœ‰ m2 æ¡ç¬¬äºŒç±»é“è·¯ï¼Œå³ åŸŽå¸‚ç¾¤ä¹‹é—´çš„é«˜é€Ÿè·¯ã€‚ æŽ¥ä¸‹æ¥ m2 è¡Œï¼Œæ¯è¡Œè¾“å…¥ä¸‰ä¸ªæ•´æ•° ai,bi(1â‰¤ai,biâ‰¤m),li(1â‰¤liâ‰¤106)ï¼Œåˆ†åˆ«è¡¨ç¤ºå¿«é€Ÿè·¯è¿žæŽ¥çš„ä¸¤ä¸ªåŸŽå¸‚ç¾¤ç¼–å·å’Œè¾¹çš„è·ç¦»ã€‚ æœ€åŽä¸€è¡Œè¾“å…¥s,t(1â‰¤s,tâ‰¤n)ï¼Œè¡¨ç¤ºèµ·ç‚¹å’Œç»ˆç‚¹åŸŽå¸‚ç¼–å·ã€‚ è¾“å‡ºæ ¼å¼ è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºåŸŽå¸‚ s åˆ°åŸŽå¸‚ t åˆ°æœ€çŸ­è·¯ã€‚å¦‚æžœä¸å­˜åœ¨è·¯å¾„ï¼Œåˆ™è¾“å‡º-1ã€‚ æ ·ä¾‹è¯´æ˜Ž 1 -&gt; 2 - &gt; 5æˆ–è€…1 -&gt; 4 -&gt; 5æ˜¯æœ€çŸ­çš„è·¯å¾„ï¼Œæ€»é•¿åº¦ä¸º 12ã€‚ æ ·ä¾‹è¾“å…¥ 5 4 2 5 1 2 2 4 1 3 2 3 4 2 1 2 9 1 5 18 2 1 2 6 1 3 10 1 5 æ ·ä¾‹è¾“å‡º 12 åˆ†æž æŠŠæ¯ä¸€ä¸ªåŸŽå¸‚ç¾¤çœ‹æˆä¸€ä¸ªæ–°çš„ç‚¹åŠ åˆ°å›¾é‡Œé¢ï¼Œæ–°åŠ çš„â€œåŸŽå¸‚ç¾¤ç‚¹â€åˆ°åŸŽå¸‚ç¾¤å†…çš„æ‰€æœ‰ç‚¹çš„è·ç¦»éƒ½æ˜¯0ï¼Œæ³¨æ„è¿™é‡Œçš„â€œåŸŽå¸‚ç¾¤ç‚¹â€è¦æ‹†ç‚¹ï¼Œæ‹†æˆå…¥ç‚¹å’Œå‡ºç‚¹ï¼Œå› ä¸ºä¸æ‹†ç‚¹çš„è¯ä¼šå¯¼è‡´åŒä¸€ä¸ªâ€œåŸŽå¸‚ç¾¤â€å†…éƒ¨çš„ç‚¹ä¸¤ä¸¤ä¹‹é—´çš„è·ç¦»å…¨éƒ¨å˜æˆ0ï¼Œè¿™æ˜¾ç„¶æ˜¯ä¸å¯¹çš„ã€‚ï¼ˆæ‹†ç‚¹ä¹‹åŽç‚¹çš„æ•°é‡å˜å¤šï¼Œåˆšå¼€å§‹æ•°ç»„å¤§å°æ²¡æœ‰æ”¹ï¼Œå¯¼è‡´äº†æ®µé”™è¯¯ï¼‰ï¼Œå»ºå®Œå›¾è·‘ä¸€è¾¹SPFAå°±å¯ä»¥äº†ã€‚ ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** @Author: sun000* @Date: 2017-06-11 11:57:57* @Last Modified by: sun000* @Last Modified time: 2017-06-11 15:48:54*/#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 60010;//ç‚¹çš„æ•°é‡æ˜¯n + 2 * mstruct node &#123; int to; long long int len; node()&#123;&#125; node(int _to, long long int _len):to(_to),len(_len)&#123;&#125;&#125;;vector&lt;node&gt; G[MAXN];int n, m;void build_group(int k)&#123; int cnt, temp; scanf("%d", &amp;cnt); for(int i = 0; i &lt; cnt; i++) &#123; scanf("%d", &amp;temp); temp--; G[k + n + m].push_back(node(temp, 0)); G[temp].push_back(node(k + n, 0)); &#125;&#125;long long int solve(int s, int t) &#123; long long int dis[MAXN]; bool vis[MAXN]; queue&lt;int&gt; Q; memset(dis, 0x3f, sizeof(dis)); memset(vis, false, sizeof(vis)); dis[s] = 0; vis[s] = true; Q.push(s); while(!Q.empty()) &#123; int u = Q.front(); Q.pop(); vis[u] = false; for(int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i].to; long long int w = G[u][i].len; if(dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; if(!vis[v]) &#123; vis[v] = true; Q.push(v); &#125; &#125; &#125; &#125; return dis[t];&#125;int main(void)&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 0; i &lt; m; i++) build_group(i); int g, u, v; long long int len; scanf("%d", &amp;g); for(int i = 0; i &lt; g; i++) &#123; scanf("%d%d%lld", &amp;u, &amp;v, &amp;len); u--; v--; G[u].push_back(node(v, len)); G[v].push_back(node(u, len)); &#125; scanf("%d", &amp;g); for(int i = 0; i &lt; g; i++) &#123; scanf("%d%d%lld", &amp;u, &amp;v, &amp;len); u--; v--; G[v + n].push_back(node(u + n + m, len)); G[u + n].push_back(node(v + n + m, len)); &#125; int s, t; scanf("%d%d", &amp;s, &amp;t); long long int ans = solve(s - 1, t - 1); printf("%lld\n", ans &lt; 0x3f3f3f3f ? ans : -1); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>å›¾è®º</tag>
        <tag>å»ºå›¾</tag>
        <tag>æœ€çŸ­è·¯</tag>
        <tag>æ‹†ç‚¹</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è®¡è’œä¹‹é“2017å¤èµ›Fé¢˜ï¼šè…¾è®¯æ¶ˆæ¶ˆä¹]]></title>
    <url>%2F2017%2F06%2F10%2F%E8%AE%A1%E8%92%9C%E4%B9%8B%E9%81%932017F%E9%A2%98%E8%85%BE%E8%AE%AF%E6%B6%88%E6%B6%88%E4%B9%90%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æŽ¥ é¢˜ç›® è…¾è®¯æŽ¨å‡ºäº†ä¸€æ¬¾ç›Šæ™ºç±»æ¸¸æˆâ€”â€”æ¶ˆæ¶ˆä¹ã€‚æ¸¸æˆä¸€å¼€å§‹ï¼Œç»™å®šä¸€ä¸ªé•¿åº¦ä¸º n çš„åºåˆ—ï¼Œå…¶ä¸­ç¬¬ i ä¸ªæ•°ä¸º Aiã€‚ æ¸¸æˆçš„ç›®æ ‡æ˜¯æŠŠè¿™äº›æ•°å…¨éƒ½åˆ åŽ»ï¼Œæ¯æ¬¡åˆ é™¤çš„æ“ä½œä¸ºï¼šé€‰å–ä¸€æ®µè¿žç»­çš„åŒºé—´ï¼Œä¸å¦¨è®°ä¸º [L,R]ï¼Œå¦‚æžœè¿™ä¸€æ®µåŒºé—´å†…æ‰€æœ‰æ•°çš„æœ€å¤§å…¬çº¦æ•° â‰¥kï¼ˆkå€¼åœ¨æ¸¸æˆçš„ä¸€å¼€å§‹ä¼šç»™å®šï¼‰ï¼Œé‚£ä¹ˆè¿™ä¸€æ®µåŒºé—´å°±èƒ½è¢«ç›´æŽ¥åˆ åŽ»ã€‚ æ³¨æ„ï¼šä¸€æ¬¡åˆ é™¤ä»¥åŽï¼Œå‰©ä¸‹çš„æ•°ä¼šåˆå¹¶æˆä¸ºä¸€ä¸ªè¿žç»­åŒºé—´ã€‚ å®šä¹‰ f(i)ä¸ºè¿›è¡Œ i æ¬¡æ“ä½œå°†æ•´ä¸ªåºåˆ—åˆ å®Œçš„æ–¹æ¡ˆæ•°ã€‚ ä½ éœ€è¦å®žçŽ°ä¸€ä¸ªç¨‹åºï¼Œè®¡ç®— \[ \sum_{i = 1}^n{(f(i) * i)} mod 1000000007 \] è¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡Œè¾“å…¥ä¸¤ä¸ªæ•´æ•° n,k(1â‰¤nâ‰¤18) ç¬¬äºŒè¡Œè¾“å…¥ nä¸ªæ­£æ•´æ•° ai(1â‰¤aiâ‰¤10^5)ï¼Œè¡¨ç¤ºåˆå§‹åºåˆ—ä¸­çš„æ¯ä¸ªæ•°ã€‚ è¾“å…¥æ•°æ®ä¿è¯ 1â‰¤kâ‰¤min(a1,a2,â€¦an) è¾“å‡ºæ ¼å¼ è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºç®—å‡ºçš„ç­”æ¡ˆã€‚ æ ·ä¾‹è¯´æ˜Ž å¯¹äºŽæ ·ä¾‹ 1 è€Œè¨€ï¼Œf(1)=1ï¼Œf(2)=9ï¼Œf(3))=26ï¼Œf(4)=24ã€‚ å¯¹äºŽæ ·ä¾‹ 2ï¼Œf(1)=0ï¼Œf(2)=2ã€‚ æ ·ä¾‹è¾“å…¥1 4 1 1 1 1 1 æ ·ä¾‹è¾“å‡º1 193 æ ·ä¾‹è¾“å…¥2 2 2 2 3 æ ·ä¾‹è¾“å‡º2 4 æ ·ä¾‹è¾“å…¥3 1 233 233 æ ·ä¾‹è¾“å‡º3 1 åˆ†æž æš´åŠ›çŠ¶æ€åŽ‹ç¼©dp,dp[s][i] : sè¡¨ç¤ºçš„çŠ¶æ€ç»è¿‡iæ¬¡æ¶ˆå®Œçš„æ–¹æ¡ˆæ•°ã€‚ æ—¶é—´å¤æ‚åº¦æ˜¯ï¼š \[ n^3*2^n \] ### ä»£ç  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** @Author: sun000* @Date: 2017-06-10 12:08:01* @Last Modified by: sun000* @Last Modified time: 2017-06-11 09:11:55*/#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MOD = 1000000007;const int MAXN = (1 &lt;&lt; 18) + 10;int n, k;int num[20];int dp[MAXN][20];//i, j,çŠ¶æ€iç”¨jæ¬¡æ¶ˆåŽ»çš„æ–¹æ¡ˆæ•°int gcd(int a, int b) &#123; return b ? gcd(b, a % b) : a;&#125;void init() &#123; memset(dp, 0, sizeof(dp)); int temp; for(int s = 1; s &lt; (1 &lt;&lt; n); s++) &#123; temp = 0; for(int i = 0; i &lt; n; i++) if(s &amp; (1 &lt;&lt; i)) temp = gcd(temp, num[i]); if(temp &gt;= k) dp[s][1] = 1; &#125;&#125;int main(void)&#123; scanf("%d%d", &amp;n, &amp;k); for(int i = 0; i &lt; n; i++) scanf("%d", &amp;num[i]); init(); int temp, now; for(int s = 1; s &lt; (1 &lt;&lt; n); s++) //æžšä¸¾çŠ¶æ€ for(int i = 2; i &lt;= n; i++) //æžšä¸¾æ¶ˆåŽ»æ¬¡æ•° //æžšä¸¾åŒºé—´ for(int l = 0; l &lt; n; l++) //æžšä¸¾èµ·ç‚¹ if(s &amp; (1 &lt;&lt; l)) //æœ‰æ•ˆèµ·ç‚¹ &#123; temp = 0; now = 0; for(int r = l; r &lt; n; r++) //æžšä¸¾ç»ˆç‚¹ if(s &amp; (1 &lt;&lt; r)) //æœ‰æ•ˆç»ˆç‚¹ &#123; temp = gcd(temp, num[r]); now |= (1 &lt;&lt; r);//é€‰æ‹©nowè¡¨ç¤ºçš„çŠ¶æ€ï¼Œæ¶ˆåŽ»ä¸€æ¬¡ if(temp &gt;= k) dp[s][i] = (dp[s][i] + dp[s ^ now][i - 1]) % MOD; else break; &#125; &#125; int ans = 0; for(int i = 1; i &lt;= n; i++) ans = (ans + (long long)dp[(1 &lt;&lt; n) - 1][i] * i % MOD) % MOD; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>çŠ¶æ€åŽ‹ç¼©</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5033 Building æš´åŠ›+å•è°ƒæ ˆä¼˜åŒ–]]></title>
    <url>%2F2017%2F06%2F08%2FHDU%205033%20Building%20%E6%9A%B4%E5%8A%9B%2B%E5%8D%95%E8%B0%83%E6%A0%88%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Building Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others) Total Submission(s): 2603 Accepted Submission(s): 739 Special Judge Problem Description Once upon a time Matt went to a small town. The town was so small and narrow that he can regard the town as a pivot. There were some skyscrapers in the town, each located at position xi with its height hi. All skyscrapers located in different place. The skyscrapers had no width, to make it simple. As the skyscrapers were so high, Matt could hardly see the sky.Given the position Matt was at, he wanted to know how large the angle range was where he could see the sky. Assume that Matt's height is 0. It's guaranteed that for each query, there is at least one building on both Matt's left and right, and no building locate at his position. Input The first line of the input contains an integer T, denoting the number of testcases. Then T test cases follow. Each test case begins with a number N(1&lt;=N&lt;=10^5), the number of buildings. In the following N lines, each line contains two numbers, xi(1&lt;=xi&lt;=10^7) and hi(1&lt;=hi&lt;=10^7). After that, there's a number Q(1&lt;=Q&lt;=10^5) for the number of queries. In the following Q lines, each line contains one number qi, which is the position Matt was at. Output For each test case, first output one line &quot;Case #x:&quot;, where x is the case number (starting from 1). Then for each query, you should output the angle range Matt could see the sky in degrees. The relative error of the answer should be no more than 10^(-4). Sample Input 3 3 1 2 2 1 5 1 1 4 3 1 3 2 2 5 1 1 4 3 1 4 2 3 5 1 1 4 Sample Output Case #1: 101.3099324740 Case #2: 90.0000000000 Case #3: 78.6900675260 é¢˜æ„ï¼š åœ¨ä¸€æ¡æ•°è½´ä¸Šæœ‰nä¸ªå¤§æ¥¼ï¼Œç»™å‡ºnä¸ªå¤§æ¥¼çš„åæ ‡xå’Œé«˜åº¦hæœ‰nä¸ªè¯¢é—®ï¼Œæ¯æ¬¡è¯¢é—®ç»™å‡ºä¸€ä¸ªx0è¡¨ç¤ºè§‚æµ‹ç‚¹çš„åæ ‡ï¼Œæ±‚è¯¥è§‚æµ‹ç‚¹èƒ½è§‚æµ‹åˆ°çš„å¤©ç©ºçš„è§’åº¦ã€‚ åˆ†æžï¼š ç”¨å•è°ƒæ ˆæ¥ç»´æŠ¤ä¸€ä¸ªæš´åŠ›çš„é¡ºåºï¼Œä»Žè§‚æµ‹ç‚¹å‘ä¸¤è¾¹çš„å»ºç­‘è¿›è¡Œæš´åŠ›æžšä¸¾æ¯ä¸€ä¸ªå»ºç­‘çš„æœ€å¤§è§†è§’ï¼ˆä¸æ˜¯æžšä¸¾æ‰€æœ‰çš„å»ºç­‘ï¼Œæ˜¯æŒ‰ç…§é«˜åº¦é€’å¢žçš„é¡ºåºæžšä¸¾ï¼Œå› ä¸ºè¶Šè¿œä½†é«˜åº¦å´ä¸èƒ½æ›´é«˜çš„è¯ï¼Œè§‚æµ‹è§’åº¦è‚¯å®šæ›´å¤§ï¼Œæˆ‘ä»¬è¦æ±‚è§‚æµ‹è§’åº¦æœ€å°ï¼‰ï¼Œç›´åˆ°æžšä¸¾åˆ°ä¸¤è¾¹æœ€é«˜çš„å»ºç­‘ä¸ºæ­¢ã€‚ ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;cstdio&gt;#include &lt;stack&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const double PI = acos(-1);int n;struct node&#123; double x, h; node()&#123;&#125; node(double xx, double hh):x(xx),h(hh)&#123;&#125;&#125;s[100010];bool cmp(node a, node b)&#123; return a.x &lt; b.x;&#125;int bef[100010], nex[100010], lm[100010], rm[100010];stack&lt;int&gt; ss;void init()&#123; memset(bef, -1, sizeof(bef)); memset(nex, -1, sizeof(nex)); while(!ss.empty()) ss.pop(); for(int i = 0; i &lt; n; i++) &#123; if(ss.empty() || s[ss.top()].h &gt; s[i].h) ss.push(i); else &#123; while(!ss.empty() &amp;&amp; s[ss.top()].h &lt; s[i].h) &#123; nex[ss.top()] = i; ss.pop(); &#125; ss.push(i); &#125; &#125; while(!ss.empty()) ss.pop(); for(int i = n - 1; i &gt;= 0; i--) &#123; if(ss.empty() || s[ss.top()].h &gt; s[i].h) ss.push(i); else &#123; while(!ss.empty() &amp;&amp; s[ss.top()].h &lt; s[i].h) &#123; bef[ss.top()] = i; ss.pop(); &#125; ss.push(i); &#125; &#125; int mh = 0; for(int i = 0; i &lt; n; i++) &#123; if(s[mh].h &lt;= s[i].h) mh = i; lm[i] = mh; &#125; mh = n - 1; for(int i = n - 1; i &gt;= 0; i--) &#123; if(s[mh].h &lt;= s[i].h) mh = i; rm[i] = mh; &#125;&#125;void debug()&#123; for(int i = 0; i &lt; n; i++) &#123; printf("%d x = %f h = %f\n", i, s[i].x, s[i].h); printf("bef %d\nnex %d\nlm %d\nrm %d\n\n", bef[i], nex[i], lm[i], rm[i]); &#125;&#125;int main(void)&#123; int t, q; double x, h, g; scanf("%d", &amp;t); for(int cas = 1; cas &lt;= t; cas++) &#123; printf("Case #%d:\n", cas); scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%lf%lf", &amp;x, &amp;h); s[i] = node(x, h); &#125; sort(s, s + n, cmp); init(); //debug(); scanf("%d", &amp;q); while(q--) &#123; scanf("%lf", &amp;g); int r = lower_bound(s, s + n, node(g, 0), cmp) - s; int l = r - 1; double tl = 0, tr = 0; for(int i = l; i != -1 &amp;&amp; i &gt;= lm[l]; i = bef[i]) tl = max(s[i].h / (g - s[i].x), tl); for(int i = r; i != -1 &amp;&amp; i &lt;= rm[r]; i = nex[i]) tr = max(s[i].h / (s[i].x - g), tr); double ans = 180 - 180 * (atan(tl) + atan(tr)) / PI; printf("%.10f\n", ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>æš´åŠ›</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 2995 Robberies æ¦‚çŽ‡èƒŒåŒ…]]></title>
    <url>%2F2017%2F06%2F07%2FHDU-2995-Robberies-%E6%A6%82%E7%8E%87%E8%83%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[Robberies Time Limit: 2000/1000 MS ( Memory Limit: 32768/32768 K (: 21326 Accepted Submission(s): 7889 Problem Description The aspiring Roy the Robber has seen a lot of American movies, and knows that the bad guys usually gets caught in the end, often because they become too greedy. He has decided to work in the lucrative business of bank robbery only for a short while, before retiring to a comfortable job at a university. For a few months now, Roy has been assessing the security of various banks and the amount of cash they hold. He wants to make a calculated risk, and grab as much money as possible.His mother, Ola, has decided upon a tolerable probability of getting caught. She feels that he is safe enough if the banks he robs together give a probability less than this. Input The first line of input gives T, the number of cases. For each scenario, the first line of input gives a floating point number P, the probability Roy needs to be below, and an integer N, the number of banks he has plans for. Then follow N lines, where line j gives an integer Mj and a floating point number Pj . Bank j contains Mj millions, and the probability of getting caught from robbing it is Pj . Output For each test case, output a line with the maximum number of millions he can expect to get while the probability of getting caught is less than the limit set.Notes and Constraints0 &lt; T &lt;= 1000.0 &lt;= P &lt;= 1.00 &lt; N &lt;= 1000 &lt; Mj &lt;= 1000.0 &lt;= Pj &lt;= 1.0A bank goes bankrupt if it is robbed, and you may assume that all probabilities are independent as the police have very low funds. Sample Input 3 0.04 3 1 0.02 2 0.03 3 0.05 0.06 3 2 0.03 2 0.03 3 0.05 0.10 3 1 0.03 2 0.02 3 0.05 Sample Output 2 4 6 é¢˜æ„ï¼š ä¸€ä¸ªå°å·åŽ»é“¶è¡Œå·ä¸œè¥¿ï¼Œç»™å®šä¸€ä¸ªpè¦æ±‚è¢«æŠ“ä½çš„æ¦‚çŽ‡å¿…é¡»å°äºŽp,ç„¶åŽç»™å®šnä¸ªé“¶è¡Œçš„mjå’Œpj,åˆ†åˆ«è¡¨ç¤ºå°å·åœ¨æ¯ä¸ªé“¶è¡Œèƒ½å·åˆ°çš„é’±å’Œä¼šè¢«æŠ“ä½çš„æ¦‚çŽ‡ã€‚è¦æ±‚å°å·åœ¨è¢«æŠ“ä½çš„æ¦‚çŽ‡å°äºŽpçš„æƒ…å†µä¸‹ï¼Œæœ€å¤šèƒ½å·å¤šå°‘é’±ã€‚ï¼ˆçœ‹æ¥å°å·ä¹Ÿè¦ä¼šç¼–ç¨‹ï¼Œä¸ä¼šç¼–ç¨‹å·ä¸åˆ°é’±ã€‚æ— ä¸šç¨‹åºå‘˜æœ‰å‡ºè·¯äº†ï¼‰ :) :) :) åˆ†æžï¼š é”™è¯¯è§£æ³•ï¼šæš´åŠ›çš„ç›´æŽ¥å¥—ç”¨01èƒŒåŒ…çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œdp[i] = max{dp[i], dp[i - v[j].p] + v[j].w} è¿™çœŸæ˜¯å¤ªstupidäº†ï¼Œæ¦‚çŽ‡ä¸æ˜¯ç”¨æ¥åŠ çš„ï¼Œæ¦‚çŽ‡å’Œåœ¨è¿™é‡Œæ²¡æœ‰ä»»ä½•æ„ä¹‰ï¼ˆå¥½æ°”å‘€ï¼Œæ ·ä¾‹ç”¨æ¦‚çŽ‡åŠ ä¹Ÿèƒ½è¿‡ï¼Œæ­£å¼å¤ªé˜´é™©äº†ï¼‰ æ­£ç¡®è§£æ³•ï¼šæ¦‚çŽ‡åº”è¯¥æ˜¯ç›¸ä¹˜çš„ï¼Œç„¶è€Œåœ¨è¿™é‡Œç›´æŽ¥ç®—è¢«æŠ“ä½çš„æ¦‚çŽ‡è¿‡äºŽéº»çƒ¦ï¼ŒäºŽæ˜¯åè¿‡æ¥è€ƒè™‘ï¼Œç®—èƒ½æˆåŠŸé€ƒè·‘çš„æ¦‚çŽ‡çš„æœ€å¤§æƒ…å†µã€‚é‚£ä¹ˆç”¨dp[i]è¡¨ç¤ºå·içš„é’±èƒ½é€ƒè·‘çš„æœ€å¤§æ¦‚çŽ‡ã€‚ å¾—åˆ°çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼šdp[i] =max{dp[i], dp[i - v[j].w] * (1 - v[j].p)} æœ€åŽæ‰¾å‡ºé€ƒè·‘æ¦‚çŽ‡å¤§äºŽç­‰äºŽpçš„æœ€å¤§çš„i ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//// main.cpp// HDU-Fighting//// Created by sun000 on 16/10/21.// Copyright Â© 2016å¹´ sun000. All rights reserved.//#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;double dp[10010];//å·é’±iæ—¶èƒ½é€ƒè·‘çš„æœ€å¤§æ¦‚çŽ‡struct node&#123; int w; double p;&#125;v[105];int main(void)&#123; int t, n, sum; double p; scanf("%d", &amp;t); while(t--) &#123; memset(dp, 0, sizeof(dp)); dp[0] = 1; sum = 0; scanf("%lf%d", &amp;p, &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d%lf", &amp;v[i].w, &amp;v[i].p); sum += v[i].w; &#125; for(int i = 1; i &lt;= n; i++)//01èƒŒåŒ…å…ˆå¾ªçŽ¯ç‰©å“ï¼Œå†å¾ªçŽ¯å®¹é‡ for(int j = sum; j &gt;= v[i].w; j--)//01èƒŒåŒ…é€†åºå¾ªçŽ¯ï¼Œå®Œå…¨èƒŒåŒ…æ­£åºå¾ªçŽ¯ &#123; dp[j] = max(dp[j], dp[j - v[i].w] * (1 - v[i].p)); //printf("dp[%d] = %lf\n", j, dp[j]); &#125; for(int i = sum; i &gt;= 0; i--) if(dp[i] &gt;= 1 - p) &#123; printf("%d\n", i); break; &#125; &#125; return0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5531ï¼ˆ2015é•¿æ˜¥ icpc E.Rebuildï¼‰ è®¡ç®—å‡ ä½•]]></title>
    <url>%2F2017%2F06%2F02%2FHDU-5531%EF%BC%882015%E9%95%BF%E6%98%A5-icpc-E-Rebuild%EF%BC%89-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%2F</url>
    <content type="text"><![CDATA[Rebuild Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others) Total Submission(s): 1881 Accepted Submission(s): 416 Problem Description Archaeologists find ruins of Ancient ACM Civilization, and they want to rebuild it. The ruins form a closed path on an x-y plane, which has n endpoints. The endpoints locate on (x1,y1), (x2,y2), â€¦,(xn,yn) respectively. Endpoint i and endpoint iâˆ’1 are adjacent for 1 &lt; i â‰¤ n, also endpoint 1 and endpoint n are adjacent. Distances between any two adjacent endpoints are positive integers. To rebuild, they need to build one cylindrical pillar at each endpoint, the radius of the pillar of endpoint i is ri. All the pillars perpendicular to the x-y plane, and the corresponding endpoint is on the centerline of it. We call two pillars are adjacent if and only if two corresponding endpoints are adjacent. For any two adjacent pillars, one must be tangent externally to another, otherwise it will violate the aesthetics of Ancient ACM Civilization. If two pillars are not adjacent, then there are no constraints, even if they overlap each other. Note that ri must not be less than 0 since we cannot build a pillar with negative radius and pillars with zero radius are acceptable since those kind of pillars still exist in their neighbors. You are given the coordinates of n endpoints. Your task is to find r1,r2,â€¦,rn which makes sum of base area of all pillars as minimum as possible. For example, if the endpoints are at (0,0), (11,0), (27,12), (5,12), we can choose (r1, r2, r3, r4)=(3.75, 7.25, 12.75, 9.25). The sum of base area equals to 3.752Ï€+7.252Ï€+12.752Ï€+9.252Ï€=988.816â€¦. Note that we count the area of the overlapping parts multiple times. If there are several possible to produce the minimum sum of base area, you may output any of them. Input The first line contains an integer t indicating the total number of test cases. The following lines describe a test case. The first line of each case contains one positive integer n, the size of the closed path. Next n lines, each line consists of two integers (xi,yi) indicate the coordinate of the i-th endpoint. 1â‰¤tâ‰¤100 3â‰¤nâ‰¤104 |xi|,|yi|â‰¤104 Distances between any two adjacent endpoints are positive integers. Output If such answer doesn't exist, then print on a single line &quot;IMPOSSIBLE&quot; (without the quotes). Otherwise, in the first line print the minimum sum of base area, and then print n lines, the i-th of them should contain a number ri, rounded to 2 digits after the decimal point. If there are several possible ways to produce the minimum sum of base area, you may output any of them. Sample Input 3 4 0 0 11 0 27 12 5 12 5 0 0 7 0 7 3 3 6 0 6 5 0 0 1 0 6 12 3 16 0 12 Sample Output 988.82 3.75 7.25 12.75 9.25 157.08 6.00 1.00 2.00 3.00 0.00 IMPOSSIBLE é¢˜æ„ï¼šè¿™é“é¢˜ç›®æŒ‰é¡ºåºç»™å‡ºä¸€äº›ç‚¹çš„åæ ‡ï¼Œç‚¹ä¾æ¬¡ç›¸è¿žï¼Œå¹¶ä¸”æœ€åŽä¸€ä¸ªç‚¹å’Œç¬¬ä¸€ä¸ªç‚¹ç›¸è¿žå½¢æˆä¸€ä¸ªçŽ¯ã€‚é—®åœ¨æ¢ä¸Šä»¥æ¯ä¸ªç‚¹ä¸ºåœ†å¿ƒä½œä¸€ç³»åˆ—åœ†ï¼Œè¦æ±‚ç›¸é‚»ä¸¤ç‚¹çš„åœ†ç›¸äº’å¤–åˆ‡ã€‚å¦‚ä¸å­˜åœ¨è¿™æ ·çš„ç‚¹åˆ™è¾“å‡ºâ€œIMPOSSIBLEâ€å¦åˆ™è¾“å‡ºè¿™äº›åœ†æ€»é¢ç§¯çš„æœ€å°å€¼ï¼Œå¹¶ä¾æ¬¡è¾“å‡ºæ­¤æ—¶æ‰€æœ‰åœ†çš„åŠå¾„ï¼ˆæ‰€æœ‰è¾“å‡ºä¿ç•™ä¸¤ä½å°æ•°ï¼‰ åˆ†æžï¼šæˆ‘ä»¬å¯ä»¥å‡è®¾ç¬¬ä¸€ä¸ªåœ†çš„åŠå¾„ä¸ºxé‚£ä¹ˆèƒ½å¤Ÿä¸€æ¬¡è¡¨ç¤ºå‡ºæ‰€æœ‰çš„åœ†çš„åŠå¾„ï¼Œå¹¶ä¸”å¯ä»¥æŠŠæ¯ä¸ªåœ†çš„åŠå¾„ä¾æ¬¡è¡¨ç¤ºä¸ºf[i] + x,æˆ–è€…f[i] - x;ï¼ˆç¬¬iä¸ªç‚¹ï¼‰iä¸ºå¥‡æ•°æ˜¯æ˜¯+ï¼Œå¶æ•°æ˜¯-ï¼›å› ä¸ºè¦æ±‚æ‰€æœ‰çš„åŠå¾„å¤§äºŽç­‰äºŽ0ï¼Œé‚£ä¹ˆæˆ‘ä»¬åœ¨å¯ä»¥ä¸€æ¬¡æ±‚å‡ºæ‰€æœ‰çš„f[i]å…ˆï¼Œå’Œxçš„èŒƒå›´[minn, maxn]ã€‚æœ€åŽå¯ä»¥ç”¨xè¡¨ç¤ºå‡ºæœ€åŽä¸€ä¸ªåœ†çš„åŠå¾„ã€‚ å¦‚æžœæ˜¯å¥‡æ•°ä¸ªç‚¹ï¼šé‚£ä¹ˆxæ˜¯ä¸€ä¸ªå¯ä»¥æ±‚çš„å®šå€¼ï¼Œåªè¦åˆ¤æ–­åœ¨ä¸åœ¨[minn, maxn]é‡Œå°±å¯ä»¥ï¼Œå¦‚æžœåœ¨åˆ™æœ‰è§£ï¼Œé‚£ä¹ˆå¯ä»¥é€šè¿‡f[i]æ±‚å‡ºæ‰€æœ‰åœ†çš„åŠå¾„ï¼Œé¢ç§¯ä¹Ÿå®¹æ˜“æ±‚ã€‚ å¦‚æžœæ˜¯å¶æ•°ä¸ªç‚¹ï¼šé‚£ä¹ˆæœ€åŽçš„åŠå¾„å’Œç¬¬ä¸€ä¸ªåœ†çš„åŠå¾„æ˜¯åŒå·ç çš„ï¼Œé‚£ä¹ˆä¸èƒ½ç›´æŽ¥æ±‚å‡ºxï¼Œæˆ‘ä»¬å¯ä»¥ç”¨xæ¥è¡¨ç¤ºæ¯ä¸€ä¸ªåœ†çš„åŠå¾„ï¼Œé‚£ä¹ˆæ€»é¢ç§¯ä¸€å®šèƒ½è¡¨ç¤ºç§°ä¸€ä¸ªxçš„äºŒæ¬¡å‡½æ•°ï¼Œç„¶åŽç»“åˆxåœ¨åŒºé—´[minn, maxn]å†…ï¼Œå¯ä»¥æ±‚å‡ºæœ€å¤§çš„æ€»é¢ç§¯ï¼Œå¹¶æ±‚å‡ºæ­¤æ—¶çš„xã€‚ç„¶åŽå¯ä»¥æ±‚å‡ºæ¯ä¸ªåœ†çš„åŠå¾„ã€‚ ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134//// main.cpp// HDU-Fighting//// Created by ç»¿è‰²å¥åº·æ–‡è‰ºå°æ¸…æ–° on ...// Copyright 2016å¹´ ç»¿è‰²å¥åº·æ–‡è‰ºå°æ¸…æ–°. All rights reserved.//#include &lt;cstdio&gt;#include &lt;cmath&gt;const double PI = acos(-1);//ä¹‹å‰å§piå†™æˆ3.1415926ç™½waäº†ä¸€å‘ï¼Œpiä»¥åŽéƒ½å†™æˆacos(-1)ä¸è¦æ— æ•…çš„waconst double eps = 1e-7;int n;double len[10005], f[10005], x;struct point&#123; double x, y;&#125; p[10005];double cal_len(point a, point b)&#123; return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;void cal_all_len()//ä¸€æ¬¡æ±‚å‡ºæ‰€æœ‰è¾¹çš„é•¿&#123; for(int i = 0; i &lt; n - 1; i++) len[i] = cal_len(p[i], p[i + 1]); len[n - 1] = cal_len(p[0], p[n - 1]);&#125;double abs(double x)&#123; if(x &gt; 0) return x; return -x;&#125;void print(double ans)&#123; printf("%.2f\n", ans * PI); for(int i = 0; i &lt; n; i++) &#123; if(i &amp; 1)//æˆ‘ä»Žä¸‹æ ‡0å¼€å§‹å­˜ï¼Œæ‰€ä»¥ä»£ç é‡Œçš„iå’Œåˆ†æžé‡Œçš„ç¬¬å‡ ä¸ªå¥‡å¶æ€§æ˜¯ç›¸åçš„ printf("%.2f\n", f[i] - x); else printf("%.2f\n", f[i] + x); &#125;&#125;int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; double maxn = 0x3f3f3f, minn = 0; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) scanf("%lf%lf", &amp;p[i].x, &amp;p[i].y); cal_all_len(); f[0] = 0; for(int i = 1; i &lt; n; i++) &#123; f[i] = len[i - 1] - f[i - 1]; if((i &amp; 1) &amp;&amp; f[i] &lt; maxn) maxn = f[i]; if(!(i &amp; 1) &amp;&amp; (-f[i]) &gt; minn) minn = -f[i]; &#125; if(minn &gt;= maxn + eps) &#123; printf("IMPOSSIBLE\n"); continue; &#125; if(n &amp; 1) &#123; x = 1.0 * (len[n - 1] - f[n -1]) / 2; if(x &lt;= minn - eps || x &gt;= maxn + eps) &#123; printf("IMPOSSIBLE\n"); continue; &#125; double ans = 0.0; for(int i = 0; i &lt; n; i++) &#123; if(i &amp; 1) ans += (f[i] - x) * (f[i] - x); else ans += (f[i] + x) * (f[i] + x); &#125; print(ans); &#125; else &#123; if(abs(f[n - 1] - len[n - 1]) &gt; eps || (minn - maxn) &gt; eps) &#123; printf("IMPOSSIBLE\n"); continue; &#125; double A = 0, B = 0, C = 0; for(int i = 0; i &lt; n; i++) &#123; A = A + 1; C += f[i] * f[i]; if(i &amp; 1) B -= 2 * f[i]; else B += 2 * f[i]; &#125; double l = (-B / 2) / A; if(l &lt; minn + eps) x = minn; else if(maxn &lt; l + eps) x = maxn; else x = l; print(A * x * x + B * x + C); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>æ•°å­¦</tag>
        <tag>è®¡ç®—å‡ ä½•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1830é«˜æ–¯æ¶ˆå…ƒ]]></title>
    <url>%2F2017%2F05%2F30%2FPOJ-1830%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%2F</url>
    <content type="text"><![CDATA[æŸäº›å¼€å…³çš„åŠ¨ä½œå¯èƒ½å½±å“å¦ä¸€äº›å¼€å…³çš„çŠ¶æ€,å› æ­¤ä»¥å¼€å…³ä¸ºèŠ‚ç‚¹ï¼Œå¦‚æžœå­˜åœ¨è¿™ç§å…³ç³»å°±åŠ å…¥ä¸€æ¡æœ‰å‘è¾¹ï¼ˆå¼€å§‹æˆ‘æƒ³æˆå¯¹ç§°çš„äº†ï¼Œæµªè´¹äº†å¾ˆå¤šæ—¶é—´- -ï¼‰ï¼Œè¿™æ ·å°±æž„æˆäº†ä¸€ä¸ªå›¾ï¼Œå¯ä»¥ç”¨é‚»æŽ¥çŸ©é˜µè¡¨ç¤ºï¼ˆä½†æ˜¯è¦è½¬ç½®ä¸€ä¸‹ï¼ŒåŽé¢ç»†è¯´ï¼‰ã€‚å½“æŸä¸ªå¼€å…³æŒ‰ä¸‹æ—¶ï¼Œå…¶è‡ªèº«çŠ¶æ€æ”¹å˜ï¼Œå—å…¶å½±å“çš„å¼€å…³çš„çŠ¶æ€ä¹Ÿæ”¹å˜ã€‚ ç”¨ä¸¤ä¸ªNç»´å‘é‡è¡¨ç¤ºåˆå§‹çŠ¶æ€å’Œç»“æŸçŠ¶æ€ï¼Œä¸¤è€…é€ä¸ªå…ƒç´ å¼‚æˆ–ï¼Œå°±å¾—åˆ°äº†å¼€å…³çŠ¶æ€çš„å˜åŒ–ã€‚ ä»¥ç¬¬ä¸€ä¸ªæ ·ä¾‹è¾“å…¥ä¸ºä¾‹åˆ†æžï¼Œ3ä¸ªå¼€å…³ï¼Œä¸¤ä¸¤ç›¸è¿žï¼Œåˆå§‹çŠ¶æ€000ï¼Œæœ€ç»ˆçŠ¶æ€111ï¼Œå°†å¯¹è§’çº¿çš„0å…¨éƒ¨æ¢æˆ1ï¼Œå¾—çŸ©é˜µA= è¿™é‡Œå†™å›¾ç‰‡æè¿° å°†çŸ©é˜µæ¯ä¸€åˆ—æƒ³è±¡ä¸ºä¸€ä¸ªå¼€å…³æŒ‰ä¸‹åŽäº§ç”Ÿçš„æ•ˆæžœï¼ˆ1è¡¨ç¤ºçŠ¶æ€ç¿»è½¬ï¼Œ0è¡¨ç¤ºä¸å˜ï¼‰ï¼Œæ¯”å¦‚ï¼Œç¬¬äºŒåˆ—å°±è¡¨ç¤ºæŒ‰ä¸‹ç¬¬äºŒä¸ªå¼€å…³ï¼Œåˆ™ç¬¬äºŒä¸ªå¼€å…³çš„æœ¬èº«çŠ¶æ€è¦æ”¹å˜ï¼ˆè¿™å°±æ˜¯æŠŠå¯¹è§’çº¿0æ¢æˆ1çš„åŽŸå› ï¼‰ï¼Œå—ç¬¬äºŒä¸ªå¼€å…³å½±å“çš„å¼€å…³jçŠ¶æ€ä¹Ÿè¦æ”¹å˜ï¼Œæ°å¥½å¯¹åº”é‚»æŽ¥çŸ©é˜µä¸­A[j, 2]=1 æŠŠAå†™æˆåˆ†å—çŸ©é˜µçš„å½¢å¼ï¼Œæ¯ä¸€åˆ—ä½œä¸ºä¸€ä¸ªå­çŸ©é˜µï¼Œåˆ™æœ‰A=[a1, a2, a3],æ­¤å¤„aiå‡ä¸ºåˆ—å‘é‡ï¼Œè®¾ç¬¬iä¸ªå¼€å…³æŒ‰ä¸‹æ¬¡æ•°ä¸ºxiï¼Œxi=0æˆ–1ï¼ˆå¼€å…³æŒ‰ä¸¤ä¸‹å’Œæ²¡æŒ‰æ˜¯ç­‰æ•ˆçš„ï¼Œ0/1å°±å¤Ÿäº†ï¼‰ è®°åˆå§‹çŠ¶æ€b0=[0,0,0],æœ€ç»ˆçŠ¶æ€b1=[1,1,1],åˆ™çŠ¶æ€å˜åŒ–b=b0^b1=[1,1,1],è¿™é‡Œbä¹Ÿæ˜¯åˆ—å‘é‡ã€‚ç›®æ ‡å°±æ˜¯æ±‚x1a1 + x2a2 +x3a3 = bçš„è§£çš„ä¸ªæ•°ï¼ˆæ­¤å¤„çš„åŠ æ˜¯æ¨¡2åŠ ï¼Œä¹Ÿå°±æ˜¯å¼‚æˆ–ï¼Œä¸‹åŒï¼‰ &gt; è¿™ä¸ªæ–¹ç¨‹å¯ä»¥å†™æˆ &gt; &gt; ä¸‹é¢å°±æ˜¯è§£è¿™ä¸ªçº¿æ€§æ–¹ç¨‹ç»„ å¯¹å¢žå¹¿çŸ©é˜µ[A b]åšåˆç­‰è¡Œå˜æ¢ï¼ŒåŒ–æˆé˜¶æ¢¯å½¢ï¼ˆé«˜æ–¯æ¶ˆå…ƒæ³•ï¼‰ï¼Œå¦‚æžœå­˜åœ¨[0,0,â€¦,0,1]çš„è¡Œï¼Œå°±æ˜¯æ— è§£ï¼›å¦‚æžœå­˜åœ¨rè¡Œ[0,0,â€¦,0,0]ï¼Œå°±æ„å‘³ç€æœ‰rä¸ªè‡ªç”±å˜é‡ï¼Œå› ä¸ºè¿™é‡Œçš„å˜é‡åªå–0/1ï¼Œæ‰€ä»¥æœ‰2rä¸ªè§£ï¼›å¦‚æžœä¸å­˜åœ¨[0,0,â€¦,0,*]ï¼Œå³æŠŠæœ€åŽä¸€è¡ŒåŽ»æŽ‰åŽä¸å­˜åœ¨å…¨0è¡Œï¼Œåˆ™Aä¸ºæ»¡ç§©çŸ©é˜µï¼Œåˆ™æ–¹ç¨‹ç»„æœ‰å”¯ä¸€è§£ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//// main.cpp// HDU-Fighting//// Created by ç»¿è‰²å¥åº·æ–‡è‰ºå°æ¸…æ–° on ...// Copyright 2016å¹´ ç»¿è‰²å¥åº·æ–‡è‰ºå°æ¸…æ–°. All rights reserved.//#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;const int mod = 2;int a[30][31];int gcd(int a, int b)&#123; int t; while(b)&#123; t = b; b = a % b; a = t; &#125; return a;&#125;int lcm(int a, int b)&#123; return a / gcd(a, b) * b;&#125;int Gauss(int equ, int var)&#123; int k, col; for (k = 0, col = 0; k &lt; equ &amp;&amp; col &lt; var; ++k, ++col)&#123; int max_r = k; for (int i = k + 1; i &lt; equ; ++i)&#123; if (abs(a[i][col]) &gt; abs(a[max_r][col])) max_r = i; &#125; if (max_r != k)&#123; for (int i = k; i &lt;= var; ++i) swap(a[k][i], a[max_r][i]); &#125; if (a[k][col] == 0)&#123; --k; continue; &#125; for (int i = k + 1; i &lt; equ; ++i)&#123; if (a[i][col] != 0) &#123; int LCM = lcm(abs(a[i][col]), abs(a[k][col])); int ta = LCM / abs(a[i][col]); int tb = LCM / abs(a[k][col]); if (a[i][col] * a[k][col] &lt; 0) tb = -tb; for (int j = col; j &lt;= var; ++j) &#123; a[i][j] = ((a[i][j] * ta - a[k][j] * tb) % mod + mod) % mod; &#125; &#125; &#125; &#125; for (int i = k; i &lt; equ; ++i)&#123; if (a[i][col] != 0) return -1; &#125; return var - k;&#125;int s[30], e[30];long long int b[30];void build(int n)&#123; int x, y; while(scanf("%d%d", &amp;x, &amp;y), x || y) a[y - 1][x - 1] = 1; for(int i = 0; i &lt; n; i++) a[i][n] = s[i] ^ e[i];&#125;void init()&#123; b[0] = 1; for(int i = 1; i &lt; 30; i++) b[i] = b[i - 1] * 2;&#125;int main(void)&#123; int t, n; scanf("%d", &amp;t); init(); while(t--) &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt;= n; j++) a[i][j] = 0; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;s[i]); a[i][i] = 1; &#125; for(int i = 0; i &lt; n; i++) scanf("%d", &amp;e[i]); build(n); int ans = Gauss(n, n); if(ans == -1) printf("Oh,it's impossible~!!\n"); else printf("%lld\n", b[ans]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>æ•°å­¦</tag>
        <tag>é«˜æ–¯æ¶ˆå…ƒ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[èŽ«æ¯”ä¹Œæ–¯åæ¼”å…¥é—¨]]></title>
    <url>%2F2017%2F05%2F28%2F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[è¿™ä¸ªæ–‡ç« ä¸»è¦è®²ä¸€ä¸‹ACMä¸­1ä¸ªå¸¸ç”¨çš„èŽ«æ¯”ä¹Œæ–¯åæ¼”å…¬å¼ï¼Œçœ‹åˆ°å¾ˆå¤šåšå®¢ä¸Šé¢å…¬å¼æ˜¯æœ‰ï¼Œä½†æ˜¯éƒ½æ²¡è¯æ˜Žï¼Œã€Šç»„åˆæ•°å­¦ã€‹ä¸Šçš„è¯æ˜Žåˆæ²¡çœ‹æ‡‚ï¼Œ å°±è‡ªå·±æƒ³äº†ç§è¯æ˜Žæ–¹æ³•ï¼Œè§‰å¾—æ¯”ã€Šç»„åˆæ•°å­¦ã€‹çš„è¯æ˜Žç®€å•äº›ï¼Œå°±å†™ä¸€ä¸‹ï¼Œå¸Œæœ›å¯¹åˆå­¦èŽ«æ¯”ä¹Œæ–¯åæ¼”çš„åŒå­¦æœ‰å¸®åŠ©ã€‚ PSï¼šä¸‹é¢å…¬å¼å‡ºçŽ°çš„sigmaæ˜¯ç´¯åŠ ï¼Œå¦å¤–å»ºè®®å¤§å®¶çœ‹çš„æ—¶å€™ æŠŠå…¬å¼åœ¨çº¸ä¸Šå†™å‡ºæ¥ï¼ ä¸€ï¼šä»€ä¹ˆæ˜¯èŽ«æ¯”ä¹Œæ–¯åæ¼” ç®€å•ç‚¹çš„è¯´ï¼Œå°±æ˜¯å…ˆç»™å‡ºä¸€ä¸ªå‡½æ•° F(n) ,ç„¶åŽå†ç”± F(n)å®šä¹‰ä¸€ä¸ªæ–°å‡½æ•° G(n) å…¶ä¸­ G(n) = sigma(F(d)) (å…¶ä¸­dè¢«â€œåŒ…å«â€äºŽn) ç„¶åŽ çŽ°åœ¨æˆ‘ä»¬ä¸çŸ¥é“ F(n)çš„å€¼ ï¼Œ å´çŸ¥é“ G(n)ï¼Œ æŽ¥ç€æˆ‘ä»¬å°±å¯ä»¥é€šè¿‡ åæ¼”ç”±G(n)åå‘å¾—åˆ°F(n) ä»€ä¹ˆå« (å…¶ä¸­dè¢«â€œåŒ…å«â€äºŽn) ï¼Ÿä»¥åŠæ€Žä¹ˆç†è§£åæ¼”ï¼Ÿ é€šè¿‡ä¸‹é¢çš„å‡ ä¸ªä¾‹å­è¯´æ˜Ž ä¾‹1ï¼š æˆ‘ä»¬ç›´æŽ¥å®šä¹‰ G(n)=sigma(F(i)) (1&lt;=i&lt;=n) {è¿™é‡Œçš„æ¯ä¸ªF(i)ï¼Œç›¸å¯¹äºŽG(n)å®žé™…ä¸Šå°±æ˜¯ä¸€ç§åŒ…å«å…³ç³»äº†ï¼ï¼} ç„¶åŽæˆ‘ä»¬çŽ°åœ¨å·²ç»çŸ¥é“ G(n)=n*(n+1)/2; æŽ¥ä¸‹æ¥ æˆ‘ä»¬è¦é€šè¿‡ G(n)åå‘å¾—åˆ°F(n) çš„è¿‡ç¨‹ï¼Œå°±æ˜¯åæ¼” å½“ç„¶ï¼Œè¿™ä¸ªé—®é¢˜å¾ˆç®€å•ï¼Œå¾ˆå®¹æ˜“éƒ½å¯ä»¥çœ‹å‡ºæ¥ F(n)=n ï½žï½ž ä¾‹2: æˆ‘ä»¬å…ˆä»¤ S,X éƒ½è¡¨ç¤ºé›†åˆ æ¯”å¦‚ S={1,4,6} X={2} ç­‰ å¹¶ä»¤|S|è¡¨ç¤º Sä¸­å…ƒç´ çš„ä¸ªæ•° æŽ¥ç€å®šä¹‰ é›†åˆä¸Šçš„å‡½æ•° F(S) /å…·ä½“æ€Žä¹ˆå®šä¹‰ä¸ç”¨ç®¡ï¼Œæˆ‘ä»¬åªéœ€è¦çŸ¥é“æœ‰è¿™ä¹ˆä¸€ä¸ªå…³äºŽé›†åˆçš„å‡½æ•°Få°±å¥½äº† :) / ç„¶åŽå†å®šä¹‰ G(S)=sigma(F(X)) (å…¶ä¸­Xæ˜¯Sçš„å­é›†) {è¿™é‡Œä¹Ÿæ˜¯ä¸€ç§åŒ…å«å…³ç³»ï¼Œé›†åˆçš„åŒ…å«ï¼ï¼} æŽ¥ç€æˆ‘ä»¬ä¸çŸ¥é“F(S)ï¼Œæƒ³é€šè¿‡G(S) æ¥å¾—åˆ° F(S) è¿™ä¸ªé—®é¢˜ç›¸å¯¹äºŽä¾‹1å°±å¤æ‚å¤šäº†ï¼Œä½†å®žé™…ä¸Šæˆ‘ä»¬å·²ç»æœ‰çŽ°æˆçš„å…³äºŽé›†åˆåŒ…å«çš„èŽ«æ¯”ä¹Œæ–¯åæ¼”å…¬å¼äº† :) F(S)=sigma((-1)^(|S|-|X|) * G(X)) (å…¶ä¸­Xæ˜¯Sçš„å­é›†) æ˜¯ä¸æ˜¯æ„Ÿè§‰æœ‰ç‚¹ç¥žå¥‡ï¼Ÿ å¤§å®¶å¯ä»¥è‡ªå·±å†™ä¸ªç¨‹åºæ¥éªŒè¯ä¸€ä¸‹ã€‚ ä¸‹é¢å°±æ˜¯æˆ‘çš„éªŒè¯ç¨‹åºï¼š æˆ‘å®šä¹‰ F(S)=|S| ï¼Œ ç„¶åŽå…ˆ è®¡ç®—å‡º F(S) ,æŽ¥ç€ è®¡ç®—å‡º G(S) , ç„¶åŽ æ¯”è¾ƒç”±G(S)åæ¼”å¾—åˆ°çš„ F(S)å’Œ |S| çš„å¤§å° ä¸‹é¢æ˜¯ æˆ‘çš„ç¨‹åº 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;#define base 10#define REP(i,n) for(int i=0;i&lt;(n);i++)int F[1&lt;&lt;base],G[1&lt;&lt;base];// é›†åˆç”¨äºŒè¿›åˆ¶è¡¨ç¤º baseè¡¨ç¤ºé›†åˆæœ€å¤š10ä¸ªå…ƒç´ int Cal(int x)&#123; // è®¡ç®— |x| int sum=0; while(x) sum+=(x&amp;1),x/=2; return sum;&#125;int main()&#123; REP(S,1&lt;&lt;base) F[S]=Cal(S); // è®¡ç®—å‡ºæœ€å¼€å§‹çš„F(S) REP(S,1&lt;&lt;base)&#123; // è®¡ç®—G(S) G[S]=0; for(int X=S;X;X=(X-1)&amp;S) G[S]+=F[X]; //ç”¨XéåŽ†Sé›†åˆ &#125; REP(S,1&lt;&lt;base)&#123; // è®¡ç®—åæ¼”çš„ F(S) F[S]=0; for(int X=S;X;X=(X-1)&amp;S) F[S]+=(int)pow(-1,Cal(S)-Cal(X))*G[X]; &#125; bool flag=1; // éªŒè¯ä¸€ä¸‹ REP(S,1&lt;&lt;base) if(F[S]!=Cal(S)) flag=0; if(flag) cout&lt;&lt;"YES"&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl;&#125; æœ€åŽå¾—åˆ°çš„ç»“æžœ å½“ç„¶æ˜¯ YES å’¯ï¼:) å…³äºŽè¿™ä¸ª åæ¼”å…¬å¼ çš„è¯æ˜Žï¼Œå…ˆä¸è¦ç€æ€¥ï¼Œçœ‹å®Œæ–‡ç« è¿‡åŽï¼Œä½ è‡ªå·±éƒ½èƒ½æ‘¸ç´¢ç€è¯æ˜Žäº†ï¼ï¼ çŽ°åœ¨å…ˆå¤§æ¦‚ç†è§£åæ¼”æ˜¯ä¸ªä»€ä¹ˆå°±è¡Œäº†ï¼ï¼ ä¾‹3ï¼š å…ˆä»¤ d|n è¡¨ç¤º dèƒ½æ•´é™¤n æ¯”å¦‚ 2|4 (=.=) å®šä¹‰ å…³äºŽ æ•´æ•° çš„å‡½æ•° F(n) ç„¶åŽ å®šä¹‰ G(n)=sigma(F(d)) (å…¶ä¸­d|n) ä¸Šé¢çš„è¿™ç§åŒ…å«å…³ç³»å°±æ›´å¤æ‚äº†ï¼Œåªæœ‰å½“dæ˜¯nçš„å› å­çš„æ—¶å€™ï¼ŒF(d)æ‰ä¼šè¢«åŒ…å«åœ¨G(n)ä¸­ã€‚ ä¸è¿‡è¿™ç§ åŒ…å«å…³ç³» åœ¨ ACMä¸­é‡åˆ°çš„æœ€å¤šï¼Œæ‰€ä»¥æˆ‘ä¼šè¯¦ç»†è®²ä¸€ä¸‹è¿™ç§ç±»åž‹çš„ åæ¼”ã€‚ ç›¸ä¿¡æ˜Žç™½äº†è¿™ä¸ªè¿‡åŽï¼Œä¾‹2çš„åæ¼”ä¹Ÿèƒ½å¤Ÿè‡ªå·±è¯æ˜Žäº†ã€‚ å…·ä½“çš„è®²è§£è§ä¸‹ä¸€ç« èŠ‚ :) äºŒï¼šä¸€ç±»åæ¼” è¿™ä¸ªä¸€ç±»åæ¼”å°±æ˜¯ä¾‹3ä¸­çš„é‚£ä¸€ç±»å’¯= = æˆ‘å…ˆç›´æŽ¥ç»™å‡ºç»“è®ºå§ åŽŸå¼ : G(n)=sigma(F(d)) (å…¶ä¸­d|n) åæ¼”å…¬å¼: F(n)=sigma(U(n/d)*G(d)) è¿™é‡ŒUæ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œä»–æ˜¯æ¯ä¸€é¡¹ G(d) çš„ç³»æ•°ï¼Œä»–çš„å®šä¹‰è§ä¸‹é¢ ï¼ˆå¼ºçƒˆå»ºè®®å…³äºŽUçš„å®šä¹‰è¿™ä¸€æ®µå¯ä»¥å…ˆè·³è¿‡ï¼Œå…ˆè®¤ä¸ºä»–æ˜¯Gçš„ç³»æ•°å°±è¡Œäº†ï¼Œå¯ä»¥è·³åˆ°ä¸‹é¢çº¢å­—ä½ç½®ï¼‰ (1).Uæ˜¯ä¸€ä¸ªå…³äºŽæ•´æ•°çš„å‡½æ•° (2).U[x] = 1 å½“ä¸”ä»…å½“ xèƒ½å¤Ÿåˆ†è§£æˆå¶æ•°ä¸ªä¸åŒè´¨æ•°çš„ä¹˜ç§¯ ï¼ˆå…¶ä¸­1ä¸èƒ½è¢«åˆ†è§£ï¼Œæ‰€ä»¥1çš„åˆ†è§£å‡ºçš„è´¨æ•°ä¸ªæ•°æ˜¯0ï¼Œæ‰€ä»¥U[1]=1ï¼‰ (3).U[x] = -1 å½“ä¸”ä»…å½“ xèƒ½å¤Ÿåˆ†è§£æˆå¥‡æ•°ä¸ªä¸åŒè´¨æ•°çš„ä¹˜ç§¯ (4).U[x] = 0 é™¤å¼€(2),(3)çš„å…¶ä»–æƒ…å†µ çœ‹ä¸Šé¢å…³äºŽUçš„å®šä¹‰å¯èƒ½æœ‰ç‚¹çœ‹æ™•äº†ï¼Œé€šä¿—ä¸€ç‚¹çš„è¯´ å¯¹äºŽä¸€ä¸ª x , åˆ†è§£å› å¼è¿‡åŽ æœ‰ x=(p1e1)(p2^e2)...(prer) å¦‚æžœ eiä¸­(1&lt;=i&lt;=r)æœ‰ä¸€ä¸ªæ•°eiå¤§äºŽ1 é‚£ä¹ˆ U[x] = 0; ä¸ç„¶çš„è¯ U[x] = (-1)^r ä¾æ—§æ¥ä¸¤ä¸ªä¾‹å­ï¼ˆæˆ‘æœ€å–œæ¬¢ä¸¾ä¾‹å­äº† = =ï¼‰ U[1]=1;å®šä¹‰ä¸­çš„è¯´æ˜Ž U[2]=-1; åˆ†è§£å¼ 2=2; U[6]=1; åˆ†è§£å¼ 6=2*3 U[9]=0; 9=3^2; å‡ºçŽ°äº†e&gt;1 U[12]=0; 12=2^2*3; è·³åˆ°è¿™é‡Œ :) ä¸Šé¢å°±æ˜¯å…³äºŽè¿™ç±»åæ¼”å…¬å¼çš„å®šä¹‰ï¼Œä¸è¦å¤´æ™•= =ï¼Œç»§ç»­å¾€ä¸‹çœ‹å§ åœ¨è¯æ˜Žä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæƒ³ä¸€ä¸‹ï¼Œä¸ºä»€ä¹ˆåæ¼”å…¬å¼ä¼šæ˜¯ F(n)=sigma(U(n/d)*G(d)) è¿™æ ·çš„åž‹å¼ï¼Ÿ ä¾æ—§é€šè¿‡ä¾‹é¢˜æ¥æ‰¾è§„å¾‹ (^ ^) æˆ‘ä»¬ä»¤ n=6; é‚£ä¹ˆ åœ¨è®¡ç®— F(6)çš„æ—¶å€™ï¼Œæˆ‘ä»¬ä¼šç”¨åˆ° G(1) G(2) G(3) G(6) æˆ‘ä»¬è€ƒå¯Ÿè€…4ä¸ªG G(1) = F(1) G(2) = F(1)+F(2) G(3) = F(1)+F(3) G(6) = F(1)+F(2)+F(3)+F(6) è§‚å¯Ÿä¸Šé¢å¯ä»¥å‘çŽ° æ¯ä¸ª G(n)éƒ½æ˜¯ç”±ä¸€äº›F(d)ç´¯åŠ å¾—åˆ°çš„ å½“æˆ‘ä»¬éœ€è¦é€†å‘æœ‰Gå¾—åˆ°F(n)æ—¶ï¼Œåªéœ€è¦å°†ä¸€äº› ä¸Ž F(n) æœ‰å…³çš„ Gè¿›è¡Œå®¹æ–¥ï¼ï¼ï¼ï¼ï¼ æœ€ç»ˆç»„åˆå¾—åˆ°F(n)ï¼ï¼ï¼ æ¯”å¦‚ F(6) = G(6)-G(2)-G(3)+G(1) ï¼ï¼ï¼ï¼ æœ‰äº›ç¥žå¥‡ï¼ï¼ ä¸è¿‡è¿™ç±»èŽ«æ¯”ä¹Œæ–¯åæ¼”çš„å®žè´¨ä¹Ÿå°±æ˜¯å®¹æ–¥åŽŸç†çš„åº”ç”¨ï¼ï¼ é‚£ä¹ˆæˆ‘ä»¬çŽ°åœ¨çŸ¥é“ä¸ºä»€ä¹ˆ è¿™ç±»åæ¼”å…¬å¼ä¼šæ˜¯ è¿™ä¸ªå½¢å¼äº†ï¼Œè€Œä¸”å¯¹å…¶åŽŸç†ä¹Ÿæœ‰äº†æ›´æ·±çš„ç†è§£ï¼ŒçŽ°åœ¨è¯¥æƒ³ä¸€æƒ³å…¬å¼çš„ç»†èŠ‚äº†ã€‚ æ—¢ç„¶æˆ‘ä»¬çŸ¥é“è¦å¾—åˆ° F(n) ï¼Œåªéœ€è¦å°†ä¸Žå…¶ç›¸å…³çš„ Gè¿›è¡Œå®¹æ–¥å°±å¯ä»¥ï¼Œé‚£ä¹ˆå‰©ä¸‹çš„é—®é¢˜å°±æ˜¯æ¯ä¸ªGçš„ç³»æ•°ï¼ï¼ï¼ æˆ‘ä»¬ä»¥ æ±‚è§£ F(6)ä¸ºä¾‹å­æ¥è¯´æ˜Ž ï¼Œå¹¶å®šä¹‰ä¸€ä¸ªç³»æ•°å‡½æ•° H(d,n). å…¶ä¸­ H(d,n)è¡¨ç¤º æ±‚è§£F(n)æ—¶ï¼ŒG(d)çš„ç³»æ•° ï¼ˆå…¶ä¸­d|nï¼‰ æ‰€ä»¥å¯ä»¥å¾—åˆ°è¿™ä¸ªå¼å­ F(6) = H(6,6)G(6)+H(2,6)G(2)+H(3,6)G(3)+H(1,6)G(1) æˆ‘ä»¬ç”¨ a,b,c,dåˆ†åˆ«æ›¿ä»£ å››ä¸ªH(6,6),H(2,6),H(3,6),H(1,6)ï¼Œå¹¶ä¸”æŠŠå¯¹åº”çš„Gç”¨Fè¡¨ç¤ºå‡ºæ¥ï¼Œå¾—åˆ° F(6)=a(F(6)+F(3)+F(2)+F(1))+b(F(2)+F(1))+c(F(3)+F(1))+dF(1),å†å˜å½¢ä¸€ä¸‹ï¼Œåˆæœ‰ F(6)(a-1)+F(3)(a+c)+F(2)(a+b)+F(1)(a+b+c+d)=0ï¼ŒæŠŠF(6),F(3),F(2),F(1)å½“ä½œä¸åŒçš„å…ƒï¼Œåˆ™å¾—åˆ°äº†ä¸‹é¢çš„æ–¹ç¨‹ç»„ï¼ï¼ï¼ a-1==0 a+c==0 a+b==0 a+b+c+d==0 ç”±æ­¤å‘çŽ°ï¼Œå››ä¸ªæœªçŸ¥æ•°ï¼Œå››ä¸ªæ–¹ç¨‹ï¼Œåªéœ€è¦è§£å‡ºæ–¹ç¨‹ï¼Œå°±èƒ½çŸ¥é“å¯¹äºŽGçš„ç³»æ•°ã€‚ å†æ·±å…¥çš„æƒ³ä¸€ä¸‹ï¼Œå¯¹äºŽæ¯ä¸ª F(n),å‡è®¾ä»–çš„å› å­æ•°ä¸º,mï¼Œåˆ™é€šè¿‡è¿™ç§æ–¹å¼ï¼Œæ€»èƒ½è®¾å‡ºmä¸ªæœªçŸ¥æ•°ï¼Œmä¸ªæ–¹ç¨‹ï¼Œ è¿™æ ·æ€»èƒ½æ‰¾åˆ°è§£ï¼Œè€Œè¿™ä¹Ÿä¸ºèŽ«æ¯”ä¹Œæ–¯åæ¼”çš„å¯èƒ½æ€§ä½œå‡ºäº†è§£é‡Šï¼ï¼ çŽ°åœ¨æˆ‘ä»¬è¦è¯æ˜Žä¸€ä¸ªç»“è®ºï¼Œå³ä½¿H(a,b)==H(1,b/a)ï¼ï¼è¿™ä¸ªç»“è®ºå¾ˆé‡è¦ï¼Œå…·ä½“åˆ†æžè§ä¸‹ :) æˆ‘ä»¬ä»¥æ±‚è§£ F(8)ä¸ºä¾‹å­ï¼Œä¸ŽF(8)ç›¸å…³çš„ H æœ‰ ï¼ŒH(8,8),H(4,8),H(2,8),H(1,8) F(8)=H(8,8)G(8)+H(4,8)G(4)+H(2,8)G(2)+H(1,8)G(1) é¦–å…ˆçœ‹ H(8,8),å…¶å€¼å¯ä»¥ç›´æŽ¥ç¡®å®šï¼Œå› ä¸ºæŠŠF(8)å½“ä½œå…ƒçš„è¯ï¼Œå·¦è¾¹ä¸€ä¸ªF(8),è€Œåœ¨å³è¾¹F(8)åªåœ¨G(8)ä¸­å‡ºçŽ°ï¼Œæ‰€ä»¥H(8,8)==1 åŒç† å¯¹äºŽ F(n)ï¼Œå…¶G(n)çš„ç³»æ•°H(n,n)==1ï¼Œæ‰€ä»¥H(8,8)==H(1,1) å†æ¥çœ‹H(4,8),ï¼Œé¦–å…ˆæƒ³ï¼ŒF(4)åœ¨å“ªäº›åœ°æ–¹å‡ºçŽ°ï¼Œå‘çŽ° åœ¨G(8)å’ŒG(4)å‡ºçŽ°ï¼Œå› ä¸ºå·¦è¾¹ä¸å«F(4)ï¼Œè€Œå‰é¢G(8)çš„ç³»æ•°åˆå·²ç»ç¡®å®šï¼Œ æ‰€ä»¥è¿™é‡ŒH(4,8)*G(4)çš„ä½œç”¨å°±æ˜¯ä¸ºäº†æŠµæ¶ˆå‰é¢G(8)çš„ä»£æ¢ä¸­ï¼Œå‡ºçŽ°çš„F(4)ï¼Œæ‰€ä»¥ H(4,8)==-H(8,8)==-H(2,2)==H(1,2),{H(1,2)==-H(1,1)è¯·å¤§å®¶è‡ªå·±éªŒè¯ä¸€ä¸‹} åŒç†å¯¹äºŽH(2,8)ï¼Œä»–æ˜¯ä¸ºäº†æŠµæ¶ˆå‰é¢åœ¨G(8)å’ŒG(4)ä¸­å‡ºçŽ°çš„F(2)ï¼Œæ‰€ä»¥H(2,8)ç›¸å½“äºŽå—åˆ°H(4,4)å’ŒH(2,4)çš„å½±å“(å‡è®¾è¿™ä¸ªç»“è®ºå¯¹n==4ä¹Ÿæˆç«‹ï¼ŒH(2,4)==H(1,2))ï¼Œ æ‰€ä»¥H(2,8)==H(1,4) æ‰¾åˆ°è§„å¾‹è¿‡åŽï¼Œæ€»ç»“ä¸€ä¸‹ï¼Œå‡è®¾nçš„å› å­æœ‰ d1,d2,d3...dm å…¶ä¸­ d1&gt;d2&gt;d3...&gt;dm æˆ‘ä»¬ä¾æ¬¡ç¡®å®šH(di,n)çš„å€¼ï¼Œå½“æˆ‘ä»¬åœ¨ç¡®å®šH(di,n)çš„å€¼æ—¶ï¼Œå‰é¢çš„å€¼å·²ç»ç¡®å®šï¼Œå³H(dj, n)(j &lt; i)çš„å€¼å·²ç»ç¡®å®šï¼Œ H(di,n)ä¼šå—åˆ°å‰é¢ä¸€äº›H(dj,n)çš„å½±å“ï¼Œå½“ä¸”ä»…å½“ dj&gt;diä¸” di|dj ã€‚ å‡è®¾ H(a,b)==H(1,b/a)å¯¹å‰é¢çš„ H(dj,n)å’Œ æ‰€æœ‰çš„H(k,m)å…¶ä¸­m &lt; n å·²ç»æˆç«‹(é¦–å…ˆå¯¹äºŽH(n,n)å·²ç»æˆç«‹)ï¼Œé‚£ä¹ˆæœ‰ H(dj,n)==H(1,n/dj)==H(dj/di,n/di) è¿™æ ·å°±æŠŠå‰é¢å¯¹H(di,n)é€ æˆå½±å“çš„Hç”± H(dj,n)è½¬ä¸ºäº† H(dj/di,n/di) ,æ‰€ä»¥H(di,n) == H(1,n/di) æ—¢ç„¶ H(a,b) éƒ½å¯ä»¥ å†™æˆ H(1,b/a) ï¼Œ äºŽæ˜¯æˆ‘ä»¬æŠŠHçš„ç¬¬ä¸€ä¸ªå…ƒç´ ç•¥åŽ»ï¼Œç®€å†™ä¸º H(x) è¯´åˆ°è¿™é‡Œï¼Œå°±å¯ä»¥æŠŠHå’ŒUè”ç³»èµ·æ¥äº†ï¼Œå…¶å®ž U(x) = H(x) = H(1,x) å†æ¥ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç»™U(x)èµ‹äºˆä¸€ä¸ªæ›´å…·ä½“çš„æ„ä¹‰ï¼Œ U(x)è¡¨ç¤ºåœ¨è®¡ç®— F(x)æ—¶ï¼ŒG(1)çš„ç³»æ•°ï¼ï¼(å› ä¸ºU(x)==H(1,x)) æŽ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬æ¥å°è¯•ä¸€ä¸‹ï¼Œå¦‚ä½•ç”¨ä¸Šé¢é‚£ä¸ªU(x)çš„æ–°æ„ä¹‰ï¼Œæ¥è®¡ç®—U(x)çš„å€¼ï¼ï¼ é¦–å…ˆéœ€è¦æ˜Žç¡®2ç‚¹ï¼ ä¸€æ˜¯G(x)ä¸­,ä¸€å®šåŒ…å«ä¸€ä¸ªF(1)ï¼Œå› ä¸º 1|x äºŒæ˜¯ï¼ŒF(1)==G(1) (0).å¦‚æžœ x==1 å› ä¸º F(1)==G(1) æ‰€ä»¥ U[1]=1; (1).å‡è®¾ x æ˜¯ä¸€ä¸ª è´¨æ•° F(x) = U(1)G(x)+U(x)G(1) å¸¦å…¥U(1) == 1, å› ä¸ºG(x)ä¸­å«æœ‰ä¸€ä¸ªF(1),è€Œå·¦è¾¹ä¸å«F(1)ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦åˆ©ç”¨G(1)æ¥æ¶ˆåŽ»F(1) æ‰€ä»¥å¾—åˆ° U(x)=-1 (2).å‡è®¾ x å¯ä»¥å†™æˆ2ä¸ªä¸åŒè´¨æ•°çš„ä¹˜ç§¯ x=p*q é‚£ä¹ˆ F(x)=U(1)G(pq)+U(q)G(p)+U(p)G(q)+U(x)G(1) è¿™é‡Œ U(1)ï¼ŒU(p)ï¼ŒU(q) å°±æ˜¯å‰é¢2ç§æƒ…å†µ å¸¦å…¥ç³»æ•°ï¼Œå› ä¸ºå·¦è¾¹æ²¡æœ‰ F(1)ï¼Œæ‰€ä»¥ä¸ºäº†æŠµæ¶ˆå³è¾¹çš„F(1)ï¼Œæˆ‘ä»¬éœ€è¦ä»¤ U(x)=1; (3).å‡è®¾ x å¯ä»¥å†™æˆ3ä¸ªä¸åŒè´¨æ•°çš„ä¹˜ç§¯ x=pp1p2 æˆ‘ä»¬ä»¤ z = p1*p2 F(x) = U(1)G(pz)+U(z)G(p)+U(p)G(z)+U(x)G(1); å…¶ä¸­ U(1),U(p),U(z) åˆ†åˆ«ä¸ºå‰é¢å‡ ç§æƒ…å†µï¼Œå¸¦å…¥è¿‡åŽ ï¼Œä¸ºæŠµæ¶ˆF(1) å¾—åˆ° U(x)=-1 ç”±æ­¤å¯ä»¥ç›¸åŒçš„æ–¹å¼å‘ä¸‹é€’æŽ¨ï¼Œå¾—åˆ°ç¬¬ä¸€æ¡ç»“è®º å¦‚æžœ x = p1p2...pr , å…¶ä¸­piæ˜¯äº’å¼‚çš„è´¨æ•°ï¼Œé‚£ä¹ˆ U[x] = (-1)^r ----------------------- 1ï¼ï¼ (4).å‡è®¾ x å¯ä»¥å†™æˆä¸€ä¸ªè´¨æ•°çš„å¹³æ–¹ x=p^2 F(x) = U(1)G(x)+U(p)G(p)+U(x)*G(1) å¸¦å…¥ç³»æ•° å¾—åˆ° U(x)=0; (5).å‡è®¾ x å¯ä»¥å†™æˆä¸€ä¸ªè´¨æ•°çš„ä¸‰æ¬¡æ–¹ x=p^3 F(x) = U(1)G(x)+U(p)G(p2)+U(p2)G(p)+U(x)G(1) å¸¦å…¥ç³»æ•°åŽ U(x)=0; ç”±æ­¤å¯ç”¨ç›¸åŒæ–¹å¼å‘ä¸‹é€’æŽ¨ï¼Œå¾—åˆ°ç¬¬äºŒæ¡ç»“è®º å¦‚æžœ x = p^e (e&gt;1) U[x] = 0; -------------------------- 2ï¼ï¼ (6).å‡è®¾ x å¯å†™æˆ x = p^e*q å…¶ä¸­p,qä¸ºä¸åŒè´¨æ•°ï¼Œe&gt;1 F(x) = U(1)G(x)+U(q)G(pe)+U(pe)G(q)+U(x)G(1) å¸¦å…¥ç³»æ•°åŽ U(x) = 0; ç”±æ­¤å¯ç»§ç»­å‘ä¸‹é€’æŽ¨ï¼Œå¾—åˆ°ç¬¬äºŒæ¡ç»“è®ºçš„åŠ å¼ºç‰ˆï¼ï¼ å¦‚æžœ x = p^e*z å…¶ä¸­pä¸ºè´¨æ•°, zä¸ºä»»æ„æ•°,e&gt;1 é‚£ä¹ˆ U[x] = 0 ----------------------2ï¼ï¼ ç”±æ­¤ï¼Œæˆ‘ä»¬å¾—åˆ°äº† U[x] çš„è®¡ç®—æ–¹æ³•ï¼ï¼å³æ˜¯Uå®šä¹‰ä¸­ç»™å‡ºçš„é‚£æ ·ï¼ï¼ï¼ˆæ²¡çœ‹å®šä¹‰çš„åŒå­¦æ­¤æ—¶å†è·³å›žåŽ»çœ‹å§ï¼‰ ä¸‰ï¼šåº”ç”¨ å¾—åˆ°äº†å…¬å¼ï¼Œä¹ŸçŸ¥é“äº†ä»–æ˜¯æ€Žä¹ˆæ¥çš„ï¼ŒçŽ°åœ¨å°±ç”¨ä¸€ä¸ªåº”ç”¨æ¥åŠ æ·±ç†è§£å§ :) é¦–å…ˆæˆ‘ä»¬è¦ç»™å‡º ç¬¬äºŒéƒ¨åˆ† ä¸­é‚£ä¸ªå…¬å¼çš„å¦å¤–ä¸€ç§å½¢å¼ = = æˆ‘ä»¬æŠŠå®ƒç§°ä¸ºå½¢å¼äºŒå§ï½ž åŽŸå¼ : G(n)=sigma(F(d)) (å…¶ä¸­n|d,d&lt;=N) åæ¼”å…¬å¼: F(n)=sigma(U(d/n)*G(d)) (å…¶ä¸­n|d,d&lt;=N) è¿™é‡ŒU[x]çš„è®¡ç®—æ–¹å¼å’Œä¸Šé¢çš„ç›¸åŒï¼ï¼ æ³¨æ„ä¸Šé¢çš„ n|d å’Œ d/n å’Œä¸Šé¢æ˜¯ç›¸åçš„ è¯æ˜Žæ–¹æ³•å’Œä¸Šé¢å·®ä¸å¤šï¼Œå¤§è‡´è¯´ä¸€ä¸‹ è¿˜æ˜¯å…ˆè®¾ç½®ä¸€ä¸ªç³»æ•°å‡½æ•° H(d,n) è¡¨ç¤ºæ±‚è§£ F(n)æ—¶ G(d)å‡ºçŽ°çš„æ¬¡æ•°ï¼Œ æŽ¥ç€ ç”¨ä¸Žä¸Šé¢ç±»ä¼¼çš„æ–¹æ³•å˜åŒ–H(d,n) ä¸º H (d/n,1) ---&gt; H(x,1) åˆ™è”ç³» U(x) == H(x,1) è¡¨ç¤º åœ¨è®¡ç®— F(1)æ—¶ï¼ŒG(x)çš„ç³»æ•° ä»¥ x ä¸ºè´¨æ•°ä¸ºä¾‹å­ï¼Œç”±äºŽ G(1)=F(1)+F(2)....+F(N) F(1) = G(1)+U(2)G(2)...+U(x)G(x)...+U(N)G(N) å› ä¸º x ä¸ºè´¨æ•° æ‰€ä»¥ F(x)è¿™ä¸€é¡¹ åªåœ¨G(1)é‡Œé¢å‡ºçŽ°äº†ä¸€æ¬¡ï¼Œè€Œå…¶ä»–åœ°æ–¹åªä¼šåœ¨ G(x)å‡ºçŽ° æ‰€ä»¥æˆ‘ä»¬éœ€è¦è®© U(x)=-1 æ¥æŠµæ¶ˆ F(x) å‰©ä¸‹çš„æ­¥éª¤å°±å’Œä¸Šé¢å·®ä¸å¤šäº†ï¼Œåˆ†ç±»è®¨è®ºä¸€ä¸‹ï¼Œå°±å¯ä»¥æ±‚å‡ºè¿™ç§æƒ…å†µä¸‹çš„Uçš„è®¡ç®—æ–¹å¼ï¼Œå’Œä¸Šé¢ç›¸åŒï¼ï¼ æŽ¥ä¸‹æ¥å°±çœŸæ­£çš„å¼€å§‹æ¼”ç¤ºæ€Žä¹ˆç”¨ èŽ«æ¯”ä¹Œæ–¯åæ¼” ç®€åŒ–è®¡ç®—äº† ï¼ï¼ çœ‹ä¸‹é¢è¿™ä¸ªé—®é¢˜ï¼ ç»™å‡ºaï¼Œb å…¶ä¸­ (1&lt;=a,b&lt;=10^6) æ±‚æ»¡è¶³æ¡ä»¶çš„ x,y çš„å¯¹æ•°ï¼Œä½¿å¾— 1&lt;=x&lt;=a,1&lt;=y&lt;=b,ä¸”gcd(x,y) == 1ã€‚ å…¶ä¸­ (2,3) (3,2) ç®—ä¸¤å¯¹ï¼ ç›´æŽ¥æš´åŠ›æ˜¾ç„¶å¤æ‚åº¦å¤ªå¤§ï¼Œæˆ‘ä»¬ç”¨èŽ«æ¯”ä¹Œæ–¯åæ¼”æ¥è§£å†³ã€‚ ä»¤N = max(a,b) ç„¶åŽå®šä¹‰ F(n) è¡¨ç¤ºæ»¡è¶³æ¡ä»¶çš„ gcd(x,y)==nçš„ (x,y) å¯¹æ•° åœ¨å®šä¹‰ G(n) è¡¨ç¤ºæ»¡è¶³ n | gcd(x,y) çš„(x,y)å¯¹æ•° å³ gcd(x,y)%n==0 çš„x,yå¯¹æ•° é‚£ä¹ˆæ ¹æ®å®šä¹‰ï¼Œæœ‰ G(n) = sigma(F(d)) (n|d,d&lt;=N) äºŽæ˜¯æˆ‘ä»¬éœ€è¦æ±‚çš„å°±æ˜¯ F(1) æ€Žä¹ˆè§£å†³ï¼Ÿ é¦–å…ˆæ ¹æ®G(n)çš„å®šä¹‰ï¼Œå¯ä»¥å¾ˆå®¹æ˜“å‘çŽ° G(n) = (a/n)*(b/n)è¿™é‡Œæ˜¯å‘ä¸‹æ•´é™¤ ï¼ˆæç¤ºï¼šæŠŠnå½“æˆæœ€å°çš„å…ƒï¼‰ ç„¶åŽ æˆ‘ä»¬åªç›´æŽ¥è®¡ç®— F(1) å³å¯ å¸¦å…¥ G(n) çš„å…¬å¼ æœ‰ F(1) = sigma(U[i](a/i)(b/i)) (1&lt;=i&lt;=N) è‡³äºŽU[]çš„å€¼ï¼Œå¯ä»¥æå‰ç”¨ç­›æ³•åœ¨O(n)çš„æ—¶é—´å†…å¤„ç†å‡ºæ¥ï¼Œè¿™æ ·æ€»çš„æ—¶é—´å¤æ‚åº¦å°±æ˜¯ O(n)ï¼Œé—®é¢˜å¾—åˆ°è§£å†³ï¼ï¼ ä¸‹é¢é™„ä¸Šæˆ‘è‡ªå·±æ±‚U[]çš„ä»£ç  ï¼ˆæ•ˆçŽ‡å¹¶ä¸æ˜¯ä¸¥æ ¼ä¸Šçš„O(n)ï¼Œä¸è¿‡ä¸€èˆ¬æƒ…å†µä¸‹å·²ç»è¶³å¤Ÿï¼‰ å››ï¼šè¿›é˜¶ åœ¨ACMä¸­ï¼Œå¯ä»¥åˆ©ç”¨ èŽ«æ¯”ä¹Œæ–¯åæ¼” æ¥æ±‚è§£å¾ˆå¤šå…³äºŽ Gcd çš„é—®é¢˜ æŽ¨èå‡ é“åŸºç¡€é¢˜ï¼š SPOJ 7001 , ZOJ 3435, HDU 1695. æƒ³åšæ›´å¤šçš„é¢˜çš„è¯ï¼Œè‡ªå·±åŽ»HUST OJæœç´¢å§ :) æœ€åŽå†è¯´ä¸€ä¸‹ä¸Šé¢çš„è¯æ˜Žæ–¹æ³•éƒ½æ˜¯ä¸ªäººYYçš„ï¼Œæ„Ÿè§‰æ¯”ã€Šç»„åˆæ•°å­¦ã€‹ä¸Šçš„è¯æ˜Žç®€å•äº›ï¼ˆæ•°å­¦å¤ªæ¸£orz...é‚£ä¸ªè¯æ˜Žæˆ‘æ˜¯æ²¡çœ‹å¤ªæ‡‚ï¼‰ï¼Œå†™ä¸‹æ¥ ç»™åˆå­¦èŽ«æ¯”ä¹Œæ–¯åæ¼”çš„ç«¥éž‹å½“ä¸ªèµ„æ–™ï¼ˆ= =ï¼‰ã€‚å…³äºŽä¸Šé¢çš„è¯æ˜Žæˆ‘æš‚æ—¶æ²¡å‘çŽ°ä»€ä¹ˆé”™è¯¯ï¼Œå¦‚æžœå‘çŽ°é”™è¯¯ï¼Œè¯·åœ¨å›žå¤é‡Œé¢æŒ‡å‡ºï¼å¦å¤– å½¢å¼äºŒçš„è¯æ˜Žåº”è¯¥å¯ä»¥ç”±å½¢å¼ä¸€ç›´æŽ¥å¾—åˆ°ï¼Œä¸è¿‡æˆ‘æ²¡æƒ³å‡ºä»€ä¹ˆå¥½åŠžæ³•ï¼ŒçŸ¥é“çš„ç¥žç‰›ä¹Ÿè¯·åœ¨è¯„è®ºä¸­è¯´ä¸€ä¸‹ï¼]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>æ•°å­¦</tag>
        <tag>èŽ«æ¯”ä¹Œæ–¯åæ¼”</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[èƒŒåŒ…ä¹è®²]]></title>
    <url>%2F2017%2F05%2F28%2F%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2%2F</url>
    <content type="text"><![CDATA[è½¬è½½ï¼šdd_engi çš„èƒŒåŒ…ä¹è®² è¯¦ç»†åŽŸåšå®¢ï¼ˆéžæœ€åˆä½œè€…ddï¼‰ ç›®å½• ç¬¬ä¸€è®² 01èƒŒåŒ…é—®é¢˜ ç¬¬äºŒè®² å®Œå…¨èƒŒåŒ…é—®é¢˜ ç¬¬ä¸‰è®² å¤šé‡èƒŒåŒ…é—®é¢˜ ç¬¬å››è®² æ··åˆä¸‰ç§èƒŒåŒ…é—®é¢˜ ç¬¬äº”è®² äºŒç»´è´¹ç”¨çš„èƒŒåŒ…é—®é¢˜ ç¬¬å…­è®² åˆ†ç»„çš„èƒŒåŒ…é—®é¢˜ ç¬¬ä¸ƒè®² æœ‰ä¾èµ–çš„èƒŒåŒ…é—®é¢˜ ç¬¬å…«è®² æ³›åŒ–ç‰©å“ ç¬¬ä¹è®² èƒŒåŒ…é—®é¢˜é—®æ³•çš„å˜åŒ– é™„ï¼šUSACOä¸­çš„èƒŒåŒ…é—®é¢˜ å‰è¨€ æœ¬ç¯‡æ–‡ç« æ˜¯æˆ‘(dd_engi)æ­£åœ¨è¿›è¡Œä¸­çš„ä¸€ä¸ªé›„å¿ƒå‹ƒå‹ƒçš„å†™ä½œè®¡åˆ’çš„ä¸€éƒ¨åˆ†ï¼Œè¿™ä¸ªè®¡åˆ’çš„å†…å®¹æ˜¯å†™ä½œä¸€ä»½è¾ƒä¸ºå®Œå–„çš„NOIPéš¾åº¦çš„åŠ¨æ€è§„åˆ’æ€»ç»“ï¼Œåä¸ºã€Šè§£åŠ¨æ€è§„åˆ’é¢˜çš„åŸºæœ¬æ€è€ƒæ–¹å¼ã€‹ã€‚çŽ°åœ¨ä½ çœ‹åˆ°çš„æ˜¯è¿™ä¸ªå†™ä½œè®¡åˆ’æœ€å…ˆå‘å¸ƒçš„ä¸€éƒ¨åˆ†ã€‚ èƒŒåŒ…é—®é¢˜æ˜¯ä¸€ä¸ªç»å…¸çš„åŠ¨æ€è§„åˆ’æ¨¡åž‹ã€‚å®ƒæ—¢ç®€å•å½¢è±¡å®¹æ˜“ç†è§£ï¼Œåˆåœ¨æŸç§ç¨‹åº¦ä¸Šèƒ½å¤Ÿæ­ç¤ºåŠ¨æ€è§„åˆ’çš„æœ¬è´¨ï¼Œæ•…ä¸å°‘æ•™æéƒ½æŠŠå®ƒä½œä¸ºåŠ¨æ€è§„åˆ’éƒ¨åˆ†çš„ç¬¬ä¸€é“ä¾‹é¢˜ï¼Œæˆ‘ä¹Ÿå°†å®ƒæ”¾åœ¨æˆ‘çš„å†™ä½œè®¡åˆ’çš„ç¬¬ä¸€éƒ¨åˆ†ã€‚ è¯»æœ¬æ–‡æœ€é‡è¦çš„æ˜¯æ€è€ƒã€‚å› ä¸ºæˆ‘çš„è¯­è¨€å’Œå†™ä½œæ–¹å¼å‘æ¥ä¸ä»¥æ˜“äºŽç†è§£ä¸ºé•¿ï¼Œæ€è·¯ä¹Ÿå¶æœ‰è·³è·ƒçš„åœ°æ–¹ï¼ŒåŽé¢æ›´æœ‰éœ€è¦å¤§é‡æ€è€ƒæ‰èƒ½ç†è§£çš„æ¯”è¾ƒæŠ½è±¡çš„å†…å®¹ã€‚æ›´é‡è¦çš„æ˜¯ï¼šä¸å¤§é‡æ€è€ƒï¼Œç»å¯¹ä¸å¯èƒ½å­¦å¥½åŠ¨æ€è§„åˆ’è¿™ä¸€ä¿¡æ¯å­¦å¥¥èµ›ä¸­æœ€ç²¾è‡´çš„éƒ¨åˆ†ã€‚ ä½ çŽ°åœ¨çœ‹åˆ°çš„æ˜¯æœ¬æ–‡çš„1.0æ­£å¼ç‰ˆã€‚æˆ‘ä¼šé•¿æœŸç»´æŠ¤è¿™ä»½æ–‡æœ¬ï¼ŒæŠŠå¤§å®¶çš„æ„è§å’Œå»ºè®®èžå…¥å…¶ä¸­ï¼Œä¹Ÿä¼šä¸æ–­åŠ å…¥æˆ‘åœ¨OIå­¦ä¹ ä»¥åŠå°†æ¥å¯èƒ½çš„ACM-ICPCçš„å¾ç¨‹ä¸­å¾—åˆ°çš„æ–°çš„å¿ƒå¾—ã€‚ä½†ç›®å‰æœ¬æ–‡è¿˜æ²¡æœ‰ä¸€ä¸ªå›ºå®šçš„å‘å¸ƒé¡µé¢ï¼Œæƒ³äº†è§£æœ¬æ–‡æ˜¯å¦æœ‰æ›´æ–°ç‰ˆæœ¬å‘å¸ƒï¼Œå¯ä»¥åœ¨OIBHè®ºå›ä¸­ä»¥â€œèƒŒåŒ…é—®é¢˜ä¹è®²â€ä¸ºå…³é”®å­—æœç´¢è´´å­ï¼Œæ¯æ¬¡æ¯”è¾ƒé‡å¤§çš„ç‰ˆæœ¬æ›´æ–°éƒ½ä¼šåœ¨è¿™é‡Œå‘è´´å…¬å¸ƒã€‚ ç›®å½• ç¬¬ä¸€è®² 01èƒŒåŒ…é—®é¢˜ è¿™æ˜¯æœ€åŸºæœ¬çš„èƒŒåŒ…é—®é¢˜ï¼Œæ¯ä¸ªç‰©å“æœ€å¤šåªèƒ½æ”¾ä¸€æ¬¡ã€‚ ç¬¬äºŒè®² å®Œå…¨èƒŒåŒ…é—®é¢˜ ç¬¬äºŒä¸ªåŸºæœ¬çš„èƒŒåŒ…é—®é¢˜æ¨¡åž‹ï¼Œæ¯ç§ç‰©å“å¯ä»¥æ”¾æ— é™å¤šæ¬¡ã€‚ ç¬¬ä¸‰è®² å¤šé‡èƒŒåŒ…é—®é¢˜ æ¯ç§ç‰©å“æœ‰ä¸€ä¸ªå›ºå®šçš„æ¬¡æ•°ä¸Šé™ã€‚ ç¬¬å››è®² æ··åˆä¸‰ç§èƒŒåŒ…é—®é¢˜ å°†å‰é¢ä¸‰ç§ç®€å•çš„é—®é¢˜å åŠ æˆè¾ƒå¤æ‚çš„é—®é¢˜ã€‚ ç¬¬äº”è®² äºŒç»´è´¹ç”¨çš„èƒŒåŒ…é—®é¢˜ ä¸€ä¸ªç®€å•çš„å¸¸è§æ‰©å±•ã€‚ ç¬¬å…­è®² åˆ†ç»„çš„èƒŒåŒ…é—®é¢˜ ä¸€ç§é¢˜ç›®ç±»åž‹ï¼Œä¹Ÿæ˜¯ä¸€ä¸ªæœ‰ç”¨çš„æ¨¡åž‹ã€‚åŽä¸¤èŠ‚çš„åŸºç¡€ã€‚ ç¬¬ä¸ƒè®² æœ‰ä¾èµ–çš„èƒŒåŒ…é—®é¢˜ å¦ä¸€ç§ç»™ç‰©å“çš„é€‰å–åŠ ä¸Šé™åˆ¶çš„æ–¹æ³•ã€‚ ç¬¬å…«è®² æ³›åŒ–ç‰©å“ æˆ‘è‡ªå·±å…³äºŽèƒŒåŒ…é—®é¢˜çš„æ€è€ƒæˆæžœï¼Œæœ‰ä¸€ç‚¹æŠ½è±¡ã€‚ ç¬¬ä¹è®² èƒŒåŒ…é—®é¢˜é—®æ³•çš„å˜åŒ– è¯•å›¾è§¦ç±»æ—é€šã€ä¸¾ä¸€åä¸‰ã€‚ èƒŒåŒ…çš„æœç´¢ é™„ï¼šUSACOä¸­çš„èƒŒåŒ…é—®é¢˜ ç»™å‡º USACO Training ä¸Šå¯ä¾›ç»ƒä¹ çš„èƒŒåŒ…é—®é¢˜åˆ—è¡¨ï¼ŒåŠç®€å•çš„è§£ç­”ã€‚ è”ç³»æ–¹å¼ å¦‚æžœæœ‰ä»»ä½•æ„è§å’Œå»ºè®®ï¼Œç‰¹åˆ«æ˜¯æ–‡ç« çš„é”™è¯¯å’Œä¸è¶³ï¼Œæˆ–è€…å¸Œæœ›ä¸ºæ–‡ç« æ·»åŠ æ–°çš„ææ–™ï¼Œå¯ä»¥é€šè¿‡http://kontactr.com/user/tianyi/è¿™ä¸ªç½‘é¡µè”ç³»æˆ‘ã€‚ è‡´è°¢ æ„Ÿè°¢ä»¥ä¸‹åå•ï¼š é˜¿å¦ jason911 donglixp ä»–ä»¬æ¯äººéƒ½æœ€å…ˆæŒ‡å‡ºäº†æœ¬æ–‡ç¬¬ä¸€ä¸ªbetaç‰ˆä¸­çš„æŸä¸ªå¹¶éžæ— å…³ç´§è¦çš„é”™è¯¯ã€‚è°¢è°¢ä½ ä»¬å¦‚æ­¤ä»”ç»†åœ°é˜…è¯»æ‹™ä½œå¹¶å¼¥è¡¥æˆ‘çš„ç–æ¼ã€‚ æ„Ÿè°¢ XiaQï¼Œå®ƒé’ˆå¯¹æœ¬æ–‡çš„ç¬¬ä¸€ä¸ªbetaç‰ˆå‘è¡¨äº†ç”¨è¯ä¸¥åŽ‰çš„å…­æ¡å»ºè®®ï¼Œè™½ç„¶æˆ‘åªè®¤åŒå¹¶é‡‡çº³äº†å…¶ä¸­çš„ä¸¤æ¡ã€‚åœ¨æ‰€æœ‰è¯»è€…å‡ ä¹Žä¸€è¾¹å€’çš„èµžæ‰¬å°†æˆ‘åŒ…å›´çš„å½“æ—¶ï¼Œä½ çš„è´´å­æ˜¯æˆ‘çš„ä¸€å‰‚æ¸…é†’å‰‚ï¼Œè®©æˆ‘èƒ½æ¸…é†’èµ·æ¥å¹¶ç”¨æ›´ä¸¥åŽ‰çš„çœ¼å…‰å®¡è§†è‡ªå·±çš„ä½œå“ã€‚ å½“ç„¶ï¼Œè¿˜æœ‰ç”¨å„ç§æ–¹å¼å¯¹æˆ‘è¡¨ç¤ºé¼“åŠ±å’Œæ”¯æŒçš„å‡ ä¹Žæ— æ³•è®¡æ•°çš„åŒå­¦ã€‚ä¸ç®¡æ˜¯å½“é¢èµžæ‰¬ï¼Œæˆ–æ˜¯åœ¨è®ºå›ä¸Šå›žå¤æˆ‘çš„è´´å­ï¼Œä¸ç®¡æ˜¯å‘æ¥çƒ­æƒ…æ´‹æº¢çš„é‚®ä»¶ï¼Œæˆ–æ˜¯åœ¨å³æ—¶èŠå¤©çš„çª—å£é‡Œç«–èµ·å¤§æ‹‡æŒ‡ï¼Œä½ ä»¬çš„é¼“åŠ±å’Œæ”¯æŒæ˜¯æ”¯æ’‘æˆ‘çš„å†™ä½œè®¡åˆ’çš„å¼ºå¤§åŠ¨åŠ›ï¼Œä¹Ÿéž­ç­–ç€æˆ‘ä¸æ–­æé«˜è‡ªèº«æ°´å¹³ï¼Œè°¢è°¢ä½ ä»¬ï¼ æœ€åŽï¼Œæ„Ÿè°¢ Emacs è¿™ä¸€ä¸–ç•Œæœ€å¼ºå¤§çš„ç¼–è¾‘å™¨çš„æ‰€æœ‰è´¡çŒ®è€…ï¼Œæ„Ÿè°¢å®ƒçš„æ’ä»¶ EmacsMuse çš„å¼€å‘è€…ä»¬ï¼Œæœ¬æ–‡çš„æ‰€æœ‰ç¼–è¾‘å·¥ä½œéƒ½å€ŸåŠ©è¿™ä¸¤ä¸ªå“è¶Šçš„è‡ªç”±è½¯ä»¶å®Œæˆã€‚è°¢è°¢ä½ ä»¬â€”â€”è‡ªç”±è½¯ä»¶ç¤¾ç¾¤â€”â€”ä¸ºç¤¾ä¼šæä¾›äº†å¦‚æ­¤æœ‰ç”Ÿäº§åŠ›çš„å·¥å…·ã€‚æˆ‘æ·±æ·±é’¦ä½©ä½ ä»¬èº«ä¸Šä½“çŽ°å‡ºçš„è‡ªç”±è½¯ä»¶çš„ç²¾ç¥žï¼Œæ²¡æœ‰ä½ ä»¬çš„æ„Ÿå¬ï¼Œæˆ‘ä¸èƒ½å®Œæˆæœ¬æ–‡ã€‚åœ¨ä½ ä»¬çš„å½±å“ä¸‹ï¼Œé‡‡ç”¨è‡ªç”±æ–‡æ¡£çš„æ–¹å¼å‘å¸ƒæœ¬æ–‡æ¡£ï¼Œä¹Ÿæ˜¯æˆ‘å¯¹è‡ªç”±ç¤¾ä¼šäº‹ä¸šçš„å¾®è–„åŠªåŠ›ã€‚ P01: 01èƒŒåŒ…é—®é¢˜ é¢˜ç›® æœ‰Nä»¶ç‰©å“å’Œä¸€ä¸ªå®¹é‡ä¸ºVçš„èƒŒåŒ…ã€‚ç¬¬iä»¶ç‰©å“çš„è´¹ç”¨æ˜¯c[i]ï¼Œä»·å€¼æ˜¯w[i]ã€‚æ±‚è§£å°†å“ªäº›ç‰©å“è£…å…¥èƒŒåŒ…å¯ä½¿ä»·å€¼æ€»å’Œæœ€å¤§ã€‚ åŸºæœ¬æ€è·¯ è¿™æ˜¯æœ€åŸºç¡€çš„èƒŒåŒ…é—®é¢˜ï¼Œç‰¹ç‚¹æ˜¯ï¼šæ¯ç§ç‰©å“ä»…æœ‰ä¸€ä»¶ï¼Œå¯ä»¥é€‰æ‹©æ”¾æˆ–ä¸æ”¾ã€‚ ç”¨å­é—®é¢˜å®šä¹‰çŠ¶æ€ï¼šå³f[i][v]è¡¨ç¤ºå‰iä»¶ç‰©å“æ°æ”¾å…¥ä¸€ä¸ªå®¹é‡ä¸ºvçš„èƒŒåŒ…å¯ä»¥èŽ·å¾—çš„æœ€å¤§ä»·å€¼ã€‚åˆ™å…¶çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¾¿æ˜¯ï¼š f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]} è¿™ä¸ªæ–¹ç¨‹éžå¸¸é‡è¦ï¼ŒåŸºæœ¬ä¸Šæ‰€æœ‰è·ŸèƒŒåŒ…ç›¸å…³çš„é—®é¢˜çš„æ–¹ç¨‹éƒ½æ˜¯ç”±å®ƒè¡ç”Ÿå‡ºæ¥çš„ã€‚æ‰€ä»¥æœ‰å¿…è¦å°†å®ƒè¯¦ç»†è§£é‡Šä¸€ä¸‹ï¼šâ€œå°†å‰iä»¶ç‰©å“æ”¾å…¥å®¹é‡ä¸ºvçš„èƒŒåŒ…ä¸­â€è¿™ä¸ªå­é—®é¢˜ï¼Œè‹¥åªè€ƒè™‘ç¬¬iä»¶ç‰©å“çš„ç­–ç•¥ï¼ˆæ”¾æˆ–ä¸æ”¾ï¼‰ï¼Œé‚£ä¹ˆå°±å¯ä»¥è½¬åŒ–ä¸ºä¸€ä¸ªåªç‰µæ‰¯å‰i-1ä»¶ç‰©å“çš„é—®é¢˜ã€‚å¦‚æžœä¸æ”¾ç¬¬iä»¶ç‰©å“ï¼Œé‚£ä¹ˆé—®é¢˜å°±è½¬åŒ–ä¸ºâ€œå‰i-1ä»¶ç‰©å“æ”¾å…¥å®¹é‡ä¸ºvçš„èƒŒåŒ…ä¸­â€ï¼Œä»·å€¼ä¸ºf[i-1][v]ï¼›å¦‚æžœæ”¾ç¬¬iä»¶ç‰©å“ï¼Œé‚£ä¹ˆé—®é¢˜å°±è½¬åŒ–ä¸ºâ€œå‰i-1ä»¶ç‰©å“æ”¾å…¥å‰©ä¸‹çš„å®¹é‡ä¸ºv-c[i]çš„èƒŒåŒ…ä¸­â€ï¼Œæ­¤æ—¶èƒ½èŽ·å¾—çš„æœ€å¤§ä»·å€¼å°±æ˜¯f[i-1][v-c[i]]å†åŠ ä¸Šé€šè¿‡æ”¾å…¥ç¬¬iä»¶ç‰©å“èŽ·å¾—çš„ä»·å€¼w[i]ã€‚ ä¼˜åŒ–ç©ºé—´å¤æ‚åº¦ ä»¥ä¸Šæ–¹æ³•çš„æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦å‡ä¸ºO(N*V)ï¼Œå…¶ä¸­æ—¶é—´å¤æ‚åº¦åŸºæœ¬å·²ç»ä¸èƒ½å†ä¼˜åŒ–äº†ï¼Œä½†ç©ºé—´å¤æ‚åº¦å´å¯ä»¥ä¼˜åŒ–åˆ°O(V)ã€‚ å…ˆè€ƒè™‘ä¸Šé¢è®²çš„åŸºæœ¬æ€è·¯å¦‚ä½•å®žçŽ°ï¼Œè‚¯å®šæ˜¯æœ‰ä¸€ä¸ªä¸»å¾ªçŽ¯i=1..Nï¼Œæ¯æ¬¡ç®—å‡ºæ¥äºŒç»´æ•°ç»„f[i][0..V]çš„æ‰€æœ‰å€¼ã€‚é‚£ä¹ˆï¼Œå¦‚æžœåªç”¨ä¸€ä¸ªæ•°ç»„f[0..V]ï¼Œèƒ½ä¸èƒ½ä¿è¯ç¬¬iæ¬¡å¾ªçŽ¯ç»“æŸåŽf[v]ä¸­è¡¨ç¤ºçš„å°±æ˜¯æˆ‘ä»¬å®šä¹‰çš„çŠ¶æ€f[i][v]å‘¢ï¼Ÿf[i][v]æ˜¯ç”±f[i-1][v]å’Œf[i-1][v-c[i]]ä¸¤ä¸ªå­é—®é¢˜é€’æŽ¨è€Œæ¥ï¼Œèƒ½å¦ä¿è¯åœ¨æŽ¨f[i][v]æ—¶ï¼ˆä¹Ÿå³åœ¨ç¬¬iæ¬¡ä¸»å¾ªçŽ¯ä¸­æŽ¨f[v]æ—¶ï¼‰èƒ½å¤Ÿå¾—åˆ°f[i-1][v]å’Œf[i-1][v-c[i]]çš„å€¼å‘¢ï¼Ÿäº‹å®žä¸Šï¼Œè¿™è¦æ±‚åœ¨æ¯æ¬¡ä¸»å¾ªçŽ¯ä¸­æˆ‘ä»¬ä»¥v=V..0çš„é¡ºåºæŽ¨f[v]ï¼Œè¿™æ ·æ‰èƒ½ä¿è¯æŽ¨f[v]æ—¶f[v-c[i]]ä¿å­˜çš„æ˜¯çŠ¶æ€f[i-1][v-c[i]]çš„å€¼ã€‚ä¼ªä»£ç å¦‚ä¸‹ï¼š 123for i=1..N for v=V..0 f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; å…¶ä¸­çš„f[v]=max{f[v],f[v-c[i]]}ä¸€å¥æ°å°±ç›¸å½“äºŽæˆ‘ä»¬çš„è½¬ç§»æ–¹ç¨‹f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]}ï¼Œå› ä¸ºçŽ°åœ¨çš„f[v-c[i]]å°±ç›¸å½“äºŽåŽŸæ¥çš„f[i-1][v-c[i]]ã€‚å¦‚æžœå°†vçš„å¾ªçŽ¯é¡ºåºä»Žä¸Šé¢çš„é€†åºæ”¹æˆé¡ºåºçš„è¯ï¼Œé‚£ä¹ˆåˆ™æˆäº†f[i][v]ç”±f[i][v-c[i]]æŽ¨çŸ¥ï¼Œä¸Žæœ¬é¢˜æ„ä¸ç¬¦ï¼Œä½†å®ƒå´æ˜¯å¦ä¸€ä¸ªé‡è¦çš„èƒŒåŒ…é—®é¢˜P02æœ€ç®€æ·çš„è§£å†³æ–¹æ¡ˆï¼Œæ•…å­¦ä¹ åªç”¨ä¸€ç»´æ•°ç»„è§£01èƒŒåŒ…é—®é¢˜æ˜¯ååˆ†å¿…è¦çš„ã€‚ äº‹å®žä¸Šï¼Œä½¿ç”¨ä¸€ç»´æ•°ç»„è§£01èƒŒåŒ…çš„ç¨‹åºåœ¨åŽé¢ä¼šè¢«å¤šæ¬¡ç”¨åˆ°ï¼Œæ‰€ä»¥è¿™é‡ŒæŠ½è±¡å‡ºä¸€ä¸ªå¤„ç†ä¸€ä»¶01èƒŒåŒ…ä¸­çš„ç‰©å“è¿‡ç¨‹ï¼Œä»¥åŽçš„ä»£ç ä¸­ç›´æŽ¥è°ƒç”¨ä¸åŠ è¯´æ˜Žã€‚{ï¼èƒŒè¿‡} æˆ‘ä»¬çœ‹ä¸€ä¸‹åŽŸæ¥çš„æ–¹ç¨‹f[i][v]=max{f[i-1][v], f[i-1][v-c[i]]+w[i]} ä¸ä¸€å®šä»Ž1å¼€å§‹ï¼Œé‚£æ ·ä¼šæµªè´¹ â€‹ è¿‡ç¨‹ZeroOnePackï¼Œè¡¨ç¤ºå¤„ç†ä¸€ä»¶01èƒŒåŒ…ä¸­çš„ç‰©å“ï¼Œä¸¤ä¸ªå‚æ•°costã€weightåˆ†åˆ«è¡¨æ˜Žè¿™ä»¶ç‰©å“çš„è´¹ç”¨å’Œä»·å€¼ã€‚ 123procedure ZeroOnePack(cost,weight) for v=V..cost f[v]=max&#123;f[v],f[v-cost]+weight&#125; æ³¨æ„è¿™ä¸ªè¿‡ç¨‹é‡Œçš„å¤„ç†ä¸Žå‰é¢ç»™å‡ºçš„ä¼ªä»£ç æœ‰æ‰€ä¸åŒã€‚å‰é¢çš„ç¤ºä¾‹ç¨‹åºå†™æˆv=V..0æ˜¯ä¸ºäº†åœ¨ç¨‹åºä¸­ä½“çŽ°æ¯ä¸ªçŠ¶æ€éƒ½æŒ‰ç…§æ–¹ç¨‹æ±‚è§£äº†ï¼Œé¿å…ä¸å¿…è¦çš„æ€ç»´å¤æ‚åº¦ã€‚è€Œè¿™é‡Œæ—¢ç„¶å·²ç»æŠ½è±¡æˆçœ‹ä½œé»‘ç®±çš„è¿‡ç¨‹äº†ï¼Œå°±å¯ä»¥åŠ å…¥ä¼˜åŒ–ã€‚è´¹ç”¨ä¸ºcostçš„ç‰©å“ä¸ä¼šå½±å“çŠ¶æ€f[0..cost-1]ï¼Œè¿™æ˜¯æ˜¾ç„¶çš„ã€‚ æœ‰äº†è¿™ä¸ªè¿‡ç¨‹ä»¥åŽï¼Œ01èƒŒåŒ…é—®é¢˜çš„ä¼ªä»£ç å°±å¯ä»¥è¿™æ ·å†™ï¼š 12for i=1..N ZeroOnePack(c[i],w[i]); åˆå§‹åŒ–çš„ç»†èŠ‚é—®é¢˜ æˆ‘ä»¬çœ‹åˆ°çš„æ±‚æœ€ä¼˜è§£çš„èƒŒåŒ…é—®é¢˜é¢˜ç›®ä¸­ï¼Œäº‹å®žä¸Šæœ‰ä¸¤ç§ä¸å¤ªç›¸åŒçš„é—®æ³•ã€‚æœ‰çš„é¢˜ç›®è¦æ±‚â€œæ°å¥½è£…æ»¡èƒŒåŒ…â€æ—¶çš„æœ€ä¼˜è§£ï¼Œæœ‰çš„é¢˜ç›®åˆ™å¹¶æ²¡æœ‰è¦æ±‚å¿…é¡»æŠŠèƒŒåŒ…è£…æ»¡ã€‚ä¸€ç§åŒºåˆ«è¿™ä¸¤ç§é—®æ³•çš„å®žçŽ°æ–¹æ³•æ˜¯åœ¨åˆå§‹åŒ–çš„æ—¶å€™æœ‰æ‰€ä¸åŒã€‚ å¦‚æžœæ˜¯ç¬¬ä¸€ç§é—®æ³•ï¼Œè¦æ±‚æ°å¥½è£…æ»¡èƒŒåŒ…ï¼Œé‚£ä¹ˆåœ¨åˆå§‹åŒ–æ—¶é™¤äº†f[0]ä¸º0å…¶å®ƒf[1..V]å‡è®¾ä¸º-âˆžï¼Œè¿™æ ·å°±å¯ä»¥ä¿è¯æœ€ç»ˆå¾—åˆ°çš„f[N]æ˜¯ä¸€ç§æ°å¥½è£…æ»¡èƒŒåŒ…çš„æœ€ä¼˜è§£ã€‚ å¦‚æžœå¹¶æ²¡æœ‰è¦æ±‚å¿…é¡»æŠŠèƒŒåŒ…è£…æ»¡ï¼Œè€Œæ˜¯åªå¸Œæœ›ä»·æ ¼å°½é‡å¤§ï¼Œåˆå§‹åŒ–æ—¶åº”è¯¥å°†f[0..V]å…¨éƒ¨è®¾ä¸º0ã€‚ ä¸ºä»€ä¹ˆå‘¢ï¼Ÿå¯ä»¥è¿™æ ·ç†è§£ï¼šåˆå§‹åŒ–çš„fæ•°ç»„äº‹å®žä¸Šå°±æ˜¯åœ¨æ²¡æœ‰ä»»ä½•ç‰©å“å¯ä»¥æ”¾å…¥èƒŒåŒ…æ—¶çš„åˆæ³•çŠ¶æ€ã€‚å¦‚æžœè¦æ±‚èƒŒåŒ…æ°å¥½è£…æ»¡ï¼Œé‚£ä¹ˆæ­¤æ—¶åªæœ‰å®¹é‡ä¸º0çš„èƒŒåŒ…å¯èƒ½è¢«ä»·å€¼ä¸º0çš„nothingâ€œæ°å¥½è£…æ»¡â€ï¼Œå…¶å®ƒå®¹é‡çš„èƒŒåŒ…å‡æ²¡æœ‰åˆæ³•çš„è§£ï¼Œå±žäºŽæœªå®šä¹‰çš„çŠ¶æ€ï¼Œå®ƒä»¬çš„å€¼å°±éƒ½åº”è¯¥æ˜¯-âˆžäº†ã€‚å¦‚æžœèƒŒåŒ…å¹¶éžå¿…é¡»è¢«è£…æ»¡ï¼Œé‚£ä¹ˆä»»ä½•å®¹é‡çš„èƒŒåŒ…éƒ½æœ‰ä¸€ä¸ªåˆæ³•è§£â€œä»€ä¹ˆéƒ½ä¸è£…â€ï¼Œè¿™ä¸ªè§£çš„ä»·å€¼ä¸º0ï¼Œæ‰€ä»¥åˆå§‹æ—¶çŠ¶æ€çš„å€¼ä¹Ÿå°±å…¨éƒ¨ä¸º0äº†ã€‚ è¿™ä¸ªå°æŠ€å·§å®Œå…¨å¯ä»¥æŽ¨å¹¿åˆ°å…¶å®ƒç±»åž‹çš„èƒŒåŒ…é—®é¢˜ï¼ŒåŽé¢ä¹Ÿå°±ä¸å†å¯¹è¿›è¡ŒçŠ¶æ€è½¬ç§»ä¹‹å‰çš„åˆå§‹åŒ–è¿›è¡Œè®²è§£ã€‚ å°ç»“ 01èƒŒåŒ…é—®é¢˜æ˜¯æœ€åŸºæœ¬çš„èƒŒåŒ…é—®é¢˜ï¼Œå®ƒåŒ…å«äº†èƒŒåŒ…é—®é¢˜ä¸­è®¾è®¡çŠ¶æ€ã€æ–¹ç¨‹çš„æœ€åŸºæœ¬æ€æƒ³ï¼Œå¦å¤–ï¼Œåˆ«çš„ç±»åž‹çš„èƒŒåŒ…é—®é¢˜å¾€å¾€ä¹Ÿå¯ä»¥è½¬æ¢æˆ01èƒŒåŒ…é—®é¢˜æ±‚è§£ã€‚æ•…ä¸€å®šè¦ä»”ç»†ä½“ä¼šä¸Šé¢åŸºæœ¬æ€è·¯çš„å¾—å‡ºæ–¹æ³•ï¼ŒçŠ¶æ€è½¬ç§»æ–¹ç¨‹çš„æ„ä¹‰ï¼Œä»¥åŠæœ€åŽæ€Žæ ·ä¼˜åŒ–çš„ç©ºé—´å¤æ‚åº¦ã€‚ é¦–é¡µ P02: å®Œå…¨èƒŒåŒ…é—®é¢˜ é¢˜ç›® æœ‰Nç§ç‰©å“å’Œä¸€ä¸ªå®¹é‡ä¸ºVçš„èƒŒåŒ…ï¼Œæ¯ç§ç‰©å“éƒ½æœ‰æ— é™ä»¶å¯ç”¨ã€‚ç¬¬iç§ç‰©å“çš„è´¹ç”¨æ˜¯c[i]ï¼Œä»·å€¼æ˜¯w[i]ã€‚æ±‚è§£å°†å“ªäº›ç‰©å“è£…å…¥èƒŒåŒ…å¯ä½¿è¿™äº›ç‰©å“çš„è´¹ç”¨æ€»å’Œä¸è¶…è¿‡èƒŒåŒ…å®¹é‡ï¼Œä¸”ä»·å€¼æ€»å’Œæœ€å¤§ã€‚ åŸºæœ¬æ€è·¯ è¿™ä¸ªé—®é¢˜éžå¸¸ç±»ä¼¼äºŽ01èƒŒåŒ…é—®é¢˜ ï¼Œæ‰€ä¸åŒçš„æ˜¯æ¯ç§ç‰©å“æœ‰æ— é™ä»¶ã€‚ä¹Ÿå°±æ˜¯ä»Žæ¯ç§ç‰©å“çš„è§’åº¦è€ƒè™‘ï¼Œä¸Žå®ƒç›¸å…³çš„ç­–ç•¥å·²å¹¶éžå–æˆ–ä¸å–ä¸¤ç§ï¼Œè€Œæ˜¯æœ‰å–0ä»¶ã€å–1ä»¶ã€å–2ä»¶â€¦â€¦ç­‰å¾ˆå¤šç§ã€‚å¦‚æžœä»ç„¶æŒ‰ç…§è§£01èƒŒåŒ…æ—¶çš„æ€è·¯ï¼Œä»¤f[i][v]è¡¨ç¤ºå‰iç§ç‰©å“æ°æ”¾å…¥ä¸€ä¸ªå®¹é‡ä¸ºvçš„èƒŒåŒ…çš„æœ€å¤§æƒå€¼ã€‚ä»ç„¶å¯ä»¥æŒ‰ç…§æ¯ç§ç‰©å“ä¸åŒçš„ç­–ç•¥å†™å‡ºçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œåƒè¿™æ ·ï¼š f[i][v]=max{f[i-1][v-k*c[i]]+kw[i]|0&lt;=kc[i]&lt;=v} è¿™è·Ÿ01èƒŒåŒ…é—®é¢˜ä¸€æ ·æœ‰O(NV)ä¸ªçŠ¶æ€éœ€è¦æ±‚è§£ï¼Œä½†æ±‚è§£æ¯ä¸ªçŠ¶æ€çš„æ—¶é—´å·²ç»ä¸æ˜¯å¸¸æ•°äº†ï¼Œæ±‚è§£çŠ¶æ€f[i][v]çš„æ—¶é—´æ˜¯O(v/c[i])ï¼Œæ€»çš„å¤æ‚åº¦æ˜¯è¶…è¿‡O(VN)çš„ã€‚ å°†01èƒŒåŒ…é—®é¢˜çš„åŸºæœ¬æ€è·¯åŠ ä»¥æ”¹è¿›ï¼Œå¾—åˆ°äº†è¿™æ ·ä¸€ä¸ªæ¸…æ™°çš„æ–¹æ³•ã€‚è¿™è¯´æ˜Ž01èƒŒåŒ…é—®é¢˜çš„æ–¹ç¨‹çš„ç¡®æ˜¯å¾ˆé‡è¦ï¼Œå¯ä»¥æŽ¨åŠå…¶å®ƒç±»åž‹çš„èƒŒåŒ…é—®é¢˜ã€‚ä½†æˆ‘ä»¬è¿˜æ˜¯è¯•å›¾æ”¹è¿›è¿™ä¸ªå¤æ‚åº¦ã€‚ ä¸€ä¸ªç®€å•æœ‰æ•ˆçš„ä¼˜åŒ– å®Œå…¨èƒŒåŒ…é—®é¢˜æœ‰ä¸€ä¸ªå¾ˆç®€å•æœ‰æ•ˆçš„ä¼˜åŒ–ï¼Œæ˜¯è¿™æ ·çš„ï¼šè‹¥ä¸¤ä»¶ç‰©å“iã€jæ»¡è¶³c[i]&lt;=c[j]ä¸”w[i]&gt;=w[j]ï¼Œåˆ™å°†ç‰©å“jåŽ»æŽ‰ï¼Œä¸ç”¨è€ƒè™‘ã€‚è¿™ä¸ªä¼˜åŒ–çš„æ­£ç¡®æ€§æ˜¾ç„¶ï¼šä»»ä½•æƒ…å†µä¸‹éƒ½å¯å°†ä»·å€¼å°è´¹ç”¨é«˜å¾—jæ¢æˆç‰©ç¾Žä»·å»‰çš„iï¼Œå¾—åˆ°è‡³å°‘ä¸ä¼šæ›´å·®çš„æ–¹æ¡ˆã€‚å¯¹äºŽéšæœºç”Ÿæˆçš„æ•°æ®ï¼Œè¿™ä¸ªæ–¹æ³•å¾€å¾€ä¼šå¤§å¤§å‡å°‘ç‰©å“çš„ä»¶æ•°ï¼Œä»Žè€ŒåŠ å¿«é€Ÿåº¦ã€‚ç„¶è€Œè¿™ä¸ªå¹¶ä¸èƒ½æ”¹å–„æœ€åæƒ…å†µçš„å¤æ‚åº¦ï¼Œå› ä¸ºæœ‰å¯èƒ½ç‰¹åˆ«è®¾è®¡çš„æ•°æ®å¯ä»¥ä¸€ä»¶ç‰©å“ä¹ŸåŽ»ä¸æŽ‰ã€‚ è¿™ä¸ªä¼˜åŒ–å¯ä»¥ç®€å•çš„O(N^2)åœ°å®žçŽ°ï¼Œä¸€èˆ¬éƒ½å¯ä»¥æ‰¿å—ã€‚å¦å¤–ï¼Œé’ˆå¯¹èƒŒåŒ…é—®é¢˜è€Œè¨€ï¼Œæ¯”è¾ƒä¸é”™çš„ä¸€ç§æ–¹æ³•æ˜¯ï¼š[æ˜¾ç„¶]é¦–å…ˆå°†è´¹ç”¨å¤§äºŽVçš„ç‰©å“åŽ»æŽ‰ï¼Œç„¶åŽä½¿ç”¨ç±»ä¼¼è®¡æ•°æŽ’åºçš„åšæ³•ï¼Œè®¡ç®—å‡ºè´¹ç”¨ç›¸åŒçš„ç‰©å“ä¸­ä»·å€¼æœ€é«˜çš„æ˜¯å“ªä¸ªï¼Œå¯ä»¥O(V+N)åœ°å®Œæˆè¿™ä¸ªä¼˜åŒ–ã€‚è¿™ä¸ªä¸å¤ªé‡è¦çš„è¿‡ç¨‹å°±ä¸ç»™å‡ºä¼ªä»£ç äº†ï¼Œå¸Œæœ›ä½ èƒ½ç‹¬ç«‹æ€è€ƒå†™å‡ºä¼ªä»£ç æˆ–ç¨‹åºã€‚ è½¬åŒ–ä¸º01èƒŒåŒ…é—®é¢˜æ±‚è§£ æ—¢ç„¶01èƒŒåŒ…é—®é¢˜æ˜¯æœ€åŸºæœ¬çš„èƒŒåŒ…é—®é¢˜ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥è€ƒè™‘æŠŠå®Œå…¨èƒŒåŒ…é—®é¢˜è½¬åŒ–ä¸º01èƒŒåŒ…é—®é¢˜æ¥è§£ã€‚æœ€ç®€å•çš„æƒ³æ³•æ˜¯ï¼Œè€ƒè™‘åˆ°ç¬¬iç§ç‰©å“æœ€å¤šé€‰V/c[i]ä»¶ï¼ŒäºŽæ˜¯å¯ä»¥æŠŠç¬¬iç§ç‰©å“è½¬åŒ–ä¸ºV/c[i]ä»¶è´¹ç”¨åŠä»·å€¼å‡ä¸å˜çš„ç‰©å“ï¼Œç„¶åŽæ±‚è§£è¿™ä¸ª01èƒŒåŒ…é—®é¢˜ã€‚è¿™æ ·å®Œå…¨æ²¡æœ‰æ”¹è¿›åŸºæœ¬æ€è·¯çš„æ—¶é—´å¤æ‚åº¦ï¼Œä½†è¿™æ¯•ç«Ÿç»™äº†æˆ‘ä»¬å°†å®Œå…¨èƒŒåŒ…é—®é¢˜è½¬åŒ–ä¸º01èƒŒåŒ…é—®é¢˜çš„æ€è·¯ï¼šå°†ä¸€ç§ç‰©å“æ‹†æˆå¤šä»¶ç‰©å“ã€‚ æ›´é«˜æ•ˆçš„è½¬åŒ–æ–¹æ³•æ˜¯ï¼šæŠŠç¬¬iç§ç‰©å“æ‹†æˆè´¹ç”¨ä¸ºc[i]2kã€ä»·å€¼ä¸ºw[i]2^kçš„è‹¥å¹²ä»¶ç‰©å“ï¼Œå…¶ä¸­kæ»¡è¶³c[i]2k&lt;=Vã€‚è¿™æ˜¯äºŒè¿›åˆ¶çš„æ€æƒ³ï¼Œå› ä¸ºä¸ç®¡æœ€ä¼˜ç­–ç•¥é€‰å‡ ä»¶ç¬¬iç§ç‰©å“ï¼Œæ€»å¯ä»¥è¡¨ç¤ºæˆè‹¥å¹²ä¸ª2^kä»¶ç‰©å“çš„å’Œã€‚è¿™æ ·æ¯”æŠŠæ¯ç§ç‰©å“æ‹†æˆO(log(V/c[i]))ä»¶ç‰©å“ï¼Œæ˜¯ä¸€ä¸ªå¾ˆå¤§çš„æ”¹è¿›ã€‚ ä½†æˆ‘ä»¬æœ‰æ›´ä¼˜çš„O(VN)çš„ç®—æ³•ã€‚ O(VN)çš„ç®—æ³• è¿™ä¸ªç®—æ³•ä½¿ç”¨ä¸€ç»´æ•°ç»„ï¼Œå…ˆçœ‹ä¼ªä»£ç ï¼š 123for i=1..N for v=0..V f[v]=max&#123;f[v],f[v-cost]+weight&#125; ä½ ä¼šå‘çŽ°ï¼Œè¿™ä¸ªä¼ªä»£ç ä¸ŽP01çš„ä¼ªä»£ç åªæœ‰vçš„å¾ªçŽ¯æ¬¡åºä¸åŒè€Œå·²ã€‚ä¸ºä»€ä¹ˆè¿™æ ·ä¸€æ”¹å°±å¯è¡Œå‘¢ï¼Ÿé¦–å…ˆæƒ³æƒ³ä¸ºä»€ä¹ˆP01ä¸­è¦æŒ‰ç…§v=V..0çš„é€†åºæ¥å¾ªçŽ¯ã€‚è¿™æ˜¯å› ä¸ºè¦ä¿è¯ç¬¬iæ¬¡å¾ªçŽ¯ä¸­çš„çŠ¶æ€f[i][v]æ˜¯ç”±çŠ¶æ€f[i-1][v-c[i]]é€’æŽ¨è€Œæ¥ã€‚æ¢å¥è¯è¯´ï¼Œè¿™æ­£æ˜¯ä¸ºäº†ä¿è¯æ¯ä»¶ç‰©å“åªé€‰ä¸€æ¬¡ï¼Œä¿è¯åœ¨è€ƒè™‘â€œé€‰å…¥ç¬¬iä»¶ç‰©å“â€è¿™ä»¶ç­–ç•¥æ—¶ï¼Œä¾æ®çš„æ˜¯ä¸€ä¸ªç»æ— å·²ç»é€‰å…¥ç¬¬iä»¶ç‰©å“çš„å­ç»“æžœf[i-1][v-c[i]]ã€‚è€ŒçŽ°åœ¨å®Œå…¨èƒŒåŒ…çš„ç‰¹ç‚¹æ°æ˜¯æ¯ç§ç‰©å“å¯é€‰æ— é™ä»¶ï¼Œæ‰€ä»¥åœ¨è€ƒè™‘â€œåŠ é€‰ä¸€ä»¶ç¬¬iç§ç‰©å“â€è¿™ç§ç­–ç•¥æ—¶ï¼Œå´æ­£éœ€è¦ä¸€ä¸ªå¯èƒ½å·²é€‰å…¥ç¬¬iç§ç‰©å“çš„å­ç»“æžœf[i][v-c[i]]ï¼Œæ‰€ä»¥å°±å¯ä»¥å¹¶ä¸”å¿…é¡»é‡‡ç”¨v=0..Vçš„é¡ºåºå¾ªçŽ¯ã€‚è¿™å°±æ˜¯è¿™ä¸ªç®€å•çš„ç¨‹åºä¸ºä½•æˆç«‹çš„é“ç†ã€‚ è¿™ä¸ªç®—æ³•ä¹Ÿå¯ä»¥ä»¥å¦å¤–çš„æ€è·¯å¾—å‡ºã€‚ä¾‹å¦‚ï¼ŒåŸºæœ¬æ€è·¯ä¸­çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹å¯ä»¥ç­‰ä»·åœ°å˜å½¢æˆè¿™ç§å½¢å¼ï¼š f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]} å°†è¿™ä¸ªæ–¹ç¨‹ç”¨ä¸€ç»´æ•°ç»„å®žçŽ°ï¼Œä¾¿å¾—åˆ°äº†ä¸Šé¢çš„ä¼ªä»£ç ã€‚ æœ€åŽæŠ½è±¡å‡ºå¤„ç†ä¸€ä»¶å®Œå…¨èƒŒåŒ…ç±»ç‰©å“çš„è¿‡ç¨‹ä¼ªä»£ç ï¼Œä»¥åŽä¼šç”¨åˆ°ï¼š 123procedure CompletePack(cost,weight) for v=cost..V f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125; æ€»ç»“ å®Œå…¨èƒŒåŒ…é—®é¢˜ä¹Ÿæ˜¯ä¸€ä¸ªç›¸å½“åŸºç¡€çš„èƒŒåŒ…é—®é¢˜ï¼Œå®ƒæœ‰ä¸¤ä¸ªçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œåˆ†åˆ«åœ¨â€œåŸºæœ¬æ€è·¯â€ä»¥åŠâ€œO(VN)çš„ç®—æ³•â€œçš„å°èŠ‚ä¸­ç»™å‡ºã€‚å¸Œæœ›ä½ èƒ½å¤Ÿå¯¹è¿™ä¸¤ä¸ªçŠ¶æ€è½¬ç§»æ–¹ç¨‹éƒ½ä»”ç»†åœ°ä½“ä¼šï¼Œä¸ä»…è®°ä½ï¼Œä¹Ÿè¦å¼„æ˜Žç™½å®ƒä»¬æ˜¯æ€Žä¹ˆå¾—å‡ºæ¥çš„ï¼Œæœ€å¥½èƒ½å¤Ÿè‡ªå·±æƒ³ä¸€ç§å¾—åˆ°è¿™äº›æ–¹ç¨‹çš„æ–¹æ³•ã€‚äº‹å®žä¸Šï¼Œå¯¹æ¯ä¸€é“åŠ¨æ€è§„åˆ’é¢˜ç›®éƒ½æ€è€ƒå…¶æ–¹ç¨‹çš„æ„ä¹‰ä»¥åŠå¦‚ä½•å¾—æ¥ï¼Œæ˜¯åŠ æ·±å¯¹åŠ¨æ€è§„åˆ’çš„ç†è§£ã€æé«˜åŠ¨æ€è§„åˆ’åŠŸåŠ›çš„å¥½æ–¹æ³•ã€‚ é¦–é¡µ P03: å¤šé‡èƒŒåŒ…é—®é¢˜ é¢˜ç›® æœ‰Nç§ç‰©å“å’Œä¸€ä¸ªå®¹é‡ä¸ºVçš„èƒŒåŒ…ã€‚ç¬¬iç§ç‰©å“æœ€å¤šæœ‰n[i]ä»¶å¯ç”¨ï¼Œæ¯ä»¶è´¹ç”¨æ˜¯c[i]ï¼Œä»·å€¼æ˜¯w[i]ã€‚æ±‚è§£å°†å“ªäº›ç‰©å“è£…å…¥èƒŒåŒ…å¯ä½¿è¿™äº›ç‰©å“çš„è´¹ç”¨æ€»å’Œä¸è¶…è¿‡èƒŒåŒ…å®¹é‡ï¼Œä¸”ä»·å€¼æ€»å’Œæœ€å¤§ã€‚ åŸºæœ¬ç®—æ³• è¿™é¢˜ç›®å’Œå®Œå…¨èƒŒåŒ…é—®é¢˜å¾ˆç±»ä¼¼ã€‚åŸºæœ¬çš„æ–¹ç¨‹åªéœ€å°†å®Œå…¨èƒŒåŒ…é—®é¢˜çš„æ–¹ç¨‹ç•¥å¾®ä¸€æ”¹å³å¯ï¼Œå› ä¸ºå¯¹äºŽç¬¬iç§ç‰©å“æœ‰n[i]+1ç§ç­–ç•¥ï¼šå–0ä»¶ï¼Œå–1ä»¶â€¦â€¦å–n[i]ä»¶ã€‚ä»¤f[i][v]è¡¨ç¤ºå‰iç§ç‰©å“æ°æ”¾å…¥ä¸€ä¸ªå®¹é‡ä¸ºvçš„èƒŒåŒ…çš„æœ€å¤§æƒå€¼ï¼Œåˆ™æœ‰çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š f[i][v]=max{f[i-1][v-k*c[i]]+kw[i]|0&lt;=k&lt;=n[i]} å¤æ‚åº¦æ˜¯O(VÎ£n[i])ã€‚ è½¬åŒ–ä¸º01èƒŒåŒ…é—®é¢˜ å¦ä¸€ç§å¥½æƒ³å¥½å†™çš„åŸºæœ¬æ–¹æ³•æ˜¯è½¬åŒ–ä¸º01èƒŒåŒ…æ±‚è§£ï¼šæŠŠç¬¬iç§ç‰©å“æ¢æˆn[i]ä»¶01èƒŒåŒ…ä¸­çš„ç‰©å“ï¼Œåˆ™å¾—åˆ°äº†ç‰©å“æ•°ä¸ºÎ£n[i]çš„01èƒŒåŒ…é—®é¢˜ï¼Œç›´æŽ¥æ±‚è§£ï¼Œå¤æ‚åº¦ä»ç„¶æ˜¯O(VÎ£n[i])ã€‚ ä½†æ˜¯æˆ‘ä»¬æœŸæœ›å°†å®ƒè½¬åŒ–ä¸º01èƒŒåŒ…é—®é¢˜ä¹‹åŽèƒ½å¤Ÿåƒå®Œå…¨èƒŒåŒ…ä¸€æ ·é™ä½Žå¤æ‚åº¦ã€‚ä»ç„¶è€ƒè™‘äºŒè¿›åˆ¶çš„æ€æƒ³ï¼Œæˆ‘ä»¬è€ƒè™‘æŠŠç¬¬iç§ç‰©å“æ¢æˆè‹¥å¹²ä»¶ç‰©å“ï¼Œä½¿å¾—åŽŸé—®é¢˜ä¸­ç¬¬iç§ç‰©å“å¯å–çš„æ¯ç§ç­–ç•¥â€”â€”å–0..n[i]ä»¶â€”â€”å‡èƒ½ç­‰ä»·äºŽå–è‹¥å¹²ä»¶ä»£æ¢ä»¥åŽçš„ç‰©å“ã€‚å¦å¤–ï¼Œå–è¶…è¿‡n[i]ä»¶çš„ç­–ç•¥å¿…ä¸èƒ½å‡ºçŽ°ã€‚ æ–¹æ³•æ˜¯ï¼šå°†ç¬¬iç§ç‰©å“åˆ†æˆè‹¥å¹²ä»¶ç‰©å“ï¼Œå…¶ä¸­æ¯ä»¶ç‰©å“æœ‰ä¸€ä¸ªç³»æ•°ï¼Œè¿™ä»¶ç‰©å“çš„è´¹ç”¨å’Œä»·å€¼å‡æ˜¯åŽŸæ¥çš„è´¹ç”¨å’Œä»·å€¼ä¹˜ä»¥è¿™ä¸ªç³»æ•°ã€‚ä½¿è¿™äº›ç³»æ•°åˆ†åˆ«ä¸º1,2,4,...,2(k-1),n[i]-2k+1ï¼Œä¸”kæ˜¯æ»¡è¶³n[i]-2k+1&gt;0çš„æœ€å¤§æ•´æ•°ã€‚ä¾‹å¦‚ï¼Œå¦‚æžœn[i]ä¸º13ï¼Œå°±å°†è¿™ç§ç‰©å“åˆ†æˆç³»æ•°åˆ†åˆ«ä¸º1,2,4,6çš„å››ä»¶ç‰©å“ã€‚ åˆ†æˆçš„è¿™å‡ ä»¶ç‰©å“çš„ç³»æ•°å’Œä¸ºn[i]ï¼Œè¡¨æ˜Žä¸å¯èƒ½å–å¤šäºŽn[i]ä»¶çš„ç¬¬iç§ç‰©å“ã€‚å¦å¤–è¿™ç§æ–¹æ³•ä¹Ÿèƒ½ä¿è¯å¯¹äºŽ0..n[i]é—´çš„æ¯ä¸€ä¸ªæ•´æ•°ï¼Œå‡å¯ä»¥ç”¨è‹¥å¹²ä¸ªç³»æ•°çš„å’Œè¡¨ç¤ºï¼Œè¿™ä¸ªè¯æ˜Žå¯ä»¥åˆ†0..2k-1å’Œ2^k..n[i]ä¸¤æ®µæ¥åˆ†åˆ«è®¨è®ºå¾—å‡ºï¼Œå¹¶ä¸éš¾ï¼Œå¸Œæœ›ä½ è‡ªå·±æ€è€ƒå°è¯•ä¸€ä¸‹ã€‚ è¿™æ ·å°±å°†ç¬¬iç§ç‰©å“åˆ†æˆäº†O(log n[i])ç§ç‰©å“ï¼Œå°†åŽŸé—®é¢˜è½¬åŒ–ä¸ºäº†å¤æ‚åº¦ä¸ºO(VÎ£log n[i])çš„01èƒŒåŒ…é—®é¢˜ï¼Œæ˜¯å¾ˆå¤§çš„æ”¹è¿›ã€‚ ä¸‹é¢ç»™å‡ºO(log amount)æ—¶é—´å¤„ç†ä¸€ä»¶å¤šé‡èƒŒåŒ…ä¸­ç‰©å“çš„è¿‡ç¨‹ï¼Œå…¶ä¸­amountè¡¨ç¤ºç‰©å“çš„æ•°é‡ï¼š 12345678910procedure MultiplePack(cost,weight,amount) if cost*amount&gt;=V CompletePack(cost,weight) return integer k=1 while k&lt;num ZeroOnePack(k*cost,k*weight) amount=amount-k k=k*2 ZeroOnePack(amount*cost,amount*weight) å¸Œæœ›ä½ ä»”ç»†ä½“ä¼šè¿™ä¸ªä¼ªä»£ç ï¼Œå¦‚æžœä¸å¤ªç†è§£çš„è¯ï¼Œä¸å¦¨ç¿»è¯‘æˆç¨‹åºä»£ç ä»¥åŽï¼Œå•æ­¥æ‰§è¡Œå‡ æ¬¡ï¼Œæˆ–è€…å¤´è„‘åŠ çº¸ç¬”æ¨¡æ‹Ÿä¸€ä¸‹ï¼Œå°±ä¼šæ…¢æ…¢ç†è§£äº†ã€‚ O(VN)çš„ç®—æ³• å¤šé‡èƒŒåŒ…é—®é¢˜åŒæ ·æœ‰O(VN)çš„ç®—æ³•ã€‚è¿™ä¸ªç®—æ³•åŸºäºŽåŸºæœ¬ç®—æ³•çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œä½†åº”ç”¨å•è°ƒé˜Ÿåˆ—çš„æ–¹æ³•ä½¿æ¯ä¸ªçŠ¶æ€çš„å€¼å¯ä»¥ä»¥å‡æ‘ŠO(1)çš„æ—¶é—´æ±‚è§£ã€‚ç”±äºŽç”¨å•è°ƒé˜Ÿåˆ—ä¼˜åŒ–çš„DPå·²è¶…å‡ºäº†NOIPçš„èŒƒå›´ï¼Œæ•…æœ¬æ–‡ä¸å†å±•å¼€è®²è§£ã€‚æˆ‘æœ€åˆäº†è§£åˆ°è¿™ä¸ªæ–¹æ³•æ˜¯åœ¨æ¥¼å¤©æˆçš„â€œç”·äººå…«é¢˜â€å¹»ç¯ç‰‡ä¸Šã€‚ å°ç»“ è¿™é‡Œæˆ‘ä»¬çœ‹åˆ°äº†å°†ä¸€ä¸ªç®—æ³•çš„å¤æ‚åº¦ç”±O(VÎ£n[i])æ”¹è¿›åˆ°O(VÎ£log n[i])çš„è¿‡ç¨‹ï¼Œè¿˜çŸ¥é“äº†å­˜åœ¨åº”ç”¨è¶…å‡ºNOIPèŒƒå›´çš„çŸ¥è¯†çš„O(VN)ç®—æ³•ã€‚å¸Œæœ›ä½ ç‰¹åˆ«æ³¨æ„â€œæ‹†åˆ†ç‰©å“â€çš„æ€æƒ³å’Œæ–¹æ³•ï¼Œè‡ªå·±è¯æ˜Žä¸€ä¸‹å®ƒçš„æ­£ç¡®æ€§ï¼Œå¹¶å°†å®Œæ•´çš„ç¨‹åºä»£ç å†™å‡ºæ¥ã€‚ é¦–é¡µ P04: æ··åˆä¸‰ç§èƒŒåŒ…é—®é¢˜ é—®é¢˜ å¦‚æžœå°†P01ã€P02ã€P03æ··åˆèµ·æ¥ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæœ‰çš„ç‰©å“åªå¯ä»¥å–ä¸€æ¬¡ï¼ˆ01èƒŒåŒ…ï¼‰ï¼Œæœ‰çš„ç‰©å“å¯ä»¥å–æ— é™æ¬¡ï¼ˆå®Œå…¨èƒŒåŒ…ï¼‰ï¼Œæœ‰çš„ç‰©å“å¯ä»¥å–çš„æ¬¡æ•°æœ‰ä¸€ä¸ªä¸Šé™ï¼ˆå¤šé‡èƒŒåŒ…ï¼‰ã€‚åº”è¯¥æ€Žä¹ˆæ±‚è§£å‘¢ï¼Ÿ 01èƒŒåŒ…ä¸Žå®Œå…¨èƒŒåŒ…çš„æ··åˆ è€ƒè™‘åˆ°åœ¨P01å’ŒP02ä¸­ç»™å‡ºçš„ä¼ªä»£ç åªæœ‰ä¸€å¤„ä¸åŒï¼Œæ•…å¦‚æžœåªæœ‰ä¸¤ç±»ç‰©å“ï¼šä¸€ç±»ç‰©å“åªèƒ½å–ä¸€æ¬¡ï¼Œå¦ä¸€ç±»ç‰©å“å¯ä»¥å–æ— é™æ¬¡ï¼Œé‚£ä¹ˆåªéœ€åœ¨å¯¹æ¯ä¸ªç‰©å“åº”ç”¨è½¬ç§»æ–¹ç¨‹æ—¶ï¼Œæ ¹æ®ç‰©å“çš„ç±»åˆ«é€‰ç”¨é¡ºåºæˆ–é€†åºçš„å¾ªçŽ¯å³å¯ï¼Œå¤æ‚åº¦æ˜¯O(VN)ã€‚ä¼ªä»£ç å¦‚ä¸‹ï¼š 1234567for i=1..N if ç¬¬iä»¶ç‰©å“æ˜¯01èƒŒåŒ… for v=V..0 f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; else if ç¬¬iä»¶ç‰©å“æ˜¯å®Œå…¨èƒŒåŒ… for v=0..V f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; å†åŠ ä¸Šå¤šé‡èƒŒåŒ… å¦‚æžœå†åŠ ä¸Šæœ‰çš„ç‰©å“æœ€å¤šå¯ä»¥å–æœ‰é™æ¬¡ï¼Œé‚£ä¹ˆåŽŸåˆ™ä¸Šä¹Ÿå¯ä»¥ç»™å‡ºO(VN)çš„è§£æ³•ï¼šé‡åˆ°å¤šé‡èƒŒåŒ…ç±»åž‹çš„ç‰©å“ç”¨å•è°ƒé˜Ÿåˆ—è§£å³å¯ã€‚ä½†å¦‚æžœä¸è€ƒè™‘è¶…è¿‡NOIPèŒƒå›´çš„ç®—æ³•çš„è¯ï¼Œç”¨P03ä¸­å°†æ¯ä¸ªè¿™ç±»ç‰©å“åˆ†æˆO(log n[i])ä¸ª01èƒŒåŒ…çš„ç‰©å“çš„æ–¹æ³•ä¹Ÿå·²ç»å¾ˆä¼˜äº†ã€‚ å½“ç„¶ï¼Œæ›´æ¸…æ™°çš„å†™æ³•æ˜¯è°ƒç”¨æˆ‘ä»¬å‰é¢ç»™å‡ºçš„ä¸‰ä¸ªç›¸å…³è¿‡ç¨‹ã€‚ æ··è¡€å„¿çš„ä¼˜åŠ¿ 1234567for i=1..N if ç¬¬iä»¶ç‰©å“æ˜¯01èƒŒåŒ… ZeroOnePack(c[i],w[i]) else if ç¬¬iä»¶ç‰©å“æ˜¯å®Œå…¨èƒŒåŒ… CompletePack(c[i],w[i]) else if ç¬¬iä»¶ç‰©å“æ˜¯å¤šé‡èƒŒåŒ… MultiplePack(c[i],w[i],n[i]) åœ¨æœ€åˆå†™å‡ºè¿™ä¸‰ä¸ªè¿‡ç¨‹çš„æ—¶å€™ï¼Œå¯èƒ½å®Œå…¨æ²¡æœ‰æƒ³åˆ°å®ƒä»¬ä¼šåœ¨è¿™é‡Œæ··åˆåº”ç”¨ã€‚æˆ‘æƒ³è¿™ä½“çŽ°äº†ç¼–ç¨‹ä¸­æŠ½è±¡çš„å¨åŠ›ã€‚å¦‚æžœä½ ä¸€ç›´å°±æ˜¯ä»¥è¿™ç§â€œæŠ½è±¡å‡ºè¿‡ç¨‹â€çš„æ–¹å¼å†™æ¯ä¸€ç±»èƒŒåŒ…é—®é¢˜çš„ï¼Œä¹Ÿéžå¸¸æ¸…æ¥šå®ƒä»¬çš„å®žçŽ°ä¸­ç»†å¾®çš„ä¸åŒï¼Œé‚£ä¹ˆåœ¨é‡åˆ°æ··åˆä¸‰ç§èƒŒåŒ…é—®é¢˜çš„é¢˜ç›®æ—¶ï¼Œä¸€å®šèƒ½å¾ˆå¿«æƒ³åˆ°ä¸Šé¢ç®€æ´çš„è§£æ³•ï¼Œå¯¹å—ï¼Ÿ å°ç»“ æœ‰äººè¯´ï¼Œå›°éš¾çš„é¢˜ç›®éƒ½æ˜¯ç”±ç®€å•çš„é¢˜ç›®å åŠ è€Œæ¥çš„ã€‚è¿™å¥è¯æ˜¯å¦å…¬ç†æš‚ä¸”å­˜ä¹‹ä¸è®ºï¼Œä½†å®ƒåœ¨æœ¬è®²ä¸­å·²ç»å¾—åˆ°äº†å……åˆ†çš„ä½“çŽ°ã€‚æœ¬æ¥01èƒŒåŒ…ã€å®Œå…¨èƒŒåŒ…ã€å¤šé‡èƒŒåŒ…éƒ½ä¸æ˜¯ä»€ä¹ˆéš¾é¢˜ï¼Œä½†å°†å®ƒä»¬ç®€å•åœ°ç»„åˆèµ·æ¥ä»¥åŽå°±å¾—åˆ°äº†è¿™æ ·ä¸€é“ä¸€å®šèƒ½å“å€’ä¸å°‘äººçš„é¢˜ç›®ã€‚ä½†åªè¦åŸºç¡€æ‰Žå®žï¼Œé¢†ä¼šä¸‰ç§åŸºæœ¬èƒŒåŒ…é—®é¢˜çš„æ€æƒ³ï¼Œå°±å¯ä»¥åšåˆ°æŠŠå›°éš¾çš„é¢˜ç›®æ‹†åˆ†æˆç®€å•çš„é¢˜ç›®æ¥è§£å†³ã€‚ é¦–é¡µ ç›®å½• ç¬¬äº”è®² äºŒç»´è´¹ç”¨çš„èƒŒåŒ…é—®é¢˜ ä¸€ä¸ªç®€å•çš„å¸¸è§æ‰©å±•ã€‚ ç¬¬å…­è®² åˆ†ç»„çš„èƒŒåŒ…é—®é¢˜ ä¸€ç§é¢˜ç›®ç±»åž‹ï¼Œä¹Ÿæ˜¯ä¸€ä¸ªæœ‰ç”¨çš„æ¨¡åž‹ã€‚åŽä¸¤èŠ‚çš„åŸºç¡€ã€‚ ç¬¬ä¸ƒè®² æœ‰ä¾èµ–çš„èƒŒåŒ…é—®é¢˜ å¦ä¸€ç§ç»™ç‰©å“çš„é€‰å–åŠ ä¸Šé™åˆ¶çš„æ–¹æ³•ã€‚ ç¬¬å…«è®² æ³›åŒ–ç‰©å“ æˆ‘è‡ªå·±å…³äºŽèƒŒåŒ…é—®é¢˜çš„æ€è€ƒæˆæžœï¼Œæœ‰ä¸€ç‚¹æŠ½è±¡ã€‚ ç¬¬ä¹è®² èƒŒåŒ…é—®é¢˜é—®æ³•çš„å˜åŒ– è¯•å›¾è§¦ç±»æ—é€šã€ä¸¾ä¸€åä¸‰ã€‚ èƒŒåŒ…çš„æœç´¢ é™„ï¼šUSACOä¸­çš„èƒŒåŒ…é—®é¢˜ ç»™å‡º USACO Training ä¸Šå¯ä¾›ç»ƒä¹ çš„èƒŒåŒ…é—®é¢˜åˆ—è¡¨ï¼ŒåŠç®€å•çš„è§£ç­”ã€‚ P05: äºŒç»´è´¹ç”¨çš„èƒŒåŒ…é—®é¢˜ é—®é¢˜ äºŒç»´è´¹ç”¨çš„èƒŒåŒ…é—®é¢˜æ˜¯æŒ‡ï¼šå¯¹äºŽæ¯ä»¶ç‰©å“ï¼Œå…·æœ‰ä¸¤ç§ä¸åŒçš„è´¹ç”¨ï¼›é€‰æ‹©è¿™ä»¶ç‰©å“å¿…é¡»åŒæ—¶ä»˜å‡ºè¿™ä¸¤ç§ä»£ä»·ï¼›å¯¹äºŽæ¯ç§ä»£ä»·éƒ½æœ‰ä¸€ä¸ªå¯ä»˜å‡ºçš„æœ€å¤§å€¼ï¼ˆèƒŒåŒ…å®¹é‡ï¼‰ã€‚é—®æ€Žæ ·é€‰æ‹©ç‰©å“å¯ä»¥å¾—åˆ°æœ€å¤§çš„ä»·å€¼ã€‚è®¾è¿™ä¸¤ç§ä»£ä»·åˆ†åˆ«ä¸ºä»£ä»·1å’Œä»£ä»·2ï¼Œç¬¬iä»¶ç‰©å“æ‰€éœ€çš„ä¸¤ç§ä»£ä»·åˆ†åˆ«ä¸ºa[i]å’Œb[i]ã€‚ä¸¤ç§ä»£ä»·å¯ä»˜å‡ºçš„æœ€å¤§å€¼ï¼ˆä¸¤ç§èƒŒåŒ…å®¹é‡ï¼‰åˆ†åˆ«ä¸ºVå’ŒUã€‚ç‰©å“çš„ä»·å€¼ä¸ºw[i]ã€‚ ç®—æ³• è´¹ç”¨åŠ äº†ä¸€ç»´ï¼Œåªéœ€çŠ¶æ€ä¹ŸåŠ ä¸€ç»´å³å¯ã€‚è®¾f[i][v][u]è¡¨ç¤ºå‰iä»¶ç‰©å“ä»˜å‡ºä¸¤ç§ä»£ä»·åˆ†åˆ«ä¸ºvå’Œuæ—¶å¯èŽ·å¾—çš„æœ€å¤§ä»·å€¼ã€‚çŠ¶æ€è½¬ç§»æ–¹ç¨‹å°±æ˜¯ï¼š f[i][v][u]=max{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]} å¦‚å‰è¿°æ–¹æ³•ï¼Œå¯ä»¥åªä½¿ç”¨äºŒç»´çš„æ•°ç»„ï¼šå½“æ¯ä»¶ç‰©å“åªå¯ä»¥å–ä¸€æ¬¡æ—¶å˜é‡vå’Œué‡‡ç”¨é€†åºçš„å¾ªçŽ¯ï¼Œå½“ç‰©å“æœ‰å¦‚å®Œå…¨èƒŒåŒ…é—®é¢˜æ—¶é‡‡ç”¨é¡ºåºçš„å¾ªçŽ¯ã€‚å½“ç‰©å“æœ‰å¦‚å¤šé‡èƒŒåŒ…é—®é¢˜æ—¶æ‹†åˆ†ç‰©å“ã€‚è¿™é‡Œå°±ä¸å†ç»™å‡ºä¼ªä»£ç äº†ï¼Œç›¸ä¿¡æœ‰äº†å‰é¢çš„åŸºç¡€ï¼Œä½ èƒ½å¤Ÿè‡ªå·±å®žçŽ°å‡ºè¿™ä¸ªé—®é¢˜çš„ç¨‹åºã€‚ ç‰©å“æ€»ä¸ªæ•°çš„é™åˆ¶ æœ‰æ—¶ï¼Œâ€œäºŒç»´è´¹ç”¨â€çš„æ¡ä»¶æ˜¯ä»¥è¿™æ ·ä¸€ç§éšå«çš„æ–¹å¼ç»™å‡ºçš„ï¼šæœ€å¤šåªèƒ½å–Mä»¶ç‰©å“ã€‚è¿™äº‹å®žä¸Šç›¸å½“äºŽæ¯ä»¶ç‰©å“å¤šäº†ä¸€ç§â€œä»¶æ•°â€çš„è´¹ç”¨ï¼Œæ¯ä¸ªç‰©å“çš„ä»¶æ•°è´¹ç”¨å‡ä¸º1ï¼Œå¯ä»¥ä»˜å‡ºçš„æœ€å¤§ä»¶æ•°è´¹ç”¨ä¸ºMã€‚æ¢å¥è¯è¯´ï¼Œè®¾f[v][m]è¡¨ç¤ºä»˜å‡ºè´¹ç”¨vã€æœ€å¤šé€‰mä»¶æ—¶å¯å¾—åˆ°çš„æœ€å¤§ä»·å€¼ï¼Œåˆ™æ ¹æ®ç‰©å“çš„ç±»åž‹ï¼ˆ01ã€å®Œå…¨ã€å¤šé‡ï¼‰ç”¨ä¸åŒçš„æ–¹æ³•å¾ªçŽ¯æ›´æ–°ï¼Œæœ€åŽåœ¨f[0..V][0..M]èŒƒå›´å†…å¯»æ‰¾ç­”æ¡ˆã€‚ å°ç»“ æ˜¯ä¸æ˜¯å¯ä»¥ç”¨æ¥è§£å†³å¤šé‡èƒŒåŒ…çš„é—®é¢˜ï¼Ÿï¼Ÿï¼Ÿåªä¸è¿‡æ¯”å¤šé‡èƒŒåŒ…å¤æ‚åº¦é«˜ å½“å‘çŽ°ç”±ç†Ÿæ‚‰çš„åŠ¨æ€è§„åˆ’é¢˜ç›®å˜å½¢å¾—æ¥çš„é¢˜ç›®æ—¶ï¼Œåœ¨åŽŸæ¥çš„çŠ¶æ€ä¸­åŠ ä¸€ç»´ä»¥æ»¡è¶³æ–°çš„é™åˆ¶æ˜¯ä¸€ç§æ¯”è¾ƒé€šç”¨çš„æ–¹æ³•ã€‚å¸Œæœ›ä½ èƒ½ä»Žæœ¬è®²ä¸­åˆæ­¥ä½“ä¼šåˆ°è¿™ç§æ–¹æ³•ã€‚ é¦–é¡µ P06: åˆ†ç»„çš„èƒŒåŒ…é—®é¢˜ é—®é¢˜ æœ‰Nä»¶ç‰©å“å’Œä¸€ä¸ªå®¹é‡ä¸ºVçš„èƒŒåŒ…ã€‚ç¬¬iä»¶ç‰©å“çš„è´¹ç”¨æ˜¯c[i]ï¼Œä»·å€¼æ˜¯w[i]ã€‚è¿™äº›ç‰©å“è¢«åˆ’åˆ†ä¸ºè‹¥å¹²ç»„ï¼Œæ¯ç»„ä¸­çš„ç‰©å“äº’ç›¸å†²çªï¼Œæœ€å¤šé€‰ä¸€ä»¶ã€‚æ±‚è§£å°†å“ªäº›ç‰©å“è£…å…¥èƒŒåŒ…å¯ä½¿è¿™äº›ç‰©å“çš„è´¹ç”¨æ€»å’Œä¸è¶…è¿‡èƒŒåŒ…å®¹é‡ï¼Œä¸”ä»·å€¼æ€»å’Œæœ€å¤§ã€‚ ç®—æ³• è¿™ä¸ªé—®é¢˜å˜æˆäº†æ¯ç»„ç‰©å“æœ‰è‹¥å¹²ç§ç­–ç•¥ï¼šæ˜¯é€‰æ‹©æœ¬ç»„çš„æŸä¸€ä»¶ï¼Œè¿˜æ˜¯ä¸€ä»¶éƒ½ä¸é€‰ã€‚ä¹Ÿå°±æ˜¯è¯´è®¾f[k][v]è¡¨ç¤ºå‰kç»„ç‰©å“èŠ±è´¹è´¹ç”¨vèƒ½å–å¾—çš„æœ€å¤§æƒå€¼ï¼Œåˆ™æœ‰ï¼š f[k][v]=max{f[k-1][v],f[k-1][v-c[i]]+w[i]|ç‰©å“iå±žäºŽç¬¬kç»„} ä½¿ç”¨ä¸€ç»´æ•°ç»„çš„ä¼ªä»£ç å¦‚ä¸‹ï¼š 1234for æ‰€æœ‰çš„ç»„k for v=V..0 for æ‰€æœ‰çš„iå±žäºŽç»„k f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125; æ³¨æ„è¿™é‡Œçš„ä¸‰å±‚å¾ªçŽ¯çš„é¡ºåºï¼Œç”šè‡³åœ¨æœ¬æ–‡çš„betaç‰ˆä¸­æˆ‘è‡ªå·±éƒ½å†™é”™äº†ã€‚â€œfor v=V..0â€è¿™ä¸€å±‚å¾ªçŽ¯å¿…é¡»åœ¨â€œfor æ‰€æœ‰çš„iå±žäºŽç»„kâ€ä¹‹å¤–ã€‚è¿™æ ·æ‰èƒ½ä¿è¯æ¯ä¸€ç»„å†…çš„ç‰©å“æœ€å¤šåªæœ‰ä¸€ä¸ªä¼šè¢«æ·»åŠ åˆ°èƒŒåŒ…ä¸­ã€‚ å¦å¤–ï¼Œæ˜¾ç„¶å¯ä»¥å¯¹æ¯ç»„å†…çš„ç‰©å“åº”ç”¨P02ä¸­â€œä¸€ä¸ªç®€å•æœ‰æ•ˆçš„ä¼˜åŒ–â€ã€‚ å°ç»“ åˆ†ç»„çš„èƒŒåŒ…é—®é¢˜å°†å½¼æ­¤äº’æ–¥çš„è‹¥å¹²ç‰©å“ç§°ä¸ºä¸€ä¸ªç»„ï¼Œè¿™å»ºç«‹äº†ä¸€ä¸ªå¾ˆå¥½çš„æ¨¡åž‹ã€‚ä¸å°‘èƒŒåŒ…é—®é¢˜çš„å˜å½¢éƒ½å¯ä»¥è½¬åŒ–ä¸ºåˆ†ç»„çš„èƒŒåŒ…é—®é¢˜ï¼ˆä¾‹å¦‚P07ï¼‰ï¼Œç”±åˆ†ç»„çš„èƒŒåŒ…é—®é¢˜è¿›ä¸€æ­¥å¯å®šä¹‰â€œæ³›åŒ–ç‰©å“â€çš„æ¦‚å¿µï¼Œååˆ†æœ‰åˆ©äºŽè§£é¢˜ã€‚ é¦–é¡µ P07: æœ‰ä¾èµ–çš„èƒŒåŒ…é—®é¢˜ ç®€åŒ–çš„é—®é¢˜ è¿™ç§èƒŒåŒ…é—®é¢˜çš„ç‰©å“é—´å­˜åœ¨æŸç§â€œä¾èµ–â€çš„å…³ç³»ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œiä¾èµ–äºŽjï¼Œè¡¨ç¤ºè‹¥é€‰ç‰©å“iï¼Œåˆ™å¿…é¡»é€‰ç‰©å“jã€‚ä¸ºäº†ç®€åŒ–èµ·è§ï¼Œæˆ‘ä»¬å…ˆè®¾æ²¡æœ‰æŸä¸ªç‰©å“æ—¢ä¾èµ–äºŽåˆ«çš„ç‰©å“ï¼Œåˆè¢«åˆ«çš„ç‰©å“æ‰€ä¾èµ–ï¼›å¦å¤–ï¼Œæ²¡æœ‰æŸä»¶ç‰©å“åŒæ—¶ä¾èµ–å¤šä»¶ç‰©å“ã€‚ ç®—æ³• è¿™ä¸ªé—®é¢˜ç”±NOIP2006é‡‘æ˜Žçš„é¢„ç®—æ–¹æ¡ˆä¸€é¢˜æ‰©å±•è€Œæ¥ã€‚éµä»Žè¯¥é¢˜çš„ææ³•ï¼Œå°†ä¸ä¾èµ–äºŽåˆ«çš„ç‰©å“çš„ç‰©å“ç§°ä¸ºâ€œä¸»ä»¶â€ï¼Œä¾èµ–äºŽæŸä¸»ä»¶çš„ç‰©å“ç§°ä¸ºâ€œé™„ä»¶â€ã€‚ç”±è¿™ä¸ªé—®é¢˜çš„ç®€åŒ–æ¡ä»¶å¯çŸ¥æ‰€æœ‰çš„ç‰©å“ç”±è‹¥å¹²ä¸»ä»¶å’Œä¾èµ–äºŽæ¯ä¸ªä¸»ä»¶çš„ä¸€ä¸ªé™„ä»¶é›†åˆç»„æˆã€‚ æŒ‰ç…§èƒŒåŒ…é—®é¢˜çš„ä¸€èˆ¬æ€è·¯ï¼Œä»…è€ƒè™‘ä¸€ä¸ªä¸»ä»¶å’Œå®ƒçš„é™„ä»¶é›†åˆã€‚å¯æ˜¯ï¼Œå¯ç”¨çš„ç­–ç•¥éžå¸¸å¤šï¼ŒåŒ…æ‹¬ï¼šä¸€ä¸ªä¹Ÿä¸é€‰ï¼Œä»…é€‰æ‹©ä¸»ä»¶ï¼Œé€‰æ‹©ä¸»ä»¶åŽå†é€‰æ‹©ä¸€ä¸ªé™„ä»¶ï¼Œé€‰æ‹©ä¸»ä»¶åŽå†é€‰æ‹©ä¸¤ä¸ªé™„ä»¶â€¦â€¦æ— æ³•ç”¨çŠ¶æ€è½¬ç§»æ–¹ç¨‹æ¥è¡¨ç¤ºå¦‚æ­¤å¤šçš„ç­–ç•¥ã€‚ï¼ˆäº‹å®žä¸Šï¼Œè®¾æœ‰nä¸ªé™„ä»¶ï¼Œåˆ™ç­–ç•¥æœ‰2^n+1ä¸ªï¼Œä¸ºæŒ‡æ•°çº§ã€‚ï¼‰ è€ƒè™‘åˆ°æ‰€æœ‰è¿™äº›ç­–ç•¥éƒ½æ˜¯äº’æ–¥çš„ï¼ˆä¹Ÿå°±æ˜¯è¯´ï¼Œä½ åªèƒ½é€‰æ‹©ä¸€ç§ç­–ç•¥ï¼‰ï¼Œæ‰€ä»¥ä¸€ä¸ªä¸»ä»¶å’Œå®ƒçš„é™„ä»¶é›†åˆå®žé™…ä¸Šå¯¹åº”äºŽP06ä¸­çš„ä¸€ä¸ªç‰©å“ç»„ï¼Œæ¯ä¸ªé€‰æ‹©äº†ä¸»ä»¶åˆé€‰æ‹©äº†è‹¥å¹²ä¸ªé™„ä»¶çš„ç­–ç•¥å¯¹åº”äºŽè¿™ä¸ªç‰©å“ç»„ä¸­çš„ä¸€ä¸ªç‰©å“ï¼Œå…¶è´¹ç”¨å’Œä»·å€¼éƒ½æ˜¯è¿™ä¸ªç­–ç•¥ä¸­çš„ç‰©å“çš„å€¼çš„å’Œã€‚ä½†ä»…ä»…æ˜¯è¿™ä¸€æ­¥è½¬åŒ–å¹¶ä¸èƒ½ç»™å‡ºä¸€ä¸ªå¥½çš„ç®—æ³•ï¼Œå› ä¸ºç‰©å“ç»„ä¸­çš„ç‰©å“è¿˜æ˜¯åƒåŽŸé—®é¢˜çš„ç­–ç•¥ä¸€æ ·å¤šã€‚ å†è€ƒè™‘P06ä¸­çš„ä¸€å¥è¯ï¼š å¯ä»¥å¯¹æ¯ç»„ä¸­çš„ç‰©å“åº”ç”¨P02ä¸­â€œä¸€ä¸ªç®€å•æœ‰æ•ˆçš„ä¼˜åŒ–â€ã€‚ è¿™æç¤ºæˆ‘ä»¬ï¼Œå¯¹äºŽä¸€ä¸ªç‰©å“ç»„ä¸­çš„ç‰©å“ï¼Œæ‰€æœ‰è´¹ç”¨ç›¸åŒçš„ç‰©å“åªç•™ä¸€ä¸ªä»·å€¼æœ€å¤§çš„ï¼Œä¸å½±å“ç»“æžœã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹ä¸»ä»¶içš„â€œé™„ä»¶é›†åˆâ€å…ˆè¿›è¡Œä¸€æ¬¡01èƒŒåŒ…ï¼Œå¾—åˆ°è´¹ç”¨ä¾æ¬¡ä¸º0..V-c[i]æ‰€æœ‰è¿™äº›å€¼æ—¶ç›¸åº”çš„æœ€å¤§ä»·å€¼f'[0..V-c[i]]ã€‚é‚£ä¹ˆè¿™ä¸ªä¸»ä»¶åŠå®ƒçš„é™„ä»¶é›†åˆç›¸å½“äºŽV-c[i]+1ä¸ªç‰©å“çš„ç‰©å“ç»„ï¼Œå…¶ä¸­è´¹ç”¨ä¸ºc[i]+kçš„ç‰©å“çš„ä»·å€¼ä¸ºf'[k]+w[i]ã€‚ä¹Ÿå°±æ˜¯è¯´åŽŸæ¥æŒ‡æ•°çº§çš„ç­–ç•¥ä¸­æœ‰å¾ˆå¤šç­–ç•¥éƒ½æ˜¯å†—ä½™çš„ï¼Œé€šè¿‡ä¸€æ¬¡01èƒŒåŒ…åŽï¼Œå°†ä¸»ä»¶iè½¬åŒ–ä¸ºV-c[i]+1ä¸ªç‰©å“çš„ç‰©å“ç»„ï¼Œå°±å¯ä»¥ç›´æŽ¥åº”ç”¨P06çš„ç®—æ³•è§£å†³é—®é¢˜äº†ã€‚ è¾ƒä¸€èˆ¬çš„é—®é¢˜ æ›´ä¸€èˆ¬çš„é—®é¢˜æ˜¯ï¼šä¾èµ–å…³ç³»ä»¥å›¾è®ºä¸­â€œæ£®æž—â€çš„å½¢å¼ç»™å‡ºï¼ˆæ£®æž—å³å¤šå‰æ ‘çš„é›†åˆï¼‰ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œä¸»ä»¶çš„é™„ä»¶ä»ç„¶å¯ä»¥å…·æœ‰è‡ªå·±çš„é™„ä»¶é›†åˆï¼Œé™åˆ¶åªæ˜¯æ¯ä¸ªç‰©å“æœ€å¤šåªä¾èµ–äºŽä¸€ä¸ªç‰©å“ï¼ˆåªæœ‰ä¸€ä¸ªä¸»ä»¶ï¼‰ä¸”ä¸å‡ºçŽ°å¾ªçŽ¯ä¾èµ–ã€‚ è§£å†³è¿™ä¸ªé—®é¢˜ä»ç„¶å¯ä»¥ç”¨å°†æ¯ä¸ªä¸»ä»¶åŠå…¶é™„ä»¶é›†åˆè½¬åŒ–ä¸ºç‰©å“ç»„çš„æ–¹å¼ã€‚å”¯ä¸€ä¸åŒçš„æ˜¯ï¼Œç”±äºŽé™„ä»¶å¯èƒ½è¿˜æœ‰é™„ä»¶ï¼Œå°±ä¸èƒ½å°†æ¯ä¸ªé™„ä»¶éƒ½çœ‹ä½œä¸€ä¸ªä¸€èˆ¬çš„01èƒŒåŒ…ä¸­çš„ç‰©å“äº†ã€‚è‹¥è¿™ä¸ªé™„ä»¶ä¹Ÿæœ‰é™„ä»¶é›†åˆï¼Œåˆ™å®ƒå¿…å®šè¦è¢«å…ˆè½¬åŒ–ä¸ºç‰©å“ç»„ï¼Œç„¶åŽç”¨åˆ†ç»„çš„èƒŒåŒ…é—®é¢˜è§£å‡ºä¸»ä»¶åŠå…¶é™„ä»¶é›†åˆæ‰€å¯¹åº”çš„é™„ä»¶ç»„ä¸­å„ä¸ªè´¹ç”¨çš„é™„ä»¶æ‰€å¯¹åº”çš„ä»·å€¼ã€‚ äº‹å®žä¸Šï¼Œè¿™æ˜¯ä¸€ç§æ ‘å½¢DPï¼Œå…¶ç‰¹ç‚¹æ˜¯ï¼šæ¯ä¸ªçˆ¶èŠ‚ç‚¹éƒ½éœ€è¦å¯¹å®ƒçš„å„ä¸ªå„¿å­çš„å±žæ€§è¿›è¡Œä¸€æ¬¡DPä»¥æ±‚å¾—è‡ªå·±çš„ç›¸å…³å±žæ€§ã€‚è¿™å·²ç»è§¦åŠåˆ°äº†â€œæ³›åŒ–ç‰©å“â€çš„æ€æƒ³ã€‚çœ‹å®ŒP08åŽï¼Œä½ ä¼šå‘çŽ°è¿™ä¸ªâ€œä¾èµ–å…³ç³»æ ‘â€æ¯ä¸€ä¸ªå­æ ‘éƒ½ç­‰ä»·äºŽä¸€ä»¶æ³›åŒ–ç‰©å“ï¼Œæ±‚æŸèŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘å¯¹åº”çš„æ³›åŒ–ç‰©å“ç›¸å½“äºŽæ±‚å…¶æ‰€æœ‰å„¿å­çš„å¯¹åº”çš„æ³›åŒ–ç‰©å“ä¹‹å’Œã€‚ å°ç»“ NOIP2006çš„é‚£é“èƒŒåŒ…é—®é¢˜æˆ‘åšå¾—å¾ˆå¤±è´¥ï¼Œå†™äº†ä¸Šç™¾è¡Œçš„ä»£ç ï¼Œå´ä¸€åˆ†æœªå¾—ã€‚åŽæ¥æˆ‘é€šè¿‡æ€è€ƒå‘çŽ°é€šè¿‡å¼•å…¥â€œç‰©å“ç»„â€å’Œâ€œä¾èµ–â€çš„æ¦‚å¿µå¯ä»¥åŠ æ·±å¯¹è¿™é¢˜çš„ç†è§£ï¼Œè¿˜å¯ä»¥è§£å†³å®ƒçš„æŽ¨å¹¿é—®é¢˜ã€‚ç”¨ç‰©å“ç»„çš„æ€æƒ³è€ƒè™‘é‚£é¢˜ä¸­æžå…¶ç‰¹æ®Šçš„ä¾èµ–å…³ç³»ï¼šç‰©å“ä¸èƒ½æ—¢ä½œä¸»ä»¶åˆä½œé™„ä»¶ï¼Œæ¯ä¸ªä¸»ä»¶æœ€å¤šæœ‰ä¸¤ä¸ªé™„ä»¶ï¼Œå¯ä»¥å‘çŽ°ä¸€ä¸ªä¸»ä»¶å’Œå®ƒçš„ä¸¤ä¸ªé™„ä»¶ç­‰ä»·äºŽä¸€ä¸ªç”±å››ä¸ªç‰©å“ç»„æˆçš„ç‰©å“ç»„ï¼Œè¿™ä¾¿æ­ç¤ºäº†é—®é¢˜çš„æŸç§æœ¬è´¨ã€‚ æˆ‘æƒ³è¯´ï¼šå¤±è´¥ä¸æ˜¯ä»€ä¹ˆä¸¢äººçš„äº‹æƒ…ï¼Œä»Žå¤±è´¥ä¸­å…¨æ— æ”¶èŽ·æ‰æ˜¯ã€‚ é¦–é¡µ P08: æ³›åŒ–ç‰©å“ å®šä¹‰ è€ƒè™‘è¿™æ ·ä¸€ç§ç‰©å“ï¼Œå®ƒå¹¶æ²¡æœ‰å›ºå®šçš„è´¹ç”¨å’Œä»·å€¼ï¼Œè€Œæ˜¯å®ƒçš„ä»·å€¼éšç€ä½ åˆ†é…ç»™å®ƒçš„è´¹ç”¨è€Œå˜åŒ–ã€‚è¿™å°±æ˜¯æ³›åŒ–ç‰©å“çš„æ¦‚å¿µã€‚ æ›´ä¸¥æ ¼çš„å®šä¹‰ä¹‹ã€‚åœ¨èƒŒåŒ…å®¹é‡ä¸ºVçš„èƒŒåŒ…é—®é¢˜ä¸­ï¼Œæ³›åŒ–ç‰©å“æ˜¯ä¸€ä¸ªå®šä¹‰åŸŸä¸º0..Vä¸­çš„æ•´æ•°çš„å‡½æ•°hï¼Œå½“åˆ†é…ç»™å®ƒçš„è´¹ç”¨ä¸ºvæ—¶ï¼Œèƒ½å¾—åˆ°çš„ä»·å€¼å°±æ˜¯h(v)ã€‚ è¿™ä¸ªå®šä¹‰æœ‰ä¸€ç‚¹ç‚¹æŠ½è±¡ï¼Œå¦ä¸€ç§ç†è§£æ˜¯ä¸€ä¸ªæ³›åŒ–ç‰©å“å°±æ˜¯ä¸€ä¸ªæ•°ç»„h[0..V]ï¼Œç»™å®ƒè´¹ç”¨vï¼Œå¯å¾—åˆ°ä»·å€¼h[V]ã€‚{fuck!è¿™ä¸ä¸€æ ·å•Šï¼} [å°†æ‰€æœ‰çš„èƒŒåŒ…æ™®éåŒ–]ï¼š1.ä¸€ä¸ªè´¹ç”¨ä¸ºcä»·å€¼ä¸ºwçš„ç‰©å“ï¼Œå¦‚æžœå®ƒæ˜¯01èƒŒåŒ…ä¸­çš„ç‰©å“ï¼Œé‚£ä¹ˆæŠŠå®ƒçœ‹æˆæ³›åŒ–ç‰©å“ï¼Œå®ƒå°±æ˜¯é™¤äº†h(c)=wå…¶å®ƒå‡½æ•°å€¼éƒ½ä¸º0çš„ä¸€ä¸ªå‡½æ•°ã€‚2.å¦‚æžœå®ƒæ˜¯å®Œå…¨èƒŒåŒ…ä¸­çš„ç‰©å“ï¼Œé‚£ä¹ˆå®ƒå¯ä»¥çœ‹æˆè¿™æ ·ä¸€ä¸ªå‡½æ•°ï¼Œä»…å½“vè¢«cæ•´é™¤æ—¶æœ‰h(v)=v/cwï¼Œå…¶å®ƒå‡½æ•°å€¼å‡ä¸º0ã€‚3.å¦‚æžœå®ƒæ˜¯å¤šé‡èƒŒåŒ…ä¸­é‡å¤æ¬¡æ•°æœ€å¤šä¸ºnçš„ç‰©å“ï¼Œé‚£ä¹ˆå®ƒå¯¹åº”çš„æ³›åŒ–ç‰©å“çš„å‡½æ•°æœ‰h(v)=v/cwä»…å½“vè¢«cæ•´é™¤ä¸”v/c&lt;=nï¼Œå…¶å®ƒæƒ…å†µå‡½æ•°å€¼å‡ä¸º0ã€‚ ä¸€ä¸ªç‰©å“ç»„å¯ä»¥çœ‹ä½œä¸€ä¸ªæ³›åŒ–ç‰©å“hã€‚å¯¹äºŽä¸€ä¸ª0..Vä¸­çš„vï¼Œè‹¥ç‰©å“ç»„ä¸­ä¸å­˜åœ¨è´¹ç”¨ä¸ºvçš„çš„ç‰©å“ï¼Œåˆ™h(v)=0ï¼Œå¦åˆ™h(v)ä¸ºæ‰€æœ‰è´¹ç”¨ä¸ºvçš„ç‰©å“çš„æœ€å¤§ä»·å€¼ã€‚P07ä¸­æ¯ä¸ªä¸»ä»¶åŠå…¶é™„ä»¶é›†åˆç­‰ä»·äºŽä¸€ä¸ªç‰©å“ç»„ï¼Œè‡ªç„¶ä¹Ÿå¯çœ‹ä½œä¸€ä¸ªæ³›åŒ–ç‰©å“ã€‚ æ³›åŒ–ç‰©å“çš„å’Œ å¦‚æžœé¢å¯¹ä¸¤ä¸ªæ³›åŒ–ç‰©å“hå’Œlï¼Œè¦ç”¨ç»™å®šçš„è´¹ç”¨ä»Žè¿™ä¸¤ä¸ªæ³›åŒ–ç‰©å“ä¸­å¾—åˆ°æœ€å¤§çš„ä»·å€¼ï¼Œæ€Žä¹ˆæ±‚å‘¢ï¼Ÿäº‹å®žä¸Šï¼Œå¯¹äºŽä¸€ä¸ªç»™å®šçš„è´¹ç”¨vï¼Œåªéœ€æžšä¸¾å°†è¿™ä¸ªè´¹ç”¨å¦‚ä½•åˆ†é…ç»™ä¸¤ä¸ªæ³›åŒ–ç‰©å“å°±å¯ä»¥äº†ã€‚åŒæ ·çš„ï¼Œå¯¹äºŽ0..Vçš„æ¯ä¸€ä¸ªæ•´æ•°vï¼Œå¯ä»¥æ±‚å¾—è´¹ç”¨våˆ†é…åˆ°hå’Œlä¸­çš„æœ€å¤§ä»·å€¼f(v)ã€‚ä¹Ÿå³f(v)=max{h(k)+l(v-k)|0&lt;=k&lt;=v}ã€‚å¯ä»¥çœ‹åˆ°ï¼Œfä¹Ÿæ˜¯ä¸€ä¸ªç”±æ³›åŒ–ç‰©å“hå’Œlå†³å®šçš„å®šä¹‰åŸŸä¸º0..Vçš„å‡½æ•°ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œfæ˜¯ä¸€ä¸ªç”±æ³›åŒ–ç‰©å“hå’Œlå†³å®šçš„æ³›åŒ–ç‰©å“ã€‚ ç”±æ­¤å¯ä»¥å®šä¹‰æ³›åŒ–ç‰©å“çš„å’Œï¼šhã€léƒ½æ˜¯æ³›åŒ–ç‰©å“ï¼Œè‹¥æ³›åŒ–ç‰©å“fæ»¡è¶³f(v)=max{h(k)+l(v-k)|0&lt;=k&lt;=v}ï¼Œåˆ™ç§°fæ˜¯hä¸Žlçš„å’Œï¼Œå³f=h+lã€‚è¿™ä¸ªè¿ç®—çš„æ—¶é—´å¤æ‚åº¦å–å†³äºŽèƒŒåŒ…çš„å®¹é‡ï¼Œæ˜¯O(V^2)ã€‚ æ³›åŒ–ç‰©å“çš„å®šä¹‰è¡¨æ˜Žï¼šåœ¨ä¸€ä¸ªèƒŒåŒ…é—®é¢˜ä¸­ï¼Œè‹¥å°†ä¸¤ä¸ªæ³›åŒ–ç‰©å“ä»£ä»¥å®ƒä»¬çš„å’Œï¼Œä¸å½±å“é—®é¢˜çš„ç­”æ¡ˆã€‚äº‹å®žä¸Šï¼Œå¯¹äºŽå…¶ä¸­çš„ç‰©å“éƒ½æ˜¯æ³›åŒ–ç‰©å“çš„èƒŒåŒ…é—®é¢˜ï¼Œæ±‚å®ƒçš„ç­”æ¡ˆçš„è¿‡ç¨‹ä¹Ÿå°±æ˜¯æ±‚æ‰€æœ‰è¿™äº›æ³›åŒ–ç‰©å“ä¹‹å’Œçš„è¿‡ç¨‹ã€‚è®¾æ­¤å’Œä¸ºsï¼Œåˆ™ç­”æ¡ˆå°±æ˜¯s[0..V]ä¸­çš„æœ€å¤§å€¼ã€‚ èƒŒåŒ…é—®é¢˜çš„æ³›åŒ–ç‰©å“ ä¸€ä¸ªèƒŒåŒ…é—®é¢˜ä¸­ï¼Œå¯èƒ½ä¼šç»™å‡ºå¾ˆå¤šæ¡ä»¶ï¼ŒåŒ…æ‹¬æ¯ç§ç‰©å“çš„è´¹ç”¨ã€ä»·å€¼ç­‰å±žæ€§ï¼Œç‰©å“ä¹‹é—´çš„åˆ†ç»„ã€ä¾èµ–ç­‰å…³ç³»ç­‰ã€‚ä½†è‚¯å®šèƒ½å°†é—®é¢˜å¯¹åº”äºŽæŸä¸ªæ³›åŒ–ç‰©å“ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œç»™å®šäº†æ‰€æœ‰æ¡ä»¶ä»¥åŽï¼Œå°±å¯ä»¥å¯¹æ¯ä¸ªéžè´Ÿæ•´æ•°væ±‚å¾—ï¼šè‹¥èƒŒåŒ…å®¹é‡ä¸ºvï¼Œå°†ç‰©å“è£…å…¥èƒŒåŒ…å¯å¾—åˆ°çš„æœ€å¤§ä»·å€¼æ˜¯å¤šå°‘ï¼Œè¿™å¯ä»¥è®¤ä¸ºæ˜¯å®šä¹‰åœ¨éžè´Ÿæ•´æ•°é›†ä¸Šçš„ä¸€ä»¶æ³›åŒ–ç‰©å“ã€‚è¿™ä¸ªæ³›åŒ–ç‰©å“â€”â€”æˆ–è€…è¯´é—®é¢˜æ‰€å¯¹åº”çš„ä¸€ä¸ªå®šä¹‰åŸŸä¸ºéžè´Ÿæ•´æ•°çš„å‡½æ•°â€”â€”åŒ…å«äº†å…³äºŽé—®é¢˜æœ¬èº«çš„é«˜åº¦æµ“ç¼©çš„ä¿¡æ¯ã€‚ä¸€èˆ¬è€Œè¨€ï¼Œæ±‚å¾—è¿™ä¸ªæ³›åŒ–ç‰©å“çš„ä¸€ä¸ªå­åŸŸï¼ˆä¾‹å¦‚0..Vï¼‰çš„å€¼ä¹‹åŽï¼Œå°±å¯ä»¥æ ¹æ®è¿™ä¸ªå‡½æ•°çš„å–å€¼å¾—åˆ°èƒŒåŒ…é—®é¢˜çš„æœ€ç»ˆç­”æ¡ˆã€‚ ç»¼ä¸Šæ‰€è¿°ï¼Œä¸€èˆ¬è€Œè¨€ï¼Œæ±‚è§£èƒŒåŒ…é—®é¢˜ï¼Œå³æ±‚è§£è¿™ä¸ªé—®é¢˜æ‰€å¯¹åº”çš„ä¸€ä¸ªå‡½æ•°ï¼Œå³è¯¥é—®é¢˜çš„æ³›åŒ–ç‰©å“ã€‚è€Œæ±‚è§£æŸä¸ªæ³›åŒ–ç‰©å“çš„ä¸€ç§æ–¹æ³•å°±æ˜¯å°†å®ƒè¡¨ç¤ºä¸ºè‹¥å¹²æ³›åŒ–ç‰©å“çš„å’Œç„¶åŽæ±‚ä¹‹ã€‚ å°ç»“ æœ¬è®²å¯ä»¥è¯´éƒ½æ˜¯æˆ‘è‡ªå·±çš„åŽŸåˆ›æ€æƒ³ã€‚å…·ä½“æ¥è¯´ï¼Œæ˜¯æˆ‘åœ¨å­¦ä¹ å‡½æ•°å¼ç¼–ç¨‹çš„ Scheme è¯­è¨€æ—¶ï¼Œç”¨å‡½æ•°ç¼–ç¨‹çš„çœ¼å…‰å®¡è§†å„ç±»èƒŒåŒ…é—®é¢˜å¾—å‡ºçš„ç†è®ºã€‚è¿™ä¸€è®²çœŸçš„å¾ˆæŠ½è±¡ï¼Œä¹Ÿè®¸åœ¨â€œæ¨¡åž‹çš„æŠ½è±¡ç¨‹åº¦â€è¿™ä¸€æ–¹é¢å·²ç»è¶…å‡ºäº†NOIPçš„è¦æ±‚ï¼Œæ‰€ä»¥æš‚ä¸”çœ‹ä¸æ‡‚ä¹Ÿæ²¡å…³ç³»ã€‚ç›¸ä¿¡éšç€ä½ çš„OIä¹‹è·¯é€æ¸å»¶ä¼¸ï¼Œæœ‰ä¸€å¤©ä½ ä¼šç†è§£çš„ã€‚ æˆ‘æƒ³è¯´ï¼šâ€œæ€è€ƒâ€æ˜¯ä¸€ä¸ªOIeræœ€é‡è¦çš„å“è´¨ã€‚ç®€å•çš„é—®é¢˜ï¼Œæ·±å…¥æ€è€ƒä»¥åŽï¼Œä¹Ÿèƒ½å‘çŽ°æ›´å¤šã€‚ é¦–é¡µ P09: èƒŒåŒ…é—®é¢˜é—®æ³•çš„å˜åŒ– ä»¥ä¸Šæ¶‰åŠçš„å„ç§èƒŒåŒ…é—®é¢˜éƒ½æ˜¯è¦æ±‚åœ¨èƒŒåŒ…å®¹é‡ï¼ˆè´¹ç”¨ï¼‰çš„é™åˆ¶ä¸‹æ±‚å¯ä»¥å–åˆ°çš„æœ€å¤§ä»·å€¼ï¼Œä½†èƒŒåŒ…é—®é¢˜è¿˜æœ‰å¾ˆå¤šç§çµæ´»çš„é—®æ³•ï¼Œåœ¨è¿™é‡Œå€¼å¾—æä¸€ä¸‹ã€‚ä½†æ˜¯æˆ‘è®¤ä¸ºï¼Œåªè¦æ·±å…¥ç†è§£äº†æ±‚èƒŒåŒ…é—®é¢˜æœ€å¤§ä»·å€¼çš„æ–¹æ³•ï¼Œå³ä½¿é—®æ³•å˜åŒ–äº†ï¼Œä¹Ÿæ˜¯ä¸éš¾æƒ³å‡ºç®—æ³•çš„ã€‚ ä¾‹å¦‚ï¼Œæ±‚è§£æœ€å¤šå¯ä»¥æ”¾å¤šå°‘ä»¶ç‰©å“æˆ–è€…æœ€å¤šå¯ä»¥è£…æ»¡å¤šå°‘èƒŒåŒ…çš„ç©ºé—´ã€‚è¿™éƒ½å¯ä»¥æ ¹æ®å…·ä½“é—®é¢˜åˆ©ç”¨å‰é¢çš„æ–¹ç¨‹æ±‚å‡ºæ‰€æœ‰çŠ¶æ€çš„å€¼ï¼ˆfæ•°ç»„ï¼‰ä¹‹åŽå¾—åˆ°ã€‚ å¾ˆå¤šéƒ½æ˜¯è¿™æ ·çš„ è¿˜æœ‰ï¼Œå¦‚æžœè¦æ±‚çš„æ˜¯â€œæ€»ä»·å€¼æœ€å°â€â€œæ€»ä»¶æ•°æœ€å°â€ï¼Œåªéœ€ç®€å•çš„å°†ä¸Šé¢çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸­çš„maxæ”¹æˆminå³å¯ã€‚ ä¸‹é¢è¯´ä¸€äº›å˜åŒ–æ›´å¤§çš„é—®æ³•ã€‚ è¾“å‡ºæ–¹æ¡ˆ ä¸€èˆ¬è€Œè¨€ï¼ŒèƒŒåŒ…é—®é¢˜æ˜¯è¦æ±‚ä¸€ä¸ªæœ€ä¼˜å€¼ï¼Œå¦‚æžœè¦æ±‚è¾“å‡ºè¿™ä¸ªæœ€ä¼˜å€¼çš„æ–¹æ¡ˆï¼Œå¯ä»¥å‚ç…§ä¸€èˆ¬åŠ¨æ€è§„åˆ’é—®é¢˜è¾“å‡ºæ–¹æ¡ˆçš„æ–¹æ³•ï¼šè®°å½•ä¸‹æ¯ä¸ªçŠ¶æ€çš„æœ€ä¼˜å€¼æ˜¯ç”±çŠ¶æ€è½¬ç§»æ–¹ç¨‹çš„å“ªä¸€é¡¹æŽ¨å‡ºæ¥çš„ï¼Œæ¢å¥è¯è¯´ï¼Œè®°å½•ä¸‹å®ƒæ˜¯ç”±å“ªä¸€ä¸ªç­–ç•¥æŽ¨å‡ºæ¥çš„ã€‚ä¾¿å¯æ ¹æ®è¿™æ¡ç­–ç•¥æ‰¾åˆ°ä¸Šä¸€ä¸ªçŠ¶æ€ï¼Œä»Žä¸Šä¸€ä¸ªçŠ¶æ€æŽ¥ç€å‘å‰æŽ¨å³å¯ã€‚ è¿˜æ˜¯ä»¥01èƒŒåŒ…ä¸ºä¾‹ï¼Œæ–¹ç¨‹ä¸ºf[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}ã€‚å†ç”¨ä¸€ä¸ªæ•°ç»„g[i][v]ï¼Œè®¾g[i][v]=0è¡¨ç¤ºæŽ¨å‡ºf[i][v]çš„å€¼æ—¶æ˜¯é‡‡ç”¨äº†æ–¹ç¨‹çš„å‰ä¸€é¡¹ï¼ˆä¹Ÿå³f[i][v]=f[i-1][v]ï¼‰ï¼Œg[i][v]è¡¨ç¤ºé‡‡ç”¨äº†æ–¹ç¨‹çš„åŽä¸€é¡¹ã€‚æ³¨æ„è¿™ä¸¤é¡¹åˆ†åˆ«è¡¨ç¤ºäº†ä¸¤ç§ç­–ç•¥ï¼šæœªé€‰ç¬¬iä¸ªç‰©å“åŠé€‰äº†ç¬¬iä¸ªç‰©å“ã€‚é‚£ä¹ˆè¾“å‡ºæ–¹æ¡ˆçš„ä¼ªä»£ç å¯ä»¥è¿™æ ·å†™ï¼ˆè®¾æœ€ç»ˆçŠ¶æ€ä¸ºf[N][V]ï¼‰ï¼š 12345678i=Nv=Vwhile(i&gt;0) if(g[i][v]==0) print "æœªé€‰ç¬¬ié¡¹ç‰©å“" else if(g[i][v]==1) print "é€‰äº†ç¬¬ié¡¹ç‰©å“" v=v-c[i] å¦å¤–ï¼Œé‡‡ç”¨æ–¹ç¨‹çš„å‰ä¸€é¡¹æˆ–åŽä¸€é¡¹ä¹Ÿå¯ä»¥åœ¨è¾“å‡ºæ–¹æ¡ˆçš„è¿‡ç¨‹ä¸­æ ¹æ®f[i][v]çš„å€¼å®žæ—¶åœ°æ±‚å‡ºæ¥ï¼Œä¹Ÿå³ä¸é¡»çºªå½•gæ•°ç»„ï¼Œå°†ä¸Šè¿°ä»£ç ä¸­çš„\(g[i][v]==0\)æ”¹æˆ\(f[i][v]==f[i-1][v]\)ï¼Œ\(g[i][v]==1\)æ”¹æˆ\(f[i][v]==f[i-1][v-c[i]]+w[i]\)ä¹Ÿå¯ã€‚ è¾“å‡ºå­—å…¸åºæœ€å°çš„æœ€ä¼˜æ–¹æ¡ˆ è¿™é‡Œâ€œå­—å…¸åºæœ€å°â€çš„æ„æ€æ˜¯1..Nå·ç‰©å“çš„é€‰æ‹©æ–¹æ¡ˆæŽ’åˆ—å‡ºæ¥ä»¥åŽå­—å…¸åºæœ€å°ã€‚ä»¥è¾“å‡º01èƒŒåŒ…æœ€å°å­—å…¸åºçš„æ–¹æ¡ˆä¸ºä¾‹ã€‚ ä¸€èˆ¬è€Œè¨€ï¼Œæ±‚ä¸€ä¸ªå­—å…¸åºæœ€å°çš„æœ€ä¼˜æ–¹æ¡ˆï¼Œåªéœ€è¦åœ¨è½¬ç§»æ—¶æ³¨æ„ç­–ç•¥ã€‚é¦–å…ˆï¼Œå­é—®é¢˜çš„å®šä¹‰è¦ç•¥æ”¹ä¸€äº›ã€‚æˆ‘ä»¬æ³¨æ„åˆ°ï¼Œå¦‚æžœå­˜åœ¨ä¸€ä¸ªé€‰äº†ç‰©å“1çš„æœ€ä¼˜æ–¹æ¡ˆï¼Œé‚£ä¹ˆç­”æ¡ˆä¸€å®šåŒ…å«ç‰©å“1ï¼ŒåŽŸé—®é¢˜è½¬åŒ–ä¸ºä¸€ä¸ªèƒŒåŒ…å®¹é‡ä¸ºv-c[1]ï¼Œç‰©å“ä¸º2..Nçš„å­é—®é¢˜ã€‚åä¹‹ï¼Œå¦‚æžœç­”æ¡ˆä¸åŒ…å«ç‰©å“1ï¼Œåˆ™è½¬åŒ–æˆèƒŒåŒ…å®¹é‡ä»ä¸ºVï¼Œç‰©å“ä¸º2..Nçš„å­é—®é¢˜ã€‚ä¸ç®¡ç­”æ¡ˆæ€Žæ ·ï¼Œå­é—®é¢˜çš„ç‰©å“éƒ½æ˜¯ä»¥i..Nè€Œéžå‰æ‰€è¿°çš„1..içš„å½¢å¼æ¥å®šä¹‰çš„ï¼Œæ‰€ä»¥çŠ¶æ€çš„å®šä¹‰å’Œè½¬ç§»æ–¹ç¨‹éƒ½éœ€è¦æ”¹ä¸€ä¸‹ã€‚ä½†ä¹Ÿè®¸æ›´ç®€æ˜“çš„æ–¹æ³•æ˜¯å…ˆæŠŠç‰©å“é€†åºæŽ’åˆ—ä¸€ä¸‹ï¼Œä»¥ä¸‹æŒ‰ç‰©å“å·²è¢«é€†åºæŽ’åˆ—æ¥å™è¿°ã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥æŒ‰ç…§å‰é¢ç»å…¸çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹æ¥æ±‚å€¼ï¼Œåªæ˜¯è¾“å‡ºæ–¹æ¡ˆçš„æ—¶å€™è¦æ³¨æ„ï¼šä»ŽNåˆ°1è¾“å…¥æ—¶ï¼Œå¦‚æžœ\(f[i][v]==f[i-v]\)åŠ\(f[i][v]==f[i-1][f-c[i]]+w[i]\) åŒæ—¶æˆç«‹ï¼Œåº”è¯¥æŒ‰ç…§åŽè€…ï¼ˆå³é€‰æ‹©äº†ç‰©å“iï¼‰æ¥è¾“å‡ºæ–¹æ¡ˆã€‚{å–Iä¸Žä¸å–Iç›¸æ¯”ï¼Œå–çš„è¯ä¸€å®šåœ¨å­—å…¸å‰} æ±‚æ–¹æ¡ˆæ€»æ•° å¯¹äºŽä¸€ä¸ªç»™å®šäº†èƒŒåŒ…å®¹é‡ã€ç‰©å“è´¹ç”¨ã€ç‰©å“é—´ç›¸äº’å…³ç³»ï¼ˆåˆ†ç»„ã€ä¾èµ–ç­‰ï¼‰çš„èƒŒåŒ…é—®é¢˜ï¼Œé™¤äº†å†ç»™å®šæ¯ä¸ªç‰©å“çš„ä»·å€¼åŽæ±‚å¯å¾—åˆ°çš„æœ€å¤§ä»·å€¼å¤–ï¼Œè¿˜å¯ä»¥å¾—åˆ°è£…æ»¡èƒŒåŒ…æˆ–å°†èƒŒåŒ…è£…è‡³æŸä¸€æŒ‡å®šå®¹é‡çš„æ–¹æ¡ˆæ€»æ•°ã€‚ å¯¹äºŽè¿™ç±»æ”¹å˜é—®æ³•çš„é—®é¢˜ï¼Œä¸€èˆ¬åªéœ€å°†çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸­çš„maxæ”¹æˆsumå³å¯ã€‚ä¾‹å¦‚è‹¥æ¯ä»¶ç‰©å“å‡æ˜¯å®Œå…¨èƒŒåŒ…ä¸­çš„ç‰©å“ï¼Œè½¬ç§»æ–¹ç¨‹å³ä¸º \(f[i][v]=\sum{f[i-1][v],f[i][v-c[i]]}\) åˆå§‹æ¡ä»¶\(f[0][0]=1\)ã€‚ äº‹å®žä¸Šï¼Œè¿™æ ·åšå¯è¡Œçš„åŽŸå› åœ¨äºŽçŠ¶æ€è½¬ç§»æ–¹ç¨‹å·²ç»è€ƒå¯Ÿäº†æ‰€æœ‰å¯èƒ½çš„èƒŒåŒ…ç»„æˆæ–¹æ¡ˆã€‚ æœ€ä¼˜æ–¹æ¡ˆçš„æ€»æ•° è¿™é‡Œçš„æœ€ä¼˜æ–¹æ¡ˆæ˜¯æŒ‡ç‰©å“æ€»ä»·å€¼æœ€å¤§çš„æ–¹æ¡ˆã€‚ä»¥01èƒŒåŒ…ä¸ºä¾‹ã€‚ ç»“åˆæ±‚æœ€å¤§æ€»ä»·å€¼å’Œæ–¹æ¡ˆæ€»æ•°ä¸¤ä¸ªé—®é¢˜çš„æ€è·¯ï¼Œæœ€ä¼˜æ–¹æ¡ˆçš„æ€»æ•°å¯ä»¥è¿™æ ·æ±‚ï¼šf[i][v]æ„ä¹‰åŒå‰è¿°ï¼Œg[i][v]è¡¨ç¤ºè¿™ä¸ªå­é—®é¢˜çš„æœ€ä¼˜æ–¹æ¡ˆçš„æ€»æ•°ï¼Œåˆ™åœ¨æ±‚f[i][v]çš„åŒæ—¶æ±‚g[i][v]çš„ä¼ªä»£ç å¦‚ä¸‹ï¼š 12345678for i=1..N for v=0..V f[i][v]=max&#123;f[i-1][v],f[i-1][v-c[i]]+w[i]&#125; g[i][v]=0 if(f[i][v]==f[i-1][v]) inc(g[i][v],g[i-1][v]) if(f[i][v]==f[i-1][v-c[i]]+w[i]) inc(g[i][v],g[i-1][v-c[i]]) å¦‚æžœä½ æ˜¯ç¬¬ä¸€æ¬¡çœ‹åˆ°è¿™æ ·çš„é—®é¢˜ï¼Œè¯·ä»”ç»†ä½“ä¼šä¸Šé¢çš„ä¼ªä»£ç ã€‚ æ±‚æ¬¡ä¼˜è§£ã€ç¬¬Kä¼˜è§£ å¯¹äºŽæ±‚æ¬¡ä¼˜è§£ã€ç¬¬Kä¼˜è§£ç±»çš„é—®é¢˜ï¼Œå¦‚æžœç›¸åº”çš„æœ€ä¼˜è§£é—®é¢˜èƒ½å†™å‡ºçŠ¶æ€è½¬ç§»æ–¹ç¨‹ã€ç”¨åŠ¨æ€è§„åˆ’è§£å†³ï¼Œé‚£ä¹ˆæ±‚æ¬¡ä¼˜è§£å¾€å¾€å¯ä»¥ç›¸åŒçš„å¤æ‚åº¦è§£å†³ï¼Œç¬¬Kä¼˜è§£åˆ™æ¯”æ±‚æœ€ä¼˜è§£çš„å¤æ‚åº¦ä¸Šå¤šä¸€ä¸ªç³»æ•°Kã€‚ å…¶åŸºæœ¬æ€æƒ³æ˜¯å°†æ¯ä¸ªçŠ¶æ€éƒ½è¡¨ç¤ºæˆæœ‰åºé˜Ÿåˆ—ï¼Œå°†çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸­çš„max/minè½¬åŒ–æˆæœ‰åºé˜Ÿåˆ—çš„åˆå¹¶ã€‚è¿™é‡Œä»ç„¶ä»¥01èƒŒåŒ…ä¸ºä¾‹è®²è§£ä¸€ä¸‹ã€‚ é¦–å…ˆçœ‹01èƒŒåŒ…æ±‚æœ€ä¼˜è§£çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼šf[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}ã€‚å¦‚æžœè¦æ±‚ç¬¬Kä¼˜è§£ï¼Œé‚£ä¹ˆçŠ¶æ€f[i][v]å°±åº”è¯¥æ˜¯ä¸€ä¸ªå¤§å°ä¸ºKçš„æ•°ç»„f[i][v][1..K]ã€‚å…¶ä¸­f[i][v][k]è¡¨ç¤ºå‰iä¸ªç‰©å“ã€èƒŒåŒ…å¤§å°ä¸ºvæ—¶ï¼Œç¬¬kä¼˜è§£çš„å€¼ã€‚â€œf[i][v]æ˜¯ä¸€ä¸ªå¤§å°ä¸ºKçš„æ•°ç»„â€è¿™ä¸€å¥ï¼Œç†Ÿæ‚‰Cè¯­è¨€çš„åŒå­¦å¯èƒ½æ¯”è¾ƒå¥½ç†è§£ï¼Œæˆ–è€…ä¹Ÿå¯ä»¥ç®€å•åœ°ç†è§£ä¸ºåœ¨åŽŸæ¥çš„æ–¹ç¨‹ä¸­åŠ äº†ä¸€ç»´ã€‚æ˜¾ç„¶f[i][v][1..K]è¿™Kä¸ªæ•°æ˜¯ç”±å¤§åˆ°å°æŽ’åˆ—çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬æŠŠå®ƒè®¤ä¸ºæ˜¯ä¸€ä¸ªæœ‰åºé˜Ÿåˆ—ã€‚ ç„¶åŽåŽŸæ–¹ç¨‹å°±å¯ä»¥è§£é‡Šä¸ºï¼šf[i][v]è¿™ä¸ªæœ‰åºé˜Ÿåˆ—æ˜¯ç”±f[i-1][v]å’Œf[i-1][v-c[i]]+w[i]è¿™ä¸¤ä¸ªæœ‰åºé˜Ÿåˆ—åˆå¹¶å¾—åˆ°çš„ã€‚æœ‰åºé˜Ÿåˆ—f[i-1][v]å³f[i-1][v][1..K]ï¼Œf[i-1][v-c[i]]+w[i]åˆ™ç†è§£ä¸ºåœ¨f[i-1][v-c[i]][1..K]çš„æ¯ä¸ªæ•°ä¸ŠåŠ ä¸Šw[i]åŽå¾—åˆ°çš„æœ‰åºé˜Ÿåˆ—ã€‚åˆå¹¶è¿™ä¸¤ä¸ªæœ‰åºé˜Ÿåˆ—å¹¶å°†ç»“æžœï¼ˆçš„å‰Ké¡¹ï¼‰å‚¨å­˜åˆ°f[i][v][1..K]ä¸­çš„å¤æ‚åº¦æ˜¯O(K)ã€‚æœ€åŽçš„ç­”æ¡ˆæ˜¯f[N][V][K]ã€‚æ€»çš„å¤æ‚åº¦æ˜¯O(NVK)ã€‚ ä¸ºä»€ä¹ˆè¿™ä¸ªæ–¹æ³•æ­£ç¡®å‘¢ï¼Ÿå®žé™…ä¸Šï¼Œä¸€ä¸ªæ­£ç¡®çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹çš„æ±‚è§£è¿‡ç¨‹éåŽ†äº†æ‰€æœ‰å¯ç”¨çš„ç­–ç•¥ï¼Œä¹Ÿå°±è¦†ç›–äº†é—®é¢˜çš„æ‰€æœ‰æ–¹æ¡ˆã€‚åªä¸è¿‡ç”±äºŽæ˜¯æ±‚æœ€ä¼˜è§£ï¼Œæ‰€ä»¥å…¶å®ƒåœ¨ä»»ä½•ä¸€ä¸ªç­–ç•¥ä¸Šè¾¾ä¸åˆ°æœ€ä¼˜çš„æ–¹æ¡ˆéƒ½è¢«å¿½ç•¥äº†ã€‚å¦‚æžœæŠŠæ¯ä¸ªçŠ¶æ€è¡¨ç¤ºæˆä¸€ä¸ªå¤§å°ä¸ºKçš„æ•°ç»„ï¼Œå¹¶åœ¨è¿™ä¸ªæ•°ç»„ä¸­æœ‰åºçš„ä¿å­˜è¯¥çŠ¶æ€å¯å–åˆ°çš„å‰Kä¸ªæœ€ä¼˜å€¼ã€‚é‚£ä¹ˆï¼Œå¯¹äºŽä»»ä¸¤ä¸ªçŠ¶æ€çš„maxè¿ç®—ç­‰ä»·äºŽä¸¤ä¸ªç”±å¤§åˆ°å°çš„æœ‰åºé˜Ÿåˆ—çš„åˆå¹¶ã€‚ å¦å¤–è¿˜è¦æ³¨æ„é¢˜ç›®å¯¹äºŽâ€œç¬¬Kä¼˜è§£â€çš„å®šä¹‰ï¼Œå°†ç­–ç•¥ä¸åŒä½†æƒå€¼ç›¸åŒçš„ä¸¤ä¸ªæ–¹æ¡ˆæ˜¯çœ‹ä½œåŒä¸€ä¸ªè§£è¿˜æ˜¯ä¸åŒçš„è§£ã€‚å¦‚æžœæ˜¯å‰è€…ï¼Œåˆ™ç»´æŠ¤æœ‰åºé˜Ÿåˆ—æ—¶è¦ä¿è¯é˜Ÿåˆ—é‡Œçš„æ•°æ²¡æœ‰é‡å¤çš„ã€‚ å°ç»“ æ˜¾ ç„¶ï¼Œè¿™é‡Œä¸å¯èƒ½ç©·å°½èƒŒåŒ…ç±»åŠ¨æ€è§„åˆ’é—®é¢˜æ‰€æœ‰çš„é—®æ³•ã€‚ç”šè‡³è¿˜å­˜åœ¨ä¸€ç±»å°†èƒŒåŒ…ç±»åŠ¨æ€è§„åˆ’é—®é¢˜ä¸Žå…¶å®ƒé¢†åŸŸï¼ˆä¾‹å¦‚æ•°è®ºã€å›¾è®ºï¼‰ç»“åˆèµ·æ¥çš„é—®é¢˜ï¼Œåœ¨è¿™ç¯‡è®ºèƒŒåŒ…é—®é¢˜çš„ ä¸“æ–‡ä¸­ä¹Ÿä¸ä¼šè®ºåŠã€‚ä½†åªè¦æ·±åˆ»é¢†ä¼šå‰è¿°æ‰€æœ‰ç±»åˆ«çš„èƒŒåŒ…é—®é¢˜çš„æ€è·¯å’ŒçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œé‡åˆ°å…¶å®ƒçš„å˜å½¢é—®æ³•ï¼Œåªè¦é¢˜ç›®éš¾åº¦è¿˜å±žäºŽNOIPï¼Œåº”è¯¥ä¹Ÿä¸éš¾æƒ³å‡ºç®—æ³•ã€‚è§¦ç±»æ—é€šã€ä¸¾ä¸€åä¸‰ï¼Œåº”è¯¥ä¹Ÿæ˜¯ä¸€ä¸ªOIeråº”æœ‰çš„å“è´¨å§ã€‚ é¦–é¡µ P11: èƒŒåŒ…é—®é¢˜çš„æœç´¢è§£æ³• ã€ŠèƒŒåŒ…é—®é¢˜ä¹è®²ã€‹çš„æœ¬æ„æ˜¯å°†èƒŒåŒ…é—®é¢˜ä½œä¸ºåŠ¨æ€è§„åˆ’é—®é¢˜ä¸­çš„ä¸€ç±»è¿›è¡Œè®²è§£ã€‚ä½†é‰´äºŽçš„ç¡®æœ‰ä¸€äº›èƒŒåŒ…é—®é¢˜åªèƒ½ç”¨æœç´¢æ¥è§£ï¼Œæ‰€ä»¥è¿™é‡Œä¹Ÿå¯¹ç”¨æœç´¢è§£èƒŒåŒ…é—®é¢˜åšç®€å•ä»‹ç»ã€‚å¤§éƒ¨åˆ†ä»¥01èƒŒåŒ…ä¸ºä¾‹ï¼Œå…¶å®ƒçš„åº”è¯¥å¯ä»¥è§¦ç±»æ—é€šã€‚ ç®€å•çš„æ·±æœ å¯¹äºŽ01èƒŒåŒ…é—®é¢˜ï¼Œç®€å•çš„æ·±æœçš„å¤æ‚åº¦æ˜¯O(2N)ã€‚å°±æ˜¯æžšä¸¾å‡ºæ‰€æœ‰2Nç§å°†ç‰©å“æ”¾å…¥èƒŒåŒ…çš„æ–¹æ¡ˆï¼Œç„¶åŽæ‰¾æœ€ä¼˜è§£ã€‚åŸºæœ¬æ¡†æž¶å¦‚ä¸‹ï¼š 12345678procedure SearchPack(i,cur_v,cur_w) if(i&gt;N) if(cur_w&gt;best) best=cur_w return if(cur_v+v[i]&lt;=V) SearchPack(i+1,cur_v+v[i],cur_w+w[i]) SearchPack(i+1,cur_v,cur_w) å…¶ä¸­cur_vå’Œcur_wè¡¨ç¤ºå½“å‰è§£çš„è´¹ç”¨å’Œæƒå€¼ã€‚ä¸»ç¨‹åºä¸­è°ƒç”¨SearchPack(1,0,0)å³å¯ã€‚ æœç´¢çš„å‰ªæž åŸºæœ¬çš„å‰ªæžæ–¹æ³•ä¸å¤–ä¹Žå¯è¡Œæ€§å‰ªæžæˆ–æœ€ä¼˜æ€§å‰ªæžã€‚ å¯è¡Œæ€§å‰ªæžå³åˆ¤æ–­æŒ‰ç…§å½“å‰çš„æœç´¢è·¯å¾„æœä¸‹åŽ»èƒ½å¦æ‰¾åˆ°ä¸€ä¸ªå¯è¡Œè§£ï¼Œä¾‹å¦‚ï¼šè‹¥å°†å‰©ä¸‹æ‰€æœ‰ç‰©å“éƒ½æ”¾å…¥èƒŒåŒ…ä»ç„¶æ— æ³•å°†èƒŒåŒ…å……æ»¡ï¼ˆè®¾é¢˜ç›®è¦æ±‚å¿…é¡»å°†èƒŒåŒ…å……æ»¡ï¼‰ï¼Œåˆ™å‰ªæžã€‚ æœ€ä¼˜æ€§å‰ªæžå³åˆ¤æ–­æŒ‰ç…§å½“å‰çš„æœç´¢è·¯å¾„æœä¸‹åŽ»èƒ½å¦æ‰¾åˆ°ä¸€ä¸ªæœ€ä¼˜è§£ï¼Œä¾‹å¦‚ï¼šè‹¥åŠ ä¸Šå‰©ä¸‹æ‰€æœ‰ç‰©å“çš„æƒå€¼ä¹Ÿæ— æ³•å¾—åˆ°æ¯”å½“å‰å¾—åˆ°çš„æœ€ä¼˜è§£æ›´ä¼˜çš„è§£ï¼Œåˆ™å‰ªæžã€‚ æœç´¢çš„é¡ºåº åœ¨æœç´¢ä¸­ï¼Œå¯ä»¥è®¤ä¸ºé¡ºåºé å‰çš„ç‰©å“ä¼šè¢«ä¼˜å…ˆè€ƒè™‘ã€‚æ‰€ä»¥åˆ©ç”¨è´ªå¿ƒçš„æ€æƒ³ï¼Œå°†æ›´æœ‰å¯èƒ½å‡ºçŽ°åœ¨ç»“æžœä¸­çš„ç‰©å“çš„é¡ºåºæå‰ï¼Œå¯ä»¥è¾ƒå¿«åœ°å¾—å‡ºè´ªå¿ƒåœ°è¾ƒä¼˜è§£ï¼Œæ›´æœ‰åˆ©äºŽæœ€ä¼˜æ€§å‰ªæžã€‚æ‰€ä»¥ï¼Œå¯ä»¥è€ƒè™‘å°†æŒ‰ç…§â€œæ€§ä»·æ¯”â€ï¼ˆæƒå€¼/è´¹ç”¨ï¼‰æ¥æŽ’åˆ—æœç´¢é¡ºåºã€‚ å¦ä¸€æ–¹é¢ï¼Œè‹¥å°†è´¹ç”¨è¾ƒå¤§çš„ç‰©å“æŽ’åˆ—åœ¨å‰é¢ï¼Œå¯ä»¥è¾ƒå¿«åœ°å¡«æ»¡èƒŒåŒ…ï¼Œæœ‰åˆ©äºŽå¯è¡Œæ€§å‰ªæžã€‚ æœ€åŽä¸€ç§å¯ä»¥è€ƒè™‘çš„æ–¹æ¡ˆæ˜¯ï¼šåœ¨å¼€å§‹æœç´¢å‰å°†è¾“å…¥æ–‡ä»¶ä¸­ç»™å®šçš„ç‰©å“çš„é¡ºåºéšæœºæ‰“ä¹±ã€‚è¿™æ ·å¯ä»¥é¿å…å‘½é¢˜äººæ•…æ„è®¾ç½®çš„é™·é˜±ã€‚ ä»¥ä¸Šä¸‰ç§å†³å®šæœç´¢é¡ºåºçš„æ–¹æ³•å¾ˆéš¾è¯´å“ªç§æ›´å¥½ï¼Œäº‹å®žä¸Šæ¯ç§æ–¹æ³•éƒ½æœ‰é€‚ç”¨çš„é¢˜ç›®å’Œæ•°æ®ï¼Œä¹Ÿæœ‰å¯èƒ½å°†å®ƒä»¬åœ¨æŸç§ç¨‹åº¦ä¸Šæ··åˆä½¿ç”¨ã€‚ å­é›†å’Œé—®é¢˜ å­é›†å’Œé—®é¢˜æ˜¯ä¸€ä¸ªNP-Completeé—®é¢˜ï¼Œä¸Žå‰è¿°çš„ï¼ˆåŠ æƒçš„ï¼‰01èƒŒåŒ…é—®é¢˜å¹¶ä¸ç›¸åŒã€‚ç»™å®šä¸€ä¸ªæ•´æ•°çš„é›†åˆSå’Œä¸€ä¸ªæ•´æ•°Xï¼Œé—®æ˜¯å¦å­˜åœ¨Sçš„ä¸€ä¸ªå­é›†æ»¡è¶³å…¶ä¸­æ‰€æœ‰å…ƒç´ çš„å’Œä¸ºXã€‚ è¿™ä¸ªé—®é¢˜æœ‰ä¸€ä¸ªæ—¶é—´å¤æ‚åº¦ä¸ºO(2(N/2))çš„è¾ƒé«˜æ•ˆçš„æœç´¢ç®—æ³•ï¼Œå…¶ä¸­Næ˜¯é›†åˆSçš„å¤§å°ã€‚ ç¬¬ä¸€æ­¥æ€æƒ³æ˜¯äºŒåˆ†ã€‚å°†é›†åˆSåˆ’åˆ†æˆä¸¤ä¸ªå­é›†S1å’ŒS2ï¼Œå®ƒä»¬çš„å¤§å°éƒ½æ˜¯N/2ã€‚å¯¹äºŽS1å’ŒS2ï¼Œåˆ†åˆ«æžšä¸¾å‡ºå®ƒä»¬æ‰€æœ‰çš„2(N/2)ä¸ªå­é›†å’Œï¼Œä¿å­˜åˆ°æŸç§æ”¯æŒæŸ¥æ‰¾çš„æ•°æ®ç»“æž„ä¸­ï¼Œä¾‹å¦‚hash setã€‚ ç„¶åŽå°±è¦å°†ä¸¤éƒ¨åˆ†ç»“æžœåˆå¹¶ï¼Œå¯»æ‰¾æ˜¯å¦æœ‰å’Œä¸ºXçš„Sçš„å­é›†ã€‚äº‹å®žä¸Šï¼Œå¯¹äºŽS1çš„æŸä¸ªå’Œä¸ºX1çš„å­é›†ï¼Œåªéœ€å¯»æ‰¾S2æ˜¯å¦æœ‰å’Œä¸ºX-X1çš„å­é›†ã€‚ å‡è®¾é‡‡ç”¨çš„hash setæ˜¯ç†æƒ³çš„ï¼Œæ¯æ¬¡æŸ¥æ‰¾å’Œæ’å…¥éƒ½ä»…èŠ±è´¹O(1)çš„æ—¶é—´ã€‚ä¸¤æ­¥çš„æ—¶é—´å¤æ‚åº¦æ˜¾ç„¶éƒ½æ˜¯O(2^(N/2))ã€‚ å®žè·µä¸­ï¼Œå¾€å¾€å¯ä»¥å…ˆå°†ç¬¬ä¸€æ­¥å¾—åˆ°çš„ä¸¤ç»„å­é›†å’Œåˆ†åˆ«æŽ’åºï¼Œç„¶åŽå†ç”¨ä¸¤ä¸ªæŒ‡é’ˆæ‰«æçš„æ–¹æ³•æŸ¥æ‰¾æ˜¯å¦æœ‰æ»¡è¶³è¦æ±‚çš„å­é›†å’Œã€‚è¿™æ ·çš„å®žçŽ°ï¼Œåœ¨å¯æŽ¥å—çš„æ—¶é—´å†…å¯ä»¥è§£å†³çš„æœ€å¤§è§„æ¨¡çº¦ä¸ºN=42ã€‚ æœç´¢è¿˜æ˜¯DP? åœ¨çœ‹åˆ°ä¸€é“èƒŒåŒ…é—®é¢˜æ—¶ï¼Œåº”è¯¥ç”¨æœç´¢è¿˜æ˜¯åŠ¨æ€è§„åˆ’å‘¢ï¼Ÿ é¦–å…ˆï¼Œå¯ä»¥ä»Žæ•°æ®èŒƒå›´ä¸­å¾—åˆ°å‘½é¢˜äººæ„å›¾çš„çº¿ç´¢ã€‚å¦‚æžœä¸€ä¸ªèƒŒåŒ…é—®é¢˜å¯ä»¥ç”¨DPè§£ï¼ŒVä¸€å®šä¸èƒ½å¾ˆå¤§ï¼Œå¦åˆ™O(VN)çš„ç®—æ³•æ— æ³•æ‰¿å—ï¼Œè€Œä¸€èˆ¬çš„æœç´¢è§£æ³•éƒ½ æ˜¯ä»…ä¸ŽNæœ‰å…³ï¼Œä¸ŽVæ— å…³çš„ã€‚æ‰€ä»¥ï¼ŒVå¾ˆå¤§æ—¶ï¼ˆä¾‹å¦‚ä¸Šç™¾ä¸‡ï¼‰ï¼Œå‘½é¢˜äººçš„æ„å›¾å°±åº”è¯¥æ˜¯è€ƒå¯Ÿæœç´¢ã€‚å¦ä¸€æ–¹é¢ï¼ŒNè¾ƒå¤§æ—¶ï¼ˆä¾‹å¦‚ä¸Šç™¾ï¼‰ï¼Œå‘½é¢˜äººçš„æ„å›¾å°±å¾ˆæœ‰å¯èƒ½æ˜¯è€ƒ å¯ŸåŠ¨æ€è§„åˆ’äº†ã€‚ å¦å¤–ï¼Œå½“æƒ³ä¸å‡ºåˆé€‚çš„åŠ¨æ€è§„åˆ’ç®—æ³•æ—¶ï¼Œå°±åªèƒ½ç”¨æœç´¢äº†ã€‚ä¾‹å¦‚çœ‹åˆ°ä¸€ä¸ªä»Žæœªè§è¿‡çš„èƒŒåŒ…ä¸­ç‰©å“çš„é™åˆ¶æ¡ä»¶ï¼Œæ— æ³•æƒ³å‡ºDPçš„æ–¹ç¨‹ï¼Œåªå¥½å†™æœç´¢ä»¥è°‹æ±‚ä¸€å®šçš„åˆ†æ•°äº†ã€‚ é™„ï¼šUSACOä¸­çš„èƒŒåŒ…é—®é¢˜ USACOæ˜¯USA Computing Olympiadçš„ç®€ç§°ï¼Œå®ƒç»„ç»‡äº†å¾ˆå¤šé¢å‘å…¨çƒçš„è®¡ç®—æœºç«žèµ›æ´»åŠ¨ã€‚ USACO Trainngæ˜¯ä¸€ä¸ªå¾ˆé€‚åˆåˆå­¦è€…çš„é¢˜åº“ï¼Œæˆ‘è®¤ä¸ºå®ƒçš„ç‰¹è‰²æ˜¯é¢˜ç›®è´¨é‡é«˜ï¼Œå¾ªåºæ¸è¿›ï¼Œè¿˜é…æœ‰ä¸é”™çš„è¯¾æ–‡å’Œé¢˜ç›®åˆ†æžã€‚å…¶ä¸­å…³äºŽèƒŒåŒ…é—®é¢˜çš„é‚£ç¯‡è¯¾æ–‡ (TEXT Knapsack Problems) ä¹Ÿå€¼å¾—ä¸€çœ‹ã€‚ å¦å¤–ï¼ŒUSACO Contestæ˜¯USACOå¸¸å¹´ç»„ç»‡çš„é¢å‘å…¨çƒçš„ç«žèµ›ç³»åˆ—ï¼Œåœ¨æ­¤ä¹ŸæŽ¨èNOIPé€‰æ‰‹å‚åŠ ã€‚ æˆ‘æ•´ç†äº†USACO Trainingä¸­æ¶‰åŠèƒŒåŒ…é—®é¢˜çš„é¢˜ç›®ï¼Œåº”è¯¥å¯ä»¥ä½œä¸ºä¸é”™çš„ä¹ é¢˜ã€‚å…¶ä¸­æ ‡åŠ å·çš„æ˜¯æˆ‘æ¯”è¾ƒæŽ¨èçš„ï¼Œæ ‡å¹å·çš„æ˜¯æˆ‘è®¤ä¸ºå¯¹NOIPé€‰æ‰‹æ¯”è¾ƒæœ‰æŒ‘æˆ˜æ€§çš„ã€‚ é¢˜ç›®åˆ—è¡¨ Inflate (+) ï¼ˆåŸºæœ¬01èƒŒåŒ…ï¼‰ Stamps (+)(!) ï¼ˆå¯¹åˆå­¦è€…æœ‰ä¸€å®šæŒ‘æˆ˜æ€§ï¼‰ Money Nuggets Subsets Rockers (+) ï¼ˆå¦ä¸€ç±»æœ‰è¶£çš„â€œäºŒç»´â€èƒŒåŒ…é—®é¢˜ï¼‰ Milk4 (!) ï¼ˆå¾ˆæ€ªçš„èƒŒåŒ…é—®é¢˜é—®æ³•ï¼Œè¾ƒéš¾ç”¨çº¯DPæ±‚è§£ï¼‰ é¢˜ç›®ç®€è§£ ä»¥ä¸‹æ–‡å­—æ¥è‡ªæˆ‘æ‰€æ’°çš„ã€ŠUSACOå¿ƒå¾—ã€‹ä¸€æ–‡ï¼Œè¯¥æ–‡çš„å®Œæ•´ç‰ˆæœ¬ï¼ŒåŒ…æ‹¬æˆ‘çš„ç¨‹åºï¼Œå¯åœ¨DDçš„USACOå¾ç¨‹ä¸­æ‰¾åˆ°ã€‚ Inflate æ˜¯åŠ æƒ01 èƒŒåŒ…é—®é¢˜ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼šæ¯ç§ç‰©å“åªæœ‰ä¸€ä»¶ï¼Œåªå¯ä»¥é€‰æ‹©æ”¾æˆ–è€…ä¸æ”¾ï¼›è€Œä¸”æ¯ç§ç‰©å“æœ‰å¯¹åº”çš„æƒå€¼ï¼Œç›®æ ‡æ˜¯ä½¿æ€»æƒå€¼æœ€å¤§æˆ–æœ€å°ã€‚å®ƒæœ€æœ´ç´ çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹æ˜¯ï¼šf[k][i] = max{f[k-1][i] , f[k-1][i-v[k]]+w[k]}ã€‚f[k][i]è¡¨ç¤ºå‰k ä»¶ç‰©å“èŠ±è´¹ä»£ä»·i å¯ä»¥å¾—åˆ°çš„æœ€å¤§æƒå€¼ã€‚v[k]å’Œw[k]åˆ†åˆ«æ˜¯ç¬¬k ä»¶ç‰©å“çš„èŠ±è´¹å’Œæƒå€¼ã€‚å¯ä»¥çœ‹åˆ°ï¼Œf[k]çš„æ±‚è§£è¿‡ç¨‹å°±æ˜¯ä½¿ç”¨ç¬¬k ä»¶ç‰©å“å¯¹f[k-1]è¿›è¡Œæ›´æ–°çš„è¿‡ç¨‹ã€‚é‚£ä¹ˆäº‹å®žä¸Šå°±ä¸ç”¨ä½¿ç”¨äºŒç»´æ•°ç»„ï¼Œåªéœ€è¦å®šä¹‰f[i]ï¼Œç„¶åŽå¯¹äºŽæ¯ä»¶ç‰©å“kï¼Œé¡ºåºåœ°æ£€æŸ¥f[i]ä¸Žf[i-v[k]]+w[k]çš„å¤§å°ï¼Œå¦‚æžœåŽè€…æ›´å¤§ï¼Œå°±å¯¹å‰è€…è¿›è¡Œæ›´æ–°ã€‚è¿™æ˜¯èƒŒåŒ…é—®é¢˜ä¸­å…¸åž‹çš„ä¼˜åŒ–æ–¹æ³•ã€‚ é¢˜ç›®stamps ä¸­ï¼Œæ¯ç§ç‰©å“çš„ä½¿ç”¨é‡æ²¡æœ‰ç›´æŽ¥é™åˆ¶ï¼Œä½†ä½¿ç”¨ç‰©å“çš„æ€»é‡æœ‰é™åˆ¶ã€‚æ±‚ç¬¬ä¸€ä¸ªä¸èƒ½ç”¨è¿™æœ‰é™ä¸ªç‰©å“ç»„æˆçš„èƒŒåŒ…çš„å¤§å°ã€‚ï¼ˆå¯ä»¥è¿™æ ·ç­‰ä»·åœ°è®¤ä¸ºï¼‰è®¾f[k][i] è¡¨ç¤ºå‰k ä»¶ç‰©å“ç»„æˆå¤§å°ä¸ºi çš„èƒŒåŒ…ï¼Œ æœ€å°‘éœ€è¦ç‰©å“çš„æ•°é‡ã€‚åˆ™f[k][i]= min{f[k-1][i],f[k-1][i-j*s[k]]+j}ï¼Œå…¶ä¸­j æ˜¯é€‰æ‹©ä½¿ç”¨ç¬¬k ä»¶ç‰©å“çš„æ•°ç›®ï¼Œè¿™ä¸ªæ–¹ç¨‹è¿ç”¨æ—¶å¯ä»¥ç”¨å’Œä¸Šé¢ä¸€æ ·çš„æ–¹æ³•å¤„ç†æˆä¸€ç»´çš„ã€‚æ±‚è§£æ—¶å…ˆè®¾ç½®ä¸€ä¸ªç²—ç³™çš„å¾ªçŽ¯ä¸Šé™ï¼Œå³æœ€å¤§çš„ç‰©å“ä¹˜æœ€å¤šç‰©å“æ•°ã€‚ Money æ˜¯å¤šé‡èƒŒåŒ…é—®é¢˜ã€‚ä¹Ÿå°±æ˜¯æ¯ä¸ªç‰©å“å¯ä»¥ä½¿ç”¨æ— é™å¤šæ¬¡ã€‚è¦æ±‚è§£çš„æ˜¯æž„æˆä¸€ç§èƒŒåŒ…çš„ä¸åŒæ–¹æ¡ˆæ€»æ•°ã€‚åŸºæœ¬ä¸Šå°±æ˜¯æŠŠä¸€èˆ¬çš„å¤šé‡èƒŒåŒ…çš„æ–¹ç¨‹ä¸­çš„min æ”¹æˆsum å°±è¡Œäº†ã€‚ Nuggets çš„æ¨¡åž‹ä¹Ÿæ˜¯å¤šé‡èƒŒåŒ…ã€‚è¦æ±‚æ±‚è§£æ‰€ç»™çš„ç‰©å“ä¸èƒ½æ°å¥½æ”¾å…¥çš„èƒŒåŒ…å¤§å°çš„æœ€å¤§å€¼ï¼ˆå¯èƒ½ä¸å­˜åœ¨ï¼‰ã€‚åªéœ€è¦æ ¹æ®â€œè‹¥iã€j äº’è´¨ï¼Œåˆ™å…³äºŽxã€y çš„ä¸å®šæ–¹ç¨‹ix+yj=n å¿…æœ‰æ­£æ•´æ•°è§£ï¼Œå…¶ä¸­n&gt;ijâ€è¿™ä¸€å®šç†å¾—å‡ºä¸€ä¸ªå¾ªçŽ¯çš„ä¸Šé™ã€‚Subsets å­é›†å’Œé—®é¢˜ç›¸å½“äºŽç‰©å“å¤§å°æ˜¯å‰N ä¸ªè‡ªç„¶æ•°æ—¶æ±‚å¤§å°ä¸ºN(N+1)/4 çš„ 01 èƒŒåŒ…çš„æ–¹æ¡ˆæ•°ã€‚ Rockers å¯ä»¥åˆ©ç”¨æ±‚è§£èƒŒåŒ…é—®é¢˜çš„æ€æƒ³è®¾è®¡è§£æ³•ã€‚æˆ‘çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹å¦‚ä¸‹ï¼š f[i][j][t]=max{f[i][j][t-1] , f[i-1][j][t] , f[i-1][j][t-time[i]]+1 , f[i-1][j-1][T]+(t&gt;=time[i])}ã€‚å…¶ä¸­ f[i][j][t]è¡¨ç¤ºå‰i é¦–æ­Œç”¨j å¼ å®Œæ•´çš„ç›˜å’Œä¸€å¼ å½•äº†t åˆ†é’Ÿçš„ç›˜å¯ä»¥æ”¾å…¥çš„æœ€å¤šæ­Œæ•°ï¼ŒT æ˜¯ä¸€å¼ å…‰ç›˜çš„æœ€å¤§å®¹é‡ï¼Œt&gt;=time[i]æ˜¯ä¸€ä¸ªbool å€¼è½¬æ¢æˆint å–å€¼ä¸º0 æˆ–1ã€‚ä½†æˆ‘åŽæ¥å‘çŽ°æˆ‘å½“æ—¶è®¾è®¡çš„çŠ¶æ€å’Œæ–¹ç¨‹æ•ˆçŽ‡æœ‰ç‚¹ä½Žï¼Œå¦‚æžœæ¢æˆè¿™æ ·ï¼šf[i][j]=(a,b)è¡¨ç¤ºå‰i é¦–æ­Œä¸­é€‰äº†j é¦–éœ€è¦ç”¨åˆ°a å¼ å®Œæ•´çš„å…‰ç›˜ä»¥åŠä¸€å¼ å½•äº†b åˆ†é’Ÿçš„å…‰ç›˜ï¼Œä¼šå°†æ—¶ç©ºå¤æ‚åº¦éƒ½å¤§å¤§é™ä½Žã€‚è¿™ç§å°†çŠ¶æ€çš„å€¼è®¾ä¸ºäºŒç»´çš„æ–¹æ³•å€¼å¾—æ³¨æ„ã€‚ Milk4 æ˜¯è¿™äº›ç±»èƒŒåŒ…é—®é¢˜ä¸­éš¾åº¦æœ€å¤§çš„ä¸€é“äº†ã€‚å¾ˆå¤šäººæ— æ³•åšåˆ°å°†å®ƒç”¨çº¯DP æ–¹æ³•æ±‚è§£ï¼Œè€Œæ˜¯ç”¨è¿­ä»£åŠ æ·±æœç´¢æžšä¸¾ä½¿ç”¨çš„æ¡¶ï¼Œå°†å…¶è½¬æ¢æˆå¤šé‡èƒŒåŒ…é—®é¢˜å†DPã€‚ç”±äºŽ USACO çš„æ•°æ®å¼±ï¼Œè¿­ä»£åŠ æ·±çš„æ·±åº¦å¾ˆå°ï¼Œè¿™æ ·ä¹Ÿå¯ä»¥ACï¼Œä½†æˆ‘ä»¬è¿˜æ˜¯å¯ä»¥ç”¨çº¯DP æ–¹æ³•å°†å®ƒå®Œç¾Žè§£å†³çš„ã€‚è®¾f[k]ä¸ºç§°é‡å‡ºk å•ä½ç‰›å¥¶éœ€è¦çš„æœ€å°‘çš„æ¡¶æ•°ã€‚é‚£ä¹ˆå¯ä»¥ç”¨ç±»ä¼¼å¤šé‡èƒŒåŒ…çš„æ–¹æ³•å¯¹f æ•°ç»„åå¤æ›´æ–°ä»¥æ±‚å¾—æœ€å°å€¼ã€‚ç„¶è€Œå›°éš¾åœ¨äºŽå¦‚ä½•è¾“å‡ºå­—å…¸åºæœ€å°çš„æ–¹æ¡ˆã€‚æˆ‘ä»¬å¯ä»¥å¯¹æ¯ä¸ªiè®°å½•pre_f[i]å’Œpre_v[i]ã€‚è¡¨ç¤ºå¾—åˆ°i å•ä½ç‰›å¥¶çš„è¿‡ç¨‹æ˜¯ç”¨pre_f[i]å•ä½ç‰›å¥¶åŠ ä¸Šè‹¥å¹²ä¸ªç¼–å·ä¸ºpre_v[i]çš„æ¡¶çš„ç‰›å¥¶ã€‚è¿™æ ·å°±å¯ä»¥ä¸€æ­¥æ­¥æ±‚å¾—å¾—åˆ°i å•ä½ç‰›å¥¶çš„å®Œæ•´æ–¹æ¡ˆã€‚ä¸ºäº†ä½¿æ–¹æ¡ˆçš„å­—å…¸åºæœ€å°ï¼Œæˆ‘ä»¬åœ¨æ¯æ¬¡æ‰¾åˆ°ä¸€ä¸ªè€—è´¹æ¡¶æ•°ç›¸åŒçš„æ–¹æ¡ˆæ—¶å¯¹å·²å‚¨å­˜çš„æ–¹æ¡ˆå’Œæ–°æ–¹æ¡ˆè¿›è¡Œæ¯”è¾ƒå†å†³å®šæ˜¯å¦æ›´æ–°æ–¹æ¡ˆã€‚ä¸ºäº†ä½¿è¿™ç§æ¯”è¾ƒå¿«æ·ï¼Œåœ¨ä½¿ç”¨å„ç§å¤§å°çš„æ¡¶å¯¹f æ•°ç»„è¿›è¡Œæ›´æ–°æ—¶å…ˆå¤§åŽå°åœ°è¿›è¡Œã€‚USACO çš„å®˜æ–¹é¢˜è§£æ­£æ˜¯è¿™ä¸€æ€è·¯ã€‚å¦‚æžœè®¤ä¸ºä»¥ä¸Šæ–‡å­—æ¯”è¾ƒéš¾ç†è§£å¯ä»¥é˜…è¯»å®˜æ–¹ç¨‹åºæˆ–æˆ‘çš„ç¨‹åºã€‚ 26 èƒŒåŒ…é—®é¢˜åº”ç”¨ Category: æ•°æ®ç»“æž„ä¸Žç®—æ³• View: 6,055 é˜… Author: Dong ä½œè€…:Dong | å¯ä»¥è½¬è½½, ä½†å¿…é¡»ä»¥è¶…é“¾æŽ¥å½¢å¼æ ‡æ˜Žæ–‡ç« åŽŸå§‹å‡ºå¤„å’Œä½œè€…ä¿¡æ¯åŠç‰ˆæƒå£°æ˜Ž ç½‘å€:http://dongxicheng.org/structure/knapsack-problems/ èƒŒåŒ…é—®é¢˜ä»‹ç» èƒŒåŒ…é—®é¢˜ä¸å•å•æ˜¯ä¸€ä¸ªç®€å•çš„ç®—æ³•é—®é¢˜ï¼Œå®ƒæœ¬è´¨ä¸Šä»£è¡¨äº†ä¸€å¤§ç±»é—®é¢˜ï¼Œè¿™ç±»é—®é¢˜å®žé™…ä¸Šæ˜¯01çº¿æ€§è§„åˆ’é—®é¢˜ï¼Œå…¶çº¦æŸæ¡ä»¶å’Œç›®æ ‡å‡½æ•°å¦‚ä¸‹ï¼š è‡ªä»Ždd_engiåœ¨2007å¹´æŽ¨å‡ºã€ŠèƒŒåŒ…é—®é¢˜ä¹è®²ã€‹ä¹‹åŽï¼ŒèƒŒåŒ…é—®é¢˜çš„ä¸»è¦ç²¾é«“åŸºæœ¬å·²é“å°½ã€‚æœ¬æ–‡æ²¡æœ‰å°è¯•å¯¹èƒŒåŒ…é—®é¢˜çš„æœ¬è´¨è¿›è¡Œæ‰©å±•æˆ–æ·±å…¥æŒ–æŽ˜ï¼Œè€Œåªæ˜¯ä»Žæœ‰é™çš„ç†è§£ï¼ˆè¿™é‡ŒæŒ‡å¯¹ã€ŠèƒŒåŒ…é—®é¢˜ä¹è®²ã€‹çš„ç†è§£ï¼‰å‡ºå‘ï¼Œå¸®åŠ©è¯»è€…æ›´å¿«åœ°å­¦ä¹ ã€ŠèƒŒåŒ…é—®é¢˜ä¹è®²ã€‹ä¸­çš„æåˆ°çš„å„ç§èƒŒåŒ…é—®é¢˜çš„ä¸»è¦ç®—æ³•æ€æƒ³ï¼Œå¹¶é€šè¿‡å®žä¾‹è§£é‡Šäº†ç›¸åº”çš„ç®—æ³•ï¼ŒåŒæ—¶ç»™å‡ºäº†å‡ ä¸ªèƒŒåŒ…é—®é¢˜çš„ç»å…¸åº”ç”¨ã€‚ èƒŒåŒ…é—®é¢˜åŠåº”ç”¨ dd_engiåœ¨ã€ŠèƒŒåŒ…é—®é¢˜ä¹è®²ã€‹ä¸­ä¸»è¦æåˆ°å››ç§èƒŒåŒ…é—®é¢˜ï¼Œåˆ†åˆ«ä¸ºï¼š01èƒŒåŒ…é—®é¢˜ï¼Œå®Œå…¨èƒŒåŒ…é—®é¢˜ï¼Œå¤šé‡èƒŒåŒ…é—®é¢˜ï¼ŒäºŒç»´è´¹ç”¨èƒŒåŒ…é—®é¢˜ã€‚æœ¬èŠ‚æ€»ç»“äº†è¿™å‡ ç§èƒŒåŒ…é—®é¢˜ï¼Œå¹¶ç»™å‡ºäº†å…¶å…¸åž‹çš„åº”ç”¨ä»¥å¸®åŠ©è¯»è€…ç†è§£è¿™å‡ ç§é—®é¢˜çš„æœ¬è´¨ã€‚ 2.1 01èƒŒåŒ…é—®é¢˜ ï¼ˆ1ï¼‰é—®é¢˜æè¿° æœ‰Nä»¶ç‰©å“å’Œä¸€ä¸ªå®¹é‡ä¸ºVçš„èƒŒåŒ…ã€‚ç¬¬iä»¶ç‰©å“çš„è´¹ç”¨æ˜¯c[i]ï¼Œä»·å€¼æ˜¯w[i]ã€‚æ±‚è§£å°†å“ªäº›ç‰©å“è£…å…¥èƒŒåŒ…å¯ä½¿ä»·å€¼æ€»å’Œæœ€å¤§ã€‚ ï¼ˆ2ï¼‰çŠ¶æ€è½¬ç§»æ–¹ç¨‹ å…¶ä¸­ï¼Œf(i,v) è¡¨ç¤ºä»Žå‰iä»¶ç‰©å“é€‰æ‹©è‹¥å¹²ç‰©å“è£…åˆ°å®¹é‡ä¸ºvçš„èƒŒåŒ…ä¸­äº§ç”Ÿçš„æœ€å¤§ä»·å€¼ã€‚å½“v=0æ—¶ï¼Œf(i,v)åˆå§‹åŒ–ä¸º0ï¼Œè¡¨ç¤ºé¢˜ç›®ä¸è¦æ±‚èƒŒåŒ…ä¸€å®šåˆšå¥½è£…æ»¡ï¼Œè€Œf(i,v)=inf/-infï¼ˆæ­£æ— ç©·æˆ–è´Ÿæ— ç©·ï¼‰è¡¨ç¤ºé¢˜ç›®è¦æ±‚èƒŒåŒ…ä¸€å®šè¦åˆšå¥½è£…æ»¡ã€‚ä¸‹é¢å‡ ç§èƒŒåŒ…ç±»ä¼¼ï¼Œä»¥åŽä¸å†èµ˜è¿°ã€‚ ï¼ˆ3ï¼‰ ä¼ªä»£ç  ä»Žè½¬ç§»æ–¹ç¨‹ä¸Šå¯ä»¥çœ‹å‡ºï¼Œå‰iä¸ªç‰©å“çš„æœ€ä¼˜è§£åªä¾èµ–äºŽå‰i-1ä¸ªç‰©å“æœ€ä¼˜è§£ï¼Œè€Œä¸Žå‰i-2ï¼Œi-3,â€¦å„ç‰©å“æœ€ä¼˜æ— ç›´æŽ¥å…³ç³»ï¼Œå¯ä»¥åˆ©ç”¨è¿™ä¸ªç‰¹ç‚¹ä¼˜åŒ–å­˜å‚¨ç©ºé—´ï¼Œå³åªç”³è¯·ä¸€ä¸ªä¸€ç»´æ•°ç»„å³å¯ï¼Œç®—æ³•æ—¶é—´å¤æ‚åº¦ï¼ˆO(VN)ï¼‰ä¸º: 123for i=1..N for v=V..0 f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; æ³¨æ„vçš„éåŽ†é¡ºåºï¼ï¼ï¼ ä¸‹é¢å‡ ç§èƒŒåŒ…ç”¨åˆ°ç±»ä¼¼ä¼˜åŒ–ï¼Œä»¥åŽä¸å†èµ˜è¿°ã€‚ ï¼ˆ4ï¼‰ ä¸¾ä¾‹ V=10ï¼ŒN=3ï¼Œc[]={3,4,5}, w={4,5,6} ï¼ˆ1ï¼‰èƒŒåŒ…ä¸ä¸€å®šè£…æ»¡ è®¡ç®—é¡ºåºæ˜¯ï¼šä»Žå³å¾€å·¦ï¼Œè‡ªä¸Šè€Œä¸‹ï¼š ï¼ˆ2ï¼‰èƒŒåŒ…åˆšå¥½è£…æ»¡ è®¡ç®—é¡ºåºæ˜¯ï¼šä»Žå³å¾€å·¦ï¼Œè‡ªä¸Šè€Œä¸‹ã€‚æ³¨æ„åˆå§‹å€¼ï¼Œå…¶ä¸­-infè¡¨ç¤ºè´Ÿæ— ç©· ï¼ˆ5ï¼‰ ç»å…¸é¢˜åž‹ [1] ä½ æœ‰ä¸€å †çŸ³å¤´è´¨é‡åˆ†åˆ«ä¸ºW1,W2,W3â€¦WN.(Wï¼œï¼100000,N &lt;30)çŽ°åœ¨éœ€è¦ä½ å°†çŸ³å¤´åˆå¹¶ä¸ºä¸¤å †ï¼Œä½¿ä¸¤å †è´¨é‡çš„å·®ä¸ºæœ€å°ã€‚ [2] ç»™ä¸€ä¸ªæ•´æ•°çš„é›†åˆï¼Œè¦æŠŠå®ƒåˆ†æˆä¸¤ä¸ªé›†åˆï¼Œè¦ä¸¤ä¸ªé›†åˆçš„æ•°çš„å’Œæœ€æŽ¥è¿‘ [3] æœ‰ä¸€ä¸ªç®±å­å®¹é‡ä¸ºVï¼ˆæ­£æ•´æ•°ï¼Œ0â‰¤Vâ‰¤20000ï¼‰ï¼ŒåŒæ—¶æœ‰nä¸ªç‰©å“ï¼ˆ0å°äºŽnâ‰¤30ï¼‰ï¼Œæ¯ä¸ªç‰©å“æœ‰ä¸€ä¸ªä½“ç§¯ï¼ˆæ­£æ•´æ•°ï¼‰ã€‚è¦æ±‚ä»Žnä¸ªç‰©å“ä¸­ï¼Œä»»å–è‹¥å¹²ä¸ªè£…å…¥ç®±å†…ï¼Œä½¿ç®±å­çš„å‰©ä½™ç©ºé—´ä¸ºæœ€å°ã€‚ 2.2 å®Œå…¨èƒŒåŒ…é—®é¢˜ ï¼ˆ1ï¼‰é—®é¢˜æè¿° æœ‰Nç§ç‰©å“å’Œä¸€ä¸ªå®¹é‡ä¸ºVçš„èƒŒåŒ…ï¼Œæ¯ç§ç‰©å“éƒ½æœ‰æ— é™ä»¶å¯ç”¨ã€‚ç¬¬iç§ç‰©å“çš„è´¹ç”¨æ˜¯c[i]ï¼Œä»·å€¼æ˜¯w[i]ã€‚æ±‚è§£å°†å“ªäº›ç‰©å“è£…å…¥èƒŒåŒ…å¯ä½¿è¿™äº›ç‰©å“çš„è´¹ç”¨æ€»å’Œä¸è¶…è¿‡èƒŒåŒ…å®¹é‡ï¼Œä¸”ä»·å€¼æ€»å’Œæœ€å¤§ã€‚ ï¼ˆ2ï¼‰çŠ¶æ€è½¬ç§»æ–¹ç¨‹ æˆ–è€…ï¼š ï¼ˆ3ï¼‰ ä¼ªä»£ç  123for i=1..N for v=0..V f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; æ³¨æ„vçš„éåŽ†é¡ºåºï¼ï¼ï¼ æ³¨æ„ï¼Œæ—¶é—´å¤æ‚åº¦ä»ä¸ºï¼šO(VN). ï¼ˆ4ï¼‰ ä¸¾ä¾‹ V=10ï¼ŒN=3ï¼Œc[]={3,4,5}, w={4,5,6} ï¼ˆ1ï¼‰èƒŒåŒ…ä¸ä¸€å®šè£…æ»¡ è®¡ç®—é¡ºåºæ˜¯ï¼šä»Žå·¦å¾€å³ï¼Œè‡ªä¸Šè€Œä¸‹ï¼š ï¼ˆ2ï¼‰èƒŒåŒ…åˆšå¥½è£…æ»¡ è®¡ç®—é¡ºåºæ˜¯ï¼šä»Žå·¦å¾€å³ï¼Œè‡ªä¸Šè€Œä¸‹ã€‚æ³¨æ„åˆå§‹å€¼ï¼Œå…¶ä¸­-infè¡¨ç¤ºè´Ÿæ— ç©· ï¼ˆ5ï¼‰ ç»å…¸é¢˜åž‹ [1] æ‰¾é›¶é’±é—®é¢˜ï¼šæœ‰nç§é¢é¢çš„ç¡¬å¸ï¼Œæ¯ç§ç¡¬å¸æ— é™å¤šï¼Œè‡³å°‘ç”¨å¤šå°‘æžšç¡¬å¸è¡¨ç¤ºç»™å®šçš„é¢å€¼Mï¼Ÿ 2.3 å¤šé‡èƒŒåŒ…é—®é¢˜ ï¼ˆ1ï¼‰é—®é¢˜æè¿° æœ‰Nç§ç‰©å“å’Œä¸€ä¸ªå®¹é‡ä¸ºVçš„èƒŒåŒ…ã€‚ç¬¬iç§ç‰©å“æœ€å¤šæœ‰n[i]ä»¶å¯ç”¨ï¼Œæ¯ä»¶è´¹ç”¨æ˜¯c[i]ï¼Œä»·å€¼æ˜¯w[i]ã€‚æ±‚è§£å°†å“ªäº›ç‰©å“è£…å…¥èƒŒåŒ…å¯ä½¿è¿™äº›ç‰©å“çš„è´¹ç”¨æ€»å’Œä¸è¶…è¿‡èƒŒåŒ…å®¹é‡ï¼Œä¸”ä»·å€¼æ€»å’Œæœ€å¤§ã€‚ ï¼ˆ2ï¼‰çŠ¶æ€è½¬ç§»æ–¹ç¨‹ ï¼ˆ3ï¼‰ è§£é¢˜æ€æƒ³ ç”¨ä»¥ä¸‹æ–¹æ³•è½¬åŒ–ä¸ºæ™®é€š01èƒŒåŒ…é—®é¢˜ï¼šå°†ç¬¬iç§ç‰©å“åˆ†æˆè‹¥å¹²ä»¶ç‰©å“ï¼Œå…¶ä¸­æ¯ä»¶ç‰©å“æœ‰ä¸€ä¸ªç³»æ•°ï¼Œè¿™ä»¶ç‰©å“çš„è´¹ç”¨å’Œä»·å€¼å‡æ˜¯åŽŸæ¥çš„è´¹ç”¨å’Œä»·å€¼ä¹˜ä»¥è¿™ä¸ªç³»æ•°ã€‚ä½¿è¿™äº›ç³»æ•°åˆ†åˆ«ä¸º 1,2,4,â€¦,2(k-1),n[i]-2k+1ï¼Œä¸”kæ˜¯æ»¡è¶³n[i]-2^k+1&gt;0çš„æœ€å¤§æ•´æ•°ã€‚ä¾‹å¦‚ï¼Œå¦‚æžœn[i]ä¸º13ï¼Œå°±å°†è¿™ç§ ç‰©å“åˆ†æˆç³»æ•°åˆ†åˆ«ä¸º1,2,4,6çš„å››ä»¶ç‰©å“ã€‚è¿™ç§æ–¹æ³•èƒ½ä¿è¯å¯¹äºŽ0..n[i]é—´çš„æ¯ä¸€ä¸ªæ•´æ•°ï¼Œå‡å¯ä»¥ç”¨è‹¥å¹²ä¸ªç³»æ•°çš„å’Œè¡¨ç¤ºã€‚è¿™ä¸ªå¾ˆå®¹æ˜“è¯æ˜Žï¼Œè¯æ˜Žè¿‡ç¨‹ä¸­ç”¨åˆ°ä»¥ä¸‹å®šç†ï¼šä»»ä½•ä¸€ä¸ªæ•´æ•°nå‡å¯ä»¥è¡¨ç¤ºæˆï¼šn=a020+a121+â€¦+ak2k,å…¶ä¸­ak=0æˆ–è€…1(å®žé™…ä¸Šå°±æ˜¯nçš„äºŒè¿›åˆ¶åˆ†è§£)ï¼Œ å®šç†ï¼šä¸€ä¸ªæ­£æ•´æ•°nå¯ä»¥è¢«åˆ†è§£æˆ1,2,4,â€¦,2(k-1),n-2k+1ï¼ˆkæ˜¯æ»¡è¶³n-2k+1&gt;0çš„æœ€å¤§æ•´æ•°ï¼‰çš„å½¢å¼ï¼Œä¸”1ï½žnä¹‹å†…çš„æ‰€æœ‰æ•´æ•°å‡å¯ä»¥å”¯ä¸€è¡¨ç¤ºæˆ1,2,4,â€¦,2(k-1),n-2k+1ä¸­æŸå‡ ä¸ªæ•°çš„å’Œçš„å½¢å¼ã€‚ è¯¥å®šç†çš„è¯æ˜Žå¦‚ä¸‹ï¼š ï¼ˆ1ï¼‰ æ•°åˆ—1,2,4,â€¦,2(k-1),n-2k+1ä¸­æ‰€æœ‰å…ƒç´ çš„å’Œä¸ºnï¼Œæ‰€ä»¥è‹¥å¹²å…ƒç´ çš„å’Œçš„èŒƒå›´ä¸ºï¼š[1, n]ï¼› ï¼ˆ2ï¼‰å¦‚æžœæ­£æ•´æ•°t&lt;= 2^k â€“ 1,åˆ™tä¸€å®šèƒ½ç”¨1,2,4,â€¦,2^(k-1)ä¸­æŸå‡ ä¸ªæ•°çš„å’Œè¡¨ç¤ºï¼Œè¿™ä¸ªå¾ˆå®¹æ˜“è¯æ˜Žï¼šæˆ‘ä»¬æŠŠtçš„äºŒè¿›åˆ¶è¡¨ç¤ºå†™å‡ºæ¥ï¼Œå¾ˆæ˜Žæ˜¾ï¼Œtå¯ä»¥è¡¨ç¤ºæˆn=a020+a121+â€¦+ak2ï¼ˆk-1ï¼‰ï¼Œå…¶ä¸­ak=0æˆ–è€…1ï¼Œè¡¨ç¤ºtçš„ç¬¬akä½äºŒè¿›åˆ¶æ•°ä¸º0æˆ–è€…1. ï¼ˆ3ï¼‰å¦‚æžœt&gt;=2k,è®¾s=n-2k+1ï¼Œåˆ™t-s&lt;=2k-1ï¼Œå› è€Œt-så¯ä»¥è¡¨ç¤ºæˆ1,2,4,â€¦,2(k-1)ä¸­æŸå‡ ä¸ªæ•°çš„å’Œçš„å½¢å¼ï¼Œè¿›è€Œtå¯ä»¥è¡¨ç¤ºæˆ1,2,4,â€¦,2(k-1)ï¼Œsä¸­æŸå‡ ä¸ªæ•°çš„å’Œï¼ˆåŠ æ•°ä¸­ä¸€å®šå«æœ‰sï¼‰çš„å½¢å¼ã€‚ ï¼ˆè¯æ¯•ï¼ï¼‰ è¯¥ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸ºï¼šO(V*sum(logn[i])). ï¼ˆ4ï¼‰ ç»å…¸é¢˜åž‹ [1] æ‰¾é›¶é’±é—®é¢˜ï¼šæœ‰nç§é¢é¢çš„ç¡¬å¸ï¼Œåˆ†åˆ«ä¸ºa[0], a[1],â€¦, a[n-1]ï¼Œæ¯ç§ç¡¬å¸çš„ä¸ªæ•°ä¸ºb[0], b[1],â€¦, b[n-1]ï¼Œè‡³å°‘ç”¨å¤šå°‘æžšç¡¬å¸è¡¨ç¤ºç»™å®šçš„é¢å€¼Mï¼Ÿ 2.4 äºŒç»´è´¹ç”¨èƒŒåŒ… ï¼ˆ1ï¼‰ é—®é¢˜æè¿° äºŒç»´è´¹ç”¨çš„èƒŒåŒ…é—®é¢˜æ˜¯æŒ‡ï¼šå¯¹äºŽæ¯ä»¶ç‰©å“ï¼Œå…·æœ‰ä¸¤ç§ä¸åŒçš„è´¹ç”¨ï¼›é€‰æ‹©è¿™ä»¶ç‰©å“å¿…é¡»åŒæ—¶ä»˜å‡ºè¿™ä¸¤ç§ä»£ä»·ï¼›å¯¹äºŽæ¯ç§ä»£ä»·éƒ½æœ‰ä¸€ä¸ªå¯ä»˜å‡ºçš„æœ€å¤§å€¼ï¼ˆèƒŒåŒ…å®¹é‡ï¼‰ã€‚é—® æ€Žæ ·é€‰æ‹©ç‰©å“å¯ä»¥å¾—åˆ°æœ€å¤§çš„ä»·å€¼ã€‚è®¾è¿™ä¸¤ç§ä»£ä»·åˆ†åˆ«ä¸ºä»£ä»·1å’Œä»£ä»·2ï¼Œç¬¬iä»¶ç‰©å“æ‰€éœ€çš„ä¸¤ç§ä»£ä»·åˆ†åˆ«ä¸ºa[i]å’Œb[i]ã€‚ä¸¤ç§ä»£ä»·å¯ä»˜å‡ºçš„æœ€å¤§å€¼ï¼ˆä¸¤ç§ èƒŒåŒ…å®¹é‡ï¼‰åˆ†åˆ«ä¸ºVå’ŒUã€‚ç‰©å“çš„ä»·å€¼ä¸ºw[i]ã€‚ ï¼ˆ2ï¼‰ çŠ¶æ€è½¬ç§»æ–¹ç¨‹ ï¼ˆ3ï¼‰ ç®—æ³•æ€æƒ³ é‡‡ç”¨åŒä¸€ç»´æƒ…å†µç±»ä¼¼çš„æ–¹æ³•æ±‚è§£ ï¼ˆ4ï¼‰ ç»å…¸é¢˜åž‹ æœ‰2nä¸ªæ•´æ•°ï¼Œå¹³å‡åˆ†æˆä¸¤ç»„ï¼Œæ¯ç»„nä¸ªæ•°ï¼Œä½¿è¿™ä¸¤ç»„æ•°çš„å’Œæœ€æŽ¥è¿‘ã€‚ 3. èƒŒåŒ…æ€»ç»“ èƒŒåŒ…é—®é¢˜å®žé™…ä¸Šä»£è¡¨çš„æ˜¯çº¿æ€§è§„åˆ’é—®é¢˜ï¼Œä¸€èˆ¬è¦è€ƒè™‘ä»¥ä¸‹å‡ ä¸ªå› ç´ å·²å†³å®šé€‰å–ä»€ä¹ˆæ ·çš„ç®—æ³•ï¼š ï¼ˆ1ï¼‰ çº¦æŸæ¡ä»¶ï¼Œæœ‰ä¸€ä¸ªè¿˜æ˜¯ä¸¤ä¸ªæˆ–è€…æ›´å¤šä¸ªï¼Œå¦‚æžœæ˜¯ä¸€ä¸ªï¼Œå¯èƒ½æ˜¯01èƒŒåŒ…ï¼Œå®Œå…¨èƒŒåŒ…æˆ–è€…å¤šé‡èƒŒåŒ…é—®é¢˜ï¼Œå¦‚æžœæœ‰ä¸¤ä¸ªçº¦æŸæ¡ä»¶ï¼Œåˆ™å¯èƒ½æ˜¯äºŒç»´èƒŒåŒ…é—®é¢˜ã€‚ ï¼ˆ2ï¼‰ ä¼˜åŒ–ç›®æ ‡ï¼Œæ±‚æœ€å¤§å€¼ï¼Œè¿˜æ˜¯æœ€å°å€¼ï¼Œè¿˜æ˜¯æ€»æ•°(åªéœ€å°†maxæ¢æˆsum) ï¼ˆ3ï¼‰ æ¯ç§ç‰©å“çš„ä¸ªæ•°é™åˆ¶ï¼Œå¦‚æžœæ¯ç§ç‰©å“åªæœ‰ä¸€ä¸ªï¼Œåªæ˜¯ç®€å•çš„01èƒŒåŒ…é—®é¢˜ï¼Œå¦‚æžœä¸ªæ•°æ— é™åˆ¶ï¼Œåˆ™æ˜¯å®Œå…¨èƒŒåŒ…é—®é¢˜ï¼Œå¦‚æžœæ¯ç§ç‰©å“çš„ä¸ªæ•°æœ‰é™åˆ¶ï¼Œåˆ™æ˜¯å¤šé‡èƒŒåŒ…é—®é¢˜ã€‚ ï¼ˆ4ï¼‰ èƒŒåŒ…æ˜¯å¦è¦æ±‚åˆšå¥½å¡žæ»¡ï¼Œæ³¨æ„ä¸å¡žæ»¡å’Œå¡žæ»¡ä¸¤ç§æƒ…å†µä¸‹åˆå§‹å€¼ä¸åŒã€‚ 4. å‚è€ƒèµ„æ–™ dd_engiï¼šã€ŠèƒŒåŒ…é—®é¢˜ä¹è®²ã€‹]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>èƒŒåŒ…</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åšå¼ˆåŸºç¡€æ±‡æ€»]]></title>
    <url>%2F2017%2F05%2F28%2F%E5%8D%9A%E5%BC%88%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[æœ‰ä¸€ç§å¾ˆæœ‰æ„æ€çš„æ¸¸æˆï¼Œå°±æ˜¯æœ‰ç‰©ä½“è‹¥å¹²å †ï¼Œå¯ä»¥æ˜¯ç«æŸ´æ£æˆ–æ˜¯å›´æ£‹å­ç­‰ç­‰å‡å¯ã€‚ä¸¤ä¸ªäººè½®æµä»Žå †ä¸­å–ç‰©ä½“è‹¥å¹²ï¼Œè§„å®šæœ€åŽå–å…‰ç‰©ä½“è€…å–èƒœã€‚è¿™æ˜¯æˆ‘å›½æ°‘é—´å¾ˆå¤è€çš„ä¸€ä¸ªæ¸¸æˆï¼Œåˆ«çœ‹è¿™æ¸¸æˆæžå…¶ç®€å•ï¼Œå´è•´å«ç€æ·±åˆ»çš„æ•°å­¦åŽŸç†ã€‚ä¸‹é¢æˆ‘ä»¬æ¥åˆ†æžä¸€ä¸‹è¦å¦‚ä½•æ‰èƒ½å¤Ÿå–èƒœã€‚ ï¼ˆä¸€ï¼‰å·´ä»€åšå¥•ï¼ˆBash Gameï¼‰ï¼š åªæœ‰ä¸€å †nä¸ªç‰©å“ï¼Œä¸¤ä¸ªäººè½®æµä»Žè¿™å †ç‰©å“ä¸­å–ç‰©ï¼Œè§„å®šæ¯æ¬¡è‡³å°‘å–ä¸€ä¸ªï¼Œæœ€å¤šå–mä¸ªã€‚æœ€åŽå–å…‰è€…å¾—èƒœã€‚ æ˜¾ç„¶ï¼Œå¦‚æžœn=m+1ï¼Œé‚£ä¹ˆç”±äºŽä¸€æ¬¡æœ€å¤šåªèƒ½å–mä¸ªï¼Œæ‰€ä»¥ï¼Œæ— è®ºå…ˆå–è€…æ‹¿èµ°å¤šå°‘ä¸ªï¼ŒåŽå–è€…éƒ½èƒ½å¤Ÿä¸€æ¬¡æ‹¿èµ°å‰©ä½™çš„ç‰©å“ï¼ŒåŽè€…å–èƒœã€‚å› æ­¤æˆ‘ä»¬å‘çŽ°äº†å¦‚ä½•å–èƒœçš„æ³•åˆ™ï¼šå¦‚æžœn=ï¼ˆm+1ï¼‰r+sï¼Œï¼ˆrä¸ºä»»æ„è‡ªç„¶æ•°ï¼Œsâ‰¤m),é‚£ä¹ˆå…ˆå–è€…è¦æ‹¿èµ°sä¸ªç‰©å“ï¼Œå¦‚æžœåŽå–è€…æ‹¿èµ°kï¼ˆâ‰¤m)ä¸ªï¼Œé‚£ä¹ˆå…ˆå–è€…å†æ‹¿èµ°m+1-kä¸ªï¼Œç»“æžœå‰©ä¸‹ï¼ˆm+1ï¼‰ï¼ˆr-1ï¼‰ä¸ªï¼Œä»¥åŽä¿æŒè¿™æ ·çš„å–æ³•ï¼Œé‚£ä¹ˆå…ˆå–è€…è‚¯å®šèŽ·èƒœã€‚æ€»ä¹‹ï¼Œè¦ä¿æŒç»™å¯¹æ‰‹ç•™ä¸‹ï¼ˆm+1ï¼‰çš„å€æ•°ï¼Œå°±èƒ½æœ€åŽèŽ·èƒœã€‚è¿™ä¸ªæ¸¸æˆè¿˜å¯ä»¥æœ‰ä¸€ç§å˜ç›¸çš„çŽ©æ³•ï¼šä¸¤ä¸ªäººè½®æµæŠ¥æ•°ï¼Œæ¯æ¬¡è‡³å°‘æŠ¥ä¸€ä¸ªï¼Œæœ€å¤šæŠ¥åä¸ªï¼Œè°èƒ½æŠ¥åˆ°100è€…èƒœã€‚ ï¼ˆäºŒï¼‰å¨ä½å¤«åšå¥•ï¼ˆWythoff Gameï¼‰ï¼š æœ‰ä¸¤å †å„è‹¥å¹²ä¸ªç‰©å“ï¼Œä¸¤ä¸ªäººè½®æµä»ŽæŸä¸€å †æˆ–åŒæ—¶ä»Žä¸¤å †ä¸­å–åŒæ ·å¤šçš„ç‰©å“ï¼Œè§„å®šæ¯æ¬¡è‡³å°‘å–ä¸€ä¸ªï¼Œå¤šè€…ä¸é™ï¼Œæœ€åŽå–å…‰è€…å¾—èƒœã€‚ è¿™ç§æƒ…å†µä¸‹æ˜¯é¢‡ä¸ºå¤æ‚çš„ã€‚æˆ‘ä»¬ç”¨ï¼ˆakï¼Œbkï¼‰ï¼ˆak â‰¤ bk ,k=0ï¼Œ1ï¼Œ2ï¼Œâ€¦,n)è¡¨ç¤ºä¸¤å †ç‰©å“çš„æ•°é‡å¹¶ç§°å…¶ä¸ºå±€åŠ¿ï¼Œå¦‚æžœç”²é¢å¯¹ï¼ˆ0ï¼Œ0ï¼‰ï¼Œé‚£ä¹ˆç”²å·²ç»è¾“äº†ï¼Œè¿™ç§å±€åŠ¿æˆ‘ä»¬ç§°ä¸ºå¥‡å¼‚å±€åŠ¿ã€‚å‰å‡ ä¸ªå¥‡å¼‚å±€åŠ¿æ˜¯ï¼šï¼ˆ0ï¼Œ0ï¼‰ã€ï¼ˆ1ï¼Œ2ï¼‰ã€ï¼ˆ3ï¼Œ5ï¼‰ã€ï¼ˆ4ï¼Œ7ï¼‰ã€ï¼ˆ6ï¼Œ10ï¼‰ã€ï¼ˆ8ï¼Œ13ï¼‰ã€ï¼ˆ9ï¼Œ15ï¼‰ã€ï¼ˆ11ï¼Œ18ï¼‰ã€ï¼ˆ12ï¼Œ20ï¼‰ã€‚ å¯ä»¥çœ‹å‡º,a0=b0=0,akæ˜¯æœªåœ¨å‰é¢å‡ºçŽ°è¿‡çš„æœ€å°è‡ªç„¶æ•°,è€Œ bk= ak + kï¼Œå¥‡å¼‚å±€åŠ¿æœ‰å¦‚ä¸‹ä¸‰æ¡æ€§è´¨ï¼š 1ã€‚ä»»ä½•è‡ªç„¶æ•°éƒ½åŒ…å«åœ¨ä¸€ä¸ªä¸”ä»…æœ‰ä¸€ä¸ªå¥‡å¼‚å±€åŠ¿ä¸­ã€‚ ç”±äºŽakæ˜¯æœªåœ¨å‰é¢å‡ºçŽ°è¿‡çš„æœ€å°è‡ªç„¶æ•°ï¼Œæ‰€ä»¥æœ‰ak &gt; ak-1 ï¼Œè€Œ bk= ak + k &gt; ak -1 + k-1 = bk-1 &gt; ak-1 ã€‚æ‰€ä»¥æ€§è´¨1ã€‚æˆç«‹ã€‚ &gt; 2ã€‚ä»»æ„æ“ä½œéƒ½å¯å°†å¥‡å¼‚å±€åŠ¿å˜ä¸ºéžå¥‡å¼‚å±€åŠ¿ã€‚ &gt; äº‹å®žä¸Šï¼Œè‹¥åªæ”¹å˜å¥‡å¼‚å±€åŠ¿ï¼ˆakï¼Œbkï¼‰çš„æŸä¸€ä¸ªåˆ†é‡ï¼Œé‚£ä¹ˆå¦ä¸€ä¸ªåˆ†é‡ä¸å¯èƒ½åœ¨å…¶ä»–å¥‡å¼‚å±€åŠ¿ä¸­ï¼Œæ‰€ä»¥å¿…ç„¶æ˜¯éžå¥‡å¼‚å±€åŠ¿ã€‚å¦‚æžœä½¿ï¼ˆakï¼Œbkï¼‰çš„ä¸¤ä¸ªåˆ†é‡åŒæ—¶å‡å°‘ï¼Œåˆ™ç”±äºŽå…¶å·®ä¸å˜ï¼Œä¸”ä¸å¯èƒ½æ˜¯å…¶ä»–å¥‡å¼‚å±€åŠ¿çš„å·®ï¼Œå› æ­¤ä¹Ÿæ˜¯éžå¥‡å¼‚å±€åŠ¿ã€‚ &gt; 3ã€‚é‡‡ç”¨é€‚å½“çš„æ–¹æ³•ï¼Œå¯ä»¥å°†éžå¥‡å¼‚å±€åŠ¿å˜ä¸ºå¥‡å¼‚å±€åŠ¿ã€‚ &gt; å‡è®¾é¢å¯¹çš„å±€åŠ¿æ˜¯ï¼ˆa,bï¼‰ï¼Œè‹¥ b = aï¼Œåˆ™åŒæ—¶ä»Žä¸¤å †ä¸­å–èµ° a ä¸ªç‰©ä½“ï¼Œå°±å˜ä¸ºäº†å¥‡å¼‚å±€åŠ¿ï¼ˆ0ï¼Œ0ï¼‰ï¼›å¦‚æžœa = ak ï¼Œb &gt; bkï¼Œé‚£ä¹ˆï¼Œå–èµ°b â€“ bkä¸ªç‰©ä½“ï¼Œå³å˜ä¸ºå¥‡å¼‚å±€åŠ¿ï¼›å¦‚æžœ a = ak ï¼Œ b &lt; bk ,åˆ™åŒæ—¶ä»Žä¸¤å †ä¸­æ‹¿èµ° ak â€“ ab + akä¸ªç‰©ä½“,å˜ä¸ºå¥‡å¼‚å±€åŠ¿ï¼ˆ ab â€“ ak , ab â€“ ak+ b â€“ akï¼‰ï¼›å¦‚æžœa &gt; ak ï¼Œb= ak + k,åˆ™ä»Žç¬¬ä¸€å †ä¸­æ‹¿èµ°å¤šä½™çš„æ•°é‡a â€“ ak å³å¯ï¼›å¦‚æžœa &lt; ak ï¼Œb= ak + k,åˆ†ä¸¤ç§æƒ…å†µï¼Œç¬¬ä¸€ç§ï¼Œa=aj ï¼ˆj &lt; kï¼‰,ä»Žç¬¬äºŒå †é‡Œé¢æ‹¿èµ° b â€“ bj å³å¯ï¼›ç¬¬äºŒç§ï¼Œa=bj ï¼ˆj &lt; kï¼‰,ä»Žç¬¬äºŒå †é‡Œé¢æ‹¿èµ° b â€“ aj å³å¯ã€‚ &gt; ä»Žå¦‚ä¸Šæ€§è´¨å¯çŸ¥ï¼Œä¸¤ä¸ªäººå¦‚æžœéƒ½é‡‡ç”¨æ­£ç¡®æ“ä½œï¼Œé‚£ä¹ˆé¢å¯¹éžå¥‡å¼‚å±€åŠ¿ï¼Œå…ˆæ‹¿è€…å¿…èƒœï¼›åä¹‹ï¼Œåˆ™åŽæ‹¿è€…å–èƒœã€‚ &gt; é‚£ä¹ˆä»»ç»™ä¸€ä¸ªå±€åŠ¿ï¼ˆaï¼Œbï¼‰ï¼Œæ€Žæ ·åˆ¤æ–­å®ƒæ˜¯ä¸æ˜¯å¥‡å¼‚å±€åŠ¿å‘¢ï¼Ÿæˆ‘ä»¬æœ‰å¦‚ä¸‹å…¬å¼ï¼š &gt; ak =[kï¼ˆ1+âˆš5ï¼‰/2]ï¼Œbk= ak + k ï¼ˆk=0ï¼Œ1ï¼Œ2ï¼Œâ€¦,n æ–¹æ‹¬å·è¡¨ç¤ºå–æ•´å‡½æ•°) å¥‡å¦™çš„æ˜¯å…¶ä¸­å‡ºçŽ°äº†é»„é‡‘åˆ†å‰²æ•°ï¼ˆ1+âˆš5ï¼‰/2 = 1ã€‚618â€¦,å› æ­¤,ç”±akï¼Œbkç»„æˆçš„çŸ©å½¢è¿‘ä¼¼ä¸ºé»„é‡‘çŸ©å½¢ï¼Œç”±äºŽ2/ï¼ˆ1+âˆš5ï¼‰=ï¼ˆâˆš5-1ï¼‰/2ï¼Œå¯ä»¥å…ˆæ±‚å‡ºj=[aï¼ˆâˆš5-1ï¼‰/2]ï¼Œè‹¥a=[jï¼ˆ1+âˆš5ï¼‰/2]ï¼Œé‚£ä¹ˆa = ajï¼Œbj = aj + jï¼Œè‹¥ä¸ç­‰äºŽï¼Œé‚£ä¹ˆa = aj+1ï¼Œbj+1 = aj+1+ j + 1ï¼Œè‹¥éƒ½ä¸æ˜¯ï¼Œé‚£ä¹ˆå°±ä¸æ˜¯å¥‡å¼‚å±€åŠ¿ã€‚ç„¶åŽå†æŒ‰ç…§ä¸Šè¿°æ³•åˆ™è¿›è¡Œï¼Œä¸€å®šä¼šé‡åˆ°å¥‡å¼‚å±€åŠ¿ã€‚ ï¼ˆä¸‰ï¼‰å°¼å§†åšå¥•ï¼ˆNimm Gameï¼‰ï¼š æœ‰ä¸‰å †å„è‹¥å¹²ä¸ªç‰©å“ï¼Œä¸¤ä¸ªäººè½®æµä»ŽæŸä¸€å †å–ä»»æ„å¤šçš„ç‰©å“ï¼Œè§„å®šæ¯æ¬¡è‡³å°‘å–ä¸€ä¸ªï¼Œå¤šè€…ä¸é™ï¼Œæœ€åŽå–å…‰è€…å¾—èƒœã€‚ è¿™ç§æƒ…å†µæœ€æœ‰æ„æ€ï¼Œå®ƒä¸ŽäºŒè¿›åˆ¶æœ‰å¯†åˆ‡å…³ç³»ï¼Œæˆ‘ä»¬ç”¨ï¼ˆaï¼Œbï¼Œcï¼‰è¡¨ç¤ºæŸç§å±€åŠ¿ï¼Œé¦–å…ˆï¼ˆ0ï¼Œ0ï¼Œ0ï¼‰æ˜¾ç„¶æ˜¯å¥‡å¼‚å±€åŠ¿ï¼Œæ— è®ºè°é¢å¯¹å¥‡å¼‚å±€åŠ¿ï¼Œéƒ½å¿…ç„¶å¤±è´¥ã€‚ç¬¬äºŒç§å¥‡å¼‚å±€åŠ¿æ˜¯ï¼ˆ0ï¼Œnï¼Œnï¼‰ï¼Œåªè¦ä¸Žå¯¹æ‰‹æ‹¿èµ°ä¸€æ ·å¤šçš„ç‰©å“ï¼Œæœ€åŽéƒ½å°†å¯¼è‡´ï¼ˆ0ï¼Œ0ï¼Œ0ï¼‰ã€‚ä»”ç»†åˆ†æžä¸€ä¸‹ï¼Œï¼ˆ1ï¼Œ2ï¼Œ3ï¼‰ä¹Ÿæ˜¯å¥‡å¼‚å±€åŠ¿ï¼Œæ— è®ºå¯¹æ‰‹å¦‚ä½•æ‹¿ï¼ŒæŽ¥ä¸‹æ¥éƒ½å¯ä»¥å˜ä¸ºï¼ˆ0ï¼Œnï¼Œnï¼‰çš„æƒ…å½¢ã€‚ è®¡ç®—æœºç®—æ³•é‡Œé¢æœ‰ä¸€ç§å«åšæŒ‰ä½æ¨¡2åŠ ï¼Œä¹Ÿå«åšå¼‚æˆ–çš„è¿ç®—ï¼Œæˆ‘ä»¬ç”¨ç¬¦å·ï¼ˆ+ï¼‰è¡¨ç¤ºè¿™ç§è¿ç®—ã€‚è¿™ç§è¿ç®—å’Œä¸€èˆ¬åŠ æ³•ä¸åŒçš„ä¸€ç‚¹æ˜¯1+1=0ã€‚å…ˆçœ‹ï¼ˆ1ï¼Œ2ï¼Œ3ï¼‰çš„æŒ‰ä½æ¨¡2åŠ çš„ç»“æžœï¼š 1 =äºŒè¿›åˆ¶01 2 =äºŒè¿›åˆ¶10 3 =äºŒè¿›åˆ¶11 ï¼ˆ+ï¼‰ â€”â€”â€”â€”â€”â€”â€” 0 =äºŒè¿›åˆ¶00 ï¼ˆæ³¨æ„ä¸è¿›ä½ï¼‰ å¯¹äºŽå¥‡å¼‚å±€åŠ¿ï¼ˆ0ï¼Œnï¼Œnï¼‰ä¹Ÿä¸€æ ·ï¼Œç»“æžœä¹Ÿæ˜¯0ã€‚ ä»»ä½•å¥‡å¼‚å±€åŠ¿ï¼ˆaï¼Œbï¼Œcï¼‰éƒ½æœ‰aï¼ˆ+ï¼‰bï¼ˆ+ï¼‰c =0ã€‚ å¦‚æžœæˆ‘ä»¬é¢å¯¹çš„æ˜¯ä¸€ä¸ªéžå¥‡å¼‚å±€åŠ¿ï¼ˆaï¼Œbï¼Œcï¼‰ï¼Œè¦å¦‚ä½•å˜ä¸ºå¥‡å¼‚å±€åŠ¿å‘¢ï¼Ÿå‡è®¾ a &lt; b&lt; c,æˆ‘ä»¬åªè¦å°† c å˜ä¸º aï¼ˆ+ï¼‰b,å³å¯,å› ä¸ºæœ‰å¦‚ä¸‹çš„è¿ç®—ç»“æžœ: aï¼ˆ+ï¼‰bï¼ˆ+ï¼‰(aï¼ˆ+ï¼‰b)=(aï¼ˆ+ï¼‰a)ï¼ˆ+ï¼‰(bï¼ˆ+ï¼‰b)=0ï¼ˆ+ï¼‰0=0ã€‚è¦å°†c å˜ä¸ºaï¼ˆ+ï¼‰bï¼Œåªè¦ä»Ž cä¸­å‡åŽ» c-ï¼ˆ aï¼ˆ+ï¼‰bï¼‰å³å¯ã€‚ ä¾‹1ã€‚ï¼ˆ14ï¼Œ21ï¼Œ39ï¼‰ï¼Œ14ï¼ˆ+ï¼‰21=27ï¼Œ39-27=12ï¼Œæ‰€ä»¥ä»Ž39ä¸­æ‹¿èµ°12ä¸ªç‰©ä½“å³å¯è¾¾åˆ°å¥‡å¼‚å±€åŠ¿ï¼ˆ14ï¼Œ21ï¼Œ27ï¼‰ã€‚ ä¾‹2ã€‚ï¼ˆ55ï¼Œ81ï¼Œ121ï¼‰ï¼Œ55ï¼ˆ+ï¼‰81=102ï¼Œ121-102=19ï¼Œæ‰€ä»¥ä»Ž121ä¸­æ‹¿èµ°19ä¸ªç‰©å“å°±å½¢æˆäº†å¥‡å¼‚å±€åŠ¿ï¼ˆ55ï¼Œ81ï¼Œ102ï¼‰ã€‚ ä¾‹3ã€‚ï¼ˆ29ï¼Œ45ï¼Œ58ï¼‰ï¼Œ29ï¼ˆ+ï¼‰45=48ï¼Œ58-48=10ï¼Œä»Ž58ä¸­æ‹¿èµ°10ä¸ªï¼Œå˜ä¸ºï¼ˆ29ï¼Œ45ï¼Œ48ï¼‰ã€‚ ä¾‹4ã€‚æˆ‘ä»¬æ¥å®žé™…è¿›è¡Œä¸€ç›˜æ¯”èµ›çœ‹çœ‹ï¼š ç”²:(7,8,9)-&gt;(1,8,9)å¥‡å¼‚å±€åŠ¿ ä¹™:(1,8,9)-&gt;(1,8,4) ç”²:(1,8,4)-&gt;(1,5,4)å¥‡å¼‚å±€åŠ¿ ä¹™:(1,5,4)-&gt;(1,4,4) ç”²:(1,4,4)-&gt;(0,4,4)å¥‡å¼‚å±€åŠ¿ ä¹™:(0,4,4)-&gt;(0,4,2) ç”²:(0.4,2)-&gt;(0,2,2)å¥‡å¼‚å±€åŠ¿ ä¹™:(0,2,2)-&gt;(0,2,1) ç”²:(0,2,1)-&gt;(0,1,1)å¥‡å¼‚å±€åŠ¿ ä¹™:(0,1,1)-&gt;(0,1,0) ç”²:(0,1,0)-&gt;(0,0,0)å¥‡å¼‚å±€åŠ¿ ç”²èƒœã€‚ å–ç«æŸ´çš„æ¸¸æˆ é¢˜ç›®1ï¼š ä»Šæœ‰è‹¥å¹²å †ç«æŸ´ï¼Œä¸¤äººä¾æ¬¡ä»Žä¸­æ‹¿å–ï¼Œè§„å®šæ¯æ¬¡åªèƒ½ä»Žä¸€å †ä¸­å–è‹¥å¹²æ ¹ï¼Œ å¯å°†ä¸€å †å…¨å–èµ°ï¼Œä½†ä¸å¯ä¸å–ï¼Œæœ€åŽå–å®Œè€…ä¸ºèƒœï¼Œæ±‚å¿…èƒœçš„æ–¹æ³•ã€‚ é¢˜ç›®2ï¼š ä»Šæœ‰è‹¥å¹²å †ç«æŸ´ï¼Œä¸¤äººä¾æ¬¡ä»Žä¸­æ‹¿å–ï¼Œè§„å®šæ¯æ¬¡åªèƒ½ä»Žä¸€å †ä¸­å–è‹¥å¹²æ ¹ï¼Œ å¯å°†ä¸€å †å…¨å–èµ°ï¼Œä½†ä¸å¯ä¸å–ï¼Œæœ€åŽå–å®Œè€…ä¸ºè´Ÿï¼Œæ±‚å¿…èƒœçš„æ–¹æ³•ã€‚ å˜¿å˜¿ï¼Œè¿™ä¸ªæ¸¸æˆæˆ‘æ—©å°±è§è¯†è¿‡äº†ã€‚å°æ—¶å€™ç”¨ç ç®—çŽ©è¿™ä¸ªæ¸¸æˆï¼šç¬¬ä¸€æ¡£æ‹¨ä¸€ä¸ªï¼Œç¬¬äºŒæ¡£æ‹¨ä¸¤ä¸ªï¼Œä¾æ¬¡ç›´åˆ°ç¬¬äº”æ¡£æ‹¨äº”ä¸ªã€‚ç„¶åŽä¸¤ä¸ªäººå°±è½®æµå†æŠŠæ£‹å­æ‹¨ä¸‹æ¥ï¼Œè°è¦æ˜¯æœ€åŽä¸€ä¸ªæ‹¨è°å°±èµ¢ã€‚æœ‰ä¸€æ¬¡æš‘å‡çœ‹è§ä¸¤ä¸ªå°å­©å­åœ¨çŽ©è¿™ä¸ªæ¸¸æˆï¼Œæˆ‘å°±åœ¨æƒ³æœ‰æ²¡æœ‰ä¸€ä¸ªå®šè®ºå‘¢ã€‚ä¸‹é¢å°±æ¥è¯•ç€è¯æ˜Žä¸€ä¸‹å§ å…ˆè§£å†³ç¬¬ä¸€ä¸ªé—®é¢˜å§ã€‚ å®šä¹‰ï¼šè‹¥æ‰€æœ‰ç«æŸ´æ•°å¼‚æˆ–ä¸º0ï¼Œåˆ™è¯¥çŠ¶æ€è¢«ç§°ä¸ºåˆ©ä»–æ€ï¼Œç”¨å­—æ¯Tè¡¨ç¤ºï¼›å¦åˆ™ï¼Œ ä¸ºåˆ©å·±æ€ï¼Œç”¨Sè¡¨ç¤ºã€‚ [å®šç†1]ï¼šå¯¹äºŽä»»ä½•ä¸€ä¸ªSæ€ï¼Œæ€»èƒ½ä»Žä¸€å †ç«æŸ´ä¸­å–å‡ºè‹¥å¹²ä¸ªä½¿ä¹‹æˆä¸ºTæ€ã€‚ è¯æ˜Žï¼š è‹¥æœ‰nå †ç«æŸ´ï¼Œæ¯å †ç«æŸ´æœ‰A(i)æ ¹ç«æŸ´æ•°ï¼Œé‚£ä¹ˆæ—¢ç„¶çŽ°åœ¨å¤„äºŽSæ€ï¼Œ c = A(1) xor A(2) xor â€¦ xor A(n) &gt; 0; æŠŠcè¡¨ç¤ºæˆäºŒè¿›åˆ¶ï¼Œè®°å®ƒçš„äºŒè¿›åˆ¶æ•°çš„æœ€é«˜ä½ä¸ºç¬¬pä½ï¼Œåˆ™å¿…ç„¶å­˜åœ¨ä¸€ä¸ªA(t),å®ƒäºŒè¿›åˆ¶çš„ç¬¬pä½ä¹Ÿæ˜¯1ã€‚ï¼ˆå¦åˆ™ï¼Œè‹¥æ‰€æœ‰çš„A(i)çš„ç¬¬pä½éƒ½æ˜¯0ï¼Œè¿™ä¸Žcçš„ç¬¬pä½å°±ä¹Ÿä¸º0çŸ›ç›¾ï¼‰ã€‚ é‚£ä¹ˆæˆ‘ä»¬æŠŠx = A(t) xor c,åˆ™å¾—åˆ°x &lt; A(t).è¿™æ˜¯å› ä¸ºæ—¢ç„¶A(t)çš„ç¬¬pä½ä¸Žcçš„ç¬¬pä½åŒä¸º1,é‚£ä¹ˆxçš„ç¬¬pä½å˜ä¸º0,è€Œé«˜äºŽpçš„ä½å¹¶æ²¡æœ‰æ”¹å˜ã€‚æ‰€ä»¥x &lt; A(t).è€Œ A(1) xor A(2) xor â€¦ xor x xor â€¦ xor A(n) = A(1) xor A(2) xor â€¦ xor A(t) xor c xor â€¦ xor A(n) = A(1) xor A(2) xorâ€¦ xor A(n) xor A(1) xor A(2) xor â€¦ xor A(n) = 0 è¿™å°±æ˜¯è¯´ä»ŽA(t)å †ä¸­å–å‡º A(t) â€“ x æ ¹ç«æŸ´åŽçŠ¶æ€å°±ä¼šä»ŽSæ€å˜ä¸ºTæ€ã€‚è¯æ¯• [å®šç†2]ï¼šTæ€ï¼Œå–ä»»ä½•ä¸€å †çš„è‹¥å¹²æ ¹ï¼Œéƒ½å°†æˆä¸ºSæ€ã€‚ è¯æ˜Žï¼šç”¨åè¯æ³•è¯•è¯•ã€‚ è‹¥ c = A(1) xor A(2) xor â€¦ xor A(i) xor â€¦ xor A(n) = 0ï¼› câ€™ = A(1) xor A(2) xor â€¦ xor A(iâ€™) xor c xor â€¦ xor A(n) = 0; åˆ™æœ‰ c xor câ€™ = A(1) xor A(2) xor â€¦ xor A(i) xor â€¦ xor A(n) xor A(1) xor A(2) xor â€¦ xor A(iâ€™) xor c xor â€¦ xor A(n) = A(i) xor A(iâ€™) =0 è¿›è€ŒæŽ¨å‡ºA(i) = A(iâ€™)ï¼Œè¿™ä¸Žå·²çŸ¥çŸ›ç›¾ã€‚æ‰€ä»¥å‘½é¢˜å¾—è¯ã€‚ [å®šç† 3]ï¼šSæ€ï¼Œåªè¦æ–¹æ³•æ­£ç¡®ï¼Œå¿…èµ¢ã€‚ æœ€ç»ˆèƒœåˆ©å³ç”±Sæ€è½¬å˜ä¸ºTæ€ï¼Œä»»ä½•ä¸€ä¸ªSæ€ï¼Œåªè¦æŠŠå®ƒå˜ä¸ºTæ€ï¼Œï¼ˆç”±å®šç†1ï¼Œå¯ä»¥æŠŠå®ƒå˜æˆTæ€ã€‚ï¼‰å¯¹æ–¹åªèƒ½æŠŠTæ€è½¬å˜ä¸ºSæ€(å®šç†2)ã€‚è¿™æ ·ï¼Œæ‰€æœ‰Sæ€å‘Tæ€çš„è½¬å˜éƒ½å¯ä»¥æœ‰å·±æ–¹æŽ§åˆ¶ï¼Œå¯¹æ–¹åªèƒ½è¢«åŠ¨åœ°å®žçŽ°ç”±Tæ€è½¬å˜ä¸ºSæ€ã€‚æ•…Sæ€å¿…èµ¢ã€‚ [å®šç†4]ï¼šTæ€ï¼Œåªè¦å¯¹æ–¹æ³•æ­£ç¡®ï¼Œå¿…è´¥ã€‚ ç”±å®šç†3æ˜“å¾—ã€‚ æŽ¥ç€æ¥è§£å†³ç¬¬äºŒä¸ªé—®é¢˜ã€‚ å®šä¹‰ï¼šè‹¥ä¸€å †ä¸­ä»…æœ‰1æ ¹ç«æŸ´ï¼Œåˆ™è¢«ç§°ä¸ºå­¤å•å †ã€‚è‹¥å¤§äºŽ1æ ¹ï¼Œåˆ™ç§°ä¸ºå……è£•å †ã€‚ å®šä¹‰ï¼šTæ€ä¸­ï¼Œè‹¥å……è£•å †çš„å †æ•°å¤§äºŽç­‰äºŽ2ï¼Œåˆ™ç§°ä¸ºå®Œå…¨åˆ©ä»–æ€ï¼Œç”¨T2è¡¨ç¤ºï¼›è‹¥å……è£•å †çš„å †æ•°ç­‰äºŽ0ï¼Œåˆ™ç§°ä¸ºéƒ¨åˆ†åˆ©ä»–æ€ï¼Œç”¨T0è¡¨ç¤ºã€‚ å­¤å•å †çš„æ ¹æ•°å¼‚æˆ–åªä¼šå½±å“äºŒè¿›åˆ¶çš„æœ€åŽä¸€ä½ï¼Œä½†å……è£•å †ä¼šå½±å“é«˜ä½ï¼ˆéžæœ€åŽä¸€ä½ï¼‰ã€‚ä¸€ä¸ªå……è£•å †ï¼Œé«˜ä½å¿…æœ‰ä¸€ä½ä¸ä¸º0ï¼Œåˆ™æ‰€æœ‰æ ¹æ•°å¼‚æˆ–ä¸ä¸º0ã€‚æ•…ä¸ä¼šæ˜¯Tæ€ã€‚ [å®šç†5]ï¼šS0æ€ï¼Œå³ä»…æœ‰å¥‡æ•°ä¸ªå­¤å•å †ï¼Œå¿…è´¥ã€‚T0æ€å¿…èƒœã€‚ è¯æ˜Žï¼š S0æ€ï¼Œå…¶å®žå°±æ˜¯æ¯æ¬¡åªèƒ½å–ä¸€æ ¹ã€‚æ¯æ¬¡ç¬¬å¥‡æ•°æ ¹éƒ½ç”±å·±å–ï¼Œç¬¬å¶æ•°æ ¹éƒ½ç”±å¯¹ æ–¹å–ï¼Œæ‰€ä»¥æœ€åŽä¸€æ ¹å¿…å·±å–ã€‚è´¥ã€‚åŒç†, T0æ€å¿…èƒœ# [å®šç†6]ï¼šS1æ€ï¼Œåªè¦æ–¹æ³•æ­£ç¡®ï¼Œå¿…èƒœã€‚ è¯æ˜Žï¼š è‹¥æ­¤æ—¶å­¤å•å †å †æ•°ä¸ºå¥‡æ•°ï¼ŒæŠŠå……è£•å †å–å®Œï¼›å¦åˆ™ï¼Œå–æˆä¸€æ ¹ã€‚è¿™æ ·ï¼Œå°±å˜æˆå¥‡æ•°ä¸ªå­¤å•å †ï¼Œç”±å¯¹æ–¹å–ã€‚ç”±å®šç†5ï¼Œå¯¹æ–¹å¿…è¾“ã€‚å·±å¿…èƒœã€‚ # [å®šç†7]ï¼šS2æ€ä¸å¯è½¬ä¸€æ¬¡å˜ä¸ºT0æ€ã€‚ è¯æ˜Žï¼š å……è£•å †æ•°ä¸å¯èƒ½ä¸€æ¬¡ç”±2å˜ä¸º0ã€‚å¾—è¯ã€‚ # [å®šç†8]ï¼šS2æ€å¯ä¸€æ¬¡è½¬å˜ä¸ºT2æ€ã€‚ è¯æ˜Žï¼š ç”±å®šç†1ï¼ŒSæ€å¯è½¬å˜ä¸ºTæ€ï¼Œæ€å¯ä¸€æ¬¡è½¬å˜ä¸ºTæ€ï¼Œåˆç”±å®šç†6ï¼ŒS2æ€ä¸å¯è½¬ä¸€æ¬¡å˜ä¸ºT0æ€ï¼Œæ‰€ä»¥è½¬å˜çš„Tæ€ä¸ºT2æ€ã€‚ # [å®šç†9]ï¼šT2æ€ï¼Œåªèƒ½è½¬å˜ä¸ºS2æ€æˆ–S1æ€ã€‚ è¯æ˜Žï¼š ç”±å®šç†2ï¼ŒTæ€å¿…ç„¶å˜ä¸ºSæ€ã€‚ç”±äºŽå……è£•å †æ•°ä¸å¯èƒ½ä¸€æ¬¡ç”±2å˜ä¸º0ï¼Œæ‰€ä»¥æ­¤æ—¶çš„Sæ€ä¸å¯èƒ½ä¸ºS0æ€ã€‚å‘½é¢˜å¾—è¯ã€‚ [å®šç†10]ï¼šS2æ€ï¼Œåªè¦æ–¹æ³•æ­£ç¡®ï¼Œå¿…èƒœ. è¯æ˜Žï¼š æ–¹æ³•å¦‚ä¸‹ï¼š 1ï¼‰ S2æ€ï¼Œå°±æŠŠå®ƒå˜ä¸ºT2æ€ã€‚ï¼ˆç”±å®šç†8ï¼‰ 2ï¼‰ å¯¹æ–¹åªèƒ½T2è½¬å˜æˆS2æ€æˆ–S1æ€ï¼ˆå®šç†9ï¼‰ è‹¥è½¬å˜ä¸ºS2, è½¬å‘1ï¼‰ è‹¥è½¬å˜ä¸ºS1, è¿™å·±å¿…èƒœã€‚ï¼ˆå®šç†5ï¼‰ [å®šç†11]ï¼šT2æ€å¿…è¾“ã€‚ è¯æ˜Žï¼šåŒ10ã€‚ ç»¼ä¸Šæ‰€è¿°ï¼Œå¿…è¾“æ€æœ‰ï¼š T2,S0 å¿…èƒœæ€ï¼š S2,S1,T0. ä¸¤é¢˜æ¯”è¾ƒï¼š ç¬¬ä¸€é¢˜çš„å…¨è¿‡ç¨‹å…¶å®žå¦‚ä¸‹ï¼š S2-&gt;T2-&gt;S2-&gt;T2-&gt; â€¦â€¦ -&gt;T2-&gt;S1-&gt;T0-&gt;S0-&gt;T0-&gt;â€¦â€¦-&gt;S0-&gt;T0(å…¨0) ç¬¬äºŒé¢˜çš„å…¨è¿‡ç¨‹å…¶å®žå¦‚ä¸‹ï¼š S2-&gt;T2-&gt;S2-&gt;T2-&gt; â€¦â€¦ -&gt;T2-&gt;S1-&gt;S0-&gt;T0-&gt;S0-&gt;â€¦â€¦-&gt;S0-&gt;T0(å…¨0) ä¸‹åˆ’çº¿è¡¨ç¤ºèƒœåˆ©ä¸€æ–¹çš„å–æ³•ã€‚ æ˜¯å¦å‘çŽ°äº†ä»–ä»¬çš„æƒŠäººç›¸ä¼¼ä¹‹å¤„ã€‚ æˆ‘ä»¬ä¸éš¾å‘çŽ°(è§åŠ é»‘éƒ¨åˆ†)ï¼ŒS1æ€å¯ä»¥è½¬å˜ä¸ºS0æ€ï¼ˆç¬¬äºŒé¢˜åšæ³•ï¼‰ï¼Œä¹Ÿå¯ä»¥è½¬å˜ä¸º T0ï¼ˆç¬¬ä¸€é¢˜åšæ³•ï¼‰ã€‚å“ªä¸€æ–¹æŽ§åˆ¶äº†S1æ€ï¼Œä»–å³å¯ä»¥æœ‰åŠžæ³•ä½¿è‡ªå·±å¾—åˆ°æœ€åŽä¸€æ ¹ï¼ˆè½¬å˜ä¸º T0ï¼‰,ä¹Ÿå¯ä»¥ä½¿å¯¹æ–¹å¾—åˆ°æœ€åŽä¸€æ ¹ï¼ˆè½¬å˜ä¸ºS0ï¼‰ã€‚ æ‰€ä»¥ï¼ŒæŠ¢å¤ºS1æ˜¯åˆ¶èƒœçš„å…³é”®ï¼ ä¸ºæ­¤ï¼Œå§‹ç»ˆæŠŠT2æ€è®©ç»™å¯¹æ–¹ï¼Œå°†ä½¿å¯¹æ–¹å¤„äºŽè¢«åŠ¨çŠ¶æ€ï¼Œä»–æ—©æ™šå°†æŠŠçŠ¶æ€å˜ä¸ºS1. æŽ¨èHDOJé¢˜ç›® http://acm.hdu.edu.cn/showproblem.php?pid=1907 http://acm.hdu.edu.cn/showproblem.php?pid=2509 çœ‹å®Œä¸Šé¢çš„ç»“è®ºï¼Œå°±èƒ½é¡ºåˆ©è§£å†³ä¸Šé¢2é“äº† S-Nim http://acm.hdu.edu.cn/showproblem.php?pid=1536 http://acm.hdu.edu.cn/showproblem.php?pid=1944 åšå¼ˆç®—æ³•å…¥é—¨å°èŠ‚ 1536 1517 1907 å°å­æœ€è¿‘è¿·é€”äºŽåšå¼ˆä¹‹ä¸­ã€‚ã€‚ã€‚æ„Ÿè§¦é¢‡æ·±ã€‚ ä¸ºäº†è®©å¤§å®¶èƒ½å¤Ÿåœ¨å­¦ä¹ åšå¼ˆçš„æ—¶å€™å°‘èµ°å¼¯è·¯ï¼Œæœ€é‡è¦çš„ä¹Ÿæ˜¯ä¸ºäº†åŠ æ·±è‡ªå·±çš„å½±å“ï¼Œæ¸©æ•…è€ŒçŸ¥æ–°ï¼Œç‰¹å‘æ­¤è´´ä¸Žå¤§å®¶å…±å‹‰ã€‚ å­¦åšå¼ˆå…ˆä»Žæ¦‚å¿µå¼€å§‹ï¼š ç‰¹åˆ«æŽ¨èLCYè€å¸ˆçš„è¯¾ä»¶ï¼šåšå¼ˆå…¥é—¨ã€‚ ä¸‹è½½åœ°å€ï¼šhttp://acm.hdu.edu.cn/forum/read.php?tid=6875 è¿™ä¸ªè¯¾ä»¶ä¸ªäººè®¤ä¸ºä»Žåšå¼ˆçš„åŸºæœ¬æ€æƒ³ï¼Œä¸€ç›´åˆ°è§£åšå¼ˆçš„ä¸­å¿ƒç®—æ³•åšäº†å¾ˆå¥½çš„è¯ é‡Šã€‚ä½†æ˜¯ç‰¹åˆ«è¦æ³¨æ„çš„æ˜¯ã€‚è¯¾ä»¶åŽé¢ä¸€éƒ¨åˆ†è‹±è¯­å†™çš„è®²ä¹‰æ˜¯é‡ä¸­ä¹‹é‡ã€‚å°å­è‹±è¯­å¾ˆå¼±ï¼Œåœ¨è¿™å›°æ‰°å¾ˆä¹…ã€‚çŽ°åœ¨ä¸ºå¤§å®¶å¤§æ¦‚ä»‹ç»ä¸€ä¸‹ã€‚ ä¸»è¦æ˜¯åŽç»§ç‚¹å’ŒSGå€¼çš„é—®é¢˜: SGå€¼ï¼šä¸€ä¸ªç‚¹çš„SGå€¼å°±æ˜¯ä¸€ä¸ªä¸ç­‰äºŽå®ƒçš„åŽç»§ç‚¹çš„SGçš„ä¸”å¤§äºŽç­‰äºŽé›¶çš„æœ€å°æ•´æ•°ã€‚ åŽç»§ç‚¹ï¼šä¹Ÿå°±æ˜¯æŒ‰ç…§é¢˜ç›®è¦æ±‚çš„èµ°æ³•ï¼ˆæ¯”å¦‚å–çŸ³å­å¯ä»¥å–çš„æ•°é‡ï¼Œæ–¹æ³•ï¼‰èƒ½å¤Ÿèµ°ä¸€æ­¥è¾¾åˆ°çš„é‚£ä¸ªç‚¹ã€‚ å…·ä½“çš„æœ‰å…³SGå€¼æ˜¯æ€Žä¹ˆè¿ç”¨çš„å¸Œæœ›å¤§å®¶è‡ªå·±å¤šæƒ³æƒ³ã€‚ è¯¾ä»¶åŽé¢æœ‰ä¸€ä¸ª1536çš„ä»£ç ã€‚å¯ä»¥æ”¾åœ¨åŽé¢åšåš çœ‹åˆ°è¿™é‡ŒæŽ¨èå¤§å®¶åšå‡ é“é¢˜ï¼š1846ï¼ˆæœ€ç®€å•çš„åšå¼ˆæ°´é¢˜ï¼‰ 1847ï¼ˆæ±‚SGå€¼ï¼‰ æœ‰äº†ä¸Šé¢çš„çŸ¥è¯†æŽ¥ä¸‹æ¥æˆ‘ä»¬æ¥çœ‹çœ‹ç»„åˆåšå¼ˆï¼ˆnå †çŸ³å­ï¼‰ æŽ¨èå¤§å®¶çœ‹ä¸ªèµ„æ–™ï¼š åšå¼ˆ-å–çŸ³å­æ¸¸æˆ(æŽ¨èç­‰çº§äº”æ˜Ÿçº§) è¿™é‡Œæå‡ºäº†ä¸€ä¸ªå¥‡å¼‚çŠ¶æ€çš„é—®é¢˜ã€‚çœ‹äº†è¿™ç¯‡æ–‡ç« ä½ ä¼šå‘çŽ°å¼‚æˆ–è¿ç®—åœ¨åšå¼ˆä¸­ä½¿ç”¨çš„å¦™å¤„ã€‚å½“ç„¶è¿™é‡ŒæŒ‡å‡ºçš„åªæ˜¯ç»„åˆåšå¼ˆä¸­ä¸€ç§ç‰¹æ®Šæƒ…å†µã€‚ çŽ‹é“è¿˜æ˜¯å¯¹SGå€¼çš„æ±‚è§£ï¼Œä½†æ˜¯çŸ¥é“è¿™ä¹ˆä¸€ç§æ€è·¯æ— ç–‘å¯¹æ€ç»´çš„å¹¿åº¦å’Œæ·±åº¦æ‰©å±•æ˜¯å¾ˆæœ‰å¸®åŠ©çš„ã€‚ ZZåšå¼ˆ è¿™é‡Œä»‹ç»äº†ç»„å’Œåšå¼ˆçš„ä¸¤ç§å¤§çš„ç±»åž‹ï¼Œä¸€ç§æ˜¯æœ€åŽå–çš„æ˜¯NçŠ¶æ€ä¸€ç§æ˜¯æœ€åŽå–çš„æ˜¯PçŠ¶æ€ï¼Œä¸¤ä¸ªçŠ¶æ€çš„è§£é¢˜æ–¹æ³•èƒ½çœ‹æ‡‚å¾ˆæœ‰å¸®åŠ©ã€‚å½“ç„¶ï¼Œèƒ½å¤ŸæŠŠæŽ¨å¯¼è¿‡ç¨‹ç†è§£ï¼Œåƒé€æ— ç–‘æ˜¯å¤§ç‰›çº§çš„åšæ³•å°å­ä¹Ÿä½©æœçš„ç´§ 1536é¢˜æŽ¨èåšåšè¿™é¢˜ï¼Œè¿™é¢˜å‰é¢æé†’å¤§å®¶æ˜¯ä¸€ä¸ªæ±‚SGå€¼çš„é¢˜ç›®ï¼Œé¢˜ç›®å‰é¢æ˜¯å¯¹å¼‚æˆ–è¿ç®—è¿ç”¨åœ¨ç»„åˆåšå¼ˆé—®é¢˜ä¸­çš„å¾ˆå¥½çš„è§£é‡Šã€‚å½“ç„¶é¢˜ç›®æœ¬èº«æ˜¯æœ‰æ‰€ä¸åŒçš„ã€‚å› ä¸ºåœ¨è¿™é‡Œé¢å¯¹å–æ³•æœ‰æ‰€è¦æ±‚ã€‚é‚£ä¹ˆè¿™æ ·å°±å›žå½’åˆ°äº†è§£å†³åšå¼ˆé—®é¢˜çš„çŽ‹é“ç®—æ³•â€”â€”æ±‚SGå€¼ä¸Šã€‚ æœ‰å…³è¿ç”¨æ±‚SGå€¼çš„åšå¼ˆé¢˜ç›®æœ‰ï¼š 1850ï¼ˆä¹Ÿå¯åŸºäºŽå¥‡å¼‚çŠ¶æ€å¼‚æˆ–ï¼‰ 1848ï¼ˆä¸­å’Œçš„å¤§æ–æ³¢é‚£å¥‘æ•°åˆ—çš„å…¸åž‹æ±‚SGå€¼é¢˜ï¼‰ 1517ï¼ˆä¸ªäººè®¤ä¸ºæœ‰ç‚¹çŒ¥ççš„é¢˜ç›®ã€‚ã€‚ã€‚ã€‚åœ¨æ­¤é¢˜ä¸Šå›°æ‰°å¾ˆä¹…ã€‚å½“ç„¶æžå‡ºæ¥å¾ˆå¼€å¿ƒã€‚å°å­æ˜¯ç”¨æ¯”è¾ƒè§„çŸ©çš„æ±‚SGå€¼çš„æ–¹æ³•æ±‚å‡ºæ¥çš„ï¼Œä½†æ˜¯è®ºå›æœ‰äººå¯¹å…¶æŽ¨å‡ºæ¥äº†è§„å¾‹ï¼Œè¿™é‡Œä½©æœä¸€ä¸‹ï¼Œå¤§å®¶å¯ä»¥å­¦ä¹ ä¸€ä¸‹ï¼‰ 1079ï¼ˆæ›´çŒ¥ççš„é¢˜ç›®ï¼Œå¯¹æ–°æ‰‹è¦æ±‚è¾ƒé«˜ï¼Œå› ä¸ºæŒ‰ä¼ ç»Ÿæ–¹æ³•éœ€è¦æ¯”è¾ƒç»†è‡´çš„æ¨¡æ‹ŸåŠ å¯¹è¾¹è§’çŠ¶æ€çš„è€ƒè™‘ï¼ŒåŒæ ·æœ‰äººæŽ¨å‡ºæ¥äº†å…¬å¼ï¼‰ å½“ä½ å…¨éƒ¨çœ‹å®Œä»¥ä¸Šçš„ä¸œè¥¿ã€‚åšå®Œä»¥ä¸Šçš„é¢˜ç›®çš„è¯ã€‚ã€‚ã€‚å°å­æ­å–œä½ ä½ åšå¼ˆå…¥é—¨äº†~ è¿™é‡Œå°å­å‘Šè¯‰å¤§å®¶ã€‚åšå¼ˆå¾ˆå¼ºå¤§ã€‚å­¦ä¹ è¦è€å¿ƒ~è°¢è°¢ Current System Time : 2008-12-11 19:16:03 ACMè¯¾ä½œä¸šï¼š 1001 Brave Game 1002 Good Luck in CET-4 Everybody! 1003 Fibonacci again and again 1004 Rabbit and Grass 1005 Being a Good Boy in Spring Festival 1006 Public Sale 1007 æ‚¼å¿µ512æ±¶å·å¤§åœ°éœ‡é‡éš¾åŒèƒžâ€”â€”é€‰æ‹”å¿—æ„¿è€… 1008 kikiâ€™s game 1009 Calendar Game 1010 A Multiplication Game 1011 Digital Deletions 1012 S-Nim 1536çš„å‚è€ƒä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//åšå¼ˆ-åŸºäºŽæ±‚SGå€¼//Accepted 1536 578MS 416K 904 B#includeâ€iostreamâ€using namespace std;int f[101],sg[10001],k;int mex(int b)&#123; int a[101]=&#123;0&#125;,i; for(i=0;i&lt;k;i++) &#123; if(b-f&lt;0)//b-fåŽç»§ç‚¹ break; if(sg[b-f]==-1) &#123; sg[b-f]=mex(b-f); &#125; a[sg[b-f]]=1; &#125; for(i=0;i&lt;k;i++) if(!a) &#123; return i; &#125;&#125;int main()&#123; int i,t,n,s,bead,j; while(cin &gt;&gt; k,k) &#123; for(i=0;i&lt;k;i++) &#123; cin &gt;&gt; f; &#125; memset(sg,-1,sizeof(sg)); for(i=0;i&lt;k;i++) for(j=i+1;j&lt;k;j++) if(f&gt;f[j]) &#123; f+=f[j]; f[j]=f-f[j]; f-=f[j]; &#125; sg[0]=0; cin &gt;&gt; t; while(tâ€“) &#123; cin &gt;&gt; n; s=0; while(nâ€“) &#123; cin &gt;&gt; bead;//è¯¥å †çš„æˆå‘˜ä¸ªæ•° if(sg[bead]==-1) sg[bead]=mex(bead); s=s^sg[bead]; &#125; if(s==0) cout &lt;&lt; â€œLâ€; else cout &lt;&lt; â€œWâ€; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 1517å‚è€ƒä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546//åšå¼ˆ-åŸºäºŽæ±‚SGå€¼//Accepted 1517 234MS 0K 837 B#includeâ€iostreamâ€using namespace std;int main()&#123; __int64 a[7000]=&#123;1&#125;,min,n; int p[10],sg[7000],i,j,k; for(i=2;i&lt;10;p=0,i++); for(i=1;i&lt;7000;i++) &#123; for(j=2,min=-1;j&lt;10;j++) if(min==-1||a[p[j]]*j&lt;a[p[min]]*min) min=j; a=a[p[min]]*min; min=a[p[min]]*min; if(a&gt;=5000000000) break; for(j=2;j&lt;10;j++) if(a[p[j]]*j==min) p[j]++; &#125;//ä»Žå°åˆ°å¤§æ±‚å‡ºæ‰€æœ‰ä¹˜ç§¯ while(scanf(â€œ%I64dâ€,&amp;n)!=EOF) &#123; for(i=0;i&lt;7000;i++) &#123; sg=0; if(a&gt;=n) break; &#125; for(j=i-1;a[j]*9&gt;=n&amp;&amp;j&gt;=0;jâ€“) sg[j]=1; while(j&gt;=0) &#123; for(k=j+1;k&lt;i&amp;&amp;a[j]*9&gt;=a[k];k++) if(a[k]%a[j]==0&amp;&amp;sg[k]==0) &#123; sg[j]=1; break; &#125; jâ€“; &#125; puts(sg[0]?â€Stan wins.â€:â€Ollie wins.â€); &#125; return 0;&#125; è¿™é‡Œæ„Ÿè°¢shÇŽå´½åŒå­¦çš„ä¸€æ®µä»£ç è®©å°å­å­¦ä¼šäº†putsçš„å¦™ç”¨ 1907å‚è€ƒä»£ç  12345678910111213141516171819202122#includeâ€iostreamâ€using namespace std;int main()&#123; int temp,t,n,s,x,i; cin &gt;&gt; t; while(tâ€“) &#123; cin &gt;&gt; n; for(i=s=temp=0;i&lt;n;i++) &#123; cin &gt;&gt; x; if(x&gt;1) temp=1; s^=x; &#125; if((s&amp;&amp;temp)||(!s&amp;&amp;!temp)) cout &lt;&lt; â€œJohnâ€ &lt;&lt; endl; else cout &lt;&lt; â€œBrotherâ€ &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>åšå¼ˆ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åŸºäºŽLinuxï¼ˆæˆ–è€…Mac OS Xï¼‰çš„å¯¹æ‹ç¨‹åº]]></title>
    <url>%2F2017%2F05%2F28%2F%E5%9F%BA%E4%BA%8ELinux%EF%BC%88%E6%88%96%E8%80%85Mac%20OS%20X%EF%BC%89%E7%9A%84%E5%AF%B9%E6%8B%8D%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[æ¯”èµ›æ—¶è°ƒç¨‹åºçš„å¥‡æ·«å·§æŠ€ä¹‹ä¸€ï¼šå¯¹æ‹ã€‚ ç¨‹åºbugè°ƒè¯•ä¸å‡ºæ¥ï¼Œä½†æ˜¯èƒ½å†™ä¸€ä¸ªæš´åŠ›çš„ä¿è¯æ­£ç¡®çš„ç®—æ³•ï¼Œå¹¶ä¸”ç›´æŽ¥æäº¤æš´åŠ›çš„ç¨‹åºä¼šè¶…æ—¶ï¼ŒäºŽæ˜¯è¿™æ—¶å€™å°±å¯ä»¥ç”¨â€œå¯¹æ‹â€æ¥è°ƒè¯•äº†ã€‚ ç”±äºŽACM ICPCç”¨çš„ç³»ç»Ÿéƒ½æ˜¯Ubuntuæ‰€ä»¥ç»™å‡ºä¸€ä¸ªåŸºäºŽLinuxçš„å¯¹æ‹ç¨‹åºï¼ˆMac OS XåŒæ ·é€‚ç”¨ï¼‰ data_maker ï¼šä½ å†™çš„èƒ½å¤Ÿéšæœºç”Ÿæˆæ•°æ®çš„ç¨‹åºï¼Œæ³¨æ„ç”Ÿæˆæ•°æ®çš„æ¡ä»¶ï¼ˆæœ‰äº›é¢˜ç›®å¯¹æ•°æ®çš„è¦æ±‚æ¯”è¾ƒé«˜ï¼Œè¿™æ—¶å€™å¾ˆéš¾ç”Ÿæˆå¯ä»¥ç”¨çš„æ•°æ®ï¼Œæ‰€ä»¥å¯¹æ‹ä¹Ÿæ˜¯æœ‰å±€é™æ€§çš„ï¼‰ MyProgï¼šä½ å†™çš„é«˜æ•ˆç¨‹åº StdProgï¼šæš´åŠ›çš„ä¿è¯ç­”æ¡ˆæ­£ç¡®çš„ç¨‹åº 12345678910111213while true; do ./data_maker &gt; tmp.in #å‡ºæ•°æ® ./MyProg &lt; tmp.in &gt; my.out #è¢«æµ‹ç¨‹åº ./StdProg &lt; tmp.in &gt; std.out #æ­£ç¡®ï¼ˆæš´åŠ›ï¼‰ç¨‹åº if diff my.out std.out; then #æ¯”è¾ƒä¸¤ä¸ªè¾“å‡ºæ–‡ä»¶ printf "AC\n" #ç»“æžœç›¸åŒæ˜¾ç¤ºAC elif diff -B -b my.out std.out; then printf "PE\n" else printf "WA\n" #ç»“æžœä¸åŒæ˜¾ç¤ºWAï¼Œå¹¶é€€å‡º exit 0 fi done ä¸Šé¢è¿™ä¸ªç¨‹åºéœ€è¦ä¿å­˜æˆ.shçš„æ ¼å¼ï¼Œä¾‹å¦‚ï¼šå¯¹æ‹.shç›´æŽ¥åœ¨ç»ˆç«¯é‡Œé¢è¿è¡Œ è¿è¡Œæ–¹æ³•ï¼š æ‰“å¼€ç»ˆç«¯ æ‰§è¡Œ æ–¹æ³•ä¸€ï¼š è¾“å…¥å‘½ä»¤ ./aa.sh æ–¹æ³•äºŒï¼šç›´æŽ¥æŠŠ aa.sh æ‹–å…¥åˆ°ç»ˆç«¯é‡Œé¢ã€‚ æ³¨æ„äº‹é¡¹ï¼š å¦‚æžœ æ²¡æœ‰æˆåŠŸæŠ¥å‡ºé—®é¢˜ï¼š: Permission deniedã€‚ å°±æ˜¯æ²¡æœ‰æƒé™ã€‚ è§£å†³åŠžæ³•ï¼šä¿®æ”¹è¯¥æ–‡ä»¶å¯¹æ‹.sh çš„æƒé™ ï¼šä½¿ç”¨å‘½ä»¤ï¼š chmod 777 å¯¹æ‹.sh ã€‚ ç„¶åŽå†æ‰§è¡Œ ä¸Šé¢ç¬¬ä¸€æ­¥æˆ–è€…ç¬¬äºŒæ­¥çš„æ“ä½œå°± OK äº†. é™„èµ ä¸€ä¸ªwindowsçš„å¯¹æ‹ç¨‹åºï¼ˆè½¬è½½äºŽä»–äººï¼Œä¾µåˆ ï¼‰ï¼šå¯¹æ‹.bat å¯¹æ‹ç¨‹åºçš„å†™æ³• å¦‚ä¸‹ 1234567891011@echo off :loop datamaker #æ•°æ®ç”Ÿæˆå™¨ rand.exe &gt; data.in è¿™é‡Œçš„å¤§äºŽç¬¦å·ï¼Œå°äºŽç¬¦å·ä¸ºé‡å®šå‘ç¬¦å· std #æ ‡å‡†ç¨‹åº std.exe &lt; data.in &gt; std.out myprogram #my.exe &lt; data.in &gt; my.out æˆ‘çš„ç¨‹åº fc ans.out std.out //æ¯”è¾ƒä¸¤ä¸ªç¨‹åºçš„è¾“å‡ºæ˜¯å¦ä¸€è‡´ï¼Œä¸€è‡´åˆ™è¿”å›ž0 if not errorlevel 1 goto loop pause goto loop #æœ€åŽä¸Šè¾¹çš„ å†…å®¹ ä¿å­˜ä¸º.batæ–‡ä»¶ #rand.exe std.exe my.exe ä»¥åŠwindowsä¸‹çš„è¿™ä¸ª .batæ–‡ä»¶ æ”¾åœ¨åŒä¸€ä¸ªç›®å½•ä¸‹*************************************************************************************************** è¿™é‡Œæ•°æ®ç”Ÿæˆå™¨ï¼š å°±æ˜¯ä½ è‡ªå·±ç¼–å†™ä¸€ä¸ªåº”ç”¨ç¨‹åº rand.exeï¼Œè¿™ä¸ªåº”ç”¨ç¨‹åºå°±æ˜¯éšæœºçš„ç”Ÿæˆä¸€ç»„ç¬¦åˆé¢˜æ„çš„è¾“å…¥æ•°æ®å¹¶å­˜æ”¾åˆ°ä¸Šè¾¹æåˆ°çš„ è¾“å…¥æ•°æ®æ–‡ä»¶ä¸­data.iné«˜æ•ˆç¨‹åºï¼šå°±æ˜¯ä¸Šè¾¹æåˆ°çš„ é«˜æ•ˆç®—æ³• å†™çš„ç¨‹åºï¼Œå³ my.exe æš´åŠ›ç¨‹åº ï¼šå°±æ˜¯æŒ‡èƒ½å¤Ÿä¿è¯æ‰€æœ‰è¾“å…¥æ•°æ®éƒ½èƒ½è¾“å‡ºæ­£ç¡®ç»“æžœçš„ ç¨‹åºï¼Œå³è¿™é‡Œçš„std.exeä¸Šè¾¹çš„. batæ–‡ä»¶ çš„åŠŸèƒ½å°±æ˜¯å¾ªçŽ¯ åˆ¤æ–­é«˜æ•ˆç¨‹åºå’Œ æš´åŠ›ç¨‹åº åœ¨åŒæ ·çš„è¾“å…¥æ•°æ®æƒ…å†µä¸‹ï¼Œè¾“å‡ºæ•°æ®æ˜¯å¦ç›¸åŒï¼Œä»Žè€Œå®žçŽ°äº†å¯¹æ‹ç¨‹åºçš„åŠŸèƒ½]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Mac OSX</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[kuangbinå¸¦ä½ é£ž]åˆ·é¢˜é¡ºåº]]></title>
    <url>%2F2017%2F05%2F27%2Fkuangbin%E5%B8%A6%E4%BD%A0%E9%A3%9E-%E5%88%B7%E9%A2%98%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[ä¸€äº›åŸºæœ¬ç®—æ³•å’Œæ•°æ®ç»“æž„(é˜Ÿåˆ— æ ˆ æ ‘ å›¾ å¹¶æŸ¥é›† å † DFS BFS æœ€çŸ­è·¯ æœ€å°ç”Ÿæˆæ ‘ æ‹“æ‰‘æŽ’åº åŠ¨æ€è§„åˆ’ è´ªå¿ƒ æœç´¢ KMP å“ˆå¸Œ Trie ACè‡ªåŠ¨æœº å¿«é€Ÿå¹‚ é€†å…ƒ è´¹é©¬å°å®šç† æ¬§æ‹‰å‡½æ•° ç´ æ•°ç­› åˆ†è§£è´¨å› æ•°)ä½ å¯ä»¥æ‰¾ä¸¤ä¸ªå°ä¼™ä¼´ä¸€èµ·åˆ†å·¥åˆä½œï¼Œå„è‡ªè®¤é¢†ä¸“é¢˜ ã€å‚è€ƒä¹¦ç±ï¼šåˆ˜æ±ä½³ã€Šç®—æ³•ç«žèµ›å…¥é—¨ç»å…¸ç¬¬äºŒç‰ˆã€‹orã€Šç®—æ³•ç«žèµ›è®­ç»ƒæ‰‹å†Œã€‹ï¼Œã€Šç®—æ³•å¯¼è®ºã€‹ã€‘ è¿™æ—¶å€™å¯ä»¥åˆ·çš„é¢˜å°±å¤šäº†ï¼Œä½ å¯ä»¥é€‰æ‹©ä¸€äº›ä¸“é¢˜è¿›è¡Œçªç ´ï¼Œå­¦ä¹ ä¸€ä¸‹æŠ€å·§ ä¾‹å¦‚ [kuangbinå¸¦ä½ é£ž]ä¸“é¢˜ä¸€ ç®€å•æœç´¢ [kuangbinå¸¦ä½ é£ž]ä¸“é¢˜å›› æœ€çŸ­è·¯ç»ƒä¹  [kuangbinå¸¦ä½ é£ž]ä¸“é¢˜äº” å¹¶æŸ¥é›† [kuangbinå¸¦ä½ é£ž]ä¸“é¢˜å…­ æœ€å°ç”Ÿæˆæ ‘ [kuangbinå¸¦ä½ é£ž]ä¸“é¢˜åäºŒ åŸºç¡€DP [kuangbinå¸¦ä½ é£ž]ä¸“é¢˜åå›› æ•°è®ºåŸºç¡€ [kuangbinå¸¦ä½ é£ž]ä¸“é¢˜åå…­ KMP &amp; æ‰©å±•KMP &amp; Manacher [kuangbinå¸¦ä½ é£ž]ä¸“é¢˜åä¸ƒ ACè‡ªåŠ¨æœº å¦‚æžœè¿™äº›ä½ å’Œä½ çš„å°ä¼™ä¼´éƒ½èƒ½ç†Ÿæ‚‰æŽŒæ¡ï¼Œå¹¶ä¸”èƒ½å¤Ÿå°½å¿«å†™å‡ºæ¥ï¼Œé‚£ä¹ˆæ²¡æœ‰æ„å¤–çš„è¯å°±å¯ä»¥åœ¨ç½‘ç»œèµ›ä¸­æ‹¿åˆ°çŽ°åœºèµ›çš„é—¨ç¥¨ï¼ˆå½“ç„¶è¿˜å¾—çœ‹å‡ºé¢˜äººçš„é£Žæ ¼...ï¼‰ ä¸€äº›è¿›é˜¶çš„ç®—æ³•ä»¥åŠå¤æ‚ä¸€äº›çš„æ•°æ®ç»“æž„ï¼ˆæ ‘çŠ¶æ•°ç»„ çº¿æ®µæ ‘ å¹³è¡¡æ ‘ åŽç¼€æ•°ç»„ äºŒåˆ†å›¾åŒ¹é… ç½‘ç»œæµ è´¹ç”¨æµ å‰²ç‚¹ æ¡¥ å¼ºè”é€š åŒè”é€š æœ€è¿‘å…¬å…±ç¥–å…ˆ å››å¤§DP(æ•°ä½dp åŒºé—´dp çŠ¶åŽ‹dp æ¦‚çŽ‡dp) åšå¼ˆè®ºSGå‡½æ•° ï¼‰ ã€å‚è€ƒèµ„æ–™ï¼šå„ç§åšå®¢......ã€‘ [kuangbinå¸¦ä½ é£ž]ä¸“é¢˜ä¸ƒ çº¿æ®µæ ‘ [kuangbinå¸¦ä½ é£ž]ä¸“é¢˜ä¹ è¿žé€šå›¾ [kuangbinå¸¦ä½ é£ž]ä¸“é¢˜å åŒ¹é…é—®é¢˜ [kuangbinå¸¦ä½ é£ž]ä¸“é¢˜åä¸€ ç½‘ç»œæµ [kuangbinå¸¦ä½ é£ž]ä¸“é¢˜åäº” æ•°ä½DP [kuangbinå¸¦ä½ é£ž]ä¸“é¢˜åå…« åŽç¼€æ•°ç»„ [kuangbinå¸¦ä½ é£ž]ä¸“é¢˜äºŒåä¸€ æ¦‚çŽ‡&amp;æœŸæœ› [kuangbinå¸¦ä½ é£ž]ä¸“é¢˜äºŒåäºŒ åŒºé—´DP è¿™äº›æŽŒæ¡ä¹‹åŽåœ¨çŽ°åœºèµ›ä¸­æ‹¿åˆ°ç‰Œå­åº”è¯¥å°±æ²¡ä»€ä¹ˆé—®é¢˜äº†ï¼Œå‘æŒ¥å‡ºè‰²è¿˜èƒ½æ‹¿åˆ°é“¶ç‰Œã€‚ã€‚ã€‚ä¸è¿‡å¦‚æžœé‡åˆ°æ¯”è¾ƒå‡¶æ®‹çš„èµ›åŒº...2.5 è¿™æ—¶å€™å¦‚æžœå¼€å§‹ç»„é˜Ÿäº†ï¼Œå°±å¯ä»¥åŽ»åˆ·ä¸€äº›å¥—é¢˜äº†ï¼Œä¾‹å¦‚Contests - Virtual Judge è¿™é‡Œæ¯ä¸€åœºæ¯”èµ›éƒ½æ˜¯è¿‡åŽ»çœŸå®žå‘ç”Ÿçš„å½•åƒï¼Œä½ å¯ä»¥cloneä¹‹åŽå’Œè‡ªå·±çš„é˜Ÿå‹ä¸€èµ·å®žæ“ä¸€ä¸‹ã€‚ æ›´é«˜æ·±çš„æŠ€å·§ï¼Œæ›´å¤æ‚çš„æ•°æ®ç»“æž„ï¼ˆæ ‘é“¾å‰–åˆ†ï¼ŒåŠ¨æ€æ ‘ï¼Œå¯æŒä¹…åŒ–çº¿æ®µæ ‘ï¼ŒDLXï¼ŒåŽç¼€è‡ªåŠ¨æœºï¼Œå›žæ–‡æ ‘ï¼Œæ–œçŽ‡ä¼˜åŒ–/å•è°ƒé˜Ÿåˆ—ä¼˜åŒ–/å››è¾¹å½¢ä¼˜åŒ–DPï¼Œæ’å¤´dpï¼ŒèŽ«æ¯”ä¹Œæ–¯åæ¼”......ï¼‰ è¿™éƒ¨åˆ†æœ€èƒ½ä½“çŽ°äººä¸Žäººçš„å·®å¼‚äº†...æ™ºå•†ç¢¾åŽ‹ä¸€èˆ¬å°±åœ¨è¿™éƒ¨åˆ†ã€‚è€Œè¦æƒ³æ‹¿åˆ°é‡‘ç‰Œï¼Œä¸€èˆ¬æ¥è¯´è¿™äº›çŸ¥è¯†éƒ½è¦å°½å¯èƒ½æŽŒæ¡ã€‚]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>kuangbin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
